{"version":3,"sources":["file:///workspace/appflow/src/vs/platform/telemetry/common/serverTelemetryService.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;;;;;;;;;;IAczF,IAAM,GAAG,GAAT,MAAM,GAAuB,SAAQ,sBAAG;QAK9C,YACC,MAA+B,EAC/B,sBAAsC,EACf,qBAA0B,EAChC,eAAoB;YAErC,KAAK,CAAC,MAAM,EAAE,qBAAqB,EAAE,eAAe,CAAC,CAAC;YACtD,IAAI,CAAC,CAAC,GAAyB,sBAAsB,CAAC;QACvD,CAAC;QAEQ,SAAS,CAAC,SAAiB,EAAE,IAAqB;YAC1D,IAAI,IAAI,CAAC,CAAC,+BAA6C,EAAE;gBACxD,OAAO;aACP;YACD,OAAO,KAAK,CAAC,SAAS,CAAC,SAAS,EAAE,IAAI,CAAC,CAAC;QACzC,CAAC;QAEQ,UAAU,CAAsF,SAAiB,EAAE,IAAgC;YAC3J,OAAO,IAAI,CAAC,SAAS,CAAC,SAAS,EAAE,IAAkC,CAAC,CAAC;QACtE,CAAC;QAEQ,cAAc,CAAC,cAAsB,EAAE,IAAqB;YACpE,IAAI,IAAI,CAAC,CAAC,+BAA6C,EAAE;gBACxD,OAAO,OAAO,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC;aAClC;YACD,OAAO,KAAK,CAAC,cAAc,CAAC,cAAc,EAAE,IAAI,CAAC,CAAC;QACnD,CAAC;QAEQ,eAAe,CAAsF,SAAiB,EAAE,IAAgC;YAChK,OAAO,IAAI,CAAC,cAAc,CAAC,SAAS,EAAE,IAAkC,CAAC,CAAC;QAC3E,CAAC;QAED,KAAK,CAAC,4BAA4B,CAAC,cAA8B;YAChE,IAAI,cAAc,KAAK,SAAS,EAAE;gBACjC,IAAI,CAAC,CAAC,8BAA4C,CAAC;gBACnD,MAAM,IAAI,KAAK,CAAC,wEAAwE,CAAC,CAAC;aAC1F;YACD,6IAA6I;YAC7I,IAAI,CAAC,CAAC,GAAyB,IAAI,CAAC,CAAC,CAAuB,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,EAAwB,cAAc,CAAC,CAAC,CAAC,CAAC,cAAc,CAAC;YACtI,IAAI,IAAI,CAAC,CAAC,gCAA8C,EAAE;gBACzD,IAAI,CAAC,OAAO,EAAE,CAAC;aACf;QACF,CAAC;KACD,CAAA;IAhDY,kBAAG;kBAAH,GAAG;QAQb,WAAA,mBAAG,CAAA;QACH,WAAA,oBAAG,CAAA;OATO,GAAG,CAgDf;IAEY,QAAA,GAAG,GAA0B,IAAI,KAAM,SAAQ,oBAAG;QAC9D,KAAK,CAAC,4BAA4B,KAAoB,OAAO,CAAC,CAAC,CAAC,uCAAuC;KACvG,CAAC;IAEW,QAAA,GAAG,GAAuB,IAAA,mBAAG,EAAgE,eAAG,CAAe,CAAC","file":"serverTelemetryService.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IConfigurationService } from 'vs/platform/configuration/common/configuration';\nimport { refineServiceDecorator } from 'vs/platform/instantiation/common/instantiation';\nimport { IProductService } from 'vs/platform/product/common/productService';\nimport { ClassifiedEvent, IGDPRProperty, OmitMetadata, StrictPropertyCheck } from 'vs/platform/telemetry/common/gdprTypings';\nimport { ITelemetryData, ITelemetryService, TelemetryLevel } from 'vs/platform/telemetry/common/telemetry';\nimport { ITelemetryServiceConfig, TelemetryService } from 'vs/platform/telemetry/common/telemetryService';\nimport { NullTelemetryServiceShape } from 'vs/platform/telemetry/common/telemetryUtils';\n\nexport interface IServerTelemetryService extends ITelemetryService {\n\tupdateInjectedTelemetryLevel(telemetryLevel: TelemetryLevel): Promise<void>;\n}\n\nexport class ServerTelemetryService extends TelemetryService implements IServerTelemetryService {\n\t// Because we cannot read the workspace config on the remote site\n\t// the ServerTelemetryService is responsible for knowing its telemetry level\n\t// this is done through IPC calls and initial value injections\n\tprivate _injectedTelemetryLevel: TelemetryLevel;\n\tconstructor(\n\t\tconfig: ITelemetryServiceConfig,\n\t\tinjectedTelemetryLevel: TelemetryLevel,\n\t\t@IConfigurationService _configurationService: IConfigurationService,\n\t\t@IProductService _productService: IProductService\n\t) {\n\t\tsuper(config, _configurationService, _productService);\n\t\tthis._injectedTelemetryLevel = injectedTelemetryLevel;\n\t}\n\n\toverride publicLog(eventName: string, data?: ITelemetryData) {\n\t\tif (this._injectedTelemetryLevel < TelemetryLevel.USAGE) {\n\t\t\treturn;\n\t\t}\n\t\treturn super.publicLog(eventName, data);\n\t}\n\n\toverride publicLog2<E extends ClassifiedEvent<OmitMetadata<T>> = never, T extends IGDPRProperty = never>(eventName: string, data?: StrictPropertyCheck<T, E>) {\n\t\treturn this.publicLog(eventName, data as ITelemetryData | undefined);\n\t}\n\n\toverride publicLogError(errorEventName: string, data?: ITelemetryData) {\n\t\tif (this._injectedTelemetryLevel < TelemetryLevel.ERROR) {\n\t\t\treturn Promise.resolve(undefined);\n\t\t}\n\t\treturn super.publicLogError(errorEventName, data);\n\t}\n\n\toverride publicLogError2<E extends ClassifiedEvent<OmitMetadata<T>> = never, T extends IGDPRProperty = never>(eventName: string, data?: StrictPropertyCheck<T, E>) {\n\t\treturn this.publicLogError(eventName, data as ITelemetryData | undefined);\n\t}\n\n\tasync updateInjectedTelemetryLevel(telemetryLevel: TelemetryLevel): Promise<void> {\n\t\tif (telemetryLevel === undefined) {\n\t\t\tthis._injectedTelemetryLevel = TelemetryLevel.NONE;\n\t\t\tthrow new Error('Telemetry level cannot be undefined. This will cause infinite looping!');\n\t\t}\n\t\t// We always take the most restrictive level because we don't want multiple clients to connect and send data when one client does not consent\n\t\tthis._injectedTelemetryLevel = this._injectedTelemetryLevel ? Math.min(this._injectedTelemetryLevel, telemetryLevel) : telemetryLevel;\n\t\tif (this._injectedTelemetryLevel === TelemetryLevel.NONE) {\n\t\t\tthis.dispose();\n\t\t}\n\t}\n}\n\nexport const ServerNullTelemetryService = new class extends NullTelemetryServiceShape implements IServerTelemetryService {\n\tasync updateInjectedTelemetryLevel(): Promise<void> { return; } // No-op, telemetry is already disabled\n};\n\nexport const IServerTelemetryService = refineServiceDecorator<ITelemetryService, IServerTelemetryService>(ITelemetryService);\n"]}