{"version":3,"sources":["file:///workspace/appflow/src/vs/platform/telemetry/common/remoteTelemetryChannel.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;IAShG,MAAa,GAAuB,SAAQ,eAAG;QAC9C,YACkB,CAAqB,EACrB,CAA4C;YAE7D,KAAK,EAAE,CAAC;YAHS,MAAC,GAAD,CAAC,CAAoB;YACrB,MAAC,GAAD,CAAC,CAA2C;QAG9D,CAAC;QAGD,KAAK,CAAC,IAAI,CAAC,CAAM,EAAE,OAAe,EAAE,GAAS;YAC5C,QAAQ,OAAO,EAAE;gBAChB,KAAK,sBAAsB,CAAC,CAAC;oBAC5B,MAAM,EAAE,cAAc,EAAE,GAAG,GAAG,CAAC;oBAC/B,OAAO,IAAI,CAAC,CAAC,CAAgB,4BAA4B,CAAC,cAAc,CAAC,CAAC;iBAC1E;gBAED,KAAK,cAAc,CAAC,CAAC;oBACpB,MAAM,EAAE,SAAS,EAAE,IAAI,EAAE,GAAG,GAAG,CAAC;oBAChC,oFAAoF;oBACpF,qFAAqF;oBACrF,wDAAwD;oBACxD,IAAI,IAAI,CAAC,CAAC,EAAkB;wBAC3B,OAAO,IAAI,CAAC,CAAC,CAAiB,GAAG,CAAC,SAAS,EAAE,IAAI,CAAC,CAAC;qBACnD;oBAED,OAAO,OAAO,CAAC,OAAO,EAAE,CAAC;iBACzB;gBAED,KAAK,gBAAgB,CAAC,CAAC;oBACtB,IAAI,IAAI,CAAC,CAAC,EAAkB;wBAC3B,OAAO,IAAI,CAAC,CAAC,CAAiB,KAAK,EAAE,CAAC;qBACtC;oBAED,OAAO,OAAO,CAAC,OAAO,EAAE,CAAC;iBACzB;gBAED,KAAK,MAAM,CAAC,CAAC;oBACZ,OAAO;iBACP;aACD;YACD,gDAAgD;YAChD,MAAM,IAAI,KAAK,CAAC,eAAe,OAAO,YAAY,CAAC,CAAC;QACrD,CAAC;QAED,MAAM,CAAC,CAAM,EAAE,KAAa,EAAE,GAAQ;YACrC,MAAM,IAAI,KAAK,CAAC,eAAe,CAAC,CAAC;QAClC,CAAC;QAED;;;WAGG;QACa,OAAO;YACtB,IAAI,CAAC,CAAC,CAAgB,4BAA4B,6BAAqB,CAAC;YACxE,KAAK,CAAC,OAAO,EAAE,CAAC;QACjB,CAAC;KACD;IAxDD,kBAwDC","file":"remoteTelemetryChannel.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event } from 'vs/base/common/event';\nimport { Disposable } from 'vs/base/common/lifecycle';\nimport { IServerChannel } from 'vs/base/parts/ipc/common/ipc';\nimport { TelemetryLevel } from 'vs/platform/telemetry/common/telemetry';\nimport { ITelemetryAppender } from 'vs/platform/telemetry/common/telemetryUtils';\nimport { IServerTelemetryService } from 'vs/platform/telemetry/common/serverTelemetryService';\n\nexport class ServerTelemetryChannel extends Disposable implements IServerChannel {\n\tconstructor(\n\t\tprivate readonly telemetryService: IServerTelemetryService,\n\t\tprivate readonly telemetryAppender: ITelemetryAppender | null\n\t) {\n\t\tsuper();\n\t}\n\n\n\tasync call(_: any, command: string, arg?: any): Promise<any> {\n\t\tswitch (command) {\n\t\t\tcase 'updateTelemetryLevel': {\n\t\t\t\tconst { telemetryLevel } = arg;\n\t\t\t\treturn this.telemetryService.updateInjectedTelemetryLevel(telemetryLevel);\n\t\t\t}\n\n\t\t\tcase 'logTelemetry': {\n\t\t\t\tconst { eventName, data } = arg;\n\t\t\t\t// Logging is done directly to the appender instead of through the telemetry service\n\t\t\t\t// as the data sent from the client has already had common properties added to it and\n\t\t\t\t// has already been sent to the telemetry output channel\n\t\t\t\tif (this.telemetryAppender) {\n\t\t\t\t\treturn this.telemetryAppender.log(eventName, data);\n\t\t\t\t}\n\n\t\t\t\treturn Promise.resolve();\n\t\t\t}\n\n\t\t\tcase 'flushTelemetry': {\n\t\t\t\tif (this.telemetryAppender) {\n\t\t\t\t\treturn this.telemetryAppender.flush();\n\t\t\t\t}\n\n\t\t\t\treturn Promise.resolve();\n\t\t\t}\n\n\t\t\tcase 'ping': {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t// Command we cannot handle so we throw an error\n\t\tthrow new Error(`IPC Command ${command} not found`);\n\t}\n\n\tlisten(_: any, event: string, arg: any): Event<any> {\n\t\tthrow new Error('Not supported');\n\t}\n\n\t/**\n\t * Disposing the channel also disables the telemetryService as there is\n\t * no longer a way to control it\n\t */\n\tpublic override dispose(): void {\n\t\tthis.telemetryService.updateInjectedTelemetryLevel(TelemetryLevel.NONE);\n\t\tsuper.dispose();\n\t}\n}\n"]}