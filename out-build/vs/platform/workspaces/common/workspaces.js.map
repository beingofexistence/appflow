{"version":3,"sources":["file:///workspace/appflow/src/vs/platform/workspaces/common/workspaces.ts"],"names":[],"mappings":"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","file":"workspaces.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event } from 'vs/base/common/event';\nimport { isUNC, toSlashes } from 'vs/base/common/extpath';\nimport * as json from 'vs/base/common/json';\nimport * as jsonEdit from 'vs/base/common/jsonEdit';\nimport { FormattingOptions } from 'vs/base/common/jsonFormatter';\nimport { normalizeDriveLetter } from 'vs/base/common/labels';\nimport { Schemas } from 'vs/base/common/network';\nimport { isAbsolute, posix } from 'vs/base/common/path';\nimport { isLinux, isMacintosh, isWindows } from 'vs/base/common/platform';\nimport { IExtUri, isEqualAuthority } from 'vs/base/common/resources';\nimport { URI } from 'vs/base/common/uri';\nimport { IWorkspaceBackupInfo, IFolderBackupInfo } from 'vs/platform/backup/common/backup';\nimport { createDecorator } from 'vs/platform/instantiation/common/instantiation';\nimport { ILogService } from 'vs/platform/log/common/log';\nimport { getRemoteAuthority } from 'vs/platform/remote/common/remoteHosts';\nimport { IBaseWorkspace, IRawFileWorkspaceFolder, IRawUriWorkspaceFolder, IWorkspaceIdentifier, WorkspaceFolder } from 'vs/platform/workspace/common/workspace';\n\nexport const IWorkspacesService = createDecorator<IWorkspacesService>('workspacesService');\n\nexport interface IWorkspacesService {\n\n\treadonly _serviceBrand: undefined;\n\n\t// Workspaces Management\n\tenterWorkspace(workspaceUri: URI): Promise<IEnterWorkspaceResult | undefined>;\n\tcreateUntitledWorkspace(folders?: IWorkspaceFolderCreationData[], remoteAuthority?: string): Promise<IWorkspaceIdentifier>;\n\tdeleteUntitledWorkspace(workspace: IWorkspaceIdentifier): Promise<void>;\n\tgetWorkspaceIdentifier(workspaceUri: URI): Promise<IWorkspaceIdentifier>;\n\n\t// Workspaces History\n\treadonly onDidChangeRecentlyOpened: Event<void>;\n\taddRecentlyOpened(recents: IRecent[]): Promise<void>;\n\tremoveRecentlyOpened(workspaces: URI[]): Promise<void>;\n\tclearRecentlyOpened(): Promise<void>;\n\tgetRecentlyOpened(): Promise<IRecentlyOpened>;\n\n\t// Dirty Workspaces\n\tgetDirtyWorkspaces(): Promise<Array<IWorkspaceBackupInfo | IFolderBackupInfo>>;\n}\n\n//#region Workspaces Recently Opened\n\nexport interface IRecentlyOpened {\n\tworkspaces: Array<IRecentWorkspace | IRecentFolder>;\n\tfiles: IRecentFile[];\n}\n\nexport type IRecent = IRecentWorkspace | IRecentFolder | IRecentFile;\n\nexport interface IRecentWorkspace {\n\treadonly workspace: IWorkspaceIdentifier;\n\tlabel?: string;\n\treadonly remoteAuthority?: string;\n}\n\nexport interface IRecentFolder {\n\treadonly folderUri: URI;\n\tlabel?: string;\n\treadonly remoteAuthority?: string;\n}\n\nexport interface IRecentFile {\n\treadonly fileUri: URI;\n\tlabel?: string;\n\treadonly remoteAuthority?: string;\n}\n\nexport function isRecentWorkspace(curr: IRecent): curr is IRecentWorkspace {\n\treturn curr.hasOwnProperty('workspace');\n}\n\nexport function isRecentFolder(curr: IRecent): curr is IRecentFolder {\n\treturn curr.hasOwnProperty('folderUri');\n}\n\nexport function isRecentFile(curr: IRecent): curr is IRecentFile {\n\treturn curr.hasOwnProperty('fileUri');\n}\n\n//#endregion\n\n//#region Workspace File Utilities\n\nexport function isStoredWorkspaceFolder(obj: unknown): obj is IStoredWorkspaceFolder {\n\treturn isRawFileWorkspaceFolder(obj) || isRawUriWorkspaceFolder(obj);\n}\n\nfunction isRawFileWorkspaceFolder(obj: unknown): obj is IRawFileWorkspaceFolder {\n\tconst candidate = obj as IRawFileWorkspaceFolder | undefined;\n\n\treturn typeof candidate?.path === 'string' && (!candidate.name || typeof candidate.name === 'string');\n}\n\nfunction isRawUriWorkspaceFolder(obj: unknown): obj is IRawUriWorkspaceFolder {\n\tconst candidate = obj as IRawUriWorkspaceFolder | undefined;\n\n\treturn typeof candidate?.uri === 'string' && (!candidate.name || typeof candidate.name === 'string');\n}\n\nexport type IStoredWorkspaceFolder = IRawFileWorkspaceFolder | IRawUriWorkspaceFolder;\n\nexport interface IStoredWorkspace extends IBaseWorkspace {\n\tfolders: IStoredWorkspaceFolder[];\n}\n\nexport interface IWorkspaceFolderCreationData {\n\treadonly uri: URI;\n\treadonly name?: string;\n}\n\nexport interface IUntitledWorkspaceInfo {\n\treadonly workspace: IWorkspaceIdentifier;\n\treadonly remoteAuthority?: string;\n}\n\nexport interface IEnterWorkspaceResult {\n\treadonly workspace: IWorkspaceIdentifier;\n\treadonly backupPath?: string;\n}\n\n/**\n * Given a folder URI and the workspace config folder, computes the `IStoredWorkspaceFolder`\n * using a relative or absolute path or a uri.\n * Undefined is returned if the `folderURI` and the `targetConfigFolderURI` don't have the\n * same schema or authority.\n *\n * @param folderURI a workspace folder\n * @param forceAbsolute if set, keep the path absolute\n * @param folderName a workspace name\n * @param targetConfigFolderURI the folder where the workspace is living in\n */\nexport function getStoredWorkspaceFolder(folderURI: URI, forceAbsolute: boolean, folderName: string | undefined, targetConfigFolderURI: URI, extUri: IExtUri): IStoredWorkspaceFolder {\n\n\t// Scheme mismatch: use full absolute URI as `uri`\n\tif (folderURI.scheme !== targetConfigFolderURI.scheme) {\n\t\treturn { name: folderName, uri: folderURI.toString(true) };\n\t}\n\n\t// Always prefer a relative path if possible unless\n\t// prevented to make the workspace file shareable\n\t// with other users\n\tlet folderPath = !forceAbsolute ? extUri.relativePath(targetConfigFolderURI, folderURI) : undefined;\n\tif (folderPath !== undefined) {\n\t\tif (folderPath.length === 0) {\n\t\t\tfolderPath = '.';\n\t\t} else {\n\t\t\tif (isWindows) {\n\t\t\t\tfolderPath = massagePathForWindows(folderPath);\n\t\t\t}\n\t\t}\n\t}\n\n\t// We could not resolve a relative path\n\telse {\n\n\t\t// Local file: use `fsPath`\n\t\tif (folderURI.scheme === Schemas.file) {\n\t\t\tfolderPath = folderURI.fsPath;\n\t\t\tif (isWindows) {\n\t\t\t\tfolderPath = massagePathForWindows(folderPath);\n\t\t\t}\n\t\t}\n\n\t\t// Different authority: use full absolute URI\n\t\telse if (!extUri.isEqualAuthority(folderURI.authority, targetConfigFolderURI.authority)) {\n\t\t\treturn { name: folderName, uri: folderURI.toString(true) };\n\t\t}\n\n\t\t// Non-local file: use `path` of URI\n\t\telse {\n\t\t\tfolderPath = folderURI.path;\n\t\t}\n\t}\n\n\treturn { name: folderName, path: folderPath };\n}\n\nfunction massagePathForWindows(folderPath: string) {\n\n\t// Drive letter should be upper case\n\tfolderPath = normalizeDriveLetter(folderPath);\n\n\t// Always prefer slash over backslash unless\n\t// we deal with UNC paths where backslash is\n\t// mandatory.\n\tif (!isUNC(folderPath)) {\n\t\tfolderPath = toSlashes(folderPath);\n\t}\n\n\treturn folderPath;\n}\n\nexport function toWorkspaceFolders(configuredFolders: IStoredWorkspaceFolder[], workspaceConfigFile: URI, extUri: IExtUri): WorkspaceFolder[] {\n\tconst result: WorkspaceFolder[] = [];\n\tconst seen: Set<string> = new Set();\n\n\tconst relativeTo = extUri.dirname(workspaceConfigFile);\n\tfor (const configuredFolder of configuredFolders) {\n\t\tlet uri: URI | undefined = undefined;\n\t\tif (isRawFileWorkspaceFolder(configuredFolder)) {\n\t\t\tif (configuredFolder.path) {\n\t\t\t\turi = extUri.resolvePath(relativeTo, configuredFolder.path);\n\t\t\t}\n\t\t} else if (isRawUriWorkspaceFolder(configuredFolder)) {\n\t\t\ttry {\n\t\t\t\turi = URI.parse(configuredFolder.uri);\n\t\t\t\tif (uri.path[0] !== posix.sep) {\n\t\t\t\t\turi = uri.with({ path: posix.sep + uri.path }); // this makes sure all workspace folder are absolute\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tconsole.warn(e); // ignore\n\t\t\t}\n\t\t}\n\n\t\tif (uri) {\n\n\t\t\t// remove duplicates\n\t\t\tconst comparisonKey = extUri.getComparisonKey(uri);\n\t\t\tif (!seen.has(comparisonKey)) {\n\t\t\t\tseen.add(comparisonKey);\n\n\t\t\t\tconst name = configuredFolder.name || extUri.basenameOrAuthority(uri);\n\t\t\t\tresult.push(new WorkspaceFolder({ uri, name, index: result.length }, configuredFolder));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * Rewrites the content of a workspace file to be saved at a new location.\n * Throws an exception if file is not a valid workspace file\n */\nexport function rewriteWorkspaceFileForNewLocation(rawWorkspaceContents: string, configPathURI: URI, isFromUntitledWorkspace: boolean, targetConfigPathURI: URI, extUri: IExtUri) {\n\tconst storedWorkspace = doParseStoredWorkspace(configPathURI, rawWorkspaceContents);\n\n\tconst sourceConfigFolder = extUri.dirname(configPathURI);\n\tconst targetConfigFolder = extUri.dirname(targetConfigPathURI);\n\n\tconst rewrittenFolders: IStoredWorkspaceFolder[] = [];\n\n\tfor (const folder of storedWorkspace.folders) {\n\t\tconst folderURI = isRawFileWorkspaceFolder(folder) ? extUri.resolvePath(sourceConfigFolder, folder.path) : URI.parse(folder.uri);\n\t\tlet absolute;\n\t\tif (isFromUntitledWorkspace) {\n\t\t\tabsolute = false; // if it was an untitled workspace, try to make paths relative\n\t\t} else {\n\t\t\tabsolute = !isRawFileWorkspaceFolder(folder) || isAbsolute(folder.path); // for existing workspaces, preserve whether a path was absolute or relative\n\t\t}\n\t\trewrittenFolders.push(getStoredWorkspaceFolder(folderURI, absolute, folder.name, targetConfigFolder, extUri));\n\t}\n\n\t// Preserve as much of the existing workspace as possible by using jsonEdit\n\t// and only changing the folders portion.\n\tconst formattingOptions: FormattingOptions = { insertSpaces: false, tabSize: 4, eol: (isLinux || isMacintosh) ? '\\n' : '\\r\\n' };\n\tconst edits = jsonEdit.setProperty(rawWorkspaceContents, ['folders'], rewrittenFolders, formattingOptions);\n\tlet newContent = jsonEdit.applyEdits(rawWorkspaceContents, edits);\n\n\tif (isEqualAuthority(storedWorkspace.remoteAuthority, getRemoteAuthority(targetConfigPathURI))) {\n\t\t// unsaved remote workspaces have the remoteAuthority set. Remove it when no longer nexessary.\n\t\tnewContent = jsonEdit.applyEdits(newContent, jsonEdit.removeProperty(newContent, ['remoteAuthority'], formattingOptions));\n\t}\n\n\treturn newContent;\n}\n\nfunction doParseStoredWorkspace(path: URI, contents: string): IStoredWorkspace {\n\n\t// Parse workspace file\n\tconst storedWorkspace: IStoredWorkspace = json.parse(contents); // use fault tolerant parser\n\n\t// Filter out folders which do not have a path or uri set\n\tif (storedWorkspace && Array.isArray(storedWorkspace.folders)) {\n\t\tstoredWorkspace.folders = storedWorkspace.folders.filter(folder => isStoredWorkspaceFolder(folder));\n\t} else {\n\t\tthrow new Error(`${path} looks like an invalid workspace file.`);\n\t}\n\n\treturn storedWorkspace;\n}\n\n//#endregion\n\n//#region Workspace Storage\n\ninterface ISerializedRecentWorkspace {\n\treadonly workspace: {\n\t\tid: string;\n\t\tconfigPath: string;\n\t};\n\treadonly label?: string;\n\treadonly remoteAuthority?: string;\n}\n\ninterface ISerializedRecentFolder {\n\treadonly folderUri: string;\n\treadonly label?: string;\n\treadonly remoteAuthority?: string;\n}\n\ninterface ISerializedRecentFile {\n\treadonly fileUri: string;\n\treadonly label?: string;\n\treadonly remoteAuthority?: string;\n}\n\ninterface ISerializedRecentlyOpened {\n\treadonly entries: Array<ISerializedRecentWorkspace | ISerializedRecentFolder | ISerializedRecentFile>; // since 1.55\n}\n\nexport type RecentlyOpenedStorageData = object;\n\nfunction isSerializedRecentWorkspace(data: any): data is ISerializedRecentWorkspace {\n\treturn data.workspace && typeof data.workspace === 'object' && typeof data.workspace.id === 'string' && typeof data.workspace.configPath === 'string';\n}\n\nfunction isSerializedRecentFolder(data: any): data is ISerializedRecentFolder {\n\treturn typeof data.folderUri === 'string';\n}\n\nfunction isSerializedRecentFile(data: any): data is ISerializedRecentFile {\n\treturn typeof data.fileUri === 'string';\n}\n\nexport function restoreRecentlyOpened(data: RecentlyOpenedStorageData | undefined, logService: ILogService): IRecentlyOpened {\n\tconst result: IRecentlyOpened = { workspaces: [], files: [] };\n\tif (data) {\n\t\tconst restoreGracefully = function <T>(entries: T[], onEntry: (entry: T, index: number) => void) {\n\t\t\tfor (let i = 0; i < entries.length; i++) {\n\t\t\t\ttry {\n\t\t\t\t\tonEntry(entries[i], i);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tlogService.warn(`Error restoring recent entry ${JSON.stringify(entries[i])}: ${e.toString()}. Skip entry.`);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tconst storedRecents = data as ISerializedRecentlyOpened;\n\t\tif (Array.isArray(storedRecents.entries)) {\n\t\t\trestoreGracefully(storedRecents.entries, entry => {\n\t\t\t\tconst label = entry.label;\n\t\t\t\tconst remoteAuthority = entry.remoteAuthority;\n\n\t\t\t\tif (isSerializedRecentWorkspace(entry)) {\n\t\t\t\t\tresult.workspaces.push({ label, remoteAuthority, workspace: { id: entry.workspace.id, configPath: URI.parse(entry.workspace.configPath) } });\n\t\t\t\t} else if (isSerializedRecentFolder(entry)) {\n\t\t\t\t\tresult.workspaces.push({ label, remoteAuthority, folderUri: URI.parse(entry.folderUri) });\n\t\t\t\t} else if (isSerializedRecentFile(entry)) {\n\t\t\t\t\tresult.files.push({ label, remoteAuthority, fileUri: URI.parse(entry.fileUri) });\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\treturn result;\n}\n\nexport function toStoreData(recents: IRecentlyOpened): RecentlyOpenedStorageData {\n\tconst serialized: ISerializedRecentlyOpened = { entries: [] };\n\n\tfor (const recent of recents.workspaces) {\n\t\tif (isRecentFolder(recent)) {\n\t\t\tserialized.entries.push({ folderUri: recent.folderUri.toString(), label: recent.label, remoteAuthority: recent.remoteAuthority });\n\t\t} else {\n\t\t\tserialized.entries.push({ workspace: { id: recent.workspace.id, configPath: recent.workspace.configPath.toString() }, label: recent.label, remoteAuthority: recent.remoteAuthority });\n\t\t}\n\t}\n\n\tfor (const recent of recents.files) {\n\t\tserialized.entries.push({ fileUri: recent.fileUri.toString(), label: recent.label, remoteAuthority: recent.remoteAuthority });\n\t}\n\n\treturn serialized;\n}\n\n//#endregion\n"]}