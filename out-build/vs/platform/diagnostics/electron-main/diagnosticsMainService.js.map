{"version":3,"sources":["file:///workspace/appflow/src/vs/platform/diagnostics/electron-main/diagnosticsMainService.ts"],"names":[],"mappings":"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","file":"diagnosticsMainService.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { app, BrowserWindow, Event as IpcEvent } from 'electron';\nimport { validatedIpcMain } from 'vs/base/parts/ipc/electron-main/ipcMain';\nimport { CancellationToken } from 'vs/base/common/cancellation';\nimport { URI } from 'vs/base/common/uri';\nimport { IDiagnosticInfo, IDiagnosticInfoOptions, IMainProcessDiagnostics, IProcessDiagnostics, IRemoteDiagnosticError, IRemoteDiagnosticInfo, IWindowDiagnostics } from 'vs/platform/diagnostics/common/diagnostics';\nimport { createDecorator } from 'vs/platform/instantiation/common/instantiation';\nimport { ICodeWindow } from 'vs/platform/window/electron-main/window';\nimport { IWindowsMainService } from 'vs/platform/windows/electron-main/windows';\nimport { isSingleFolderWorkspaceIdentifier, isWorkspaceIdentifier } from 'vs/platform/workspace/common/workspace';\nimport { IWorkspacesManagementMainService } from 'vs/platform/workspaces/electron-main/workspacesManagementMainService';\nimport { assertIsDefined } from 'vs/base/common/types';\nimport { ILogService } from 'vs/platform/log/common/log';\nimport { UtilityProcess } from 'vs/platform/utilityProcess/electron-main/utilityProcess';\n\nexport const ID = 'diagnosticsMainService';\nexport const IDiagnosticsMainService = createDecorator<IDiagnosticsMainService>(ID);\n\nexport interface IRemoteDiagnosticOptions {\n\tincludeProcesses?: boolean;\n\tincludeWorkspaceMetadata?: boolean;\n}\n\nexport interface IDiagnosticsMainService {\n\treadonly _serviceBrand: undefined;\n\tgetRemoteDiagnostics(options: IRemoteDiagnosticOptions): Promise<(IRemoteDiagnosticInfo | IRemoteDiagnosticError)[]>;\n\tgetMainDiagnostics(): Promise<IMainProcessDiagnostics>;\n}\n\nexport class DiagnosticsMainService implements IDiagnosticsMainService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tconstructor(\n\t\t@IWindowsMainService private readonly windowsMainService: IWindowsMainService,\n\t\t@IWorkspacesManagementMainService private readonly workspacesManagementMainService: IWorkspacesManagementMainService,\n\t\t@ILogService private readonly logService: ILogService\n\t) { }\n\n\tasync getRemoteDiagnostics(options: IRemoteDiagnosticOptions): Promise<(IRemoteDiagnosticInfo | IRemoteDiagnosticError)[]> {\n\t\tconst windows = this.windowsMainService.getWindows();\n\t\tconst diagnostics: Array<IDiagnosticInfo | IRemoteDiagnosticError | undefined> = await Promise.all(windows.map(async window => {\n\t\t\tconst remoteAuthority = window.remoteAuthority;\n\t\t\tif (!remoteAuthority) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tconst replyChannel = `vscode:getDiagnosticInfoResponse${window.id}`;\n\t\t\tconst args: IDiagnosticInfoOptions = {\n\t\t\t\tincludeProcesses: options.includeProcesses,\n\t\t\t\tfolders: options.includeWorkspaceMetadata ? await this.getFolderURIs(window) : undefined\n\t\t\t};\n\n\t\t\treturn new Promise<IDiagnosticInfo | IRemoteDiagnosticError>(resolve => {\n\t\t\t\twindow.sendWhenReady('vscode:getDiagnosticInfo', CancellationToken.None, { replyChannel, args });\n\n\t\t\t\tvalidatedIpcMain.once(replyChannel, (_: IpcEvent, data: IRemoteDiagnosticInfo) => {\n\t\t\t\t\t// No data is returned if getting the connection fails.\n\t\t\t\t\tif (!data) {\n\t\t\t\t\t\tresolve({ hostName: remoteAuthority, errorMessage: `Unable to resolve connection to '${remoteAuthority}'.` });\n\t\t\t\t\t}\n\n\t\t\t\t\tresolve(data);\n\t\t\t\t});\n\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tresolve({ hostName: remoteAuthority, errorMessage: `Connection to '${remoteAuthority}' could not be established` });\n\t\t\t\t}, 5000);\n\t\t\t});\n\t\t}));\n\n\t\treturn diagnostics.filter((x): x is IRemoteDiagnosticInfo | IRemoteDiagnosticError => !!x);\n\t}\n\n\tasync getMainDiagnostics(): Promise<IMainProcessDiagnostics> {\n\t\tthis.logService.trace('Received request for main process info from other instance.');\n\n\t\tconst windows: IWindowDiagnostics[] = [];\n\t\tfor (const window of BrowserWindow.getAllWindows()) {\n\t\t\tconst codeWindow = this.windowsMainService.getWindowById(window.id);\n\t\t\tif (codeWindow) {\n\t\t\t\twindows.push(await this.codeWindowToInfo(codeWindow));\n\t\t\t} else {\n\t\t\t\twindows.push(this.browserWindowToInfo(window));\n\t\t\t}\n\t\t}\n\n\t\tconst pidToNames: IProcessDiagnostics[] = [];\n\t\tfor (const { pid, name } of UtilityProcess.getAll()) {\n\t\t\tpidToNames.push({ pid, name });\n\t\t}\n\n\t\treturn {\n\t\t\tmainPID: process.pid,\n\t\t\tmainArguments: process.argv.slice(1),\n\t\t\twindows,\n\t\t\tpidToNames,\n\t\t\tscreenReader: !!app.accessibilitySupportEnabled,\n\t\t\tgpuFeatureStatus: app.getGPUFeatureStatus()\n\t\t};\n\t}\n\n\tprivate async codeWindowToInfo(window: ICodeWindow): Promise<IWindowDiagnostics> {\n\t\tconst folderURIs = await this.getFolderURIs(window);\n\t\tconst win = assertIsDefined(window.win);\n\n\t\treturn this.browserWindowToInfo(win, folderURIs, window.remoteAuthority);\n\t}\n\n\tprivate browserWindowToInfo(window: BrowserWindow, folderURIs: URI[] = [], remoteAuthority?: string): IWindowDiagnostics {\n\t\treturn {\n\t\t\tid: window.id,\n\t\t\tpid: window.webContents.getOSProcessId(),\n\t\t\ttitle: window.getTitle(),\n\t\t\tfolderURIs,\n\t\t\tremoteAuthority\n\t\t};\n\t}\n\n\tprivate async getFolderURIs(window: ICodeWindow): Promise<URI[]> {\n\t\tconst folderURIs: URI[] = [];\n\n\t\tconst workspace = window.openedWorkspace;\n\t\tif (isSingleFolderWorkspaceIdentifier(workspace)) {\n\t\t\tfolderURIs.push(workspace.uri);\n\t\t} else if (isWorkspaceIdentifier(workspace)) {\n\t\t\tconst resolvedWorkspace = await this.workspacesManagementMainService.resolveLocalWorkspace(workspace.configPath); // workspace folders can only be shown for local (resolved) workspaces\n\t\t\tif (resolvedWorkspace) {\n\t\t\t\tconst rootFolders = resolvedWorkspace.folders;\n\t\t\t\trootFolders.forEach(root => {\n\t\t\t\t\tfolderURIs.push(root.uri);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn folderURIs;\n\t}\n}\n"]}