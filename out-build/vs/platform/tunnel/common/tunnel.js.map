{"version":3,"sources":["file:///workspace/appflow/src/vs/platform/tunnel/common/tunnel.ts"],"names":[],"mappings":"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","file":"tunnel.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken } from 'vs/base/common/cancellation';\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { IDisposable } from 'vs/base/common/lifecycle';\nimport { OperatingSystem } from 'vs/base/common/platform';\nimport { URI } from 'vs/base/common/uri';\nimport { IConfigurationService } from 'vs/platform/configuration/common/configuration';\nimport { createDecorator } from 'vs/platform/instantiation/common/instantiation';\nimport { ILogService } from 'vs/platform/log/common/log';\nimport { IAddressProvider } from 'vs/platform/remote/common/remoteAgentConnection';\nimport { TunnelPrivacy } from 'vs/platform/remote/common/remoteAuthorityResolver';\n\nexport const ITunnelService = createDecorator<ITunnelService>('tunnelService');\nexport const ISharedTunnelsService = createDecorator<ISharedTunnelsService>('sharedTunnelsService');\n\nexport interface RemoteTunnel {\n\treadonly tunnelRemotePort: number;\n\treadonly tunnelRemoteHost: string;\n\treadonly tunnelLocalPort?: number;\n\treadonly localAddress: string;\n\treadonly privacy: string;\n\treadonly protocol?: string;\n\tdispose(silent?: boolean): Promise<void>;\n}\n\nexport interface TunnelOptions {\n\tremoteAddress: { port: number; host: string };\n\tlocalAddressPort?: number;\n\tlabel?: string;\n\tpublic?: boolean;\n\tprivacy?: string;\n\tprotocol?: string;\n}\n\nexport enum TunnelProtocol {\n\tHttp = 'http',\n\tHttps = 'https'\n}\n\nexport enum TunnelPrivacyId {\n\tConstantPrivate = 'constantPrivate', // private, and changing is unsupported\n\tPrivate = 'private',\n\tPublic = 'public'\n}\n\nexport interface TunnelCreationOptions {\n\televationRequired?: boolean;\n}\n\nexport interface TunnelProviderFeatures {\n\televation: boolean;\n\t/**\n\t * @deprecated\n\t */\n\tpublic?: boolean;\n\tprivacyOptions: TunnelPrivacy[];\n}\n\nexport interface ITunnelProvider {\n\tforwardPort(tunnelOptions: TunnelOptions, tunnelCreationOptions: TunnelCreationOptions): Promise<RemoteTunnel | string | undefined> | undefined;\n}\n\nexport function isTunnelProvider(addressOrTunnelProvider: IAddressProvider | ITunnelProvider): addressOrTunnelProvider is ITunnelProvider {\n\treturn !!(addressOrTunnelProvider as ITunnelProvider).forwardPort;\n}\n\nexport enum ProvidedOnAutoForward {\n\tNotify = 1,\n\tOpenBrowser = 2,\n\tOpenPreview = 3,\n\tSilent = 4,\n\tIgnore = 5,\n\tOpenBrowserOnce = 6\n}\n\nexport interface ProvidedPortAttributes {\n\tport: number;\n\tautoForwardAction: ProvidedOnAutoForward;\n}\n\nexport interface PortAttributesProvider {\n\tprovidePortAttributes(ports: number[], pid: number | undefined, commandLine: string | undefined, token: CancellationToken): Promise<ProvidedPortAttributes[]>;\n}\n\nexport interface ITunnel {\n\tremoteAddress: { port: number; host: string };\n\n\t/**\n\t * The complete local address(ex. localhost:1234)\n\t */\n\tlocalAddress: string;\n\n\t/**\n\t * @deprecated Use privacy instead\n\t */\n\tpublic?: boolean;\n\n\tprivacy?: string;\n\n\tprotocol?: string;\n\n\t/**\n\t * Implementers of Tunnel should fire onDidDispose when dispose is called.\n\t */\n\tonDidDispose: Event<void>;\n\n\tdispose(): Promise<void> | void;\n}\n\nexport interface ISharedTunnelsService {\n\treadonly _serviceBrand: undefined;\n\n\topenTunnel(authority: string, addressProvider: IAddressProvider | undefined, remoteHost: string | undefined, remotePort: number, localHost: string, localPort?: number, elevateIfNeeded?: boolean, privacy?: string, protocol?: string): Promise<RemoteTunnel | string | undefined> | undefined;\n}\n\nexport interface ITunnelService {\n\treadonly _serviceBrand: undefined;\n\n\treadonly tunnels: Promise<readonly RemoteTunnel[]>;\n\treadonly canChangePrivacy: boolean;\n\treadonly privacyOptions: TunnelPrivacy[];\n\treadonly onTunnelOpened: Event<RemoteTunnel>;\n\treadonly onTunnelClosed: Event<{ host: string; port: number }>;\n\treadonly canElevate: boolean;\n\treadonly hasTunnelProvider: boolean;\n\treadonly onAddedTunnelProvider: Event<void>;\n\n\tcanTunnel(uri: URI): boolean;\n\topenTunnel(addressProvider: IAddressProvider | undefined, remoteHost: string | undefined, remotePort: number, localHost?: string, localPort?: number, elevateIfNeeded?: boolean, privacy?: string, protocol?: string): Promise<RemoteTunnel | string | undefined> | undefined;\n\tgetExistingTunnel(remoteHost: string, remotePort: number): Promise<RemoteTunnel | string | undefined>;\n\tsetEnvironmentTunnel(remoteHost: string, remotePort: number, localAddress: string, privacy: string, protocol: string): void;\n\tcloseTunnel(remoteHost: string, remotePort: number): Promise<void>;\n\tsetTunnelProvider(provider: ITunnelProvider | undefined): IDisposable;\n\tsetTunnelFeatures(features: TunnelProviderFeatures): void;\n\tisPortPrivileged(port: number): boolean;\n}\n\nexport function extractLocalHostUriMetaDataForPortMapping(uri: URI): { address: string; port: number } | undefined {\n\tif (uri.scheme !== 'http' && uri.scheme !== 'https') {\n\t\treturn undefined;\n\t}\n\tconst localhostMatch = /^(localhost|127\\.0\\.0\\.1|0\\.0\\.0\\.0):(\\d+)$/.exec(uri.authority);\n\tif (!localhostMatch) {\n\t\treturn undefined;\n\t}\n\treturn {\n\t\taddress: localhostMatch[1],\n\t\tport: +localhostMatch[2],\n\t};\n}\n\nexport const LOCALHOST_ADDRESSES = ['localhost', '127.0.0.1', '0:0:0:0:0:0:0:1', '::1'];\nexport function isLocalhost(host: string): boolean {\n\treturn LOCALHOST_ADDRESSES.indexOf(host) >= 0;\n}\n\nexport const ALL_INTERFACES_ADDRESSES = ['0.0.0.0', '0:0:0:0:0:0:0:0', '::'];\nexport function isAllInterfaces(host: string): boolean {\n\treturn ALL_INTERFACES_ADDRESSES.indexOf(host) >= 0;\n}\n\nexport function isPortPrivileged(port: number, host: string, os: OperatingSystem, osRelease: string): boolean {\n\tif (os === OperatingSystem.Windows) {\n\t\treturn false;\n\t}\n\tif (os === OperatingSystem.Macintosh) {\n\t\tif (isAllInterfaces(host)) {\n\t\t\tconst osVersion = (/(\\d+)\\.(\\d+)\\.(\\d+)/g).exec(osRelease);\n\t\t\tif (osVersion?.length === 4) {\n\t\t\t\tconst major = parseInt(osVersion[1]);\n\t\t\t\tif (major >= 18 /* since macOS Mojave, darwin version 18.0.0 */) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn port < 1024;\n}\n\nexport class DisposableTunnel {\n\tprivate _onDispose: Emitter<void> = new Emitter();\n\tonDidDispose: Event<void> = this._onDispose.event;\n\n\tconstructor(\n\t\tpublic readonly remoteAddress: { port: number; host: string },\n\t\tpublic readonly localAddress: { port: number; host: string } | string,\n\t\tprivate readonly _dispose: () => Promise<void>) { }\n\n\tdispose(): Promise<void> {\n\t\tthis._onDispose.fire();\n\t\treturn this._dispose();\n\t}\n}\n\nexport abstract class AbstractTunnelService implements ITunnelService {\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate _onTunnelOpened: Emitter<RemoteTunnel> = new Emitter();\n\tpublic onTunnelOpened: Event<RemoteTunnel> = this._onTunnelOpened.event;\n\tprivate _onTunnelClosed: Emitter<{ host: string; port: number }> = new Emitter();\n\tpublic onTunnelClosed: Event<{ host: string; port: number }> = this._onTunnelClosed.event;\n\tprivate _onAddedTunnelProvider: Emitter<void> = new Emitter();\n\tpublic onAddedTunnelProvider: Event<void> = this._onAddedTunnelProvider.event;\n\tprotected readonly _tunnels = new Map</*host*/ string, Map</* port */ number, { refcount: number; readonly value: Promise<RemoteTunnel | string | undefined> }>>();\n\tprotected _tunnelProvider: ITunnelProvider | undefined;\n\tprotected _canElevate: boolean = false;\n\tprivate _privacyOptions: TunnelPrivacy[] = [];\n\tprivate _factoryInProgress: Set<number/*port*/> = new Set();\n\n\tpublic constructor(\n\t\t@ILogService protected readonly logService: ILogService,\n\t\t@IConfigurationService protected readonly configurationService: IConfigurationService\n\t) { }\n\n\tget hasTunnelProvider(): boolean {\n\t\treturn !!this._tunnelProvider;\n\t}\n\n\tprotected get defaultTunnelHost(): string {\n\t\tconst settingValue = this.configurationService.getValue('remote.localPortHost');\n\t\treturn (!settingValue || settingValue === 'localhost') ? '127.0.0.1' : '0.0.0.0';\n\t}\n\n\tsetTunnelProvider(provider: ITunnelProvider | undefined): IDisposable {\n\t\tthis._tunnelProvider = provider;\n\t\tif (!provider) {\n\t\t\t// clear features\n\t\t\tthis._canElevate = false;\n\t\t\tthis._privacyOptions = [];\n\t\t\tthis._onAddedTunnelProvider.fire();\n\t\t\treturn {\n\t\t\t\tdispose: () => { }\n\t\t\t};\n\t\t}\n\n\t\tthis._onAddedTunnelProvider.fire();\n\t\treturn {\n\t\t\tdispose: () => {\n\t\t\t\tthis._tunnelProvider = undefined;\n\t\t\t\tthis._canElevate = false;\n\t\t\t\tthis._privacyOptions = [];\n\t\t\t}\n\t\t};\n\t}\n\n\tsetTunnelFeatures(features: TunnelProviderFeatures): void {\n\t\tthis._canElevate = features.elevation;\n\t\tthis._privacyOptions = features.privacyOptions;\n\t}\n\n\tpublic get canElevate(): boolean {\n\t\treturn this._canElevate;\n\t}\n\n\tpublic get canChangePrivacy() {\n\t\treturn this._privacyOptions.length > 0;\n\t}\n\n\tpublic get privacyOptions() {\n\t\treturn this._privacyOptions;\n\t}\n\n\tpublic get tunnels(): Promise<readonly RemoteTunnel[]> {\n\t\treturn this.getTunnels();\n\t}\n\n\tprivate async getTunnels(): Promise<readonly RemoteTunnel[]> {\n\t\tconst tunnels: RemoteTunnel[] = [];\n\t\tconst tunnelArray = Array.from(this._tunnels.values());\n\t\tfor (const portMap of tunnelArray) {\n\t\t\tconst portArray = Array.from(portMap.values());\n\t\t\tfor (const x of portArray) {\n\t\t\t\tconst tunnelValue = await x.value;\n\t\t\t\tif (tunnelValue && (typeof tunnelValue !== 'string')) {\n\t\t\t\t\ttunnels.push(tunnelValue);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn tunnels;\n\t}\n\n\tasync dispose(): Promise<void> {\n\t\tfor (const portMap of this._tunnels.values()) {\n\t\t\tfor (const { value } of portMap.values()) {\n\t\t\t\tawait value.then(tunnel => typeof tunnel !== 'string' ? tunnel?.dispose() : undefined);\n\t\t\t}\n\t\t\tportMap.clear();\n\t\t}\n\t\tthis._tunnels.clear();\n\t}\n\n\tsetEnvironmentTunnel(remoteHost: string, remotePort: number, localAddress: string, privacy: string, protocol: string): void {\n\t\tthis.addTunnelToMap(remoteHost, remotePort, Promise.resolve({\n\t\t\ttunnelRemoteHost: remoteHost,\n\t\t\ttunnelRemotePort: remotePort,\n\t\t\tlocalAddress,\n\t\t\tprivacy,\n\t\t\tprotocol,\n\t\t\tdispose: () => Promise.resolve()\n\t\t}));\n\t}\n\n\tasync getExistingTunnel(remoteHost: string, remotePort: number): Promise<RemoteTunnel | string | undefined> {\n\t\tif (isAllInterfaces(remoteHost) || isLocalhost(remoteHost)) {\n\t\t\tremoteHost = LOCALHOST_ADDRESSES[0];\n\t\t}\n\n\t\tconst existing = this.getTunnelFromMap(remoteHost, remotePort);\n\t\tif (existing) {\n\t\t\t++existing.refcount;\n\t\t\treturn existing.value;\n\t\t}\n\t\treturn undefined;\n\t}\n\n\topenTunnel(addressProvider: IAddressProvider | undefined, remoteHost: string | undefined, remotePort: number, localHost?: string, localPort?: number, elevateIfNeeded: boolean = false, privacy?: string, protocol?: string): Promise<RemoteTunnel | string | undefined> | undefined {\n\t\tthis.logService.trace(`ForwardedPorts: (TunnelService) openTunnel request for ${remoteHost}:${remotePort} on local port ${localPort}.`);\n\t\tconst addressOrTunnelProvider = this._tunnelProvider ?? addressProvider;\n\t\tif (!addressOrTunnelProvider) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (!remoteHost) {\n\t\t\tremoteHost = 'localhost';\n\t\t}\n\t\tif (!localHost) {\n\t\t\tlocalHost = this.defaultTunnelHost;\n\t\t}\n\n\t\t// Prevent tunnel factories from calling openTunnel from within the factory\n\t\tif (this._tunnelProvider && this._factoryInProgress.has(remotePort)) {\n\t\t\tthis.logService.debug(`ForwardedPorts: (TunnelService) Another call to create a tunnel with the same address has occurred before the last one completed. This call will be ignored.`);\n\t\t\treturn;\n\t\t}\n\n\t\tconst resolvedTunnel = this.retainOrCreateTunnel(addressOrTunnelProvider, remoteHost, remotePort, localHost, localPort, elevateIfNeeded, privacy, protocol);\n\t\tif (!resolvedTunnel) {\n\t\t\tthis.logService.trace(`ForwardedPorts: (TunnelService) Tunnel was not created.`);\n\t\t\treturn resolvedTunnel;\n\t\t}\n\n\t\treturn resolvedTunnel.then(tunnel => {\n\t\t\tif (!tunnel) {\n\t\t\t\tthis.logService.trace('ForwardedPorts: (TunnelService) New tunnel is undefined.');\n\t\t\t\tthis.removeEmptyOrErrorTunnelFromMap(remoteHost!, remotePort);\n\t\t\t\treturn undefined;\n\t\t\t} else if (typeof tunnel === 'string') {\n\t\t\t\tthis.logService.trace('ForwardedPorts: (TunnelService) The tunnel provider returned an error when creating the tunnel.');\n\t\t\t\tthis.removeEmptyOrErrorTunnelFromMap(remoteHost!, remotePort);\n\t\t\t\treturn tunnel;\n\t\t\t}\n\t\t\tthis.logService.trace('ForwardedPorts: (TunnelService) New tunnel established.');\n\t\t\tconst newTunnel = this.makeTunnel(tunnel);\n\t\t\tif (tunnel.tunnelRemoteHost !== remoteHost || tunnel.tunnelRemotePort !== remotePort) {\n\t\t\t\tthis.logService.warn('ForwardedPorts: (TunnelService) Created tunnel does not match requirements of requested tunnel. Host or port mismatch.');\n\t\t\t}\n\t\t\tif (privacy && tunnel.privacy !== privacy) {\n\t\t\t\tthis.logService.warn('ForwardedPorts: (TunnelService) Created tunnel does not match requirements of requested tunnel. Privacy mismatch.');\n\t\t\t}\n\t\t\tthis._onTunnelOpened.fire(newTunnel);\n\t\t\treturn newTunnel;\n\t\t});\n\t}\n\n\tprivate makeTunnel(tunnel: RemoteTunnel): RemoteTunnel {\n\t\treturn {\n\t\t\ttunnelRemotePort: tunnel.tunnelRemotePort,\n\t\t\ttunnelRemoteHost: tunnel.tunnelRemoteHost,\n\t\t\ttunnelLocalPort: tunnel.tunnelLocalPort,\n\t\t\tlocalAddress: tunnel.localAddress,\n\t\t\tprivacy: tunnel.privacy,\n\t\t\tprotocol: tunnel.protocol,\n\t\t\tdispose: async () => {\n\t\t\t\tthis.logService.trace(`ForwardedPorts: (TunnelService) dispose request for ${tunnel.tunnelRemoteHost}:${tunnel.tunnelRemotePort} `);\n\t\t\t\tconst existingHost = this._tunnels.get(tunnel.tunnelRemoteHost);\n\t\t\t\tif (existingHost) {\n\t\t\t\t\tconst existing = existingHost.get(tunnel.tunnelRemotePort);\n\t\t\t\t\tif (existing) {\n\t\t\t\t\t\texisting.refcount--;\n\t\t\t\t\t\tawait this.tryDisposeTunnel(tunnel.tunnelRemoteHost, tunnel.tunnelRemotePort, existing);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\tprivate async tryDisposeTunnel(remoteHost: string, remotePort: number, tunnel: { refcount: number; readonly value: Promise<RemoteTunnel | string | undefined> }): Promise<void> {\n\t\tif (tunnel.refcount <= 0) {\n\t\t\tthis.logService.trace(`ForwardedPorts: (TunnelService) Tunnel is being disposed ${remoteHost}:${remotePort}.`);\n\t\t\tconst disposePromise: Promise<void> = tunnel.value.then(async (tunnel) => {\n\t\t\t\tif (tunnel && (typeof tunnel !== 'string')) {\n\t\t\t\t\tawait tunnel.dispose(true);\n\t\t\t\t\tthis._onTunnelClosed.fire({ host: tunnel.tunnelRemoteHost, port: tunnel.tunnelRemotePort });\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (this._tunnels.has(remoteHost)) {\n\t\t\t\tthis._tunnels.get(remoteHost)!.delete(remotePort);\n\t\t\t}\n\t\t\treturn disposePromise;\n\t\t}\n\t}\n\n\tasync closeTunnel(remoteHost: string, remotePort: number): Promise<void> {\n\t\tthis.logService.trace(`ForwardedPorts: (TunnelService) close request for ${remoteHost}:${remotePort} `);\n\t\tconst portMap = this._tunnels.get(remoteHost);\n\t\tif (portMap && portMap.has(remotePort)) {\n\t\t\tconst value = portMap.get(remotePort)!;\n\t\t\tvalue.refcount = 0;\n\t\t\tawait this.tryDisposeTunnel(remoteHost, remotePort, value);\n\t\t}\n\t}\n\n\tprotected addTunnelToMap(remoteHost: string, remotePort: number, tunnel: Promise<RemoteTunnel | string | undefined>) {\n\t\tif (!this._tunnels.has(remoteHost)) {\n\t\t\tthis._tunnels.set(remoteHost, new Map());\n\t\t}\n\t\tthis._tunnels.get(remoteHost)!.set(remotePort, { refcount: 1, value: tunnel });\n\t}\n\n\tprivate async removeEmptyOrErrorTunnelFromMap(remoteHost: string, remotePort: number) {\n\t\tconst hostMap = this._tunnels.get(remoteHost);\n\t\tif (hostMap) {\n\t\t\tconst tunnel = hostMap.get(remotePort);\n\t\t\tconst tunnelResult = tunnel ? await tunnel.value : undefined;\n\t\t\tif (!tunnelResult || (typeof tunnelResult === 'string')) {\n\t\t\t\thostMap.delete(remotePort);\n\t\t\t}\n\t\t\tif (hostMap.size === 0) {\n\t\t\t\tthis._tunnels.delete(remoteHost);\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected getTunnelFromMap(remoteHost: string, remotePort: number): { refcount: number; readonly value: Promise<RemoteTunnel | string | undefined> } | undefined {\n\t\tconst hosts = [remoteHost];\n\t\t// Order matters. We want the original host to be first.\n\t\tif (isLocalhost(remoteHost)) {\n\t\t\thosts.push(...LOCALHOST_ADDRESSES);\n\t\t\t// For localhost, we add the all interfaces hosts because if the tunnel is already available at all interfaces,\n\t\t\t// then of course it is available at localhost.\n\t\t\thosts.push(...ALL_INTERFACES_ADDRESSES);\n\t\t} else if (isAllInterfaces(remoteHost)) {\n\t\t\thosts.push(...ALL_INTERFACES_ADDRESSES);\n\t\t}\n\n\t\tconst existingPortMaps = hosts.map(host => this._tunnels.get(host));\n\t\tfor (const map of existingPortMaps) {\n\t\t\tconst existingTunnel = map?.get(remotePort);\n\t\t\tif (existingTunnel) {\n\t\t\t\treturn existingTunnel;\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tcanTunnel(uri: URI): boolean {\n\t\treturn !!extractLocalHostUriMetaDataForPortMapping(uri);\n\t}\n\n\tpublic abstract isPortPrivileged(port: number): boolean;\n\n\tprotected abstract retainOrCreateTunnel(addressProvider: IAddressProvider | ITunnelProvider, remoteHost: string, remotePort: number, localHost: string, localPort: number | undefined, elevateIfNeeded: boolean, privacy?: string, protocol?: string): Promise<RemoteTunnel | string | undefined> | undefined;\n\n\tprotected createWithProvider(tunnelProvider: ITunnelProvider, remoteHost: string, remotePort: number, localPort: number | undefined, elevateIfNeeded: boolean, privacy?: string, protocol?: string): Promise<RemoteTunnel | string | undefined> | undefined {\n\t\tthis.logService.trace(`ForwardedPorts: (TunnelService) Creating tunnel with provider ${remoteHost}:${remotePort} on local port ${localPort}.`);\n\t\tconst key = remotePort;\n\t\tthis._factoryInProgress.add(key);\n\t\tconst preferredLocalPort = localPort === undefined ? remotePort : localPort;\n\t\tconst creationInfo = { elevationRequired: elevateIfNeeded ? this.isPortPrivileged(preferredLocalPort) : false };\n\t\tconst tunnelOptions: TunnelOptions = { remoteAddress: { host: remoteHost, port: remotePort }, localAddressPort: localPort, privacy, public: privacy ? (privacy !== TunnelPrivacyId.Private) : undefined, protocol };\n\t\tconst tunnel = tunnelProvider.forwardPort(tunnelOptions, creationInfo);\n\t\tif (tunnel) {\n\t\t\tthis.addTunnelToMap(remoteHost, remotePort, tunnel);\n\t\t\ttunnel.finally(() => {\n\t\t\t\tthis.logService.trace('ForwardedPorts: (TunnelService) Tunnel created by provider.');\n\t\t\t\tthis._factoryInProgress.delete(key);\n\t\t\t});\n\t\t} else {\n\t\t\tthis._factoryInProgress.delete(key);\n\t\t}\n\t\treturn tunnel;\n\t}\n}\n"]}