{"version":3,"sources":["vs/platform/files/node/diskFileSystemProvider.ts"],"names":[],"mappings":"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","file":"diskFileSystemProvider.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as fs from 'fs';\nimport { gracefulify } from 'graceful-fs';\nimport { Barrier, retry } from 'vs/base/common/async';\nimport { ResourceMap } from 'vs/base/common/map';\nimport { VSBuffer } from 'vs/base/common/buffer';\nimport { CancellationToken } from 'vs/base/common/cancellation';\nimport { Event } from 'vs/base/common/event';\nimport { isEqual } from 'vs/base/common/extpath';\nimport { DisposableStore, IDisposable, toDisposable } from 'vs/base/common/lifecycle';\nimport { basename, dirname, join } from 'vs/base/common/path';\nimport { isLinux, isWindows } from 'vs/base/common/platform';\nimport { extUriBiasedIgnorePathCase, joinPath, basename as resourcesBasename, dirname as resourcesDirname } from 'vs/base/common/resources';\nimport { newWriteableStream, ReadableStreamEvents } from 'vs/base/common/stream';\nimport { URI } from 'vs/base/common/uri';\nimport { IDirent, Promises, RimRafMode, SymlinkSupport } from 'vs/base/node/pfs';\nimport { localize } from 'vs/nls';\nimport { createFileSystemProviderError, IFileAtomicReadOptions, IFileDeleteOptions, IFileOpenOptions, IFileOverwriteOptions, IFileReadStreamOptions, FileSystemProviderCapabilities, FileSystemProviderError, FileSystemProviderErrorCode, FileType, IFileWriteOptions, IFileSystemProviderWithFileAtomicReadCapability, IFileSystemProviderWithFileCloneCapability, IFileSystemProviderWithFileFolderCopyCapability, IFileSystemProviderWithFileReadStreamCapability, IFileSystemProviderWithFileReadWriteCapability, IFileSystemProviderWithOpenReadWriteCloseCapability, isFileOpenForWriteOptions, IStat, FilePermission, IFileSystemProviderWithFileAtomicWriteCapability, IFileSystemProviderWithFileAtomicDeleteCapability } from 'vs/platform/files/common/files';\nimport { readFileIntoStream } from 'vs/platform/files/common/io';\nimport { AbstractNonRecursiveWatcherClient, AbstractUniversalWatcherClient, IDiskFileChange, ILogMessage } from 'vs/platform/files/common/watcher';\nimport { ILogService } from 'vs/platform/log/common/log';\nimport { AbstractDiskFileSystemProvider, IDiskFileSystemProviderOptions } from 'vs/platform/files/common/diskFileSystemProvider';\nimport { toErrorMessage } from 'vs/base/common/errorMessage';\nimport { UniversalWatcherClient } from 'vs/platform/files/node/watcher/watcherClient';\nimport { NodeJSWatcherClient } from 'vs/platform/files/node/watcher/nodejs/nodejsClient';\n\n/**\n * Enable graceful-fs very early from here to have it enabled\n * in all contexts that leverage the disk file system provider.\n */\n(() => {\n\ttry {\n\t\tgracefulify(fs);\n\t} catch (error) {\n\t\tconsole.error(`Error enabling graceful-fs: ${toErrorMessage(error)}`);\n\t}\n})();\n\nexport class DiskFileSystemProvider extends AbstractDiskFileSystemProvider implements\n\tIFileSystemProviderWithFileReadWriteCapability,\n\tIFileSystemProviderWithOpenReadWriteCloseCapability,\n\tIFileSystemProviderWithFileReadStreamCapability,\n\tIFileSystemProviderWithFileFolderCopyCapability,\n\tIFileSystemProviderWithFileAtomicReadCapability,\n\tIFileSystemProviderWithFileAtomicWriteCapability,\n\tIFileSystemProviderWithFileAtomicDeleteCapability,\n\tIFileSystemProviderWithFileCloneCapability {\n\n\tprivate static TRACE_LOG_RESOURCE_LOCKS = false; // not enabled by default because very spammy\n\n\tconstructor(\n\t\tlogService: ILogService,\n\t\toptions?: IDiskFileSystemProviderOptions\n\t) {\n\t\tsuper(logService, options);\n\t}\n\n\t//#region File Capabilities\n\n\treadonly onDidChangeCapabilities = Event.None;\n\n\tprivate _capabilities: FileSystemProviderCapabilities | undefined;\n\tget capabilities(): FileSystemProviderCapabilities {\n\t\tif (!this._capabilities) {\n\t\t\tthis._capabilities =\n\t\t\t\tFileSystemProviderCapabilities.FileReadWrite |\n\t\t\t\tFileSystemProviderCapabilities.FileOpenReadWriteClose |\n\t\t\t\tFileSystemProviderCapabilities.FileReadStream |\n\t\t\t\tFileSystemProviderCapabilities.FileFolderCopy |\n\t\t\t\tFileSystemProviderCapabilities.FileWriteUnlock |\n\t\t\t\tFileSystemProviderCapabilities.FileAtomicRead |\n\t\t\t\tFileSystemProviderCapabilities.FileAtomicWrite |\n\t\t\t\tFileSystemProviderCapabilities.FileAtomicDelete |\n\t\t\t\tFileSystemProviderCapabilities.FileClone;\n\n\t\t\tif (isLinux) {\n\t\t\t\tthis._capabilities |= FileSystemProviderCapabilities.PathCaseSensitive;\n\t\t\t}\n\t\t}\n\n\t\treturn this._capabilities;\n\t}\n\n\t//#endregion\n\n\t//#region File Metadata Resolving\n\n\tasync stat(resource: URI): Promise<IStat> {\n\t\ttry {\n\t\t\tconst { stat, symbolicLink } = await SymlinkSupport.stat(this.toFilePath(resource)); // cannot use fs.stat() here to support links properly\n\n\t\t\treturn {\n\t\t\t\ttype: this.toType(stat, symbolicLink),\n\t\t\t\tctime: stat.birthtime.getTime(), // intentionally not using ctime here, we want the creation time\n\t\t\t\tmtime: stat.mtime.getTime(),\n\t\t\t\tsize: stat.size,\n\t\t\t\tpermissions: (stat.mode & 0o200) === 0 ? FilePermission.Locked : undefined\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tthrow this.toFileSystemProviderError(error);\n\t\t}\n\t}\n\n\tprivate async statIgnoreError(resource: URI): Promise<IStat | undefined> {\n\t\ttry {\n\t\t\treturn await this.stat(resource);\n\t\t} catch (error) {\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\tasync readdir(resource: URI): Promise<[string, FileType][]> {\n\t\ttry {\n\t\t\tconst children = await Promises.readdir(this.toFilePath(resource), { withFileTypes: true });\n\n\t\t\tconst result: [string, FileType][] = [];\n\t\t\tawait Promise.all(children.map(async child => {\n\t\t\t\ttry {\n\t\t\t\t\tlet type: FileType;\n\t\t\t\t\tif (child.isSymbolicLink()) {\n\t\t\t\t\t\ttype = (await this.stat(joinPath(resource, child.name))).type; // always resolve target the link points to if any\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttype = this.toType(child);\n\t\t\t\t\t}\n\n\t\t\t\t\tresult.push([child.name, type]);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthis.logService.trace(error); // ignore errors for individual entries that can arise from permission denied\n\t\t\t\t}\n\t\t\t}));\n\n\t\t\treturn result;\n\t\t} catch (error) {\n\t\t\tthrow this.toFileSystemProviderError(error);\n\t\t}\n\t}\n\n\tprivate toType(entry: fs.Stats | IDirent, symbolicLink?: { dangling: boolean }): FileType {\n\n\t\t// Signal file type by checking for file / directory, except:\n\t\t// - symbolic links pointing to nonexistent files are FileType.Unknown\n\t\t// - files that are neither file nor directory are FileType.Unknown\n\t\tlet type: FileType;\n\t\tif (symbolicLink?.dangling) {\n\t\t\ttype = FileType.Unknown;\n\t\t} else if (entry.isFile()) {\n\t\t\ttype = FileType.File;\n\t\t} else if (entry.isDirectory()) {\n\t\t\ttype = FileType.Directory;\n\t\t} else {\n\t\t\ttype = FileType.Unknown;\n\t\t}\n\n\t\t// Always signal symbolic link as file type additionally\n\t\tif (symbolicLink) {\n\t\t\ttype |= FileType.SymbolicLink;\n\t\t}\n\n\t\treturn type;\n\t}\n\n\t//#endregion\n\n\t//#region File Reading/Writing\n\n\tprivate readonly resourceLocks = new ResourceMap<Barrier>(resource => extUriBiasedIgnorePathCase.getComparisonKey(resource));\n\n\tprivate async createResourceLock(resource: URI): Promise<IDisposable> {\n\t\tconst filePath = this.toFilePath(resource);\n\t\tthis.traceLock(`[Disk FileSystemProvider]: createResourceLock() - request to acquire resource lock (${filePath})`);\n\n\t\t// Await pending locks for resource. It is possible for a new lock being\n\t\t// added right after opening, so we have to loop over locks until no lock\n\t\t// remains.\n\t\tlet existingLock: Barrier | undefined = undefined;\n\t\twhile (existingLock = this.resourceLocks.get(resource)) {\n\t\t\tthis.traceLock(`[Disk FileSystemProvider]: createResourceLock() - waiting for resource lock to be released (${filePath})`);\n\t\t\tawait existingLock.wait();\n\t\t}\n\n\t\t// Store new\n\t\tconst newLock = new Barrier();\n\t\tthis.resourceLocks.set(resource, newLock);\n\n\t\tthis.traceLock(`[Disk FileSystemProvider]: createResourceLock() - new resource lock created (${filePath})`);\n\n\t\treturn toDisposable(() => {\n\t\t\tthis.traceLock(`[Disk FileSystemProvider]: createResourceLock() - resource lock dispose() (${filePath})`);\n\n\t\t\t// Delete lock if it is still ours\n\t\t\tif (this.resourceLocks.get(resource) === newLock) {\n\t\t\t\tthis.traceLock(`[Disk FileSystemProvider]: createResourceLock() - resource lock removed from resource-lock map (${filePath})`);\n\t\t\t\tthis.resourceLocks.delete(resource);\n\t\t\t}\n\n\t\t\t// Open lock\n\t\t\tthis.traceLock(`[Disk FileSystemProvider]: createResourceLock() - resource lock barrier open() (${filePath})`);\n\t\t\tnewLock.open();\n\t\t});\n\t}\n\n\tasync readFile(resource: URI, options?: IFileAtomicReadOptions): Promise<Uint8Array> {\n\t\tlet lock: IDisposable | undefined = undefined;\n\t\ttry {\n\t\t\tif (options?.atomic) {\n\t\t\t\tthis.traceLock(`[Disk FileSystemProvider]: atomic read operation started (${this.toFilePath(resource)})`);\n\n\t\t\t\t// When the read should be atomic, make sure\n\t\t\t\t// to await any pending locks for the resource\n\t\t\t\t// and lock for the duration of the read.\n\t\t\t\tlock = await this.createResourceLock(resource);\n\t\t\t}\n\n\t\t\tconst filePath = this.toFilePath(resource);\n\n\t\t\treturn await Promises.readFile(filePath);\n\t\t} catch (error) {\n\t\t\tthrow this.toFileSystemProviderError(error);\n\t\t} finally {\n\t\t\tlock?.dispose();\n\t\t}\n\t}\n\n\tprivate traceLock(msg: string): void {\n\t\tif (DiskFileSystemProvider.TRACE_LOG_RESOURCE_LOCKS) {\n\t\t\tthis.logService.trace(msg);\n\t\t}\n\t}\n\n\treadFileStream(resource: URI, opts: IFileReadStreamOptions, token: CancellationToken): ReadableStreamEvents<Uint8Array> {\n\t\tconst stream = newWriteableStream<Uint8Array>(data => VSBuffer.concat(data.map(data => VSBuffer.wrap(data))).buffer);\n\n\t\treadFileIntoStream(this, resource, stream, data => data.buffer, {\n\t\t\t...opts,\n\t\t\tbufferSize: 256 * 1024 // read into chunks of 256kb each to reduce IPC overhead\n\t\t}, token);\n\n\t\treturn stream;\n\t}\n\n\tasync writeFile(resource: URI, content: Uint8Array, opts: IFileWriteOptions): Promise<void> {\n\t\tif (opts?.atomic !== false && opts?.atomic?.postfix) {\n\t\t\treturn this.doWriteFileAtomic(resource, joinPath(resourcesDirname(resource), `${resourcesBasename(resource)}${opts.atomic.postfix}`), content, opts);\n\t\t} else {\n\t\t\treturn this.doWriteFile(resource, content, opts);\n\t\t}\n\t}\n\n\tprivate async doWriteFileAtomic(resource: URI, tempResource: URI, content: Uint8Array, opts: IFileWriteOptions): Promise<void> {\n\n\t\t// Write to temp resource first\n\t\tawait this.doWriteFile(tempResource, content, opts);\n\n\t\ttry {\n\n\t\t\t// Rename over existing to ensure atomic replace\n\t\t\tawait this.rename(tempResource, resource, { overwrite: true });\n\n\t\t} catch (error) {\n\n\t\t\t// Cleanup in case of rename error\n\t\t\ttry {\n\t\t\t\tawait this.delete(tempResource, { recursive: false, useTrash: false, atomic: false });\n\t\t\t} catch (error) {\n\t\t\t\t// ignore - we want the outer error to bubble up\n\t\t\t}\n\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tprivate async doWriteFile(resource: URI, content: Uint8Array, opts: IFileWriteOptions): Promise<void> {\n\t\tlet handle: number | undefined = undefined;\n\t\ttry {\n\t\t\tconst filePath = this.toFilePath(resource);\n\n\t\t\t// Validate target unless { create: true, overwrite: true }\n\t\t\tif (!opts.create || !opts.overwrite) {\n\t\t\t\tconst fileExists = await Promises.exists(filePath);\n\t\t\t\tif (fileExists) {\n\t\t\t\t\tif (!opts.overwrite) {\n\t\t\t\t\t\tthrow createFileSystemProviderError(localize('fileExists', \"File already exists\"), FileSystemProviderErrorCode.FileExists);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (!opts.create) {\n\t\t\t\t\t\tthrow createFileSystemProviderError(localize('fileNotExists', \"File does not exist\"), FileSystemProviderErrorCode.FileNotFound);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Open\n\t\t\thandle = await this.open(resource, { create: true, unlock: opts.unlock });\n\n\t\t\t// Write content at once\n\t\t\tawait this.write(handle, 0, content, 0, content.byteLength);\n\t\t} catch (error) {\n\t\t\tthrow await this.toFileSystemProviderWriteError(resource, error);\n\t\t} finally {\n\t\t\tif (typeof handle === 'number') {\n\t\t\t\tawait this.close(handle);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate readonly mapHandleToPos = new Map<number, number>();\n\tprivate readonly mapHandleToLock = new Map<number, IDisposable>();\n\n\tprivate readonly writeHandles = new Map<number, URI>();\n\n\tprivate static canFlush: boolean = true;\n\n\tstatic configureFlushOnWrite(enabled: boolean): void {\n\t\tDiskFileSystemProvider.canFlush = enabled;\n\t}\n\n\tasync open(resource: URI, opts: IFileOpenOptions): Promise<number> {\n\t\tconst filePath = this.toFilePath(resource);\n\n\t\t// Writes: guard multiple writes to the same resource\n\t\t// behind a single lock to prevent races when writing\n\t\t// from multiple places at the same time to the same file\n\t\tlet lock: IDisposable | undefined = undefined;\n\t\tif (isFileOpenForWriteOptions(opts)) {\n\t\t\tlock = await this.createResourceLock(resource);\n\t\t}\n\n\t\tlet fd: number | undefined = undefined;\n\t\ttry {\n\n\t\t\t// Determine whether to unlock the file (write only)\n\t\t\tif (isFileOpenForWriteOptions(opts) && opts.unlock) {\n\t\t\t\ttry {\n\t\t\t\t\tconst { stat } = await SymlinkSupport.stat(filePath);\n\t\t\t\t\tif (!(stat.mode & 0o200 /* File mode indicating writable by owner */)) {\n\t\t\t\t\t\tawait Promises.chmod(filePath, stat.mode | 0o200);\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tif (error.code !== 'ENOENT') {\n\t\t\t\t\t\tthis.logService.trace(error); // ignore any errors here and try to just write\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Determine file flags for opening (read vs write)\n\t\t\tlet flags: string | undefined = undefined;\n\t\t\tif (isFileOpenForWriteOptions(opts)) {\n\t\t\t\tif (isWindows) {\n\t\t\t\t\ttry {\n\n\t\t\t\t\t\t// On Windows and if the file exists, we use a different strategy of saving the file\n\t\t\t\t\t\t// by first truncating the file and then writing with r+ flag. This helps to save hidden files on Windows\n\t\t\t\t\t\t// (see https://github.com/microsoft/vscode/issues/931) and prevent removing alternate data streams\n\t\t\t\t\t\t// (see https://github.com/microsoft/vscode/issues/6363)\n\t\t\t\t\t\tawait Promises.truncate(filePath, 0);\n\n\t\t\t\t\t\t// After a successful truncate() the flag can be set to 'r+' which will not truncate.\n\t\t\t\t\t\tflags = 'r+';\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tif (error.code !== 'ENOENT') {\n\t\t\t\t\t\t\tthis.logService.trace(error);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// We take opts.create as a hint that the file is opened for writing\n\t\t\t\t// as such we use 'w' to truncate an existing or create the\n\t\t\t\t// file otherwise. we do not allow reading.\n\t\t\t\tif (!flags) {\n\t\t\t\t\tflags = 'w';\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\t// Otherwise we assume the file is opened for reading\n\t\t\t\t// as such we use 'r' to neither truncate, nor create\n\t\t\t\t// the file.\n\t\t\t\tflags = 'r';\n\t\t\t}\n\n\t\t\t// Finally open handle to file path\n\t\t\tfd = await Promises.open(filePath, flags);\n\n\t\t} catch (error) {\n\n\t\t\t// Release lock because we have no valid handle\n\t\t\t// if we did open a lock during this operation\n\t\t\tlock?.dispose();\n\n\t\t\t// Rethrow as file system provider error\n\t\t\tif (isFileOpenForWriteOptions(opts)) {\n\t\t\t\tthrow await this.toFileSystemProviderWriteError(resource, error);\n\t\t\t} else {\n\t\t\t\tthrow this.toFileSystemProviderError(error);\n\t\t\t}\n\t\t}\n\n\t\t// Remember this handle to track file position of the handle\n\t\t// we init the position to 0 since the file descriptor was\n\t\t// just created and the position was not moved so far (see\n\t\t// also http://man7.org/linux/man-pages/man2/open.2.html -\n\t\t// \"The file offset is set to the beginning of the file.\")\n\t\tthis.mapHandleToPos.set(fd, 0);\n\n\t\t// remember that this handle was used for writing\n\t\tif (isFileOpenForWriteOptions(opts)) {\n\t\t\tthis.writeHandles.set(fd, resource);\n\t\t}\n\n\t\tif (lock) {\n\t\t\tconst previousLock = this.mapHandleToLock.get(fd);\n\n\t\t\t// Remember that this handle has an associated lock\n\t\t\tthis.traceLock(`[Disk FileSystemProvider]: open() - storing lock for handle ${fd} (${filePath})`);\n\t\t\tthis.mapHandleToLock.set(fd, lock);\n\n\t\t\t// There is a slight chance that a resource lock for a\n\t\t\t// handle was not yet disposed when we acquire a new\n\t\t\t// lock, so we must ensure to dispose the previous lock\n\t\t\t// before storing a new one for the same handle, other\n\t\t\t// wise we end up in a deadlock situation\n\t\t\t// https://github.com/microsoft/vscode/issues/142462\n\t\t\tif (previousLock) {\n\t\t\t\tthis.traceLock(`[Disk FileSystemProvider]: open() - disposing a previous lock that was still stored on same handle ${fd} (${filePath})`);\n\t\t\t\tpreviousLock.dispose();\n\t\t\t}\n\t\t}\n\n\t\treturn fd;\n\t}\n\n\tasync close(fd: number): Promise<void> {\n\n\t\t// It is very important that we keep any associated lock\n\t\t// for the file handle before attempting to call `fs.close(fd)`\n\t\t// because of a possible race condition: as soon as a file\n\t\t// handle is released, the OS may assign the same handle to\n\t\t// the next `fs.open` call and as such it is possible that our\n\t\t// lock is getting overwritten\n\t\tconst lockForHandle = this.mapHandleToLock.get(fd);\n\n\t\ttry {\n\n\t\t\t// Remove this handle from map of positions\n\t\t\tthis.mapHandleToPos.delete(fd);\n\n\t\t\t// If a handle is closed that was used for writing, ensure\n\t\t\t// to flush the contents to disk if possible.\n\t\t\tif (this.writeHandles.delete(fd) && DiskFileSystemProvider.canFlush) {\n\t\t\t\ttry {\n\t\t\t\t\tawait Promises.fdatasync(fd); // https://github.com/microsoft/vscode/issues/9589\n\t\t\t\t} catch (error) {\n\t\t\t\t\t// In some exotic setups it is well possible that node fails to sync\n\t\t\t\t\t// In that case we disable flushing and log the error to our logger\n\t\t\t\t\tDiskFileSystemProvider.configureFlushOnWrite(false);\n\t\t\t\t\tthis.logService.error(error);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn await Promises.close(fd);\n\t\t} catch (error) {\n\t\t\tthrow this.toFileSystemProviderError(error);\n\t\t} finally {\n\t\t\tif (lockForHandle) {\n\t\t\t\tif (this.mapHandleToLock.get(fd) === lockForHandle) {\n\t\t\t\t\tthis.traceLock(`[Disk FileSystemProvider]: close() - resource lock removed from handle-lock map ${fd}`);\n\t\t\t\t\tthis.mapHandleToLock.delete(fd); // only delete from map if this is still our lock!\n\t\t\t\t}\n\n\t\t\t\tthis.traceLock(`[Disk FileSystemProvider]: close() - disposing lock for handle ${fd}`);\n\t\t\t\tlockForHandle.dispose();\n\t\t\t}\n\t\t}\n\t}\n\n\tasync read(fd: number, pos: number, data: Uint8Array, offset: number, length: number): Promise<number> {\n\t\tconst normalizedPos = this.normalizePos(fd, pos);\n\n\t\tlet bytesRead: number | null = null;\n\t\ttry {\n\t\t\tbytesRead = (await Promises.read(fd, data, offset, length, normalizedPos)).bytesRead;\n\t\t} catch (error) {\n\t\t\tthrow this.toFileSystemProviderError(error);\n\t\t} finally {\n\t\t\tthis.updatePos(fd, normalizedPos, bytesRead);\n\t\t}\n\n\t\treturn bytesRead;\n\t}\n\n\tprivate normalizePos(fd: number, pos: number): number | null {\n\n\t\t// When calling fs.read/write we try to avoid passing in the \"pos\" argument and\n\t\t// rather prefer to pass in \"null\" because this avoids an extra seek(pos)\n\t\t// call that in some cases can even fail (e.g. when opening a file over FTP -\n\t\t// see https://github.com/microsoft/vscode/issues/73884).\n\t\t//\n\t\t// as such, we compare the passed in position argument with our last known\n\t\t// position for the file descriptor and use \"null\" if they match.\n\t\tif (pos === this.mapHandleToPos.get(fd)) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn pos;\n\t}\n\n\tprivate updatePos(fd: number, pos: number | null, bytesLength: number | null): void {\n\t\tconst lastKnownPos = this.mapHandleToPos.get(fd);\n\t\tif (typeof lastKnownPos === 'number') {\n\n\t\t\t// pos !== null signals that previously a position was used that is\n\t\t\t// not null. node.js documentation explains, that in this case\n\t\t\t// the internal file pointer is not moving and as such we do not move\n\t\t\t// our position pointer.\n\t\t\t//\n\t\t\t// Docs: \"If position is null, data will be read from the current file position,\n\t\t\t// and the file position will be updated. If position is an integer, the file position\n\t\t\t// will remain unchanged.\"\n\t\t\tif (typeof pos === 'number') {\n\t\t\t\t// do not modify the position\n\t\t\t}\n\n\t\t\t// bytesLength = number is a signal that the read/write operation was\n\t\t\t// successful and as such we need to advance the position in the Map\n\t\t\t//\n\t\t\t// Docs (http://man7.org/linux/man-pages/man2/read.2.html):\n\t\t\t// \"On files that support seeking, the read operation commences at the\n\t\t\t// file offset, and the file offset is incremented by the number of\n\t\t\t// bytes read.\"\n\t\t\t//\n\t\t\t// Docs (http://man7.org/linux/man-pages/man2/write.2.html):\n\t\t\t// \"For a seekable file (i.e., one to which lseek(2) may be applied, for\n\t\t\t// example, a regular file) writing takes place at the file offset, and\n\t\t\t// the file offset is incremented by the number of bytes actually\n\t\t\t// written.\"\n\t\t\telse if (typeof bytesLength === 'number') {\n\t\t\t\tthis.mapHandleToPos.set(fd, lastKnownPos + bytesLength);\n\t\t\t}\n\n\t\t\t// bytesLength = null signals an error in the read/write operation\n\t\t\t// and as such we drop the handle from the Map because the position\n\t\t\t// is unspecificed at this point.\n\t\t\telse {\n\t\t\t\tthis.mapHandleToPos.delete(fd);\n\t\t\t}\n\t\t}\n\t}\n\n\tasync write(fd: number, pos: number, data: Uint8Array, offset: number, length: number): Promise<number> {\n\n\t\t// We know at this point that the file to write to is truncated and thus empty\n\t\t// if the write now fails, the file remains empty. as such we really try hard\n\t\t// to ensure the write succeeds by retrying up to three times.\n\t\treturn retry(() => this.doWrite(fd, pos, data, offset, length), 100 /* ms delay */, 3 /* retries */);\n\t}\n\n\tprivate async doWrite(fd: number, pos: number, data: Uint8Array, offset: number, length: number): Promise<number> {\n\t\tconst normalizedPos = this.normalizePos(fd, pos);\n\n\t\tlet bytesWritten: number | null = null;\n\t\ttry {\n\t\t\tbytesWritten = (await Promises.write(fd, data, offset, length, normalizedPos)).bytesWritten;\n\t\t} catch (error) {\n\t\t\tthrow await this.toFileSystemProviderWriteError(this.writeHandles.get(fd), error);\n\t\t} finally {\n\t\t\tthis.updatePos(fd, normalizedPos, bytesWritten);\n\t\t}\n\n\t\treturn bytesWritten;\n\t}\n\n\t//#endregion\n\n\t//#region Move/Copy/Delete/Create Folder\n\n\tasync mkdir(resource: URI): Promise<void> {\n\t\ttry {\n\t\t\tawait Promises.mkdir(this.toFilePath(resource));\n\t\t} catch (error) {\n\t\t\tthrow this.toFileSystemProviderError(error);\n\t\t}\n\t}\n\n\tasync delete(resource: URI, opts: IFileDeleteOptions): Promise<void> {\n\t\ttry {\n\t\t\tconst filePath = this.toFilePath(resource);\n\t\t\tif (opts.recursive) {\n\t\t\t\tlet rmMoveToPath: string | undefined = undefined;\n\t\t\t\tif (opts?.atomic !== false && opts.atomic.postfix) {\n\t\t\t\t\trmMoveToPath = join(dirname(filePath), `${basename(filePath)}${opts.atomic.postfix}`);\n\t\t\t\t}\n\n\t\t\t\tawait Promises.rm(filePath, RimRafMode.MOVE, rmMoveToPath);\n\t\t\t} else {\n\t\t\t\ttry {\n\t\t\t\t\tawait Promises.unlink(filePath);\n\t\t\t\t} catch (unlinkError) {\n\n\t\t\t\t\t// `fs.unlink` will throw when used on directories\n\t\t\t\t\t// we try to detect this error and then see if the\n\t\t\t\t\t// provided resource is actually a directory. in that\n\t\t\t\t\t// case we use `fs.rmdir` to delete the directory.\n\n\t\t\t\t\tif (unlinkError.code === 'EPERM' || unlinkError.code === 'EISDIR') {\n\t\t\t\t\t\tlet isDirectory = false;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconst { stat, symbolicLink } = await SymlinkSupport.stat(filePath);\n\t\t\t\t\t\t\tisDirectory = stat.isDirectory() && !symbolicLink;\n\t\t\t\t\t\t} catch (statError) {\n\t\t\t\t\t\t\t// ignore\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (isDirectory) {\n\t\t\t\t\t\t\tawait Promises.rmdir(filePath);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrow unlinkError;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow unlinkError;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthrow this.toFileSystemProviderError(error);\n\t\t}\n\t}\n\n\tasync rename(from: URI, to: URI, opts: IFileOverwriteOptions): Promise<void> {\n\t\tconst fromFilePath = this.toFilePath(from);\n\t\tconst toFilePath = this.toFilePath(to);\n\n\t\tif (fromFilePath === toFilePath) {\n\t\t\treturn; // simulate node.js behaviour here and do a no-op if paths match\n\t\t}\n\n\t\ttry {\n\n\t\t\t// Validate the move operation can perform\n\t\t\tawait this.validateMoveCopy(from, to, 'move', opts.overwrite);\n\n\t\t\t// Rename\n\t\t\tawait Promises.rename(fromFilePath, toFilePath);\n\t\t} catch (error) {\n\n\t\t\t// Rewrite some typical errors that can happen especially around symlinks\n\t\t\t// to something the user can better understand\n\t\t\tif (error.code === 'EINVAL' || error.code === 'EBUSY' || error.code === 'ENAMETOOLONG') {\n\t\t\t\terror = new Error(localize('moveError', \"Unable to move '{0}' into '{1}' ({2}).\", basename(fromFilePath), basename(dirname(toFilePath)), error.toString()));\n\t\t\t}\n\n\t\t\tthrow this.toFileSystemProviderError(error);\n\t\t}\n\t}\n\n\tasync copy(from: URI, to: URI, opts: IFileOverwriteOptions): Promise<void> {\n\t\tconst fromFilePath = this.toFilePath(from);\n\t\tconst toFilePath = this.toFilePath(to);\n\n\t\tif (fromFilePath === toFilePath) {\n\t\t\treturn; // simulate node.js behaviour here and do a no-op if paths match\n\t\t}\n\n\t\ttry {\n\n\t\t\t// Validate the copy operation can perform\n\t\t\tawait this.validateMoveCopy(from, to, 'copy', opts.overwrite);\n\n\t\t\t// Copy\n\t\t\tawait Promises.copy(fromFilePath, toFilePath, { preserveSymlinks: true });\n\t\t} catch (error) {\n\n\t\t\t// Rewrite some typical errors that can happen especially around symlinks\n\t\t\t// to something the user can better understand\n\t\t\tif (error.code === 'EINVAL' || error.code === 'EBUSY' || error.code === 'ENAMETOOLONG') {\n\t\t\t\terror = new Error(localize('copyError', \"Unable to copy '{0}' into '{1}' ({2}).\", basename(fromFilePath), basename(dirname(toFilePath)), error.toString()));\n\t\t\t}\n\n\t\t\tthrow this.toFileSystemProviderError(error);\n\t\t}\n\t}\n\n\tprivate async validateMoveCopy(from: URI, to: URI, mode: 'move' | 'copy', overwrite?: boolean): Promise<void> {\n\t\tconst fromFilePath = this.toFilePath(from);\n\t\tconst toFilePath = this.toFilePath(to);\n\n\t\tlet isSameResourceWithDifferentPathCase = false;\n\t\tconst isPathCaseSensitive = !!(this.capabilities & FileSystemProviderCapabilities.PathCaseSensitive);\n\t\tif (!isPathCaseSensitive) {\n\t\t\tisSameResourceWithDifferentPathCase = isEqual(fromFilePath, toFilePath, true /* ignore case */);\n\t\t}\n\n\t\tif (isSameResourceWithDifferentPathCase) {\n\n\t\t\t// You cannot copy the same file to the same location with different\n\t\t\t// path case unless you are on a case sensitive file system\n\t\t\tif (mode === 'copy') {\n\t\t\t\tthrow createFileSystemProviderError(localize('fileCopyErrorPathCase', \"File cannot be copied to same path with different path case\"), FileSystemProviderErrorCode.FileExists);\n\t\t\t}\n\n\t\t\t// You can move the same file to the same location with different\n\t\t\t// path case on case insensitive file systems\n\t\t\telse if (mode === 'move') {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// Here we have to see if the target to move/copy to exists or not.\n\t\t// We need to respect the `overwrite` option to throw in case the\n\t\t// target exists.\n\n\t\tconst fromStat = await this.statIgnoreError(from);\n\t\tif (!fromStat) {\n\t\t\tthrow createFileSystemProviderError(localize('fileMoveCopyErrorNotFound', \"File to move/copy does not exist\"), FileSystemProviderErrorCode.FileNotFound);\n\t\t}\n\n\t\tconst toStat = await this.statIgnoreError(to);\n\t\tif (!toStat) {\n\t\t\treturn; // target does not exist so we are good\n\t\t}\n\n\t\tif (!overwrite) {\n\t\t\tthrow createFileSystemProviderError(localize('fileMoveCopyErrorExists', \"File at target already exists and thus will not be moved/copied to unless overwrite is specified\"), FileSystemProviderErrorCode.FileExists);\n\t\t}\n\n\t\t// Handle existing target for move/copy\n\t\tif ((fromStat.type & FileType.File) !== 0 && (toStat.type & FileType.File) !== 0) {\n\t\t\treturn; // node.js can move/copy a file over an existing file without having to delete it first\n\t\t} else {\n\t\t\tawait this.delete(to, { recursive: true, useTrash: false, atomic: false });\n\t\t}\n\t}\n\n\t//#endregion\n\n\t//#region Clone File\n\n\tasync cloneFile(from: URI, to: URI): Promise<void> {\n\t\treturn this.doCloneFile(from, to, false /* optimistically assume parent folders exist */);\n\t}\n\n\tprivate async doCloneFile(from: URI, to: URI, mkdir: boolean): Promise<void> {\n\t\tconst fromFilePath = this.toFilePath(from);\n\t\tconst toFilePath = this.toFilePath(to);\n\n\t\tconst isPathCaseSensitive = !!(this.capabilities & FileSystemProviderCapabilities.PathCaseSensitive);\n\t\tif (isEqual(fromFilePath, toFilePath, !isPathCaseSensitive)) {\n\t\t\treturn; // cloning is only supported `from` and `to` are different files\n\t\t}\n\n\t\t// Implement clone by using `fs.copyFile`, however setup locks\n\t\t// for both `from` and `to` because node.js does not ensure\n\t\t// this to be an atomic operation\n\n\t\tconst locks = new DisposableStore();\n\n\t\ttry {\n\t\t\tconst [fromLock, toLock] = await Promise.all([\n\t\t\t\tthis.createResourceLock(from),\n\t\t\t\tthis.createResourceLock(to)\n\t\t\t]);\n\n\t\t\tlocks.add(fromLock);\n\t\t\tlocks.add(toLock);\n\n\t\t\tif (mkdir) {\n\t\t\t\tawait Promises.mkdir(dirname(toFilePath), { recursive: true });\n\t\t\t}\n\n\t\t\tawait Promises.copyFile(fromFilePath, toFilePath);\n\t\t} catch (error) {\n\t\t\tif (error.code === 'ENOENT' && !mkdir) {\n\t\t\t\treturn this.doCloneFile(from, to, true);\n\t\t\t}\n\n\t\t\tthrow this.toFileSystemProviderError(error);\n\t\t} finally {\n\t\t\tlocks.dispose();\n\t\t}\n\t}\n\n\t//#endregion\n\n\t//#region File Watching\n\n\tprotected createUniversalWatcher(\n\t\tonChange: (changes: IDiskFileChange[]) => void,\n\t\tonLogMessage: (msg: ILogMessage) => void,\n\t\tverboseLogging: boolean\n\t): AbstractUniversalWatcherClient {\n\t\treturn new UniversalWatcherClient(changes => onChange(changes), msg => onLogMessage(msg), verboseLogging);\n\t}\n\n\tprotected createNonRecursiveWatcher(\n\t\tonChange: (changes: IDiskFileChange[]) => void,\n\t\tonLogMessage: (msg: ILogMessage) => void,\n\t\tverboseLogging: boolean\n\t): AbstractNonRecursiveWatcherClient {\n\t\treturn new NodeJSWatcherClient(changes => onChange(changes), msg => onLogMessage(msg), verboseLogging);\n\t}\n\n\t//#endregion\n\n\t//#region Helpers\n\n\tprivate toFileSystemProviderError(error: NodeJS.ErrnoException): FileSystemProviderError {\n\t\tif (error instanceof FileSystemProviderError) {\n\t\t\treturn error; // avoid double conversion\n\t\t}\n\n\t\tlet resultError: Error | string = error;\n\t\tlet code: FileSystemProviderErrorCode;\n\t\tswitch (error.code) {\n\t\t\tcase 'ENOENT':\n\t\t\t\tcode = FileSystemProviderErrorCode.FileNotFound;\n\t\t\t\tbreak;\n\t\t\tcase 'EISDIR':\n\t\t\t\tcode = FileSystemProviderErrorCode.FileIsADirectory;\n\t\t\t\tbreak;\n\t\t\tcase 'ENOTDIR':\n\t\t\t\tcode = FileSystemProviderErrorCode.FileNotADirectory;\n\t\t\t\tbreak;\n\t\t\tcase 'EEXIST':\n\t\t\t\tcode = FileSystemProviderErrorCode.FileExists;\n\t\t\t\tbreak;\n\t\t\tcase 'EPERM':\n\t\t\tcase 'EACCES':\n\t\t\t\tcode = FileSystemProviderErrorCode.NoPermissions;\n\t\t\t\tbreak;\n\t\t\tcase 'ERR_UNC_HOST_NOT_ALLOWED':\n\t\t\t\tresultError = `${error.message}. Please update the 'security.allowedUNCHosts' setting if you want to allow this host.`;\n\t\t\t\tcode = FileSystemProviderErrorCode.Unknown;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tcode = FileSystemProviderErrorCode.Unknown;\n\t\t}\n\n\t\treturn createFileSystemProviderError(resultError, code);\n\t}\n\n\tprivate async toFileSystemProviderWriteError(resource: URI | undefined, error: NodeJS.ErrnoException): Promise<FileSystemProviderError> {\n\t\tlet fileSystemProviderWriteError = this.toFileSystemProviderError(error);\n\n\t\t// If the write error signals permission issues, we try\n\t\t// to read the file's mode to see if the file is write\n\t\t// locked.\n\t\tif (resource && fileSystemProviderWriteError.code === FileSystemProviderErrorCode.NoPermissions) {\n\t\t\ttry {\n\t\t\t\tconst { stat } = await SymlinkSupport.stat(this.toFilePath(resource));\n\t\t\t\tif (!(stat.mode & 0o200 /* File mode indicating writable by owner */)) {\n\t\t\t\t\tfileSystemProviderWriteError = createFileSystemProviderError(error, FileSystemProviderErrorCode.FileWriteLocked);\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tthis.logService.trace(error); // ignore - return original error\n\t\t\t}\n\t\t}\n\n\t\treturn fileSystemProviderWriteError;\n\t}\n\n\t//#endregion\n}\n"]}