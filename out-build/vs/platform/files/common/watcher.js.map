{"version":3,"sources":["file:///workspace/appflow/src/vs/platform/files/common/watcher.ts"],"names":[],"mappings":"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","file":"watcher.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event } from 'vs/base/common/event';\nimport { GLOBSTAR, IRelativePattern, parse, ParsedPattern } from 'vs/base/common/glob';\nimport { Disposable, DisposableStore, MutableDisposable } from 'vs/base/common/lifecycle';\nimport { isAbsolute } from 'vs/base/common/path';\nimport { isLinux } from 'vs/base/common/platform';\nimport { URI as uri } from 'vs/base/common/uri';\nimport { FileChangeType, IFileChange, isParent } from 'vs/platform/files/common/files';\n\ninterface IWatchRequest {\n\n\t/**\n\t * The path to watch.\n\t */\n\tpath: string;\n\n\t/**\n\t * Whether to watch recursively or not.\n\t */\n\trecursive: boolean;\n\n\t/**\n\t * A set of glob patterns or paths to exclude from watching.\n\t */\n\texcludes: string[];\n\n\t/**\n\t * An optional set of glob patterns or paths to include for\n\t * watching. If not provided, all paths are considered for\n\t * events.\n\t */\n\tincludes?: Array<string | IRelativePattern>;\n}\n\nexport interface INonRecursiveWatchRequest extends IWatchRequest {\n\n\t/**\n\t * The watcher will be non-recursive.\n\t */\n\trecursive: false;\n}\n\nexport interface IRecursiveWatchRequest extends IWatchRequest {\n\n\t/**\n\t * The watcher will be recursive.\n\t */\n\trecursive: true;\n\n\t/**\n\t * @deprecated this only exists for WSL1 support and should never\n\t * be used in any other case.\n\t */\n\tpollingInterval?: number;\n}\n\nexport function isRecursiveWatchRequest(request: IWatchRequest): request is IRecursiveWatchRequest {\n\treturn request.recursive === true;\n}\n\nexport type IUniversalWatchRequest = IRecursiveWatchRequest | INonRecursiveWatchRequest;\n\ninterface IWatcher {\n\n\t/**\n\t * A normalized file change event from the raw events\n\t * the watcher emits.\n\t */\n\treadonly onDidChangeFile: Event<IDiskFileChange[]>;\n\n\t/**\n\t * An event to indicate a message that should get logged.\n\t */\n\treadonly onDidLogMessage: Event<ILogMessage>;\n\n\t/**\n\t * An event to indicate an error occurred from the watcher\n\t * that is unrecoverable. Listeners should restart the\n\t * watcher if possible.\n\t */\n\treadonly onDidError: Event<string>;\n\n\t/**\n\t * Configures the watcher to watch according to the\n\t * requests. Any existing watched path that is not\n\t * in the array, will be removed from watching and\n\t * any new path will be added to watching.\n\t */\n\twatch(requests: IWatchRequest[]): Promise<void>;\n\n\t/**\n\t * Enable verbose logging in the watcher.\n\t */\n\tsetVerboseLogging(enabled: boolean): Promise<void>;\n\n\t/**\n\t * Stop all watchers.\n\t */\n\tstop(): Promise<void>;\n}\n\nexport interface IRecursiveWatcher extends IWatcher {\n\twatch(requests: IRecursiveWatchRequest[]): Promise<void>;\n}\n\nexport interface IRecursiveWatcherOptions {\n\n\t/**\n\t * If `true`, will enable polling for all watchers, otherwise\n\t * will enable it for paths included in the string array.\n\t *\n\t * @deprecated this only exists for WSL1 support and should never\n\t * be used in any other case.\n\t */\n\tusePolling: boolean | string[];\n\n\t/**\n\t * If polling is enabled (via `usePolling`), defines the duration\n\t * in which the watcher will poll for changes.\n\t *\n\t * @deprecated this only exists for WSL1 support and should never\n\t * be used in any other case.\n\t */\n\tpollingInterval?: number;\n}\n\nexport interface INonRecursiveWatcher extends IWatcher {\n\twatch(requests: INonRecursiveWatchRequest[]): Promise<void>;\n}\n\nexport interface IUniversalWatcher extends IWatcher {\n\twatch(requests: IUniversalWatchRequest[]): Promise<void>;\n}\n\nexport abstract class AbstractWatcherClient extends Disposable {\n\n\tprivate static readonly MAX_RESTARTS = 5;\n\n\tprivate watcher: IWatcher | undefined;\n\tprivate readonly watcherDisposables = this._register(new MutableDisposable());\n\n\tprivate requests: IWatchRequest[] | undefined = undefined;\n\n\tprivate restartCounter = 0;\n\n\tconstructor(\n\t\tprivate readonly onFileChanges: (changes: IDiskFileChange[]) => void,\n\t\tprivate readonly onLogMessage: (msg: ILogMessage) => void,\n\t\tprivate verboseLogging: boolean,\n\t\tprivate options: {\n\t\t\ttype: string;\n\t\t\trestartOnError: boolean;\n\t\t}\n\t) {\n\t\tsuper();\n\t}\n\n\tprotected abstract createWatcher(disposables: DisposableStore): IWatcher;\n\n\tprotected init(): void {\n\n\t\t// Associate disposables to the watcher\n\t\tconst disposables = new DisposableStore();\n\t\tthis.watcherDisposables.value = disposables;\n\n\t\t// Ask implementors to create the watcher\n\t\tthis.watcher = this.createWatcher(disposables);\n\t\tthis.watcher.setVerboseLogging(this.verboseLogging);\n\n\t\t// Wire in event handlers\n\t\tdisposables.add(this.watcher.onDidChangeFile(changes => this.onFileChanges(changes)));\n\t\tdisposables.add(this.watcher.onDidLogMessage(msg => this.onLogMessage(msg)));\n\t\tdisposables.add(this.watcher.onDidError(error => this.onError(error)));\n\t}\n\n\tprotected onError(error: string): void {\n\n\t\t// Restart on error (up to N times, if enabled)\n\t\tif (this.options.restartOnError) {\n\t\t\tif (this.restartCounter < AbstractWatcherClient.MAX_RESTARTS && this.requests) {\n\t\t\t\tthis.error(`restarting watcher after error: ${error}`);\n\t\t\t\tthis.restart(this.requests);\n\t\t\t} else {\n\t\t\t\tthis.error(`gave up attempting to restart watcher after error: ${error}`);\n\t\t\t}\n\t\t}\n\n\t\t// Do not attempt to restart if not enabled\n\t\telse {\n\t\t\tthis.error(error);\n\t\t}\n\t}\n\n\tprivate restart(requests: IUniversalWatchRequest[]): void {\n\t\tthis.restartCounter++;\n\n\t\tthis.init();\n\t\tthis.watch(requests);\n\t}\n\n\tasync watch(requests: IUniversalWatchRequest[]): Promise<void> {\n\t\tthis.requests = requests;\n\n\t\tawait this.watcher?.watch(requests);\n\t}\n\n\tasync setVerboseLogging(verboseLogging: boolean): Promise<void> {\n\t\tthis.verboseLogging = verboseLogging;\n\n\t\tawait this.watcher?.setVerboseLogging(verboseLogging);\n\t}\n\n\tprivate error(message: string) {\n\t\tthis.onLogMessage({ type: 'error', message: `[File Watcher (${this.options.type})] ${message}` });\n\t}\n\n\tprotected trace(message: string) {\n\t\tthis.onLogMessage({ type: 'trace', message: `[File Watcher (${this.options.type})] ${message}` });\n\t}\n\n\toverride dispose(): void {\n\n\t\t// Render the watcher invalid from here\n\t\tthis.watcher = undefined;\n\n\t\treturn super.dispose();\n\t}\n}\n\nexport abstract class AbstractNonRecursiveWatcherClient extends AbstractWatcherClient {\n\n\tconstructor(\n\t\tonFileChanges: (changes: IDiskFileChange[]) => void,\n\t\tonLogMessage: (msg: ILogMessage) => void,\n\t\tverboseLogging: boolean\n\t) {\n\t\tsuper(onFileChanges, onLogMessage, verboseLogging, { type: 'node.js', restartOnError: false });\n\t}\n\n\tprotected abstract override createWatcher(disposables: DisposableStore): INonRecursiveWatcher;\n}\n\nexport abstract class AbstractUniversalWatcherClient extends AbstractWatcherClient {\n\n\tconstructor(\n\t\tonFileChanges: (changes: IDiskFileChange[]) => void,\n\t\tonLogMessage: (msg: ILogMessage) => void,\n\t\tverboseLogging: boolean\n\t) {\n\t\tsuper(onFileChanges, onLogMessage, verboseLogging, { type: 'universal', restartOnError: true });\n\t}\n\n\tprotected abstract override createWatcher(disposables: DisposableStore): IUniversalWatcher;\n}\n\nexport interface IDiskFileChange {\n\ttype: FileChangeType;\n\tpath: string;\n}\n\nexport interface ILogMessage {\n\ttype: 'trace' | 'warn' | 'error' | 'info' | 'debug';\n\tmessage: string;\n}\n\nexport function toFileChanges(changes: IDiskFileChange[]): IFileChange[] {\n\treturn changes.map(change => ({\n\t\ttype: change.type,\n\t\tresource: uri.file(change.path)\n\t}));\n}\n\nexport function coalesceEvents(changes: IDiskFileChange[]): IDiskFileChange[] {\n\n\t// Build deltas\n\tconst coalescer = new EventCoalescer();\n\tfor (const event of changes) {\n\t\tcoalescer.processEvent(event);\n\t}\n\n\treturn coalescer.coalesce();\n}\n\nexport function normalizeWatcherPattern(path: string, pattern: string | IRelativePattern): string | IRelativePattern {\n\n\t// Patterns are always matched on the full absolute path\n\t// of the event. As such, if the pattern is not absolute\n\t// and is a string and does not start with a leading\n\t// `**`, we have to convert it to a relative pattern with\n\t// the given `base`\n\n\tif (typeof pattern === 'string' && !pattern.startsWith(GLOBSTAR) && !isAbsolute(pattern)) {\n\t\treturn { base: path, pattern };\n\t}\n\n\treturn pattern;\n}\n\nexport function parseWatcherPatterns(path: string, patterns: Array<string | IRelativePattern>): ParsedPattern[] {\n\tconst parsedPatterns: ParsedPattern[] = [];\n\n\tfor (const pattern of patterns) {\n\t\tparsedPatterns.push(parse(normalizeWatcherPattern(path, pattern)));\n\t}\n\n\treturn parsedPatterns;\n}\n\nclass EventCoalescer {\n\n\tprivate readonly coalesced = new Set<IDiskFileChange>();\n\tprivate readonly mapPathToChange = new Map<string, IDiskFileChange>();\n\n\tprivate toKey(event: IDiskFileChange): string {\n\t\tif (isLinux) {\n\t\t\treturn event.path;\n\t\t}\n\n\t\treturn event.path.toLowerCase(); // normalise to file system case sensitivity\n\t}\n\n\tprocessEvent(event: IDiskFileChange): void {\n\t\tconst existingEvent = this.mapPathToChange.get(this.toKey(event));\n\n\t\tlet keepEvent = false;\n\n\t\t// Event path already exists\n\t\tif (existingEvent) {\n\t\t\tconst currentChangeType = existingEvent.type;\n\t\t\tconst newChangeType = event.type;\n\n\t\t\t// macOS/Windows: track renames to different case\n\t\t\t// by keeping both CREATE and DELETE events\n\t\t\tif (existingEvent.path !== event.path && (event.type === FileChangeType.DELETED || event.type === FileChangeType.ADDED)) {\n\t\t\t\tkeepEvent = true;\n\t\t\t}\n\n\t\t\t// Ignore CREATE followed by DELETE in one go\n\t\t\telse if (currentChangeType === FileChangeType.ADDED && newChangeType === FileChangeType.DELETED) {\n\t\t\t\tthis.mapPathToChange.delete(this.toKey(event));\n\t\t\t\tthis.coalesced.delete(existingEvent);\n\t\t\t}\n\n\t\t\t// Flatten DELETE followed by CREATE into CHANGE\n\t\t\telse if (currentChangeType === FileChangeType.DELETED && newChangeType === FileChangeType.ADDED) {\n\t\t\t\texistingEvent.type = FileChangeType.UPDATED;\n\t\t\t}\n\n\t\t\t// Do nothing. Keep the created event\n\t\t\telse if (currentChangeType === FileChangeType.ADDED && newChangeType === FileChangeType.UPDATED) { }\n\n\t\t\t// Otherwise apply change type\n\t\t\telse {\n\t\t\t\texistingEvent.type = newChangeType;\n\t\t\t}\n\t\t}\n\n\t\t// Otherwise keep\n\t\telse {\n\t\t\tkeepEvent = true;\n\t\t}\n\n\t\tif (keepEvent) {\n\t\t\tthis.coalesced.add(event);\n\t\t\tthis.mapPathToChange.set(this.toKey(event), event);\n\t\t}\n\t}\n\n\tcoalesce(): IDiskFileChange[] {\n\t\tconst addOrChangeEvents: IDiskFileChange[] = [];\n\t\tconst deletedPaths: string[] = [];\n\n\t\t// This algorithm will remove all DELETE events up to the root folder\n\t\t// that got deleted if any. This ensures that we are not producing\n\t\t// DELETE events for each file inside a folder that gets deleted.\n\t\t//\n\t\t// 1.) split ADD/CHANGE and DELETED events\n\t\t// 2.) sort short deleted paths to the top\n\t\t// 3.) for each DELETE, check if there is a deleted parent and ignore the event in that case\n\t\treturn Array.from(this.coalesced).filter(e => {\n\t\t\tif (e.type !== FileChangeType.DELETED) {\n\t\t\t\taddOrChangeEvents.push(e);\n\n\t\t\t\treturn false; // remove ADD / CHANGE\n\t\t\t}\n\n\t\t\treturn true; // keep DELETE\n\t\t}).sort((e1, e2) => {\n\t\t\treturn e1.path.length - e2.path.length; // shortest path first\n\t\t}).filter(e => {\n\t\t\tif (deletedPaths.some(deletedPath => isParent(e.path, deletedPath, !isLinux /* ignorecase */))) {\n\t\t\t\treturn false; // DELETE is ignored if parent is deleted already\n\t\t\t}\n\n\t\t\t// otherwise mark as deleted\n\t\t\tdeletedPaths.push(e.path);\n\n\t\t\treturn true;\n\t\t}).concat(addOrChangeEvents);\n\t}\n}\n"]}