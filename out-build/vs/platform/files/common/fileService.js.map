{"version":3,"sources":["vs/platform/files/common/fileService.ts"],"names":[],"mappings":"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","file":"fileService.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { coalesce } from 'vs/base/common/arrays';\nimport { Promises, ResourceQueue } from 'vs/base/common/async';\nimport { bufferedStreamToBuffer, bufferToReadable, newWriteableBufferStream, readableToBuffer, streamToBuffer, VSBuffer, VSBufferReadable, VSBufferReadableBufferedStream, VSBufferReadableStream } from 'vs/base/common/buffer';\nimport { CancellationToken, CancellationTokenSource } from 'vs/base/common/cancellation';\nimport { Emitter } from 'vs/base/common/event';\nimport { hash } from 'vs/base/common/hash';\nimport { Iterable } from 'vs/base/common/iterator';\nimport { Disposable, DisposableStore, dispose, IDisposable, toDisposable } from 'vs/base/common/lifecycle';\nimport { TernarySearchTree } from 'vs/base/common/ternarySearchTree';\nimport { Schemas } from 'vs/base/common/network';\nimport { mark } from 'vs/base/common/performance';\nimport { basename, dirname, extUri, extUriIgnorePathCase, IExtUri, isAbsolutePath, joinPath } from 'vs/base/common/resources';\nimport { consumeStream, isReadableBufferedStream, isReadableStream, listenStream, newWriteableStream, peekReadable, peekStream, transform } from 'vs/base/common/stream';\nimport { URI } from 'vs/base/common/uri';\nimport { localize } from 'vs/nls';\nimport { ensureFileSystemProviderError, etag, ETAG_DISABLED, FileChangesEvent, IFileDeleteOptions, FileOperation, FileOperationError, FileOperationEvent, FileOperationResult, FilePermission, FileSystemProviderCapabilities, FileSystemProviderErrorCode, FileType, hasFileAtomicReadCapability, hasFileFolderCopyCapability, hasFileReadStreamCapability, hasOpenReadWriteCloseCapability, hasReadWriteCapability, ICreateFileOptions, IFileContent, IFileService, IFileStat, IFileStatWithMetadata, IFileStreamContent, IFileSystemProvider, IFileSystemProviderActivationEvent, IFileSystemProviderCapabilitiesChangeEvent, IFileSystemProviderRegistrationEvent, IFileSystemProviderWithFileAtomicReadCapability, IFileSystemProviderWithFileReadStreamCapability, IFileSystemProviderWithFileReadWriteCapability, IFileSystemProviderWithOpenReadWriteCloseCapability, IReadFileOptions, IReadFileStreamOptions, IResolveFileOptions, IFileStatResult, IFileStatResultWithMetadata, IResolveMetadataFileOptions, IStat, IFileStatWithPartialMetadata, IWatchOptions, IWriteFileOptions, NotModifiedSinceFileOperationError, toFileOperationResult, toFileSystemProviderErrorCode, hasFileCloneCapability, TooLargeFileOperationError } from 'vs/platform/files/common/files';\nimport { readFileIntoStream } from 'vs/platform/files/common/io';\nimport { ILogService } from 'vs/platform/log/common/log';\nimport { ErrorNoTelemetry } from 'vs/base/common/errors';\n\nexport class FileService extends Disposable implements IFileService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\t// Choose a buffer size that is a balance between memory needs and\n\t// manageable IPC overhead. The larger the buffer size, the less\n\t// roundtrips we have to do for reading/writing data.\n\tprivate readonly BUFFER_SIZE = 256 * 1024;\n\n\tconstructor(@ILogService private readonly logService: ILogService) {\n\t\tsuper();\n\t}\n\n\t//#region File System Provider\n\n\tprivate readonly _onDidChangeFileSystemProviderRegistrations = this._register(new Emitter<IFileSystemProviderRegistrationEvent>());\n\treadonly onDidChangeFileSystemProviderRegistrations = this._onDidChangeFileSystemProviderRegistrations.event;\n\n\tprivate readonly _onWillActivateFileSystemProvider = this._register(new Emitter<IFileSystemProviderActivationEvent>());\n\treadonly onWillActivateFileSystemProvider = this._onWillActivateFileSystemProvider.event;\n\n\tprivate readonly _onDidChangeFileSystemProviderCapabilities = this._register(new Emitter<IFileSystemProviderCapabilitiesChangeEvent>());\n\treadonly onDidChangeFileSystemProviderCapabilities = this._onDidChangeFileSystemProviderCapabilities.event;\n\n\tprivate readonly provider = new Map<string, IFileSystemProvider>();\n\n\tregisterProvider(scheme: string, provider: IFileSystemProvider): IDisposable {\n\t\tif (this.provider.has(scheme)) {\n\t\t\tthrow new Error(`A filesystem provider for the scheme '${scheme}' is already registered.`);\n\t\t}\n\n\t\tmark(`code/registerFilesystem/${scheme}`);\n\n\t\tconst providerDisposables = new DisposableStore();\n\n\t\t// Add provider with event\n\t\tthis.provider.set(scheme, provider);\n\t\tthis._onDidChangeFileSystemProviderRegistrations.fire({ added: true, scheme, provider });\n\n\t\t// Forward events from provider\n\t\tproviderDisposables.add(provider.onDidChangeFile(changes => this._onDidFilesChange.fire(new FileChangesEvent(changes, !this.isPathCaseSensitive(provider)))));\n\t\tif (typeof provider.onDidWatchError === 'function') {\n\t\t\tproviderDisposables.add(provider.onDidWatchError(error => this._onDidWatchError.fire(new Error(error))));\n\t\t}\n\t\tproviderDisposables.add(provider.onDidChangeCapabilities(() => this._onDidChangeFileSystemProviderCapabilities.fire({ provider, scheme })));\n\n\t\treturn toDisposable(() => {\n\t\t\tthis._onDidChangeFileSystemProviderRegistrations.fire({ added: false, scheme, provider });\n\t\t\tthis.provider.delete(scheme);\n\n\t\t\tdispose(providerDisposables);\n\t\t});\n\t}\n\n\tgetProvider(scheme: string): IFileSystemProvider | undefined {\n\t\treturn this.provider.get(scheme);\n\t}\n\n\tasync activateProvider(scheme: string): Promise<void> {\n\n\t\t// Emit an event that we are about to activate a provider with the given scheme.\n\t\t// Listeners can participate in the activation by registering a provider for it.\n\t\tconst joiners: Promise<void>[] = [];\n\t\tthis._onWillActivateFileSystemProvider.fire({\n\t\t\tscheme,\n\t\t\tjoin(promise) {\n\t\t\t\tjoiners.push(promise);\n\t\t\t},\n\t\t});\n\n\t\tif (this.provider.has(scheme)) {\n\t\t\treturn; // provider is already here so we can return directly\n\t\t}\n\n\t\t// If the provider is not yet there, make sure to join on the listeners assuming\n\t\t// that it takes a bit longer to register the file system provider.\n\t\tawait Promises.settled(joiners);\n\t}\n\n\tasync canHandleResource(resource: URI): Promise<boolean> {\n\n\t\t// Await activation of potentially extension contributed providers\n\t\tawait this.activateProvider(resource.scheme);\n\n\t\treturn this.hasProvider(resource);\n\t}\n\n\thasProvider(resource: URI): boolean {\n\t\treturn this.provider.has(resource.scheme);\n\t}\n\n\thasCapability(resource: URI, capability: FileSystemProviderCapabilities): boolean {\n\t\tconst provider = this.provider.get(resource.scheme);\n\n\t\treturn !!(provider && (provider.capabilities & capability));\n\t}\n\n\tlistCapabilities(): Iterable<{ scheme: string; capabilities: FileSystemProviderCapabilities }> {\n\t\treturn Iterable.map(this.provider, ([scheme, provider]) => ({ scheme, capabilities: provider.capabilities }));\n\t}\n\n\tprotected async withProvider(resource: URI): Promise<IFileSystemProvider> {\n\n\t\t// Assert path is absolute\n\t\tif (!isAbsolutePath(resource)) {\n\t\t\tthrow new FileOperationError(localize('invalidPath', \"Unable to resolve filesystem provider with relative file path '{0}'\", this.resourceForError(resource)), FileOperationResult.FILE_INVALID_PATH);\n\t\t}\n\n\t\t// Activate provider\n\t\tawait this.activateProvider(resource.scheme);\n\n\t\t// Assert provider\n\t\tconst provider = this.provider.get(resource.scheme);\n\t\tif (!provider) {\n\t\t\tconst error = new ErrorNoTelemetry();\n\t\t\terror.message = localize('noProviderFound', \"ENOPRO: No file system provider found for resource '{0}'\", resource.toString());\n\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn provider;\n\t}\n\n\tprivate async withReadProvider(resource: URI): Promise<IFileSystemProviderWithFileReadWriteCapability | IFileSystemProviderWithOpenReadWriteCloseCapability | IFileSystemProviderWithFileReadStreamCapability> {\n\t\tconst provider = await this.withProvider(resource);\n\n\t\tif (hasOpenReadWriteCloseCapability(provider) || hasReadWriteCapability(provider) || hasFileReadStreamCapability(provider)) {\n\t\t\treturn provider;\n\t\t}\n\n\t\tthrow new Error(`Filesystem provider for scheme '${resource.scheme}' neither has FileReadWrite, FileReadStream nor FileOpenReadWriteClose capability which is needed for the read operation.`);\n\t}\n\n\tprivate async withWriteProvider(resource: URI): Promise<IFileSystemProviderWithFileReadWriteCapability | IFileSystemProviderWithOpenReadWriteCloseCapability> {\n\t\tconst provider = await this.withProvider(resource);\n\n\t\tif (hasOpenReadWriteCloseCapability(provider) || hasReadWriteCapability(provider)) {\n\t\t\treturn provider;\n\t\t}\n\n\t\tthrow new Error(`Filesystem provider for scheme '${resource.scheme}' neither has FileReadWrite nor FileOpenReadWriteClose capability which is needed for the write operation.`);\n\t}\n\n\t//#endregion\n\n\t//#region Operation events\n\n\tprivate readonly _onDidRunOperation = this._register(new Emitter<FileOperationEvent>());\n\treadonly onDidRunOperation = this._onDidRunOperation.event;\n\n\t//#endregion\n\n\t//#region File Metadata Resolving\n\n\tasync resolve(resource: URI, options: IResolveMetadataFileOptions): Promise<IFileStatWithMetadata>;\n\tasync resolve(resource: URI, options?: IResolveFileOptions): Promise<IFileStat>;\n\tasync resolve(resource: URI, options?: IResolveFileOptions): Promise<IFileStat> {\n\t\ttry {\n\t\t\treturn await this.doResolveFile(resource, options);\n\t\t} catch (error) {\n\n\t\t\t// Specially handle file not found case as file operation result\n\t\t\tif (toFileSystemProviderErrorCode(error) === FileSystemProviderErrorCode.FileNotFound) {\n\t\t\t\tthrow new FileOperationError(localize('fileNotFoundError', \"Unable to resolve nonexistent file '{0}'\", this.resourceForError(resource)), FileOperationResult.FILE_NOT_FOUND);\n\t\t\t}\n\n\t\t\t// Bubble up any other error as is\n\t\t\tthrow ensureFileSystemProviderError(error);\n\t\t}\n\t}\n\n\tprivate async doResolveFile(resource: URI, options: IResolveMetadataFileOptions): Promise<IFileStatWithMetadata>;\n\tprivate async doResolveFile(resource: URI, options?: IResolveFileOptions): Promise<IFileStat>;\n\tprivate async doResolveFile(resource: URI, options?: IResolveFileOptions): Promise<IFileStat> {\n\t\tconst provider = await this.withProvider(resource);\n\t\tconst isPathCaseSensitive = this.isPathCaseSensitive(provider);\n\n\t\tconst resolveTo = options?.resolveTo;\n\t\tconst resolveSingleChildDescendants = options?.resolveSingleChildDescendants;\n\t\tconst resolveMetadata = options?.resolveMetadata;\n\n\t\tconst stat = await provider.stat(resource);\n\n\t\tlet trie: TernarySearchTree<URI, boolean> | undefined;\n\n\t\treturn this.toFileStat(provider, resource, stat, undefined, !!resolveMetadata, (stat, siblings) => {\n\n\t\t\t// lazy trie to check for recursive resolving\n\t\t\tif (!trie) {\n\t\t\t\ttrie = TernarySearchTree.forUris<true>(() => !isPathCaseSensitive);\n\t\t\t\ttrie.set(resource, true);\n\t\t\t\tif (resolveTo) {\n\t\t\t\t\ttrie.fill(true, resolveTo);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// check for recursive resolving\n\t\t\tif (trie.get(stat.resource) || trie.findSuperstr(stat.resource.with({ query: null, fragment: null } /* required for https://github.com/microsoft/vscode/issues/128151 */))) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// check for resolving single child folders\n\t\t\tif (stat.isDirectory && resolveSingleChildDescendants) {\n\t\t\t\treturn siblings === 1;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t});\n\t}\n\n\tprivate async toFileStat(provider: IFileSystemProvider, resource: URI, stat: IStat | { type: FileType } & Partial<IStat>, siblings: number | undefined, resolveMetadata: boolean, recurse: (stat: IFileStat, siblings?: number) => boolean): Promise<IFileStat>;\n\tprivate async toFileStat(provider: IFileSystemProvider, resource: URI, stat: IStat, siblings: number | undefined, resolveMetadata: true, recurse: (stat: IFileStat, siblings?: number) => boolean): Promise<IFileStatWithMetadata>;\n\tprivate async toFileStat(provider: IFileSystemProvider, resource: URI, stat: IStat | { type: FileType } & Partial<IStat>, siblings: number | undefined, resolveMetadata: boolean, recurse: (stat: IFileStat, siblings?: number) => boolean): Promise<IFileStat> {\n\t\tconst { providerExtUri } = this.getExtUri(provider);\n\n\t\t// convert to file stat\n\t\tconst fileStat: IFileStat = {\n\t\t\tresource,\n\t\t\tname: providerExtUri.basename(resource),\n\t\t\tisFile: (stat.type & FileType.File) !== 0,\n\t\t\tisDirectory: (stat.type & FileType.Directory) !== 0,\n\t\t\tisSymbolicLink: (stat.type & FileType.SymbolicLink) !== 0,\n\t\t\tmtime: stat.mtime,\n\t\t\tctime: stat.ctime,\n\t\t\tsize: stat.size,\n\t\t\treadonly: Boolean((stat.permissions ?? 0) & FilePermission.Readonly) || Boolean(provider.capabilities & FileSystemProviderCapabilities.Readonly),\n\t\t\tlocked: Boolean((stat.permissions ?? 0) & FilePermission.Locked),\n\t\t\tetag: etag({ mtime: stat.mtime, size: stat.size }),\n\t\t\tchildren: undefined\n\t\t};\n\n\t\t// check to recurse for directories\n\t\tif (fileStat.isDirectory && recurse(fileStat, siblings)) {\n\t\t\ttry {\n\t\t\t\tconst entries = await provider.readdir(resource);\n\t\t\t\tconst resolvedEntries = await Promises.settled(entries.map(async ([name, type]) => {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst childResource = providerExtUri.joinPath(resource, name);\n\t\t\t\t\t\tconst childStat = resolveMetadata ? await provider.stat(childResource) : { type };\n\n\t\t\t\t\t\treturn await this.toFileStat(provider, childResource, childStat, entries.length, resolveMetadata, recurse);\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tthis.logService.trace(error);\n\n\t\t\t\t\t\treturn null; // can happen e.g. due to permission errors\n\t\t\t\t\t}\n\t\t\t\t}));\n\n\t\t\t\t// make sure to get rid of null values that signal a failure to resolve a particular entry\n\t\t\t\tfileStat.children = coalesce(resolvedEntries);\n\t\t\t} catch (error) {\n\t\t\t\tthis.logService.trace(error);\n\n\t\t\t\tfileStat.children = []; // gracefully handle errors, we may not have permissions to read\n\t\t\t}\n\n\t\t\treturn fileStat;\n\t\t}\n\n\t\treturn fileStat;\n\t}\n\n\tasync resolveAll(toResolve: { resource: URI; options?: IResolveFileOptions }[]): Promise<IFileStatResult[]>;\n\tasync resolveAll(toResolve: { resource: URI; options: IResolveMetadataFileOptions }[]): Promise<IFileStatResultWithMetadata[]>;\n\tasync resolveAll(toResolve: { resource: URI; options?: IResolveFileOptions }[]): Promise<IFileStatResult[]> {\n\t\treturn Promises.settled(toResolve.map(async entry => {\n\t\t\ttry {\n\t\t\t\treturn { stat: await this.doResolveFile(entry.resource, entry.options), success: true };\n\t\t\t} catch (error) {\n\t\t\t\tthis.logService.trace(error);\n\n\t\t\t\treturn { stat: undefined, success: false };\n\t\t\t}\n\t\t}));\n\t}\n\n\tasync stat(resource: URI): Promise<IFileStatWithPartialMetadata> {\n\t\tconst provider = await this.withProvider(resource);\n\n\t\tconst stat = await provider.stat(resource);\n\n\t\treturn this.toFileStat(provider, resource, stat, undefined, true, () => false /* Do not resolve any children */);\n\t}\n\n\tasync exists(resource: URI): Promise<boolean> {\n\t\tconst provider = await this.withProvider(resource);\n\n\t\ttry {\n\t\t\tconst stat = await provider.stat(resource);\n\n\t\t\treturn !!stat;\n\t\t} catch (error) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t//#endregion\n\n\t//#region File Reading/Writing\n\n\tasync canCreateFile(resource: URI, options?: ICreateFileOptions): Promise<Error | true> {\n\t\ttry {\n\t\t\tawait this.doValidateCreateFile(resource, options);\n\t\t} catch (error) {\n\t\t\treturn error;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tprivate async doValidateCreateFile(resource: URI, options?: ICreateFileOptions): Promise<void> {\n\n\t\t// validate overwrite\n\t\tif (!options?.overwrite && await this.exists(resource)) {\n\t\t\tthrow new FileOperationError(localize('fileExists', \"Unable to create file '{0}' that already exists when overwrite flag is not set\", this.resourceForError(resource)), FileOperationResult.FILE_MODIFIED_SINCE, options);\n\t\t}\n\t}\n\n\tasync createFile(resource: URI, bufferOrReadableOrStream: VSBuffer | VSBufferReadable | VSBufferReadableStream = VSBuffer.fromString(''), options?: ICreateFileOptions): Promise<IFileStatWithMetadata> {\n\n\t\t// validate\n\t\tawait this.doValidateCreateFile(resource, options);\n\n\t\t// do write into file (this will create it too)\n\t\tconst fileStat = await this.writeFile(resource, bufferOrReadableOrStream);\n\n\t\t// events\n\t\tthis._onDidRunOperation.fire(new FileOperationEvent(resource, FileOperation.CREATE, fileStat));\n\n\t\treturn fileStat;\n\t}\n\n\tasync writeFile(resource: URI, bufferOrReadableOrStream: VSBuffer | VSBufferReadable | VSBufferReadableStream, options?: IWriteFileOptions): Promise<IFileStatWithMetadata> {\n\t\tconst provider = this.throwIfFileSystemIsReadonly(await this.withWriteProvider(resource), resource);\n\t\tconst { providerExtUri } = this.getExtUri(provider);\n\n\t\ttry {\n\n\t\t\t// validate write\n\t\t\tconst stat = await this.validateWriteFile(provider, resource, options);\n\n\t\t\t// mkdir recursively as needed\n\t\t\tif (!stat) {\n\t\t\t\tawait this.mkdirp(provider, providerExtUri.dirname(resource));\n\t\t\t}\n\n\t\t\t// optimization: if the provider has unbuffered write capability and the data\n\t\t\t// to write is not a buffer, we consume up to 3 chunks and try to write the data\n\t\t\t// unbuffered to reduce the overhead. If the stream or readable has more data\n\t\t\t// to provide we continue to write buffered.\n\t\t\tlet bufferOrReadableOrStreamOrBufferedStream: VSBuffer | VSBufferReadable | VSBufferReadableStream | VSBufferReadableBufferedStream;\n\t\t\tif (hasReadWriteCapability(provider) && !(bufferOrReadableOrStream instanceof VSBuffer)) {\n\t\t\t\tif (isReadableStream(bufferOrReadableOrStream)) {\n\t\t\t\t\tconst bufferedStream = await peekStream(bufferOrReadableOrStream, 3);\n\t\t\t\t\tif (bufferedStream.ended) {\n\t\t\t\t\t\tbufferOrReadableOrStreamOrBufferedStream = VSBuffer.concat(bufferedStream.buffer);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbufferOrReadableOrStreamOrBufferedStream = bufferedStream;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbufferOrReadableOrStreamOrBufferedStream = peekReadable(bufferOrReadableOrStream, data => VSBuffer.concat(data), 3);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbufferOrReadableOrStreamOrBufferedStream = bufferOrReadableOrStream;\n\t\t\t}\n\n\t\t\t// write file: unbuffered (only if data to write is a buffer, or the provider has no buffered write capability)\n\t\t\tif (!hasOpenReadWriteCloseCapability(provider) || (hasReadWriteCapability(provider) && bufferOrReadableOrStreamOrBufferedStream instanceof VSBuffer)) {\n\t\t\t\tawait this.doWriteUnbuffered(provider, resource, options, bufferOrReadableOrStreamOrBufferedStream);\n\t\t\t}\n\n\t\t\t// write file: buffered\n\t\t\telse {\n\t\t\t\tconst contents = bufferOrReadableOrStreamOrBufferedStream instanceof VSBuffer ? bufferToReadable(bufferOrReadableOrStreamOrBufferedStream) : bufferOrReadableOrStreamOrBufferedStream;\n\n\t\t\t\t// atomic write\n\t\t\t\tif (options?.atomic !== false && options?.atomic?.postfix) {\n\t\t\t\t\tawait this.doWriteBufferedAtomic(provider, resource, joinPath(dirname(resource), `${basename(resource)}${options.atomic.postfix}`), options, contents);\n\t\t\t\t}\n\n\t\t\t\t// non-atomic write\n\t\t\t\telse {\n\t\t\t\t\tawait this.doWriteBuffered(provider, resource, options, contents);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// events\n\t\t\tthis._onDidRunOperation.fire(new FileOperationEvent(resource, FileOperation.WRITE));\n\t\t} catch (error) {\n\t\t\tthrow new FileOperationError(localize('err.write', \"Unable to write file '{0}' ({1})\", this.resourceForError(resource), ensureFileSystemProviderError(error).toString()), toFileOperationResult(error), options);\n\t\t}\n\n\t\treturn this.resolve(resource, { resolveMetadata: true });\n\t}\n\n\tprivate async validateWriteFile(provider: IFileSystemProvider, resource: URI, options?: IWriteFileOptions): Promise<IStat | undefined> {\n\n\t\t// Validate unlock support\n\t\tconst unlock = !!options?.unlock;\n\t\tif (unlock && !(provider.capabilities & FileSystemProviderCapabilities.FileWriteUnlock)) {\n\t\t\tthrow new Error(localize('writeFailedUnlockUnsupported', \"Unable to unlock file '{0}' because provider does not support it.\", this.resourceForError(resource)));\n\t\t}\n\n\t\t// Validate atomic support\n\t\tconst atomic = !!options?.atomic;\n\t\tif (atomic) {\n\t\t\tif (!(provider.capabilities & FileSystemProviderCapabilities.FileAtomicWrite)) {\n\t\t\t\tthrow new Error(localize('writeFailedAtomicUnsupported', \"Unable to atomically write file '{0}' because provider does not support it.\", this.resourceForError(resource)));\n\t\t\t}\n\n\t\t\tif (unlock) {\n\t\t\t\tthrow new Error(localize('writeFailedAtomicUnlock', \"Unable to unlock file '{0}' because atomic write is enabled.\", this.resourceForError(resource)));\n\t\t\t}\n\t\t}\n\n\t\t// Validate via file stat meta data\n\t\tlet stat: IStat | undefined = undefined;\n\t\ttry {\n\t\t\tstat = await provider.stat(resource);\n\t\t} catch (error) {\n\t\t\treturn undefined; // file might not exist\n\t\t}\n\n\t\t// File cannot be directory\n\t\tif ((stat.type & FileType.Directory) !== 0) {\n\t\t\tthrow new FileOperationError(localize('fileIsDirectoryWriteError', \"Unable to write file '{0}' that is actually a directory\", this.resourceForError(resource)), FileOperationResult.FILE_IS_DIRECTORY, options);\n\t\t}\n\n\t\t// File cannot be readonly\n\t\tthis.throwIfFileIsReadonly(resource, stat);\n\n\t\t// Dirty write prevention: if the file on disk has been changed and does not match our expected\n\t\t// mtime and etag, we bail out to prevent dirty writing.\n\t\t//\n\t\t// First, we check for a mtime that is in the future before we do more checks. The assumption is\n\t\t// that only the mtime is an indicator for a file that has changed on disk.\n\t\t//\n\t\t// Second, if the mtime has advanced, we compare the size of the file on disk with our previous\n\t\t// one using the etag() function. Relying only on the mtime check has prooven to produce false\n\t\t// positives due to file system weirdness (especially around remote file systems). As such, the\n\t\t// check for size is a weaker check because it can return a false negative if the file has changed\n\t\t// but to the same length. This is a compromise we take to avoid having to produce checksums of\n\t\t// the file content for comparison which would be much slower to compute.\n\t\tif (\n\t\t\ttypeof options?.mtime === 'number' && typeof options.etag === 'string' && options.etag !== ETAG_DISABLED &&\n\t\t\ttypeof stat.mtime === 'number' && typeof stat.size === 'number' &&\n\t\t\toptions.mtime < stat.mtime && options.etag !== etag({ mtime: options.mtime /* not using stat.mtime for a reason, see above */, size: stat.size })\n\t\t) {\n\t\t\tthrow new FileOperationError(localize('fileModifiedError', \"File Modified Since\"), FileOperationResult.FILE_MODIFIED_SINCE, options);\n\t\t}\n\n\t\treturn stat;\n\t}\n\n\tasync readFile(resource: URI, options?: IReadFileOptions, token?: CancellationToken): Promise<IFileContent> {\n\t\tconst provider = await this.withReadProvider(resource);\n\n\t\tif (options?.atomic) {\n\t\t\treturn this.doReadFileAtomic(provider, resource, options, token);\n\t\t}\n\n\t\treturn this.doReadFile(provider, resource, options, token);\n\t}\n\n\tprivate async doReadFileAtomic(provider: IFileSystemProviderWithFileReadWriteCapability | IFileSystemProviderWithOpenReadWriteCloseCapability | IFileSystemProviderWithFileReadStreamCapability, resource: URI, options?: IReadFileOptions, token?: CancellationToken): Promise<IFileContent> {\n\t\treturn new Promise<IFileContent>((resolve, reject) => {\n\t\t\tthis.writeQueue.queueFor(resource, this.getExtUri(provider).providerExtUri).queue(async () => {\n\t\t\t\ttry {\n\t\t\t\t\tconst content = await this.doReadFile(provider, resource, options, token);\n\t\t\t\t\tresolve(content);\n\t\t\t\t} catch (error) {\n\t\t\t\t\treject(error);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate async doReadFile(provider: IFileSystemProviderWithFileReadWriteCapability | IFileSystemProviderWithOpenReadWriteCloseCapability | IFileSystemProviderWithFileReadStreamCapability, resource: URI, options?: IReadFileOptions, token?: CancellationToken): Promise<IFileContent> {\n\t\tconst stream = await this.doReadFileStream(provider, resource, {\n\t\t\t...options,\n\t\t\t// optimization: since we know that the caller does not\n\t\t\t// care about buffering, we indicate this to the reader.\n\t\t\t// this reduces all the overhead the buffered reading\n\t\t\t// has (open, read, close) if the provider supports\n\t\t\t// unbuffered reading.\n\t\t\tpreferUnbuffered: true\n\t\t}, token);\n\n\t\treturn {\n\t\t\t...stream,\n\t\t\tvalue: await streamToBuffer(stream.value)\n\t\t};\n\t}\n\n\tasync readFileStream(resource: URI, options?: IReadFileStreamOptions, token?: CancellationToken): Promise<IFileStreamContent> {\n\t\tconst provider = await this.withReadProvider(resource);\n\n\t\treturn this.doReadFileStream(provider, resource, options, token);\n\t}\n\n\tprivate async doReadFileStream(provider: IFileSystemProviderWithFileReadWriteCapability | IFileSystemProviderWithOpenReadWriteCloseCapability | IFileSystemProviderWithFileReadStreamCapability, resource: URI, options?: IReadFileOptions & IReadFileStreamOptions & { preferUnbuffered?: boolean }, token?: CancellationToken): Promise<IFileStreamContent> {\n\n\t\t// install a cancellation token that gets cancelled\n\t\t// when any error occurs. this allows us to resolve\n\t\t// the content of the file while resolving metadata\n\t\t// but still cancel the operation in certain cases.\n\t\t//\n\t\t// in addition, we pass the optional token in that\n\t\t// we got from the outside to even allow for external\n\t\t// cancellation of the read operation.\n\t\tconst cancellableSource = new CancellationTokenSource(token);\n\n\t\t// validate read operation\n\t\tconst statPromise = this.validateReadFile(resource, options).then(stat => stat, error => {\n\t\t\tcancellableSource.dispose(true);\n\n\t\t\tthrow error;\n\t\t});\n\n\t\tlet fileStream: VSBufferReadableStream | undefined = undefined;\n\t\ttry {\n\n\t\t\t// if the etag is provided, we await the result of the validation\n\t\t\t// due to the likelihood of hitting a NOT_MODIFIED_SINCE result.\n\t\t\t// otherwise, we let it run in parallel to the file reading for\n\t\t\t// optimal startup performance.\n\t\t\tif (typeof options?.etag === 'string' && options.etag !== ETAG_DISABLED) {\n\t\t\t\tawait statPromise;\n\t\t\t}\n\n\t\t\t// read unbuffered\n\t\t\tif (\n\t\t\t\t(options?.atomic && hasFileAtomicReadCapability(provider)) ||\t\t\t\t\t\t\t\t// atomic reads are always unbuffered\n\t\t\t\t!(hasOpenReadWriteCloseCapability(provider) || hasFileReadStreamCapability(provider)) ||\t// provider has no buffered capability\n\t\t\t\t(hasReadWriteCapability(provider) && options?.preferUnbuffered)\t\t\t\t\t\t\t\t// unbuffered read is preferred\n\t\t\t) {\n\t\t\t\tfileStream = this.readFileUnbuffered(provider, resource, options);\n\t\t\t}\n\n\t\t\t// read streamed (always prefer over primitive buffered read)\n\t\t\telse if (hasFileReadStreamCapability(provider)) {\n\t\t\t\tfileStream = this.readFileStreamed(provider, resource, cancellableSource.token, options);\n\t\t\t}\n\n\t\t\t// read buffered\n\t\t\telse {\n\t\t\t\tfileStream = this.readFileBuffered(provider, resource, cancellableSource.token, options);\n\t\t\t}\n\n\t\t\tfileStream.on('end', () => cancellableSource.dispose());\n\t\t\tfileStream.on('error', () => cancellableSource.dispose());\n\n\t\t\tconst fileStat = await statPromise;\n\n\t\t\treturn {\n\t\t\t\t...fileStat,\n\t\t\t\tvalue: fileStream\n\t\t\t};\n\t\t} catch (error) {\n\n\t\t\t// Await the stream to finish so that we exit this method\n\t\t\t// in a consistent state with file handles closed\n\t\t\t// (https://github.com/microsoft/vscode/issues/114024)\n\t\t\tif (fileStream) {\n\t\t\t\tawait consumeStream(fileStream);\n\t\t\t}\n\n\t\t\t// Re-throw errors as file operation errors but preserve\n\t\t\t// specific errors (such as not modified since)\n\t\t\tthrow this.restoreReadError(error, resource, options);\n\t\t}\n\t}\n\n\tprivate restoreReadError(error: Error, resource: URI, options?: IReadFileStreamOptions): FileOperationError {\n\t\tconst message = localize('err.read', \"Unable to read file '{0}' ({1})\", this.resourceForError(resource), ensureFileSystemProviderError(error).toString());\n\n\t\tif (error instanceof NotModifiedSinceFileOperationError) {\n\t\t\treturn new NotModifiedSinceFileOperationError(message, error.stat, options);\n\t\t}\n\n\t\tif (error instanceof TooLargeFileOperationError) {\n\t\t\treturn new TooLargeFileOperationError(message, error.fileOperationResult, error.size, error.options as IReadFileOptions);\n\t\t}\n\n\t\treturn new FileOperationError(message, toFileOperationResult(error), options);\n\t}\n\n\tprivate readFileStreamed(provider: IFileSystemProviderWithFileReadStreamCapability, resource: URI, token: CancellationToken, options: IReadFileStreamOptions = Object.create(null)): VSBufferReadableStream {\n\t\tconst fileStream = provider.readFileStream(resource, options, token);\n\n\t\treturn transform(fileStream, {\n\t\t\tdata: data => data instanceof VSBuffer ? data : VSBuffer.wrap(data),\n\t\t\terror: error => this.restoreReadError(error, resource, options)\n\t\t}, data => VSBuffer.concat(data));\n\t}\n\n\tprivate readFileBuffered(provider: IFileSystemProviderWithOpenReadWriteCloseCapability, resource: URI, token: CancellationToken, options: IReadFileStreamOptions = Object.create(null)): VSBufferReadableStream {\n\t\tconst stream = newWriteableBufferStream();\n\n\t\treadFileIntoStream(provider, resource, stream, data => data, {\n\t\t\t...options,\n\t\t\tbufferSize: this.BUFFER_SIZE,\n\t\t\terrorTransformer: error => this.restoreReadError(error, resource, options)\n\t\t}, token);\n\n\t\treturn stream;\n\t}\n\n\tprivate readFileUnbuffered(provider: IFileSystemProviderWithFileReadWriteCapability | IFileSystemProviderWithFileAtomicReadCapability, resource: URI, options?: IReadFileOptions & IReadFileStreamOptions): VSBufferReadableStream {\n\t\tconst stream = newWriteableStream<VSBuffer>(data => VSBuffer.concat(data));\n\n\t\t// Read the file into the stream async but do not wait for\n\t\t// this to complete because streams work via events\n\t\t(async () => {\n\t\t\ttry {\n\t\t\t\tlet buffer: Uint8Array;\n\t\t\t\tif (options?.atomic && hasFileAtomicReadCapability(provider)) {\n\t\t\t\t\tbuffer = await provider.readFile(resource, { atomic: true });\n\t\t\t\t} else {\n\t\t\t\t\tbuffer = await provider.readFile(resource);\n\t\t\t\t}\n\n\t\t\t\t// respect position option\n\t\t\t\tif (typeof options?.position === 'number') {\n\t\t\t\t\tbuffer = buffer.slice(options.position);\n\t\t\t\t}\n\n\t\t\t\t// respect length option\n\t\t\t\tif (typeof options?.length === 'number') {\n\t\t\t\t\tbuffer = buffer.slice(0, options.length);\n\t\t\t\t}\n\n\t\t\t\t// Throw if file is too large to load\n\t\t\t\tthis.validateReadFileLimits(resource, buffer.byteLength, options);\n\n\t\t\t\t// End stream with data\n\t\t\t\tstream.end(VSBuffer.wrap(buffer));\n\t\t\t} catch (err) {\n\t\t\t\tstream.error(err);\n\t\t\t\tstream.end();\n\t\t\t}\n\t\t})();\n\n\t\treturn stream;\n\t}\n\n\tprivate async validateReadFile(resource: URI, options?: IReadFileStreamOptions): Promise<IFileStatWithMetadata> {\n\t\tconst stat = await this.resolve(resource, { resolveMetadata: true });\n\n\t\t// Throw if resource is a directory\n\t\tif (stat.isDirectory) {\n\t\t\tthrow new FileOperationError(localize('fileIsDirectoryReadError', \"Unable to read file '{0}' that is actually a directory\", this.resourceForError(resource)), FileOperationResult.FILE_IS_DIRECTORY, options);\n\t\t}\n\n\t\t// Throw if file not modified since (unless disabled)\n\t\tif (typeof options?.etag === 'string' && options.etag !== ETAG_DISABLED && options.etag === stat.etag) {\n\t\t\tthrow new NotModifiedSinceFileOperationError(localize('fileNotModifiedError', \"File not modified since\"), stat, options);\n\t\t}\n\n\t\t// Throw if file is too large to load\n\t\tthis.validateReadFileLimits(resource, stat.size, options);\n\n\t\treturn stat;\n\t}\n\n\tprivate validateReadFileLimits(resource: URI, size: number, options?: IReadFileStreamOptions): void {\n\t\tif (typeof options?.limits?.size === 'number' && size > options.limits.size) {\n\t\t\tthrow new TooLargeFileOperationError(localize('fileTooLargeError', \"Unable to read file '{0}' that is too large to open\", this.resourceForError(resource)), FileOperationResult.FILE_TOO_LARGE, size, options);\n\t\t}\n\t}\n\n\t//#endregion\n\n\t//#region Move/Copy/Delete/Create Folder\n\n\tasync canMove(source: URI, target: URI, overwrite?: boolean): Promise<Error | true> {\n\t\treturn this.doCanMoveCopy(source, target, 'move', overwrite);\n\t}\n\n\tasync canCopy(source: URI, target: URI, overwrite?: boolean): Promise<Error | true> {\n\t\treturn this.doCanMoveCopy(source, target, 'copy', overwrite);\n\t}\n\n\tprivate async doCanMoveCopy(source: URI, target: URI, mode: 'move' | 'copy', overwrite?: boolean): Promise<Error | true> {\n\t\tif (source.toString() !== target.toString()) {\n\t\t\ttry {\n\t\t\t\tconst sourceProvider = mode === 'move' ? this.throwIfFileSystemIsReadonly(await this.withWriteProvider(source), source) : await this.withReadProvider(source);\n\t\t\t\tconst targetProvider = this.throwIfFileSystemIsReadonly(await this.withWriteProvider(target), target);\n\n\t\t\t\tawait this.doValidateMoveCopy(sourceProvider, source, targetProvider, target, mode, overwrite);\n\t\t\t} catch (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tasync move(source: URI, target: URI, overwrite?: boolean): Promise<IFileStatWithMetadata> {\n\t\tconst sourceProvider = this.throwIfFileSystemIsReadonly(await this.withWriteProvider(source), source);\n\t\tconst targetProvider = this.throwIfFileSystemIsReadonly(await this.withWriteProvider(target), target);\n\n\t\t// move\n\t\tconst mode = await this.doMoveCopy(sourceProvider, source, targetProvider, target, 'move', !!overwrite);\n\n\t\t// resolve and send events\n\t\tconst fileStat = await this.resolve(target, { resolveMetadata: true });\n\t\tthis._onDidRunOperation.fire(new FileOperationEvent(source, mode === 'move' ? FileOperation.MOVE : FileOperation.COPY, fileStat));\n\n\t\treturn fileStat;\n\t}\n\n\tasync copy(source: URI, target: URI, overwrite?: boolean): Promise<IFileStatWithMetadata> {\n\t\tconst sourceProvider = await this.withReadProvider(source);\n\t\tconst targetProvider = this.throwIfFileSystemIsReadonly(await this.withWriteProvider(target), target);\n\n\t\t// copy\n\t\tconst mode = await this.doMoveCopy(sourceProvider, source, targetProvider, target, 'copy', !!overwrite);\n\n\t\t// resolve and send events\n\t\tconst fileStat = await this.resolve(target, { resolveMetadata: true });\n\t\tthis._onDidRunOperation.fire(new FileOperationEvent(source, mode === 'copy' ? FileOperation.COPY : FileOperation.MOVE, fileStat));\n\n\t\treturn fileStat;\n\t}\n\n\tprivate async doMoveCopy(sourceProvider: IFileSystemProvider, source: URI, targetProvider: IFileSystemProvider, target: URI, mode: 'move' | 'copy', overwrite: boolean): Promise<'move' | 'copy'> {\n\t\tif (source.toString() === target.toString()) {\n\t\t\treturn mode; // simulate node.js behaviour here and do a no-op if paths match\n\t\t}\n\n\t\t// validation\n\t\tconst { exists, isSameResourceWithDifferentPathCase } = await this.doValidateMoveCopy(sourceProvider, source, targetProvider, target, mode, overwrite);\n\n\t\t// delete as needed (unless target is same resurce with different path case)\n\t\tif (exists && !isSameResourceWithDifferentPathCase && overwrite) {\n\t\t\tawait this.del(target, { recursive: true });\n\t\t}\n\n\t\t// create parent folders\n\t\tawait this.mkdirp(targetProvider, this.getExtUri(targetProvider).providerExtUri.dirname(target));\n\n\t\t// copy source => target\n\t\tif (mode === 'copy') {\n\n\t\t\t// same provider with fast copy: leverage copy() functionality\n\t\t\tif (sourceProvider === targetProvider && hasFileFolderCopyCapability(sourceProvider)) {\n\t\t\t\tawait sourceProvider.copy(source, target, { overwrite });\n\t\t\t}\n\n\t\t\t// when copying via buffer/unbuffered, we have to manually\n\t\t\t// traverse the source if it is a folder and not a file\n\t\t\telse {\n\t\t\t\tconst sourceFile = await this.resolve(source);\n\t\t\t\tif (sourceFile.isDirectory) {\n\t\t\t\t\tawait this.doCopyFolder(sourceProvider, sourceFile, targetProvider, target);\n\t\t\t\t} else {\n\t\t\t\t\tawait this.doCopyFile(sourceProvider, source, targetProvider, target);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn mode;\n\t\t}\n\n\t\t// move source => target\n\t\telse {\n\n\t\t\t// same provider: leverage rename() functionality\n\t\t\tif (sourceProvider === targetProvider) {\n\t\t\t\tawait sourceProvider.rename(source, target, { overwrite });\n\n\t\t\t\treturn mode;\n\t\t\t}\n\n\t\t\t// across providers: copy to target & delete at source\n\t\t\telse {\n\t\t\t\tawait this.doMoveCopy(sourceProvider, source, targetProvider, target, 'copy', overwrite);\n\t\t\t\tawait this.del(source, { recursive: true });\n\n\t\t\t\treturn 'copy';\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate async doCopyFile(sourceProvider: IFileSystemProvider, source: URI, targetProvider: IFileSystemProvider, target: URI): Promise<void> {\n\n\t\t// copy: source (buffered) => target (buffered)\n\t\tif (hasOpenReadWriteCloseCapability(sourceProvider) && hasOpenReadWriteCloseCapability(targetProvider)) {\n\t\t\treturn this.doPipeBuffered(sourceProvider, source, targetProvider, target);\n\t\t}\n\n\t\t// copy: source (buffered) => target (unbuffered)\n\t\tif (hasOpenReadWriteCloseCapability(sourceProvider) && hasReadWriteCapability(targetProvider)) {\n\t\t\treturn this.doPipeBufferedToUnbuffered(sourceProvider, source, targetProvider, target);\n\t\t}\n\n\t\t// copy: source (unbuffered) => target (buffered)\n\t\tif (hasReadWriteCapability(sourceProvider) && hasOpenReadWriteCloseCapability(targetProvider)) {\n\t\t\treturn this.doPipeUnbufferedToBuffered(sourceProvider, source, targetProvider, target);\n\t\t}\n\n\t\t// copy: source (unbuffered) => target (unbuffered)\n\t\tif (hasReadWriteCapability(sourceProvider) && hasReadWriteCapability(targetProvider)) {\n\t\t\treturn this.doPipeUnbuffered(sourceProvider, source, targetProvider, target);\n\t\t}\n\t}\n\n\tprivate async doCopyFolder(sourceProvider: IFileSystemProvider, sourceFolder: IFileStat, targetProvider: IFileSystemProvider, targetFolder: URI): Promise<void> {\n\n\t\t// create folder in target\n\t\tawait targetProvider.mkdir(targetFolder);\n\n\t\t// create children in target\n\t\tif (Array.isArray(sourceFolder.children)) {\n\t\t\tawait Promises.settled(sourceFolder.children.map(async sourceChild => {\n\t\t\t\tconst targetChild = this.getExtUri(targetProvider).providerExtUri.joinPath(targetFolder, sourceChild.name);\n\t\t\t\tif (sourceChild.isDirectory) {\n\t\t\t\t\treturn this.doCopyFolder(sourceProvider, await this.resolve(sourceChild.resource), targetProvider, targetChild);\n\t\t\t\t} else {\n\t\t\t\t\treturn this.doCopyFile(sourceProvider, sourceChild.resource, targetProvider, targetChild);\n\t\t\t\t}\n\t\t\t}));\n\t\t}\n\t}\n\n\tprivate async doValidateMoveCopy(sourceProvider: IFileSystemProvider, source: URI, targetProvider: IFileSystemProvider, target: URI, mode: 'move' | 'copy', overwrite?: boolean): Promise<{ exists: boolean; isSameResourceWithDifferentPathCase: boolean }> {\n\t\tlet isSameResourceWithDifferentPathCase = false;\n\n\t\t// Check if source is equal or parent to target (requires providers to be the same)\n\t\tif (sourceProvider === targetProvider) {\n\t\t\tconst { providerExtUri, isPathCaseSensitive } = this.getExtUri(sourceProvider);\n\t\t\tif (!isPathCaseSensitive) {\n\t\t\t\tisSameResourceWithDifferentPathCase = providerExtUri.isEqual(source, target);\n\t\t\t}\n\n\t\t\tif (isSameResourceWithDifferentPathCase && mode === 'copy') {\n\t\t\t\tthrow new Error(localize('unableToMoveCopyError1', \"Unable to copy when source '{0}' is same as target '{1}' with different path case on a case insensitive file system\", this.resourceForError(source), this.resourceForError(target)));\n\t\t\t}\n\n\t\t\tif (!isSameResourceWithDifferentPathCase && providerExtUri.isEqualOrParent(target, source)) {\n\t\t\t\tthrow new Error(localize('unableToMoveCopyError2', \"Unable to move/copy when source '{0}' is parent of target '{1}'.\", this.resourceForError(source), this.resourceForError(target)));\n\t\t\t}\n\t\t}\n\n\t\t// Extra checks if target exists and this is not a rename\n\t\tconst exists = await this.exists(target);\n\t\tif (exists && !isSameResourceWithDifferentPathCase) {\n\n\t\t\t// Bail out if target exists and we are not about to overwrite\n\t\t\tif (!overwrite) {\n\t\t\t\tthrow new FileOperationError(localize('unableToMoveCopyError3', \"Unable to move/copy '{0}' because target '{1}' already exists at destination.\", this.resourceForError(source), this.resourceForError(target)), FileOperationResult.FILE_MOVE_CONFLICT);\n\t\t\t}\n\n\t\t\t// Special case: if the target is a parent of the source, we cannot delete\n\t\t\t// it as it would delete the source as well. In this case we have to throw\n\t\t\tif (sourceProvider === targetProvider) {\n\t\t\t\tconst { providerExtUri } = this.getExtUri(sourceProvider);\n\t\t\t\tif (providerExtUri.isEqualOrParent(source, target)) {\n\t\t\t\t\tthrow new Error(localize('unableToMoveCopyError4', \"Unable to move/copy '{0}' into '{1}' since a file would replace the folder it is contained in.\", this.resourceForError(source), this.resourceForError(target)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn { exists, isSameResourceWithDifferentPathCase };\n\t}\n\n\tprivate getExtUri(provider: IFileSystemProvider): { providerExtUri: IExtUri; isPathCaseSensitive: boolean } {\n\t\tconst isPathCaseSensitive = this.isPathCaseSensitive(provider);\n\n\t\treturn {\n\t\t\tproviderExtUri: isPathCaseSensitive ? extUri : extUriIgnorePathCase,\n\t\t\tisPathCaseSensitive\n\t\t};\n\t}\n\n\tprivate isPathCaseSensitive(provider: IFileSystemProvider): boolean {\n\t\treturn !!(provider.capabilities & FileSystemProviderCapabilities.PathCaseSensitive);\n\t}\n\n\tasync createFolder(resource: URI): Promise<IFileStatWithMetadata> {\n\t\tconst provider = this.throwIfFileSystemIsReadonly(await this.withProvider(resource), resource);\n\n\t\t// mkdir recursively\n\t\tawait this.mkdirp(provider, resource);\n\n\t\t// events\n\t\tconst fileStat = await this.resolve(resource, { resolveMetadata: true });\n\t\tthis._onDidRunOperation.fire(new FileOperationEvent(resource, FileOperation.CREATE, fileStat));\n\n\t\treturn fileStat;\n\t}\n\n\tprivate async mkdirp(provider: IFileSystemProvider, directory: URI): Promise<void> {\n\t\tconst directoriesToCreate: string[] = [];\n\n\t\t// mkdir until we reach root\n\t\tconst { providerExtUri } = this.getExtUri(provider);\n\t\twhile (!providerExtUri.isEqual(directory, providerExtUri.dirname(directory))) {\n\t\t\ttry {\n\t\t\t\tconst stat = await provider.stat(directory);\n\t\t\t\tif ((stat.type & FileType.Directory) === 0) {\n\t\t\t\t\tthrow new Error(localize('mkdirExistsError', \"Unable to create folder '{0}' that already exists but is not a directory\", this.resourceForError(directory)));\n\t\t\t\t}\n\n\t\t\t\tbreak; // we have hit a directory that exists -> good\n\t\t\t} catch (error) {\n\n\t\t\t\t// Bubble up any other error that is not file not found\n\t\t\t\tif (toFileSystemProviderErrorCode(error) !== FileSystemProviderErrorCode.FileNotFound) {\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\n\t\t\t\t// Upon error, remember directories that need to be created\n\t\t\t\tdirectoriesToCreate.push(providerExtUri.basename(directory));\n\n\t\t\t\t// Continue up\n\t\t\t\tdirectory = providerExtUri.dirname(directory);\n\t\t\t}\n\t\t}\n\n\t\t// Create directories as needed\n\t\tfor (let i = directoriesToCreate.length - 1; i >= 0; i--) {\n\t\t\tdirectory = providerExtUri.joinPath(directory, directoriesToCreate[i]);\n\n\t\t\ttry {\n\t\t\t\tawait provider.mkdir(directory);\n\t\t\t} catch (error) {\n\t\t\t\tif (toFileSystemProviderErrorCode(error) !== FileSystemProviderErrorCode.FileExists) {\n\t\t\t\t\t// For mkdirp() we tolerate that the mkdir() call fails\n\t\t\t\t\t// in case the folder already exists. This follows node.js\n\t\t\t\t\t// own implementation of fs.mkdir({ recursive: true }) and\n\t\t\t\t\t// reduces the chances of race conditions leading to errors\n\t\t\t\t\t// if multiple calls try to create the same folders\n\t\t\t\t\t// As such, we only throw an error here if it is other than\n\t\t\t\t\t// the fact that the file already exists.\n\t\t\t\t\t// (see also https://github.com/microsoft/vscode/issues/89834)\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tasync canDelete(resource: URI, options?: Partial<IFileDeleteOptions>): Promise<Error | true> {\n\t\ttry {\n\t\t\tawait this.doValidateDelete(resource, options);\n\t\t} catch (error) {\n\t\t\treturn error;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tprivate async doValidateDelete(resource: URI, options?: Partial<IFileDeleteOptions>): Promise<IFileSystemProvider> {\n\t\tconst provider = this.throwIfFileSystemIsReadonly(await this.withProvider(resource), resource);\n\n\t\t// Validate trash support\n\t\tconst useTrash = !!options?.useTrash;\n\t\tif (useTrash && !(provider.capabilities & FileSystemProviderCapabilities.Trash)) {\n\t\t\tthrow new Error(localize('deleteFailedTrashUnsupported', \"Unable to delete file '{0}' via trash because provider does not support it.\", this.resourceForError(resource)));\n\t\t}\n\n\t\t// Validate atomic support\n\t\tconst atomic = options?.atomic;\n\t\tif (atomic && !(provider.capabilities & FileSystemProviderCapabilities.FileAtomicDelete)) {\n\t\t\tthrow new Error(localize('deleteFailedAtomicUnsupported', \"Unable to delete file '{0}' atomically because provider does not support it.\", this.resourceForError(resource)));\n\t\t}\n\n\t\tif (useTrash && atomic) {\n\t\t\tthrow new Error(localize('deleteFailedTrashAndAtomicUnsupported', \"Unable to atomically delete file '{0}' because using trash is enabled.\", this.resourceForError(resource)));\n\t\t}\n\n\t\t// Validate delete\n\t\tlet stat: IStat | undefined = undefined;\n\t\ttry {\n\t\t\tstat = await provider.stat(resource);\n\t\t} catch (error) {\n\t\t\t// Handled later\n\t\t}\n\n\t\tif (stat) {\n\t\t\tthis.throwIfFileIsReadonly(resource, stat);\n\t\t} else {\n\t\t\tthrow new FileOperationError(localize('deleteFailedNotFound', \"Unable to delete nonexistent file '{0}'\", this.resourceForError(resource)), FileOperationResult.FILE_NOT_FOUND);\n\t\t}\n\n\t\t// Validate recursive\n\t\tconst recursive = !!options?.recursive;\n\t\tif (!recursive) {\n\t\t\tconst stat = await this.resolve(resource);\n\t\t\tif (stat.isDirectory && Array.isArray(stat.children) && stat.children.length > 0) {\n\t\t\t\tthrow new Error(localize('deleteFailedNonEmptyFolder', \"Unable to delete non-empty folder '{0}'.\", this.resourceForError(resource)));\n\t\t\t}\n\t\t}\n\n\t\treturn provider;\n\t}\n\n\tasync del(resource: URI, options?: Partial<IFileDeleteOptions>): Promise<void> {\n\t\tconst provider = await this.doValidateDelete(resource, options);\n\n\t\tconst useTrash = !!options?.useTrash;\n\t\tconst recursive = !!options?.recursive;\n\t\tconst atomic = options?.atomic ?? false;\n\n\t\t// Delete through provider\n\t\tawait provider.delete(resource, { recursive, useTrash, atomic });\n\n\t\t// Events\n\t\tthis._onDidRunOperation.fire(new FileOperationEvent(resource, FileOperation.DELETE));\n\t}\n\n\t//#endregion\n\n\t//#region Clone File\n\n\tasync cloneFile(source: URI, target: URI): Promise<void> {\n\t\tconst sourceProvider = await this.withProvider(source);\n\t\tconst targetProvider = this.throwIfFileSystemIsReadonly(await this.withWriteProvider(target), target);\n\n\t\tif (sourceProvider === targetProvider && this.getExtUri(sourceProvider).providerExtUri.isEqual(source, target)) {\n\t\t\treturn; // return early if paths are equal\n\t\t}\n\n\t\t// same provider, use `cloneFile` when native support is provided\n\t\tif (sourceProvider === targetProvider && hasFileCloneCapability(sourceProvider)) {\n\t\t\treturn sourceProvider.cloneFile(source, target);\n\t\t}\n\n\t\t// otherwise, either providers are different or there is no native\n\t\t// `cloneFile` support, then we fallback to emulate a clone as best\n\t\t// as we can with the other primitives\n\n\t\t// create parent folders\n\t\tawait this.mkdirp(targetProvider, this.getExtUri(targetProvider).providerExtUri.dirname(target));\n\n\t\t// queue on the source to ensure atomic read\n\t\tconst sourceWriteQueue = this.writeQueue.queueFor(source, this.getExtUri(sourceProvider).providerExtUri);\n\n\t\t// leverage `copy` method if provided and providers are identical\n\t\tif (sourceProvider === targetProvider && hasFileFolderCopyCapability(sourceProvider)) {\n\t\t\treturn sourceWriteQueue.queue(() => sourceProvider.copy(source, target, { overwrite: true }));\n\t\t}\n\n\t\t// otherwise copy via buffer/unbuffered and use a write queue\n\t\t// on the source to ensure atomic operation as much as possible\n\t\treturn sourceWriteQueue.queue(() => this.doCopyFile(sourceProvider, source, targetProvider, target));\n\t}\n\n\t//#endregion\n\n\t//#region File Watching\n\n\tprivate readonly _onDidFilesChange = this._register(new Emitter<FileChangesEvent>());\n\treadonly onDidFilesChange = this._onDidFilesChange.event;\n\n\tprivate readonly _onDidWatchError = this._register(new Emitter<Error>());\n\treadonly onDidWatchError = this._onDidWatchError.event;\n\n\tprivate readonly activeWatchers = new Map<number /* watch request hash */, { disposable: IDisposable; count: number }>();\n\n\twatch(resource: URI, options: IWatchOptions = { recursive: false, excludes: [] }): IDisposable {\n\t\tconst disposables = new DisposableStore();\n\n\t\t// Forward watch request to provider and wire in disposables\n\t\tlet watchDisposed = false;\n\t\tlet disposeWatch = () => { watchDisposed = true; };\n\t\tdisposables.add(toDisposable(() => disposeWatch()));\n\n\t\t// Watch and wire in disposable which is async but\n\t\t// check if we got disposed meanwhile and forward\n\t\t(async () => {\n\t\t\ttry {\n\t\t\t\tconst disposable = await this.doWatch(resource, options);\n\t\t\t\tif (watchDisposed) {\n\t\t\t\t\tdispose(disposable);\n\t\t\t\t} else {\n\t\t\t\t\tdisposeWatch = () => dispose(disposable);\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tthis.logService.error(error);\n\t\t\t}\n\t\t})();\n\n\t\treturn disposables;\n\t}\n\n\tprivate async doWatch(resource: URI, options: IWatchOptions): Promise<IDisposable> {\n\t\tconst provider = await this.withProvider(resource);\n\n\t\t// Deduplicate identical watch requests\n\t\tconst watchHash = hash([this.getExtUri(provider).providerExtUri.getComparisonKey(resource), options]);\n\t\tlet watcher = this.activeWatchers.get(watchHash);\n\t\tif (!watcher) {\n\t\t\twatcher = {\n\t\t\t\tcount: 0,\n\t\t\t\tdisposable: provider.watch(resource, options)\n\t\t\t};\n\n\t\t\tthis.activeWatchers.set(watchHash, watcher);\n\t\t}\n\n\t\t// Increment usage counter\n\t\twatcher.count += 1;\n\n\t\treturn toDisposable(() => {\n\t\t\tif (watcher) {\n\n\t\t\t\t// Unref\n\t\t\t\twatcher.count--;\n\n\t\t\t\t// Dispose only when last user is reached\n\t\t\t\tif (watcher.count === 0) {\n\t\t\t\t\tdispose(watcher.disposable);\n\t\t\t\t\tthis.activeWatchers.delete(watchHash);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\toverride dispose(): void {\n\t\tsuper.dispose();\n\n\t\tfor (const [, watcher] of this.activeWatchers) {\n\t\t\tdispose(watcher.disposable);\n\t\t}\n\n\t\tthis.activeWatchers.clear();\n\t}\n\n\t//#endregion\n\n\t//#region Helpers\n\n\tprivate readonly writeQueue = this._register(new ResourceQueue());\n\n\tprivate async doWriteBufferedAtomic(provider: IFileSystemProviderWithOpenReadWriteCloseCapability, resource: URI, tempResource: URI, options: IWriteFileOptions | undefined, readableOrStreamOrBufferedStream: VSBufferReadable | VSBufferReadableStream | VSBufferReadableBufferedStream): Promise<void> {\n\n\t\t// Write to temp resource first\n\t\tawait this.doWriteBuffered(provider, tempResource, options, readableOrStreamOrBufferedStream);\n\n\t\ttry {\n\n\t\t\t// Rename over existing to ensure atomic replace\n\t\t\tawait provider.rename(tempResource, resource, { overwrite: true });\n\t\t} catch (error) {\n\n\t\t\t// Cleanup in case of rename error\n\t\t\ttry {\n\t\t\t\tawait provider.delete(tempResource, { recursive: false, useTrash: false, atomic: false });\n\t\t\t} catch (error) {\n\t\t\t\t// ignore - we want the outer error to bubble up\n\t\t\t}\n\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tprivate async doWriteBuffered(provider: IFileSystemProviderWithOpenReadWriteCloseCapability, resource: URI, options: IWriteFileOptions | undefined, readableOrStreamOrBufferedStream: VSBufferReadable | VSBufferReadableStream | VSBufferReadableBufferedStream): Promise<void> {\n\t\treturn this.writeQueue.queueFor(resource, this.getExtUri(provider).providerExtUri).queue(async () => {\n\n\t\t\t// open handle\n\t\t\tconst handle = await provider.open(resource, { create: true, unlock: options?.unlock ?? false });\n\n\t\t\t// write into handle until all bytes from buffer have been written\n\t\t\ttry {\n\t\t\t\tif (isReadableStream(readableOrStreamOrBufferedStream) || isReadableBufferedStream(readableOrStreamOrBufferedStream)) {\n\t\t\t\t\tawait this.doWriteStreamBufferedQueued(provider, handle, readableOrStreamOrBufferedStream);\n\t\t\t\t} else {\n\t\t\t\t\tawait this.doWriteReadableBufferedQueued(provider, handle, readableOrStreamOrBufferedStream);\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tthrow ensureFileSystemProviderError(error);\n\t\t\t} finally {\n\n\t\t\t\t// close handle always\n\t\t\t\tawait provider.close(handle);\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate async doWriteStreamBufferedQueued(provider: IFileSystemProviderWithOpenReadWriteCloseCapability, handle: number, streamOrBufferedStream: VSBufferReadableStream | VSBufferReadableBufferedStream): Promise<void> {\n\t\tlet posInFile = 0;\n\t\tlet stream: VSBufferReadableStream;\n\n\t\t// Buffered stream: consume the buffer first by writing\n\t\t// it to the target before reading from the stream.\n\t\tif (isReadableBufferedStream(streamOrBufferedStream)) {\n\t\t\tif (streamOrBufferedStream.buffer.length > 0) {\n\t\t\t\tconst chunk = VSBuffer.concat(streamOrBufferedStream.buffer);\n\t\t\t\tawait this.doWriteBuffer(provider, handle, chunk, chunk.byteLength, posInFile, 0);\n\n\t\t\t\tposInFile += chunk.byteLength;\n\t\t\t}\n\n\t\t\t// If the stream has been consumed, return early\n\t\t\tif (streamOrBufferedStream.ended) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tstream = streamOrBufferedStream.stream;\n\t\t}\n\n\t\t// Unbuffered stream - just take as is\n\t\telse {\n\t\t\tstream = streamOrBufferedStream;\n\t\t}\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tlistenStream(stream, {\n\t\t\t\tonData: async chunk => {\n\n\t\t\t\t\t// pause stream to perform async write operation\n\t\t\t\t\tstream.pause();\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tawait this.doWriteBuffer(provider, handle, chunk, chunk.byteLength, posInFile, 0);\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\treturn reject(error);\n\t\t\t\t\t}\n\n\t\t\t\t\tposInFile += chunk.byteLength;\n\n\t\t\t\t\t// resume stream now that we have successfully written\n\t\t\t\t\t// run this on the next tick to prevent increasing the\n\t\t\t\t\t// execution stack because resume() may call the event\n\t\t\t\t\t// handler again before finishing.\n\t\t\t\t\tsetTimeout(() => stream.resume());\n\t\t\t\t},\n\t\t\t\tonError: error => reject(error),\n\t\t\t\tonEnd: () => resolve()\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate async doWriteReadableBufferedQueued(provider: IFileSystemProviderWithOpenReadWriteCloseCapability, handle: number, readable: VSBufferReadable): Promise<void> {\n\t\tlet posInFile = 0;\n\n\t\tlet chunk: VSBuffer | null;\n\t\twhile ((chunk = readable.read()) !== null) {\n\t\t\tawait this.doWriteBuffer(provider, handle, chunk, chunk.byteLength, posInFile, 0);\n\n\t\t\tposInFile += chunk.byteLength;\n\t\t}\n\t}\n\n\tprivate async doWriteBuffer(provider: IFileSystemProviderWithOpenReadWriteCloseCapability, handle: number, buffer: VSBuffer, length: number, posInFile: number, posInBuffer: number): Promise<void> {\n\t\tlet totalBytesWritten = 0;\n\t\twhile (totalBytesWritten < length) {\n\n\t\t\t// Write through the provider\n\t\t\tconst bytesWritten = await provider.write(handle, posInFile + totalBytesWritten, buffer.buffer, posInBuffer + totalBytesWritten, length - totalBytesWritten);\n\t\t\ttotalBytesWritten += bytesWritten;\n\t\t}\n\t}\n\n\tprivate async doWriteUnbuffered(provider: IFileSystemProviderWithFileReadWriteCapability, resource: URI, options: IWriteFileOptions | undefined, bufferOrReadableOrStreamOrBufferedStream: VSBuffer | VSBufferReadable | VSBufferReadableStream | VSBufferReadableBufferedStream): Promise<void> {\n\t\treturn this.writeQueue.queueFor(resource, this.getExtUri(provider).providerExtUri).queue(() => this.doWriteUnbufferedQueued(provider, resource, options, bufferOrReadableOrStreamOrBufferedStream));\n\t}\n\n\tprivate async doWriteUnbufferedQueued(provider: IFileSystemProviderWithFileReadWriteCapability, resource: URI, options: IWriteFileOptions | undefined, bufferOrReadableOrStreamOrBufferedStream: VSBuffer | VSBufferReadable | VSBufferReadableStream | VSBufferReadableBufferedStream): Promise<void> {\n\t\tlet buffer: VSBuffer;\n\t\tif (bufferOrReadableOrStreamOrBufferedStream instanceof VSBuffer) {\n\t\t\tbuffer = bufferOrReadableOrStreamOrBufferedStream;\n\t\t} else if (isReadableStream(bufferOrReadableOrStreamOrBufferedStream)) {\n\t\t\tbuffer = await streamToBuffer(bufferOrReadableOrStreamOrBufferedStream);\n\t\t} else if (isReadableBufferedStream(bufferOrReadableOrStreamOrBufferedStream)) {\n\t\t\tbuffer = await bufferedStreamToBuffer(bufferOrReadableOrStreamOrBufferedStream);\n\t\t} else {\n\t\t\tbuffer = readableToBuffer(bufferOrReadableOrStreamOrBufferedStream);\n\t\t}\n\n\t\t// Write through the provider\n\t\tawait provider.writeFile(resource, buffer.buffer, { create: true, overwrite: true, unlock: options?.unlock ?? false, atomic: options?.atomic ?? false });\n\t}\n\n\tprivate async doPipeBuffered(sourceProvider: IFileSystemProviderWithOpenReadWriteCloseCapability, source: URI, targetProvider: IFileSystemProviderWithOpenReadWriteCloseCapability, target: URI): Promise<void> {\n\t\treturn this.writeQueue.queueFor(target, this.getExtUri(targetProvider).providerExtUri).queue(() => this.doPipeBufferedQueued(sourceProvider, source, targetProvider, target));\n\t}\n\n\tprivate async doPipeBufferedQueued(sourceProvider: IFileSystemProviderWithOpenReadWriteCloseCapability, source: URI, targetProvider: IFileSystemProviderWithOpenReadWriteCloseCapability, target: URI): Promise<void> {\n\t\tlet sourceHandle: number | undefined = undefined;\n\t\tlet targetHandle: number | undefined = undefined;\n\n\t\ttry {\n\n\t\t\t// Open handles\n\t\t\tsourceHandle = await sourceProvider.open(source, { create: false });\n\t\t\ttargetHandle = await targetProvider.open(target, { create: true, unlock: false });\n\n\t\t\tconst buffer = VSBuffer.alloc(this.BUFFER_SIZE);\n\n\t\t\tlet posInFile = 0;\n\t\t\tlet posInBuffer = 0;\n\t\t\tlet bytesRead = 0;\n\t\t\tdo {\n\t\t\t\t// read from source (sourceHandle) at current position (posInFile) into buffer (buffer) at\n\t\t\t\t// buffer position (posInBuffer) up to the size of the buffer (buffer.byteLength).\n\t\t\t\tbytesRead = await sourceProvider.read(sourceHandle, posInFile, buffer.buffer, posInBuffer, buffer.byteLength - posInBuffer);\n\n\t\t\t\t// write into target (targetHandle) at current position (posInFile) from buffer (buffer) at\n\t\t\t\t// buffer position (posInBuffer) all bytes we read (bytesRead).\n\t\t\t\tawait this.doWriteBuffer(targetProvider, targetHandle, buffer, bytesRead, posInFile, posInBuffer);\n\n\t\t\t\tposInFile += bytesRead;\n\t\t\t\tposInBuffer += bytesRead;\n\n\t\t\t\t// when buffer full, fill it again from the beginning\n\t\t\t\tif (posInBuffer === buffer.byteLength) {\n\t\t\t\t\tposInBuffer = 0;\n\t\t\t\t}\n\t\t\t} while (bytesRead > 0);\n\t\t} catch (error) {\n\t\t\tthrow ensureFileSystemProviderError(error);\n\t\t} finally {\n\t\t\tawait Promises.settled([\n\t\t\t\ttypeof sourceHandle === 'number' ? sourceProvider.close(sourceHandle) : Promise.resolve(),\n\t\t\t\ttypeof targetHandle === 'number' ? targetProvider.close(targetHandle) : Promise.resolve(),\n\t\t\t]);\n\t\t}\n\t}\n\n\tprivate async doPipeUnbuffered(sourceProvider: IFileSystemProviderWithFileReadWriteCapability, source: URI, targetProvider: IFileSystemProviderWithFileReadWriteCapability, target: URI): Promise<void> {\n\t\treturn this.writeQueue.queueFor(target, this.getExtUri(targetProvider).providerExtUri).queue(() => this.doPipeUnbufferedQueued(sourceProvider, source, targetProvider, target));\n\t}\n\n\tprivate async doPipeUnbufferedQueued(sourceProvider: IFileSystemProviderWithFileReadWriteCapability, source: URI, targetProvider: IFileSystemProviderWithFileReadWriteCapability, target: URI): Promise<void> {\n\t\treturn targetProvider.writeFile(target, await sourceProvider.readFile(source), { create: true, overwrite: true, unlock: false, atomic: false });\n\t}\n\n\tprivate async doPipeUnbufferedToBuffered(sourceProvider: IFileSystemProviderWithFileReadWriteCapability, source: URI, targetProvider: IFileSystemProviderWithOpenReadWriteCloseCapability, target: URI): Promise<void> {\n\t\treturn this.writeQueue.queueFor(target, this.getExtUri(targetProvider).providerExtUri).queue(() => this.doPipeUnbufferedToBufferedQueued(sourceProvider, source, targetProvider, target));\n\t}\n\n\tprivate async doPipeUnbufferedToBufferedQueued(sourceProvider: IFileSystemProviderWithFileReadWriteCapability, source: URI, targetProvider: IFileSystemProviderWithOpenReadWriteCloseCapability, target: URI): Promise<void> {\n\n\t\t// Open handle\n\t\tconst targetHandle = await targetProvider.open(target, { create: true, unlock: false });\n\n\t\t// Read entire buffer from source and write buffered\n\t\ttry {\n\t\t\tconst buffer = await sourceProvider.readFile(source);\n\t\t\tawait this.doWriteBuffer(targetProvider, targetHandle, VSBuffer.wrap(buffer), buffer.byteLength, 0, 0);\n\t\t} catch (error) {\n\t\t\tthrow ensureFileSystemProviderError(error);\n\t\t} finally {\n\t\t\tawait targetProvider.close(targetHandle);\n\t\t}\n\t}\n\n\tprivate async doPipeBufferedToUnbuffered(sourceProvider: IFileSystemProviderWithOpenReadWriteCloseCapability, source: URI, targetProvider: IFileSystemProviderWithFileReadWriteCapability, target: URI): Promise<void> {\n\n\t\t// Read buffer via stream buffered\n\t\tconst buffer = await streamToBuffer(this.readFileBuffered(sourceProvider, source, CancellationToken.None));\n\n\t\t// Write buffer into target at once\n\t\tawait this.doWriteUnbuffered(targetProvider, target, undefined, buffer);\n\t}\n\n\tprotected throwIfFileSystemIsReadonly<T extends IFileSystemProvider>(provider: T, resource: URI): T {\n\t\tif (provider.capabilities & FileSystemProviderCapabilities.Readonly) {\n\t\t\tthrow new FileOperationError(localize('err.readonly', \"Unable to modify read-only file '{0}'\", this.resourceForError(resource)), FileOperationResult.FILE_PERMISSION_DENIED);\n\t\t}\n\n\t\treturn provider;\n\t}\n\n\tprivate throwIfFileIsReadonly(resource: URI, stat: IStat): void {\n\t\tif ((stat.permissions ?? 0) & FilePermission.Readonly) {\n\t\t\tthrow new FileOperationError(localize('err.readonly', \"Unable to modify read-only file '{0}'\", this.resourceForError(resource)), FileOperationResult.FILE_PERMISSION_DENIED);\n\t\t}\n\t}\n\n\tprivate resourceForError(resource: URI): string {\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\treturn resource.fsPath;\n\t\t}\n\n\t\treturn resource.toString(true);\n\t}\n\n\t//#endregion\n}\n"]}