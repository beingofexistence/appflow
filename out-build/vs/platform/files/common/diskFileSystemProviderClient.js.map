{"version":3,"sources":["file:///workspace/appflow/src/vs/platform/files/common/diskFileSystemProviderClient.ts"],"names":[],"mappings":"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","file":"diskFileSystemProviderClient.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { VSBuffer } from 'vs/base/common/buffer';\nimport { CancellationToken } from 'vs/base/common/cancellation';\nimport { toErrorMessage } from 'vs/base/common/errorMessage';\nimport { canceled } from 'vs/base/common/errors';\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { Disposable, DisposableStore, IDisposable, toDisposable } from 'vs/base/common/lifecycle';\nimport { newWriteableStream, ReadableStreamEventPayload, ReadableStreamEvents } from 'vs/base/common/stream';\nimport { URI, UriComponents } from 'vs/base/common/uri';\nimport { generateUuid } from 'vs/base/common/uuid';\nimport { IChannel } from 'vs/base/parts/ipc/common/ipc';\nimport { createFileSystemProviderError, IFileAtomicReadOptions, FileChangeType, IFileDeleteOptions, IFileOpenOptions, IFileOverwriteOptions, IFileReadStreamOptions, FileSystemProviderCapabilities, FileSystemProviderErrorCode, FileType, IFileWriteOptions, IFileChange, IFileSystemProviderWithFileAtomicReadCapability, IFileSystemProviderWithFileCloneCapability, IFileSystemProviderWithFileFolderCopyCapability, IFileSystemProviderWithFileReadStreamCapability, IFileSystemProviderWithFileReadWriteCapability, IFileSystemProviderWithOpenReadWriteCloseCapability, IStat, IWatchOptions, IFileSystemProviderError } from 'vs/platform/files/common/files';\n\nexport const LOCAL_FILE_SYSTEM_CHANNEL_NAME = 'localFilesystem';\n\n/**\n * An implementation of a local disk file system provider\n * that is backed by a `IChannel` and thus implemented via\n * IPC on a different process.\n */\nexport class DiskFileSystemProviderClient extends Disposable implements\n\tIFileSystemProviderWithFileReadWriteCapability,\n\tIFileSystemProviderWithOpenReadWriteCloseCapability,\n\tIFileSystemProviderWithFileReadStreamCapability,\n\tIFileSystemProviderWithFileFolderCopyCapability,\n\tIFileSystemProviderWithFileAtomicReadCapability,\n\tIFileSystemProviderWithFileCloneCapability {\n\n\tconstructor(\n\t\tprivate readonly channel: IChannel,\n\t\tprivate readonly extraCapabilities: { trash?: boolean; pathCaseSensitive?: boolean }\n\t) {\n\t\tsuper();\n\n\t\tthis.registerFileChangeListeners();\n\t}\n\n\t//#region File Capabilities\n\n\treadonly onDidChangeCapabilities: Event<void> = Event.None;\n\n\tprivate _capabilities: FileSystemProviderCapabilities | undefined;\n\tget capabilities(): FileSystemProviderCapabilities {\n\t\tif (!this._capabilities) {\n\t\t\tthis._capabilities =\n\t\t\t\tFileSystemProviderCapabilities.FileReadWrite |\n\t\t\t\tFileSystemProviderCapabilities.FileOpenReadWriteClose |\n\t\t\t\tFileSystemProviderCapabilities.FileReadStream |\n\t\t\t\tFileSystemProviderCapabilities.FileFolderCopy |\n\t\t\t\tFileSystemProviderCapabilities.FileWriteUnlock |\n\t\t\t\tFileSystemProviderCapabilities.FileAtomicRead |\n\t\t\t\tFileSystemProviderCapabilities.FileAtomicWrite |\n\t\t\t\tFileSystemProviderCapabilities.FileAtomicDelete |\n\t\t\t\tFileSystemProviderCapabilities.FileClone;\n\n\t\t\tif (this.extraCapabilities.pathCaseSensitive) {\n\t\t\t\tthis._capabilities |= FileSystemProviderCapabilities.PathCaseSensitive;\n\t\t\t}\n\n\t\t\tif (this.extraCapabilities.trash) {\n\t\t\t\tthis._capabilities |= FileSystemProviderCapabilities.Trash;\n\t\t\t}\n\t\t}\n\n\t\treturn this._capabilities;\n\t}\n\n\t//#endregion\n\n\t//#region File Metadata Resolving\n\n\tstat(resource: URI): Promise<IStat> {\n\t\treturn this.channel.call('stat', [resource]);\n\t}\n\n\treaddir(resource: URI): Promise<[string, FileType][]> {\n\t\treturn this.channel.call('readdir', [resource]);\n\t}\n\n\t//#endregion\n\n\t//#region File Reading/Writing\n\n\tasync readFile(resource: URI, opts?: IFileAtomicReadOptions): Promise<Uint8Array> {\n\t\tconst { buffer } = await this.channel.call('readFile', [resource, opts]) as VSBuffer;\n\n\t\treturn buffer;\n\t}\n\n\treadFileStream(resource: URI, opts: IFileReadStreamOptions, token: CancellationToken): ReadableStreamEvents<Uint8Array> {\n\t\tconst stream = newWriteableStream<Uint8Array>(data => VSBuffer.concat(data.map(data => VSBuffer.wrap(data))).buffer);\n\t\tconst disposables = new DisposableStore();\n\n\t\t// Reading as file stream goes through an event to the remote side\n\t\tdisposables.add(this.channel.listen<ReadableStreamEventPayload<VSBuffer>>('readFileStream', [resource, opts])(dataOrErrorOrEnd => {\n\n\t\t\t// data\n\t\t\tif (dataOrErrorOrEnd instanceof VSBuffer) {\n\t\t\t\tstream.write(dataOrErrorOrEnd.buffer);\n\t\t\t}\n\n\t\t\t// end or error\n\t\t\telse {\n\t\t\t\tif (dataOrErrorOrEnd === 'end') {\n\t\t\t\t\tstream.end();\n\t\t\t\t} else {\n\t\t\t\t\tlet error: Error;\n\n\t\t\t\t\t// Take Error as is if type matches\n\t\t\t\t\tif (dataOrErrorOrEnd instanceof Error) {\n\t\t\t\t\t\terror = dataOrErrorOrEnd;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Otherwise, try to deserialize into an error.\n\t\t\t\t\t// Since we communicate via IPC, we cannot be sure\n\t\t\t\t\t// that Error objects are properly serialized.\n\t\t\t\t\telse {\n\t\t\t\t\t\tconst errorCandidate = dataOrErrorOrEnd as IFileSystemProviderError;\n\n\t\t\t\t\t\terror = createFileSystemProviderError(errorCandidate.message ?? toErrorMessage(errorCandidate), errorCandidate.code ?? FileSystemProviderErrorCode.Unknown);\n\t\t\t\t\t}\n\n\t\t\t\t\tstream.error(error);\n\t\t\t\t\tstream.end();\n\t\t\t\t}\n\n\t\t\t\t// Signal to the remote side that we no longer listen\n\t\t\t\tdisposables.dispose();\n\t\t\t}\n\t\t}));\n\n\t\t// Support cancellation\n\t\tdisposables.add(token.onCancellationRequested(() => {\n\n\t\t\t// Ensure to end the stream properly with an error\n\t\t\t// to indicate the cancellation.\n\t\t\tstream.error(canceled());\n\t\t\tstream.end();\n\n\t\t\t// Ensure to dispose the listener upon cancellation. This will\n\t\t\t// bubble through the remote side as event and allows to stop\n\t\t\t// reading the file.\n\t\t\tdisposables.dispose();\n\t\t}));\n\n\t\treturn stream;\n\t}\n\n\twriteFile(resource: URI, content: Uint8Array, opts: IFileWriteOptions): Promise<void> {\n\t\treturn this.channel.call('writeFile', [resource, VSBuffer.wrap(content), opts]);\n\t}\n\n\topen(resource: URI, opts: IFileOpenOptions): Promise<number> {\n\t\treturn this.channel.call('open', [resource, opts]);\n\t}\n\n\tclose(fd: number): Promise<void> {\n\t\treturn this.channel.call('close', [fd]);\n\t}\n\n\tasync read(fd: number, pos: number, data: Uint8Array, offset: number, length: number): Promise<number> {\n\t\tconst [bytes, bytesRead]: [VSBuffer, number] = await this.channel.call('read', [fd, pos, length]);\n\n\t\t// copy back the data that was written into the buffer on the remote\n\t\t// side. we need to do this because buffers are not referenced by\n\t\t// pointer, but only by value and as such cannot be directly written\n\t\t// to from the other process.\n\t\tdata.set(bytes.buffer.slice(0, bytesRead), offset);\n\n\t\treturn bytesRead;\n\t}\n\n\twrite(fd: number, pos: number, data: Uint8Array, offset: number, length: number): Promise<number> {\n\t\treturn this.channel.call('write', [fd, pos, VSBuffer.wrap(data), offset, length]);\n\t}\n\n\t//#endregion\n\n\t//#region Move/Copy/Delete/Create Folder\n\n\tmkdir(resource: URI): Promise<void> {\n\t\treturn this.channel.call('mkdir', [resource]);\n\t}\n\n\tdelete(resource: URI, opts: IFileDeleteOptions): Promise<void> {\n\t\treturn this.channel.call('delete', [resource, opts]);\n\t}\n\n\trename(resource: URI, target: URI, opts: IFileOverwriteOptions): Promise<void> {\n\t\treturn this.channel.call('rename', [resource, target, opts]);\n\t}\n\n\tcopy(resource: URI, target: URI, opts: IFileOverwriteOptions): Promise<void> {\n\t\treturn this.channel.call('copy', [resource, target, opts]);\n\t}\n\n\t//#endregion\n\n\t//#region Clone File\n\n\tcloneFile(resource: URI, target: URI): Promise<void> {\n\t\treturn this.channel.call('cloneFile', [resource, target]);\n\t}\n\n\t//#endregion\n\n\t//#region File Watching\n\n\tprivate readonly _onDidChange = this._register(new Emitter<readonly IFileChange[]>());\n\treadonly onDidChangeFile = this._onDidChange.event;\n\n\tprivate readonly _onDidWatchError = this._register(new Emitter<string>());\n\treadonly onDidWatchError = this._onDidWatchError.event;\n\n\t// The contract for file watching via remote is to identify us\n\t// via a unique but readonly session ID. Since the remote is\n\t// managing potentially many watchers from different clients,\n\t// this helps the server to properly partition events to the right\n\t// clients.\n\tprivate readonly sessionId = generateUuid();\n\n\tprivate registerFileChangeListeners(): void {\n\n\t\t// The contract for file changes is that there is one listener\n\t\t// for both events and errors from the watcher. So we need to\n\t\t// unwrap the event from the remote and emit through the proper\n\t\t// emitter.\n\t\tthis._register(this.channel.listen<{ resource: UriComponents; type: FileChangeType }[] | string>('fileChange', [this.sessionId])(eventsOrError => {\n\t\t\tif (Array.isArray(eventsOrError)) {\n\t\t\t\tconst events = eventsOrError;\n\t\t\t\tthis._onDidChange.fire(events.map(event => ({ resource: URI.revive(event.resource), type: event.type })));\n\t\t\t} else {\n\t\t\t\tconst error = eventsOrError;\n\t\t\t\tthis._onDidWatchError.fire(error);\n\t\t\t}\n\t\t}));\n\t}\n\n\twatch(resource: URI, opts: IWatchOptions): IDisposable {\n\n\t\t// Generate a request UUID to correlate the watcher\n\t\t// back to us when we ask to dispose the watcher later.\n\t\tconst req = generateUuid();\n\n\t\tthis.channel.call('watch', [this.sessionId, req, resource, opts]);\n\n\t\treturn toDisposable(() => this.channel.call('unwatch', [this.sessionId, req]));\n\t}\n\n\t//#endregion\n}\n"]}