{"version":3,"sources":["file:///workspace/appflow/src/vs/platform/files/common/diskFileSystemProvider.ts"],"names":[],"mappings":"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","file":"diskFileSystemProvider.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { insert } from 'vs/base/common/arrays';\nimport { ThrottledDelayer } from 'vs/base/common/async';\nimport { onUnexpectedError } from 'vs/base/common/errors';\nimport { Emitter } from 'vs/base/common/event';\nimport { Disposable, IDisposable, toDisposable } from 'vs/base/common/lifecycle';\nimport { normalize } from 'vs/base/common/path';\nimport { URI } from 'vs/base/common/uri';\nimport { IFileChange, IFileSystemProvider, IWatchOptions } from 'vs/platform/files/common/files';\nimport { AbstractNonRecursiveWatcherClient, AbstractUniversalWatcherClient, IDiskFileChange, ILogMessage, INonRecursiveWatchRequest, IRecursiveWatcherOptions, isRecursiveWatchRequest, IUniversalWatchRequest, toFileChanges } from 'vs/platform/files/common/watcher';\nimport { ILogService, LogLevel } from 'vs/platform/log/common/log';\n\nexport interface IDiskFileSystemProviderOptions {\n\twatcher?: {\n\n\t\t/**\n\t\t * Extra options for the recursive file watching.\n\t\t */\n\t\trecursive?: IRecursiveWatcherOptions;\n\n\t\t/**\n\t\t * Forces all file watch requests to run through a\n\t\t * single universal file watcher, both recursive\n\t\t * and non-recursively.\n\t\t *\n\t\t * Enabling this option might cause some overhead,\n\t\t * specifically the universal file watcher will run\n\t\t * in a separate process given its complexity. Only\n\t\t * enable it when you understand the consequences.\n\t\t */\n\t\tforceUniversal?: boolean;\n\t};\n}\n\nexport abstract class AbstractDiskFileSystemProvider extends Disposable implements\n\tPick<IFileSystemProvider, 'watch'>,\n\tPick<IFileSystemProvider, 'onDidChangeFile'>,\n\tPick<IFileSystemProvider, 'onDidWatchError'> {\n\n\tconstructor(\n\t\tprotected readonly logService: ILogService,\n\t\tprivate readonly options?: IDiskFileSystemProviderOptions\n\t) {\n\t\tsuper();\n\t}\n\n\tprotected readonly _onDidChangeFile = this._register(new Emitter<readonly IFileChange[]>());\n\treadonly onDidChangeFile = this._onDidChangeFile.event;\n\n\tprotected readonly _onDidWatchError = this._register(new Emitter<string>());\n\treadonly onDidWatchError = this._onDidWatchError.event;\n\n\twatch(resource: URI, opts: IWatchOptions): IDisposable {\n\t\tif (opts.recursive || this.options?.watcher?.forceUniversal) {\n\t\t\treturn this.watchUniversal(resource, opts);\n\t\t}\n\n\t\treturn this.watchNonRecursive(resource, opts);\n\t}\n\n\t//#region File Watching (universal)\n\n\tprivate universalWatcher: AbstractUniversalWatcherClient | undefined;\n\n\tprivate readonly universalPathsToWatch: IUniversalWatchRequest[] = [];\n\tprivate readonly universalWatchRequestDelayer = this._register(new ThrottledDelayer<void>(0));\n\n\tprivate watchUniversal(resource: URI, opts: IWatchOptions): IDisposable {\n\n\t\t// Add to list of paths to watch universally\n\t\tconst pathToWatch: IUniversalWatchRequest = { path: this.toFilePath(resource), excludes: opts.excludes, includes: opts.includes, recursive: opts.recursive };\n\t\tconst remove = insert(this.universalPathsToWatch, pathToWatch);\n\n\t\t// Trigger update\n\t\tthis.refreshUniversalWatchers();\n\n\t\treturn toDisposable(() => {\n\n\t\t\t// Remove from list of paths to watch universally\n\t\t\tremove();\n\n\t\t\t// Trigger update\n\t\t\tthis.refreshUniversalWatchers();\n\t\t});\n\t}\n\n\tprivate refreshUniversalWatchers(): void {\n\n\t\t// Buffer requests for universal watching to decide on right watcher\n\t\t// that supports potentially watching more than one path at once\n\t\tthis.universalWatchRequestDelayer.trigger(() => {\n\t\t\treturn this.doRefreshUniversalWatchers();\n\t\t}).catch(error => onUnexpectedError(error));\n\t}\n\n\tprivate doRefreshUniversalWatchers(): Promise<void> {\n\n\t\t// Create watcher if this is the first time\n\t\tif (!this.universalWatcher) {\n\t\t\tthis.universalWatcher = this._register(this.createUniversalWatcher(\n\t\t\t\tchanges => this._onDidChangeFile.fire(toFileChanges(changes)),\n\t\t\t\tmsg => this.onWatcherLogMessage(msg),\n\t\t\t\tthis.logService.getLevel() === LogLevel.Trace\n\t\t\t));\n\n\t\t\t// Apply log levels dynamically\n\t\t\tthis._register(this.logService.onDidChangeLogLevel(() => {\n\t\t\t\tthis.universalWatcher?.setVerboseLogging(this.logService.getLevel() === LogLevel.Trace);\n\t\t\t}));\n\t\t}\n\n\t\t// Adjust for polling\n\t\tconst usePolling = this.options?.watcher?.recursive?.usePolling;\n\t\tif (usePolling === true) {\n\t\t\tfor (const request of this.universalPathsToWatch) {\n\t\t\t\tif (isRecursiveWatchRequest(request)) {\n\t\t\t\t\trequest.pollingInterval = this.options?.watcher?.recursive?.pollingInterval ?? 5000;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (Array.isArray(usePolling)) {\n\t\t\tfor (const request of this.universalPathsToWatch) {\n\t\t\t\tif (isRecursiveWatchRequest(request)) {\n\t\t\t\t\tif (usePolling.includes(request.path)) {\n\t\t\t\t\t\trequest.pollingInterval = this.options?.watcher?.recursive?.pollingInterval ?? 5000;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Ask to watch the provided paths\n\t\treturn this.universalWatcher.watch(this.universalPathsToWatch);\n\t}\n\n\tprotected abstract createUniversalWatcher(\n\t\tonChange: (changes: IDiskFileChange[]) => void,\n\t\tonLogMessage: (msg: ILogMessage) => void,\n\t\tverboseLogging: boolean\n\t): AbstractUniversalWatcherClient;\n\n\t//#endregion\n\n\t//#region File Watching (non-recursive)\n\n\tprivate nonRecursiveWatcher: AbstractNonRecursiveWatcherClient | undefined;\n\n\tprivate readonly nonRecursivePathsToWatch: INonRecursiveWatchRequest[] = [];\n\tprivate readonly nonRecursiveWatchRequestDelayer = this._register(new ThrottledDelayer<void>(0));\n\n\tprivate watchNonRecursive(resource: URI, opts: IWatchOptions): IDisposable {\n\n\t\t// Add to list of paths to watch non-recursively\n\t\tconst pathToWatch: INonRecursiveWatchRequest = { path: this.toFilePath(resource), excludes: opts.excludes, includes: opts.includes, recursive: false };\n\t\tconst remove = insert(this.nonRecursivePathsToWatch, pathToWatch);\n\n\t\t// Trigger update\n\t\tthis.refreshNonRecursiveWatchers();\n\n\t\treturn toDisposable(() => {\n\n\t\t\t// Remove from list of paths to watch non-recursively\n\t\t\tremove();\n\n\t\t\t// Trigger update\n\t\t\tthis.refreshNonRecursiveWatchers();\n\t\t});\n\t}\n\n\tprivate refreshNonRecursiveWatchers(): void {\n\n\t\t// Buffer requests for nonrecursive watching to decide on right watcher\n\t\t// that supports potentially watching more than one path at once\n\t\tthis.nonRecursiveWatchRequestDelayer.trigger(() => {\n\t\t\treturn this.doRefreshNonRecursiveWatchers();\n\t\t}).catch(error => onUnexpectedError(error));\n\t}\n\n\tprivate doRefreshNonRecursiveWatchers(): Promise<void> {\n\n\t\t// Create watcher if this is the first time\n\t\tif (!this.nonRecursiveWatcher) {\n\t\t\tthis.nonRecursiveWatcher = this._register(this.createNonRecursiveWatcher(\n\t\t\t\tchanges => this._onDidChangeFile.fire(toFileChanges(changes)),\n\t\t\t\tmsg => this.onWatcherLogMessage(msg),\n\t\t\t\tthis.logService.getLevel() === LogLevel.Trace\n\t\t\t));\n\n\t\t\t// Apply log levels dynamically\n\t\t\tthis._register(this.logService.onDidChangeLogLevel(() => {\n\t\t\t\tthis.nonRecursiveWatcher?.setVerboseLogging(this.logService.getLevel() === LogLevel.Trace);\n\t\t\t}));\n\t\t}\n\n\t\t// Ask to watch the provided paths\n\t\treturn this.nonRecursiveWatcher.watch(this.nonRecursivePathsToWatch);\n\t}\n\n\tprotected abstract createNonRecursiveWatcher(\n\t\tonChange: (changes: IDiskFileChange[]) => void,\n\t\tonLogMessage: (msg: ILogMessage) => void,\n\t\tverboseLogging: boolean\n\t): AbstractNonRecursiveWatcherClient;\n\n\t//#endregion\n\n\tprivate onWatcherLogMessage(msg: ILogMessage): void {\n\t\tif (msg.type === 'error') {\n\t\t\tthis._onDidWatchError.fire(msg.message);\n\t\t}\n\n\t\tthis.logService[msg.type](msg.message);\n\t}\n\n\tprotected toFilePath(resource: URI): string {\n\t\treturn normalize(resource.fsPath);\n\t}\n}\n"]}