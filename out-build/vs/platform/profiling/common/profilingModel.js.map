{"version":3,"sources":["file:///workspace/appflow/src/vs/platform/profiling/common/profilingModel.ts"],"names":[],"mappings":"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","file":"profilingModel.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport type { IV8Profile, IV8ProfileNode } from 'vs/platform/profiling/common/profiling';\n\n// #region\n// https://github.com/microsoft/vscode-js-profile-visualizer/blob/6e7401128ee860be113a916f80fcfe20ac99418e/packages/vscode-js-profile-core/src/cpu/model.ts#L4\n\nexport interface IProfileModel {\n\tnodes: ReadonlyArray<IComputedNode>;\n\tlocations: ReadonlyArray<ILocation>;\n\tsamples: ReadonlyArray<number>;\n\ttimeDeltas: ReadonlyArray<number>;\n\trootPath?: string;\n\tduration: number;\n}\n\nexport interface IComputedNode {\n\tid: number;\n\tselfTime: number;\n\taggregateTime: number;\n\tchildren: number[];\n\tparent?: number;\n\tlocationId: number;\n}\n\nexport interface ISourceLocation {\n\tlineNumber: number;\n\tcolumnNumber: number;\n\t//   source: Dap.Source;\n\trelativePath?: string;\n}\n\nexport interface CdpCallFrame {\n\tfunctionName: string;\n\tscriptId: string;\n\turl: string;\n\tlineNumber: number;\n\tcolumnNumber: number;\n}\n\nexport interface CdpPositionTickInfo {\n\tline: number;\n\tticks: number;\n}\n\nexport interface INode {\n\tid: number;\n\t//   category: Category;\n\tcallFrame: CdpCallFrame;\n\tsrc?: ISourceLocation;\n}\n\nexport interface ILocation extends INode {\n\tselfTime: number;\n\taggregateTime: number;\n\tticks: number;\n}\n\nexport interface IAnnotationLocation {\n\tcallFrame: CdpCallFrame;\n\tlocations: ISourceLocation[];\n}\n\nexport interface IProfileNode extends IV8ProfileNode {\n\tlocationId?: number;\n\tpositionTicks?: (CdpPositionTickInfo & {\n\t\tstartLocationId?: number;\n\t\tendLocationId?: number;\n\t})[];\n}\n\nexport interface ICpuProfileRaw extends IV8Profile {\n\t//   $vscode?: IJsDebugAnnotations;\n\tnodes: IProfileNode[];\n}\n\n\n/**\n * Recursive function that computes and caches the aggregate time for the\n * children of the computed now.\n */\nconst computeAggregateTime = (index: number, nodes: IComputedNode[]): number => {\n\tconst row = nodes[index];\n\tif (row.aggregateTime) {\n\t\treturn row.aggregateTime;\n\t}\n\n\tlet total = row.selfTime;\n\tfor (const child of row.children) {\n\t\ttotal += computeAggregateTime(child, nodes);\n\t}\n\n\treturn (row.aggregateTime = total);\n};\n\nconst ensureSourceLocations = (profile: ICpuProfileRaw): ReadonlyArray<IAnnotationLocation> => {\n\n\tlet locationIdCounter = 0;\n\tconst locationsByRef = new Map<string, { id: number; callFrame: CdpCallFrame; location: ISourceLocation }>();\n\n\tconst getLocationIdFor = (callFrame: CdpCallFrame) => {\n\t\tconst ref = [\n\t\t\tcallFrame.functionName,\n\t\t\tcallFrame.url,\n\t\t\tcallFrame.scriptId,\n\t\t\tcallFrame.lineNumber,\n\t\t\tcallFrame.columnNumber,\n\t\t].join(':');\n\n\t\tconst existing = locationsByRef.get(ref);\n\t\tif (existing) {\n\t\t\treturn existing.id;\n\t\t}\n\t\tconst id = locationIdCounter++;\n\t\tlocationsByRef.set(ref, {\n\t\t\tid,\n\t\t\tcallFrame,\n\t\t\tlocation: {\n\t\t\t\tlineNumber: callFrame.lineNumber + 1,\n\t\t\t\tcolumnNumber: callFrame.columnNumber + 1,\n\t\t\t\t// source: {\n\t\t\t\t// \tname: maybeFileUrlToPath(callFrame.url),\n\t\t\t\t// \tpath: maybeFileUrlToPath(callFrame.url),\n\t\t\t\t// \tsourceReference: 0,\n\t\t\t\t// },\n\t\t\t},\n\t\t});\n\n\t\treturn id;\n\t};\n\n\tfor (const node of profile.nodes) {\n\t\tnode.locationId = getLocationIdFor(node.callFrame);\n\t\tnode.positionTicks = node.positionTicks?.map(tick => ({\n\t\t\t...tick,\n\t\t\t// weirdly, line numbers here are 1-based, not 0-based. The position tick\n\t\t\t// only gives line-level granularity, so 'mark' the entire range of source\n\t\t\t// code the tick refers to\n\t\t\tstartLocationId: getLocationIdFor({\n\t\t\t\t...node.callFrame,\n\t\t\t\tlineNumber: tick.line - 1,\n\t\t\t\tcolumnNumber: 0,\n\t\t\t}),\n\t\t\tendLocationId: getLocationIdFor({\n\t\t\t\t...node.callFrame,\n\t\t\t\tlineNumber: tick.line,\n\t\t\t\tcolumnNumber: 0,\n\t\t\t}),\n\t\t}));\n\t}\n\n\treturn [...locationsByRef.values()]\n\t\t.sort((a, b) => a.id - b.id)\n\t\t.map(l => ({ locations: [l.location], callFrame: l.callFrame }));\n};\n\n/**\n * Computes the model for the given profile.\n */\nexport const buildModel = (profile: ICpuProfileRaw): IProfileModel => {\n\tif (!profile.timeDeltas || !profile.samples) {\n\t\treturn {\n\t\t\tnodes: [],\n\t\t\tlocations: [],\n\t\t\tsamples: profile.samples || [],\n\t\t\ttimeDeltas: profile.timeDeltas || [],\n\t\t\t// rootPath: profile.$vscode?.rootPath,\n\t\t\tduration: profile.endTime - profile.startTime,\n\t\t};\n\t}\n\n\tconst { samples, timeDeltas } = profile;\n\tconst sourceLocations = ensureSourceLocations(profile);\n\tconst locations: ILocation[] = sourceLocations.map((l, id) => {\n\t\tconst src = l.locations[0]; //getBestLocation(profile, l.locations);\n\n\t\treturn {\n\t\t\tid,\n\t\t\tselfTime: 0,\n\t\t\taggregateTime: 0,\n\t\t\tticks: 0,\n\t\t\t// category: categorize(l.callFrame, src),\n\t\t\tcallFrame: l.callFrame,\n\t\t\tsrc,\n\t\t};\n\t});\n\n\tconst idMap = new Map<number /* id in profile */, number /* incrementing ID */>();\n\tconst mapId = (nodeId: number) => {\n\t\tlet id = idMap.get(nodeId);\n\t\tif (id === undefined) {\n\t\t\tid = idMap.size;\n\t\t\tidMap.set(nodeId, id);\n\t\t}\n\n\t\treturn id;\n\t};\n\n\t// 1. Created a sorted list of nodes. It seems that the profile always has\n\t// incrementing IDs, although they are just not initially sorted.\n\tconst nodes = new Array<IComputedNode>(profile.nodes.length);\n\tfor (let i = 0; i < profile.nodes.length; i++) {\n\t\tconst node = profile.nodes[i];\n\n\t\t// make them 0-based:\n\t\tconst id = mapId(node.id);\n\t\tnodes[id] = {\n\t\t\tid,\n\t\t\tselfTime: 0,\n\t\t\taggregateTime: 0,\n\t\t\tlocationId: node.locationId as number,\n\t\t\tchildren: node.children?.map(mapId) || [],\n\t\t};\n\n\t\tfor (const child of node.positionTicks || []) {\n\t\t\tif (child.startLocationId) {\n\t\t\t\tlocations[child.startLocationId].ticks += child.ticks;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (const node of nodes) {\n\t\tfor (const child of node.children) {\n\t\t\tnodes[child].parent = node.id;\n\t\t}\n\t}\n\n\t// 2. The profile samples are the 'bottom-most' node, the currently running\n\t// code. Sum of these in the self time.\n\tconst duration = profile.endTime - profile.startTime;\n\tlet lastNodeTime = duration - timeDeltas[0];\n\tfor (let i = 0; i < timeDeltas.length - 1; i++) {\n\t\tconst d = timeDeltas[i + 1];\n\t\tnodes[mapId(samples[i])].selfTime += d;\n\t\tlastNodeTime -= d;\n\t}\n\n\t// Add in an extra time delta for the last sample. `timeDeltas[0]` is the\n\t// time before the first sample, and the time of the last sample is only\n\t// derived (approximately) by the missing time in the sum of deltas. Save\n\t// some work by calculating it here.\n\tif (nodes.length) {\n\t\tnodes[mapId(samples[timeDeltas.length - 1])].selfTime += lastNodeTime;\n\t\ttimeDeltas.push(lastNodeTime);\n\t}\n\n\t// 3. Add the aggregate times for all node children and locations\n\tfor (let i = 0; i < nodes.length; i++) {\n\t\tconst node = nodes[i];\n\t\tconst location = locations[node.locationId];\n\t\tlocation.aggregateTime += computeAggregateTime(i, nodes);\n\t\tlocation.selfTime += node.selfTime;\n\t}\n\n\treturn {\n\t\tnodes,\n\t\tlocations,\n\t\tsamples: samples.map(mapId),\n\t\ttimeDeltas,\n\t\t// rootPath: profile.$vscode?.rootPath,\n\t\tduration,\n\t};\n};\n\nexport class BottomUpNode {\n\tpublic static root() {\n\t\treturn new BottomUpNode({\n\t\t\tid: -1,\n\t\t\tselfTime: 0,\n\t\t\taggregateTime: 0,\n\t\t\tticks: 0,\n\t\t\tcallFrame: {\n\t\t\t\tfunctionName: '(root)',\n\t\t\t\tlineNumber: -1,\n\t\t\t\tcolumnNumber: -1,\n\t\t\t\tscriptId: '0',\n\t\t\t\turl: '',\n\t\t\t},\n\t\t});\n\t}\n\n\tpublic children: { [id: number]: BottomUpNode } = {};\n\tpublic aggregateTime = 0;\n\tpublic selfTime = 0;\n\tpublic ticks = 0;\n\tpublic childrenSize = 0;\n\n\tpublic get id() {\n\t\treturn this.location.id;\n\t}\n\n\tpublic get callFrame() {\n\t\treturn this.location.callFrame;\n\t}\n\n\tpublic get src() {\n\t\treturn this.location.src;\n\t}\n\n\tconstructor(public readonly location: ILocation, public readonly parent?: BottomUpNode) { }\n\n\tpublic addNode(node: IComputedNode) {\n\t\tthis.selfTime += node.selfTime;\n\t\tthis.aggregateTime += node.aggregateTime;\n\t}\n\n}\n\nexport const processNode = (aggregate: BottomUpNode, node: IComputedNode, model: IProfileModel, initialNode = node) => {\n\tlet child = aggregate.children[node.locationId];\n\tif (!child) {\n\t\tchild = new BottomUpNode(model.locations[node.locationId], aggregate);\n\t\taggregate.childrenSize++;\n\t\taggregate.children[node.locationId] = child;\n\t}\n\n\tchild.addNode(initialNode);\n\n\tif (node.parent) {\n\t\tprocessNode(child, model.nodes[node.parent], model, initialNode);\n\t}\n};\n\n//#endregion\n\n\nexport interface BottomUpSample {\n\tselfTime: number;\n\ttotalTime: number;\n\tlocation: string;\n\tabsLocation: string;\n\turl: string;\n\tcaller: { percentage: number; absLocation: string; location: string }[];\n\tpercentage: number;\n\tisSpecial: boolean;\n}\n"]}