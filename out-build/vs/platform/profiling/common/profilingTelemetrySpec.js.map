{"version":3,"sources":["file:///workspace/appflow/src/vs/platform/profiling/common/profilingTelemetrySpec.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;IAqChG,SAAgB,IAAI,CAAS,IAAgB,EAAE,gBAAqB,EAAgB,UAAe,EAAU,mBAA4B;QAExI,MAAM,EAAE,MAAM,EAAE,YAAY,EAAE,MAAM,EAAE,GAAG,IAAI,CAAC;QAE9C,uBAAuB;QACvB,gBAAgB,CAAC,UAAU,CAAyD,qBAAqB,EAAE;YAC1G,YAAY;YACZ,QAAQ,EAAE,MAAM,CAAC,QAAQ;YACzB,SAAS,EAAE,MAAM,CAAC,SAAS;YAC3B,UAAU,EAAE,MAAM,CAAC,UAAU;YAC7B,YAAY,EAAE,MAAM,CAAC,QAAQ;YAC7B,OAAO,EAAE,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC;YACrD,gBAAgB,EAAE,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,UAAU,IAAI,CAAC,CAAC,QAAQ,EAAE,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC;YACnF,MAAM;SACN,CAAC,CAAC;QAEH,wCAAwC;QACxC,MAAM,SAAS,GAAG,IAAI,gBAAgB,CAAC,IAAI,CAAC,CAAC;QAC7C,IAAI,mBAAmB,EAAE;YACxB,WAAE,CAAW,iBAAiB,CAAC,SAAS,CAAC,CAAC;SAC1C;aAAM;YACN,UAAU,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;SAC5B;IACF,CAAC;IAvBD,oBAuBC;IAED,MAAM,gBAAiB,SAAQ,KAAK;QAGnC,YAAY,IAAgB;YAC3B,KAAK,CAAC,uBAAuB,IAAI,CAAC,MAAM,OAAO,IAAI,CAAC,MAAM,CAAC,QAAQ,EAAE,CAAC,CAAC;YACvE,IAAI,CAAC,IAAI,GAAG,iBAAiB,CAAC;YAC9B,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC;YAErC,MAAM,KAAK,GAAG,CAAC,IAAI,CAAC,MAAM,CAAC,WAAW,EAAE,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC;YACvF,IAAI,CAAC,KAAK,GAAG,WAAW,KAAK,CAAC,IAAI,CAAC,UAAU,CAAC,EAAE,CAAC;QAClD,CAAC;KACD","file":"profilingTelemetrySpec.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ILogService } from 'vs/platform/log/common/log';\nimport { BottomUpSample } from 'vs/platform/profiling/common/profilingModel';\nimport { ITelemetryService } from 'vs/platform/telemetry/common/telemetry';\nimport { errorHandler } from 'vs/base/common/errors';\n\ntype TelemetrySampleData = {\n\tselfTime: number;\n\ttotalTime: number;\n\tpercentage: number;\n\tperfBaseline: number;\n\tfunctionName: string;\n\tcallers: string;\n\tcallersAnnotated: string;\n\tsource: string;\n};\n\ntype TelemetrySampleDataClassification = {\n\towner: 'jrieken';\n\tcomment: 'A callstack that took a long time to execute';\n\tselfTime: { classification: 'SystemMetaData'; purpose: 'PerformanceAndHealth'; isMeasurement: true; comment: 'Self time of the sample' };\n\ttotalTime: { classification: 'SystemMetaData'; purpose: 'PerformanceAndHealth'; isMeasurement: true; comment: 'Total time of the sample' };\n\tpercentage: { classification: 'SystemMetaData'; purpose: 'PerformanceAndHealth'; isMeasurement: true; comment: 'Relative time (percentage) of the sample' };\n\tperfBaseline: { classification: 'SystemMetaData'; purpose: 'PerformanceAndHealth'; isMeasurement: true; comment: 'Performance baseline for the machine' };\n\tfunctionName: { classification: 'SystemMetaData'; purpose: 'PerformanceAndHealth'; comment: 'The name of the sample' };\n\tcallers: { classification: 'CallstackOrException'; purpose: 'PerformanceAndHealth'; comment: 'The heaviest call trace into this sample' };\n\tcallersAnnotated: { classification: 'SystemMetaData'; purpose: 'PerformanceAndHealth'; comment: 'The heaviest call trace into this sample annotated with respective costs' };\n\tsource: { classification: 'SystemMetaData'; purpose: 'PerformanceAndHealth'; comment: 'The source - either renderer or an extension' };\n};\n\nexport interface SampleData {\n\tperfBaseline: number;\n\tsample: BottomUpSample;\n\tsource: string;\n}\n\nexport function reportSample(data: SampleData, telemetryService: ITelemetryService, logService: ILogService, sendAsErrorTelemtry: boolean): void {\n\n\tconst { sample, perfBaseline, source } = data;\n\n\t// send telemetry event\n\ttelemetryService.publicLog2<TelemetrySampleData, TelemetrySampleDataClassification>(`unresponsive.sample`, {\n\t\tperfBaseline,\n\t\tselfTime: sample.selfTime,\n\t\ttotalTime: sample.totalTime,\n\t\tpercentage: sample.percentage,\n\t\tfunctionName: sample.location,\n\t\tcallers: sample.caller.map(c => c.location).join('<'),\n\t\tcallersAnnotated: sample.caller.map(c => `${c.percentage}|${c.location}`).join('<'),\n\t\tsource\n\t});\n\n\t// log a fake error with a clearer stack\n\tconst fakeError = new PerformanceError(data);\n\tif (sendAsErrorTelemtry) {\n\t\terrorHandler.onUnexpectedError(fakeError);\n\t} else {\n\t\tlogService.error(fakeError);\n\t}\n}\n\nclass PerformanceError extends Error {\n\treadonly selfTime: number;\n\n\tconstructor(data: SampleData) {\n\t\tsuper(`PerfSampleError: by ${data.source} in ${data.sample.location}`);\n\t\tthis.name = 'PerfSampleError';\n\t\tthis.selfTime = data.sample.selfTime;\n\n\t\tconst trace = [data.sample.absLocation, ...data.sample.caller.map(c => c.absLocation)];\n\t\tthis.stack = `\\n\\t at ${trace.join('\\n\\t at ')}`;\n\t}\n}\n"]}