{"version":3,"sources":["file:///workspace/appflow/src/vs/platform/terminal/common/terminal.ts"],"names":[],"mappings":"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","file":"terminal.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event } from 'vs/base/common/event';\nimport { IProcessEnvironment, OperatingSystem } from 'vs/base/common/platform';\nimport { URI, UriComponents } from 'vs/base/common/uri';\nimport { createDecorator } from 'vs/platform/instantiation/common/instantiation';\nimport { IPtyHostProcessReplayEvent, ISerializedCommandDetectionCapability, ITerminalCapabilityStore } from 'vs/platform/terminal/common/capabilities/capabilities';\nimport { IGetTerminalLayoutInfoArgs, IProcessDetails, ISetTerminalLayoutInfoArgs } from 'vs/platform/terminal/common/terminalProcess';\nimport { ThemeIcon } from 'vs/base/common/themables';\nimport { ISerializableEnvironmentVariableCollections } from 'vs/platform/terminal/common/environmentVariable';\nimport { RawContextKey } from 'vs/platform/contextkey/common/contextkey';\nimport { IWorkspaceFolder } from 'vs/platform/workspace/common/workspace';\nimport { Registry } from 'vs/platform/registry/common/platform';\nimport type * as performance from 'vs/base/common/performance';\nimport { ILogService } from 'vs/platform/log/common/log';\n\nexport const terminalTabFocusModeContextKey = new RawContextKey<boolean>('terminalTabFocusMode', false, true);\n\nexport const enum TerminalSettingPrefix {\n\tDefaultProfile = 'terminal.integrated.defaultProfile.',\n\tProfiles = 'terminal.integrated.profiles.'\n}\n\nexport const enum TerminalSettingId {\n\tSendKeybindingsToShell = 'terminal.integrated.sendKeybindingsToShell',\n\tAutomationProfileLinux = 'terminal.integrated.automationProfile.linux',\n\tAutomationProfileMacOs = 'terminal.integrated.automationProfile.osx',\n\tAutomationProfileWindows = 'terminal.integrated.automationProfile.windows',\n\tProfilesWindows = 'terminal.integrated.profiles.windows',\n\tProfilesMacOs = 'terminal.integrated.profiles.osx',\n\tProfilesLinux = 'terminal.integrated.profiles.linux',\n\tDefaultProfileLinux = 'terminal.integrated.defaultProfile.linux',\n\tDefaultProfileMacOs = 'terminal.integrated.defaultProfile.osx',\n\tDefaultProfileWindows = 'terminal.integrated.defaultProfile.windows',\n\tUseWslProfiles = 'terminal.integrated.useWslProfiles',\n\tTabsDefaultColor = 'terminal.integrated.tabs.defaultColor',\n\tTabsDefaultIcon = 'terminal.integrated.tabs.defaultIcon',\n\tTabsEnabled = 'terminal.integrated.tabs.enabled',\n\tTabsEnableAnimation = 'terminal.integrated.tabs.enableAnimation',\n\tTabsHideCondition = 'terminal.integrated.tabs.hideCondition',\n\tTabsShowActiveTerminal = 'terminal.integrated.tabs.showActiveTerminal',\n\tTabsShowActions = 'terminal.integrated.tabs.showActions',\n\tTabsLocation = 'terminal.integrated.tabs.location',\n\tTabsFocusMode = 'terminal.integrated.tabs.focusMode',\n\tMacOptionIsMeta = 'terminal.integrated.macOptionIsMeta',\n\tMacOptionClickForcesSelection = 'terminal.integrated.macOptionClickForcesSelection',\n\tAltClickMovesCursor = 'terminal.integrated.altClickMovesCursor',\n\tCopyOnSelection = 'terminal.integrated.copyOnSelection',\n\tEnableMultiLinePasteWarning = 'terminal.integrated.enableMultiLinePasteWarning',\n\tDrawBoldTextInBrightColors = 'terminal.integrated.drawBoldTextInBrightColors',\n\tFontFamily = 'terminal.integrated.fontFamily',\n\tFontSize = 'terminal.integrated.fontSize',\n\tLetterSpacing = 'terminal.integrated.letterSpacing',\n\tLineHeight = 'terminal.integrated.lineHeight',\n\tMinimumContrastRatio = 'terminal.integrated.minimumContrastRatio',\n\tTabStopWidth = 'terminal.integrated.tabStopWidth',\n\tFastScrollSensitivity = 'terminal.integrated.fastScrollSensitivity',\n\tMouseWheelScrollSensitivity = 'terminal.integrated.mouseWheelScrollSensitivity',\n\tBellDuration = 'terminal.integrated.bellDuration',\n\tFontWeight = 'terminal.integrated.fontWeight',\n\tFontWeightBold = 'terminal.integrated.fontWeightBold',\n\tCursorBlinking = 'terminal.integrated.cursorBlinking',\n\tCursorStyle = 'terminal.integrated.cursorStyle',\n\tCursorStyleInactive = 'terminal.integrated.cursorStyleInactive',\n\tCursorWidth = 'terminal.integrated.cursorWidth',\n\tScrollback = 'terminal.integrated.scrollback',\n\tDetectLocale = 'terminal.integrated.detectLocale',\n\tDefaultLocation = 'terminal.integrated.defaultLocation',\n\tGpuAcceleration = 'terminal.integrated.gpuAcceleration',\n\tTerminalTitleSeparator = 'terminal.integrated.tabs.separator',\n\tTerminalTitle = 'terminal.integrated.tabs.title',\n\tTerminalDescription = 'terminal.integrated.tabs.description',\n\tRightClickBehavior = 'terminal.integrated.rightClickBehavior',\n\tCwd = 'terminal.integrated.cwd',\n\tConfirmOnExit = 'terminal.integrated.confirmOnExit',\n\tConfirmOnKill = 'terminal.integrated.confirmOnKill',\n\tEnableBell = 'terminal.integrated.enableBell',\n\tCommandsToSkipShell = 'terminal.integrated.commandsToSkipShell',\n\tAllowChords = 'terminal.integrated.allowChords',\n\tAllowMnemonics = 'terminal.integrated.allowMnemonics',\n\tTabFocusMode = 'terminal.integrated.tabFocusMode',\n\tEnvMacOs = 'terminal.integrated.env.osx',\n\tEnvLinux = 'terminal.integrated.env.linux',\n\tEnvWindows = 'terminal.integrated.env.windows',\n\tEnvironmentChangesIndicator = 'terminal.integrated.environmentChangesIndicator',\n\tEnvironmentChangesRelaunch = 'terminal.integrated.environmentChangesRelaunch',\n\tShowExitAlert = 'terminal.integrated.showExitAlert',\n\tSplitCwd = 'terminal.integrated.splitCwd',\n\tWindowsEnableConpty = 'terminal.integrated.windowsEnableConpty',\n\tWordSeparators = 'terminal.integrated.wordSeparators',\n\tEnableFileLinks = 'terminal.integrated.enableFileLinks',\n\tUnicodeVersion = 'terminal.integrated.unicodeVersion',\n\tLocalEchoLatencyThreshold = 'terminal.integrated.localEchoLatencyThreshold',\n\tLocalEchoEnabled = 'terminal.integrated.localEchoEnabled',\n\tLocalEchoExcludePrograms = 'terminal.integrated.localEchoExcludePrograms',\n\tLocalEchoStyle = 'terminal.integrated.localEchoStyle',\n\tEnablePersistentSessions = 'terminal.integrated.enablePersistentSessions',\n\tPersistentSessionReviveProcess = 'terminal.integrated.persistentSessionReviveProcess',\n\tHideOnStartup = 'terminal.integrated.hideOnStartup',\n\tCustomGlyphs = 'terminal.integrated.customGlyphs',\n\tPersistentSessionScrollback = 'terminal.integrated.persistentSessionScrollback',\n\tInheritEnv = 'terminal.integrated.inheritEnv',\n\tShowLinkHover = 'terminal.integrated.showLinkHover',\n\tIgnoreProcessNames = 'terminal.integrated.ignoreProcessNames',\n\tAutoReplies = 'terminal.integrated.autoReplies',\n\tShellIntegrationEnabled = 'terminal.integrated.shellIntegration.enabled',\n\tShellIntegrationShowWelcome = 'terminal.integrated.shellIntegration.showWelcome',\n\tShellIntegrationDecorationsEnabled = 'terminal.integrated.shellIntegration.decorationsEnabled',\n\tShellIntegrationCommandHistory = 'terminal.integrated.shellIntegration.history',\n\tShellIntegrationSuggestEnabled = 'terminal.integrated.shellIntegration.suggestEnabled',\n\tEnableImages = 'terminal.integrated.enableImages',\n\tSmoothScrolling = 'terminal.integrated.smoothScrolling',\n\tIgnoreBracketedPasteMode = 'terminal.integrated.ignoreBracketedPasteMode',\n\tFocusAfterRun = 'terminal.integrated.focusAfterRun',\n\n\t// Debug settings that are hidden from user\n\n\t/** Simulated latency applied to all calls made to the pty host */\n\tDeveloperPtyHostLatency = 'terminal.integrated.developer.ptyHost.latency',\n\t/** Simulated startup delay of the pty host process */\n\tDeveloperPtyHostStartupDelay = 'terminal.integrated.developer.ptyHost.startupDelay',\n\t/** Shows the textarea element */\n\tDevMode = 'terminal.integrated.developer.devMode'\n}\n\nexport const enum PosixShellType {\n\tPowerShell = 'pwsh',\n\tBash = 'bash',\n\tFish = 'fish',\n\tSh = 'sh',\n\tCsh = 'csh',\n\tKsh = 'ksh',\n\tZsh = 'zsh',\n}\nexport const enum WindowsShellType {\n\tCommandPrompt = 'cmd',\n\tPowerShell = 'pwsh',\n\tWsl = 'wsl',\n\tGitBash = 'gitbash'\n}\nexport type TerminalShellType = PosixShellType | WindowsShellType;\n\nexport interface IRawTerminalInstanceLayoutInfo<T> {\n\trelativeSize: number;\n\tterminal: T;\n}\nexport type ITerminalInstanceLayoutInfoById = IRawTerminalInstanceLayoutInfo<number>;\nexport type ITerminalInstanceLayoutInfo = IRawTerminalInstanceLayoutInfo<IPtyHostAttachTarget>;\n\nexport interface IRawTerminalTabLayoutInfo<T> {\n\tisActive: boolean;\n\tactivePersistentProcessId: number | undefined;\n\tterminals: IRawTerminalInstanceLayoutInfo<T>[];\n}\n\nexport type ITerminalTabLayoutInfoById = IRawTerminalTabLayoutInfo<number>;\n\nexport interface IRawTerminalsLayoutInfo<T> {\n\ttabs: IRawTerminalTabLayoutInfo<T>[];\n}\n\nexport interface IPtyHostAttachTarget {\n\tid: number;\n\tpid: number;\n\ttitle: string;\n\ttitleSource: TitleEventSource;\n\tcwd: string;\n\tworkspaceId: string;\n\tworkspaceName: string;\n\tisOrphan: boolean;\n\ticon: TerminalIcon | undefined;\n\tfixedDimensions: IFixedTerminalDimensions | undefined;\n\tenvironmentVariableCollections: ISerializableEnvironmentVariableCollections | undefined;\n\treconnectionProperties?: IReconnectionProperties;\n\twaitOnExit?: WaitOnExitValue;\n\thideFromUser?: boolean;\n\tisFeatureTerminal?: boolean;\n\ttype?: TerminalType;\n\thasChildProcesses: boolean;\n\tshellIntegrationNonce: string;\n}\n\nexport interface IReconnectionProperties {\n\townerId: string;\n\tdata?: unknown;\n}\n\nexport type TerminalType = 'Task' | 'Local' | undefined;\n\nexport enum TitleEventSource {\n\t/** From the API or the rename command that overrides any other type */\n\tApi,\n\t/** From the process name property*/\n\tProcess,\n\t/** From the VT sequence */\n\tSequence,\n\t/** Config changed */\n\tConfig\n}\n\nexport type ITerminalsLayoutInfo = IRawTerminalsLayoutInfo<IPtyHostAttachTarget | null>;\nexport type ITerminalsLayoutInfoById = IRawTerminalsLayoutInfo<number>;\n\nexport enum TerminalIpcChannels {\n\t/**\n\t * Communicates between the renderer process and shared process.\n\t */\n\tLocalPty = 'localPty',\n\t/**\n\t * Communicates between the shared process and the pty host process.\n\t */\n\tPtyHost = 'ptyHost',\n\t/**\n\t * Communicates between the renderer process and the pty host process.\n\t */\n\tPtyHostWindow = 'ptyHostWindow',\n\t/**\n\t * Deals with logging from the pty host process.\n\t */\n\tLogger = 'logger',\n\t/**\n\t * Enables the detection of unresponsive pty hosts.\n\t */\n\tHeartbeat = 'heartbeat'\n}\n\nexport const enum ProcessPropertyType {\n\tCwd = 'cwd',\n\tInitialCwd = 'initialCwd',\n\tFixedDimensions = 'fixedDimensions',\n\tTitle = 'title',\n\tShellType = 'shellType',\n\tHasChildProcesses = 'hasChildProcesses',\n\tResolvedShellLaunchConfig = 'resolvedShellLaunchConfig',\n\tOverrideDimensions = 'overrideDimensions',\n\tFailedShellIntegrationActivation = 'failedShellIntegrationActivation',\n\tUsedShellIntegrationInjection = 'usedShellIntegrationInjection'\n}\n\nexport interface IProcessProperty<T extends ProcessPropertyType> {\n\ttype: T;\n\tvalue: IProcessPropertyMap[T];\n}\n\nexport interface IProcessPropertyMap {\n\t[ProcessPropertyType.Cwd]: string;\n\t[ProcessPropertyType.InitialCwd]: string;\n\t[ProcessPropertyType.FixedDimensions]: IFixedTerminalDimensions;\n\t[ProcessPropertyType.Title]: string;\n\t[ProcessPropertyType.ShellType]: TerminalShellType | undefined;\n\t[ProcessPropertyType.HasChildProcesses]: boolean;\n\t[ProcessPropertyType.ResolvedShellLaunchConfig]: IShellLaunchConfig;\n\t[ProcessPropertyType.OverrideDimensions]: ITerminalDimensionsOverride | undefined;\n\t[ProcessPropertyType.FailedShellIntegrationActivation]: boolean | undefined;\n\t[ProcessPropertyType.UsedShellIntegrationInjection]: boolean | undefined;\n}\n\nexport interface IFixedTerminalDimensions {\n\t/**\n\t * The fixed columns of the terminal.\n\t */\n\tcols?: number;\n\n\t/**\n\t * The fixed rows of the terminal.\n\t */\n\trows?: number;\n}\n\n/**\n * A service that communicates with a pty host.\n*/\nexport interface IPtyService {\n\treadonly _serviceBrand: undefined;\n\n\treadonly onProcessData: Event<{ id: number; event: IProcessDataEvent | string }>;\n\treadonly onProcessReady: Event<{ id: number; event: IProcessReadyEvent }>;\n\treadonly onProcessReplay: Event<{ id: number; event: IPtyHostProcessReplayEvent }>;\n\treadonly onProcessOrphanQuestion: Event<{ id: number }>;\n\treadonly onDidRequestDetach: Event<{ requestId: number; workspaceId: string; instanceId: number }>;\n\treadonly onDidChangeProperty: Event<{ id: number; property: IProcessProperty<any> }>;\n\treadonly onProcessExit: Event<{ id: number; event: number | undefined }>;\n\n\tcreateProcess(\n\t\tshellLaunchConfig: IShellLaunchConfig,\n\t\tcwd: string,\n\t\tcols: number,\n\t\trows: number,\n\t\tunicodeVersion: '6' | '11',\n\t\tenv: IProcessEnvironment,\n\t\texecutableEnv: IProcessEnvironment,\n\t\toptions: ITerminalProcessOptions,\n\t\tshouldPersist: boolean,\n\t\tworkspaceId: string,\n\t\tworkspaceName: string\n\t): Promise<number>;\n\tattachToProcess(id: number): Promise<void>;\n\tdetachFromProcess(id: number, forcePersist?: boolean): Promise<void>;\n\tshutdownAll(): Promise<void>;\n\n\t/**\n\t * Lists all orphaned processes, ie. those without a connected frontend.\n\t */\n\tlistProcesses(): Promise<IProcessDetails[]>;\n\tgetPerformanceMarks(): Promise<performance.PerformanceMark[]>;\n\t/**\n\t * Measures and returns the latency of the current and all other processes to the pty host.\n\t */\n\tgetLatency(): Promise<IPtyHostLatencyMeasurement[]>;\n\n\tstart(id: number): Promise<ITerminalLaunchError | { injectedArgs: string[] } | undefined>;\n\tshutdown(id: number, immediate: boolean): Promise<void>;\n\tinput(id: number, data: string): Promise<void>;\n\tresize(id: number, cols: number, rows: number): Promise<void>;\n\tclearBuffer(id: number): Promise<void>;\n\tgetInitialCwd(id: number): Promise<string>;\n\tgetCwd(id: number): Promise<string>;\n\tacknowledgeDataEvent(id: number, charCount: number): Promise<void>;\n\tsetUnicodeVersion(id: number, version: '6' | '11'): Promise<void>;\n\tprocessBinary(id: number, data: string): Promise<void>;\n\t/** Confirm the process is _not_ an orphan. */\n\torphanQuestionReply(id: number): Promise<void>;\n\tupdateTitle(id: number, title: string, titleSource: TitleEventSource): Promise<void>;\n\tupdateIcon(id: number, userInitiated: boolean, icon: TerminalIcon, color?: string): Promise<void>;\n\n\tinstallAutoReply(match: string, reply: string): Promise<void>;\n\tuninstallAllAutoReplies(): Promise<void>;\n\tuninstallAutoReply(match: string): Promise<void>;\n\tgetDefaultSystemShell(osOverride?: OperatingSystem): Promise<string>;\n\tgetEnvironment(): Promise<IProcessEnvironment>;\n\tgetWslPath(original: string, direction: 'unix-to-win' | 'win-to-unix'): Promise<string>;\n\tgetRevivedPtyNewId(workspaceId: string, id: number): Promise<number | undefined>;\n\tsetTerminalLayoutInfo(args: ISetTerminalLayoutInfoArgs): Promise<void>;\n\tgetTerminalLayoutInfo(args: IGetTerminalLayoutInfoArgs): Promise<ITerminalsLayoutInfo | undefined>;\n\treduceConnectionGraceTime(): Promise<void>;\n\trequestDetachInstance(workspaceId: string, instanceId: number): Promise<IProcessDetails | undefined>;\n\tacceptDetachInstanceReply(requestId: number, persistentProcessId?: number): Promise<void>;\n\tfreePortKillProcess(port: string): Promise<{ port: string; processId: string }>;\n\t/**\n\t * Serializes and returns terminal state.\n\t * @param ids The persistent terminal IDs to serialize.\n\t */\n\tserializeTerminalState(ids: number[]): Promise<string>;\n\t/**\n\t * Revives a workspaces terminal processes, these can then be reconnected to using the normal\n\t * flow for restoring terminals after reloading.\n\t */\n\treviveTerminalProcesses(workspaceId: string, state: ISerializedTerminalState[], dateTimeFormatLocate: string): Promise<void>;\n\trefreshProperty<T extends ProcessPropertyType>(id: number, property: T): Promise<IProcessPropertyMap[T]>;\n\tupdateProperty<T extends ProcessPropertyType>(id: number, property: T, value: IProcessPropertyMap[T]): Promise<void>;\n\n\t// TODO: Make mandatory and remove impl from pty host service\n\trefreshIgnoreProcessNames?(names: string[]): Promise<void>;\n}\nexport const IPtyService = createDecorator<IPtyService>('ptyService');\n\nexport interface IPtyHostController {\n\treadonly onPtyHostExit: Event<number>;\n\treadonly onPtyHostStart: Event<void>;\n\treadonly onPtyHostUnresponsive: Event<void>;\n\treadonly onPtyHostResponsive: Event<void>;\n\treadonly onPtyHostRequestResolveVariables: Event<IRequestResolveVariablesEvent>;\n\n\trestartPtyHost(): Promise<void>;\n\tacceptPtyHostResolvedVariables(requestId: number, resolved: string[]): Promise<void>;\n\tgetProfiles(workspaceId: string, profiles: unknown, defaultProfile: unknown, includeDetectedProfiles?: boolean): Promise<ITerminalProfile[]>;\n}\n\n/**\n * A service that communicates with a pty host controller (eg. main or server\n * process) and is able to launch and forward requests to the pty host.\n*/\nexport interface IPtyHostService extends IPtyService, IPtyHostController {\n}\n\nexport interface IPtyHostLatencyMeasurement {\n\tlabel: string;\n\tlatency: number;\n}\n\n/**\n * Serialized terminal state matching the interface that can be used across versions, the version\n * should be verified before using the state payload.\n */\nexport interface ICrossVersionSerializedTerminalState {\n\tversion: number;\n\tstate: unknown;\n}\n\nexport interface ISerializedTerminalState {\n\tid: number;\n\tshellLaunchConfig: IShellLaunchConfig;\n\tprocessDetails: IProcessDetails;\n\tprocessLaunchConfig: IPersistentTerminalProcessLaunchConfig;\n\tunicodeVersion: '6' | '11';\n\treplayEvent: IPtyHostProcessReplayEvent;\n\ttimestamp: number;\n}\n\nexport interface IPersistentTerminalProcessLaunchConfig {\n\tenv: IProcessEnvironment;\n\texecutableEnv: IProcessEnvironment;\n\toptions: ITerminalProcessOptions;\n}\n\nexport interface IRequestResolveVariablesEvent {\n\trequestId: number;\n\tworkspaceId: string;\n\toriginalText: string[];\n}\n\nexport enum HeartbeatConstants {\n\t/**\n\t * The duration between heartbeats\n\t */\n\tBeatInterval = 5000,\n\t/**\n\t * The duration of the first heartbeat while the pty host is starting up. This is much larger\n\t * than the regular BeatInterval to accomodate slow machines, we still want to warn about the\n\t * pty host's unresponsiveness eventually though.\n\t */\n\tConnectingBeatInterval = 20000,\n\t/**\n\t * Defines a multiplier for BeatInterval for how long to wait before starting the second wait\n\t * timer.\n\t */\n\tFirstWaitMultiplier = 1.2,\n\t/**\n\t * Defines a multiplier for BeatInterval for how long to wait before telling the user about\n\t * non-responsiveness. The second timer is to avoid informing the user incorrectly when waking\n\t * the computer up from sleep\n\t */\n\tSecondWaitMultiplier = 1,\n\t/**\n\t * How long to wait before telling the user about non-responsiveness when they try to create a\n\t * process. This short circuits the standard wait timeouts to tell the user sooner and only\n\t * create process is handled to avoid additional perf overhead.\n\t */\n\tCreateProcessTimeout = 5000\n}\n\nexport interface IHeartbeatService {\n\treadonly onBeat: Event<void>;\n}\n\n\nexport interface IShellLaunchConfig {\n\t/**\n\t * The name of the terminal, if this is not set the name of the process will be used.\n\t */\n\tname?: string;\n\n\t/**\n\t * A string to follow the name of the terminal with, indicating the type of terminal\n\t */\n\ttype?: 'Task' | 'Local';\n\n\t/**\n\t * The shell executable (bash, cmd, etc.).\n\t */\n\texecutable?: string;\n\n\t/**\n\t * The CLI arguments to use with executable, a string[] is in argv format and will be escaped,\n\t * a string is in \"CommandLine\" pre-escaped format and will be used as is. The string option is\n\t * only supported on Windows and will throw an exception if used on macOS or Linux.\n\t */\n\targs?: string[] | string;\n\n\t/**\n\t * The current working directory of the terminal, this overrides the `terminal.integrated.cwd`\n\t * settings key.\n\t */\n\tcwd?: string | URI;\n\n\t/**\n\t * A custom environment for the terminal, if this is not set the environment will be inherited\n\t * from the VS Code process.\n\t */\n\tenv?: ITerminalEnvironment;\n\n\t/**\n\t * Whether to ignore a custom cwd from the `terminal.integrated.cwd` settings key (e.g. if the\n\t * shell is being launched by an extension).\n\t */\n\tignoreConfigurationCwd?: boolean;\n\n\t/**\n\t * The reconnection properties for this terminal\n\t */\n\treconnectionProperties?: IReconnectionProperties;\n\n\t/** Whether to wait for a key press before closing the terminal. */\n\twaitOnExit?: WaitOnExitValue;\n\n\t/**\n\t * A string including ANSI escape sequences that will be written to the terminal emulator\n\t * _before_ the terminal process has launched, when a string is specified, a trailing \\n is\n\t * added at the end. This allows for example the terminal instance to display a styled message\n\t * as the first line of the terminal. Use \\x1b over \\033 or \\e for the escape control character.\n\t */\n\tinitialText?: string | { text: string; trailingNewLine: boolean };\n\n\t/**\n\t * Custom PTY/pseudoterminal process to use.\n\t */\n\tcustomPtyImplementation?: (terminalId: number, cols: number, rows: number) => ITerminalChildProcess;\n\n\t/**\n\t * A UUID generated by the extension host process for terminals created on the extension host process.\n\t */\n\textHostTerminalId?: string;\n\n\t/**\n\t * This is a terminal that attaches to an already running terminal.\n\t */\n\tattachPersistentProcess?: {\n\t\tid: number;\n\t\tfindRevivedId?: boolean;\n\t\tpid: number;\n\t\ttitle: string;\n\t\ttitleSource: TitleEventSource;\n\t\tcwd: string;\n\t\ticon?: TerminalIcon;\n\t\tcolor?: string;\n\t\thasChildProcesses?: boolean;\n\t\tfixedDimensions?: IFixedTerminalDimensions;\n\t\tenvironmentVariableCollections?: ISerializableEnvironmentVariableCollections;\n\t\treconnectionProperties?: IReconnectionProperties;\n\t\ttype?: TerminalType;\n\t\twaitOnExit?: WaitOnExitValue;\n\t\thideFromUser?: boolean;\n\t\tisFeatureTerminal?: boolean;\n\t\tshellIntegrationNonce: string;\n\t};\n\n\t/**\n\t * Whether the terminal process environment should be exactly as provided in\n\t * `TerminalOptions.env`. When this is false (default), the environment will be based on the\n\t * window's environment and also apply configured platform settings like\n\t * `terminal.integrated.env.windows` on top. When this is true, the complete environment must be\n\t * provided as nothing will be inherited from the process or any configuration.\n\t */\n\tstrictEnv?: boolean;\n\n\t/**\n\t * Whether the terminal process environment will inherit VS Code's \"shell environment\" that may\n\t * get sourced from running a login shell depnding on how the application was launched.\n\t * Consumers that rely on development tools being present in the $PATH should set this to true.\n\t * This will overwrite the value of the inheritEnv setting.\n\t */\n\tuseShellEnvironment?: boolean;\n\n\t/**\n\t * When enabled the terminal will run the process as normal but not be surfaced to the user\n\t * until `Terminal.show` is called. The typical usage for this is when you need to run\n\t * something that may need interactivity but only want to tell the user about it when\n\t * interaction is needed. Note that the terminals will still be exposed to all extensions\n\t * as normal.\n\t */\n\thideFromUser?: boolean;\n\n\t/**\n\t * Whether this terminal is not a terminal that the user directly created and uses, but rather\n\t * a terminal used to drive some VS Code feature.\n\t */\n\tisFeatureTerminal?: boolean;\n\n\t/**\n\t * Whether this terminal was created by an extension.\n\t */\n\tisExtensionOwnedTerminal?: boolean;\n\n\t/**\n\t * The icon for the terminal, used primarily in the terminal tab.\n\t */\n\ticon?: TerminalIcon;\n\n\t/**\n\t * The color ID to use for this terminal. If not specified it will use the default fallback\n\t */\n\tcolor?: string;\n\n\t/**\n\t * When a parent terminal is provided via API, the group needs\n\t * to find the index in order to place the child\n\t * directly to the right of its parent.\n\t */\n\tparentTerminalId?: number;\n\n\t/**\n\t * The dimensions for the instance as set by the user\n\t * or via Size to Content Width\n\t */\n\tfixedDimensions?: IFixedTerminalDimensions;\n\n\t/**\n\t * Opt-out of the default terminal persistence on restart and reload\n\t */\n\tisTransient?: boolean;\n\n\t/**\n\t * Create a terminal without shell integration even when it's enabled\n\t */\n\tignoreShellIntegration?: boolean;\n}\n\nexport type WaitOnExitValue = boolean | string | ((exitCode: number) => string);\n\nexport interface ICreateContributedTerminalProfileOptions {\n\ticon?: URI | string | { light: URI; dark: URI };\n\tcolor?: string;\n\tlocation?: TerminalLocation | { viewColumn: number; preserveState?: boolean } | { splitActiveTerminal: boolean };\n}\n\nexport enum TerminalLocation {\n\tPanel = 1,\n\tEditor = 2\n}\n\nexport const enum TerminalLocationString {\n\tTerminalView = 'view',\n\tEditor = 'editor'\n}\n\nexport type TerminalIcon = ThemeIcon | URI | { light: URI; dark: URI };\n\nexport interface IShellLaunchConfigDto {\n\tname?: string;\n\texecutable?: string;\n\targs?: string[] | string;\n\tcwd?: string | UriComponents;\n\tenv?: ITerminalEnvironment;\n\tuseShellEnvironment?: boolean;\n\thideFromUser?: boolean;\n\treconnectionProperties?: IReconnectionProperties;\n\ttype?: 'Task' | 'Local';\n\tisFeatureTerminal?: boolean;\n}\n\n/**\n * A set of options for the terminal process. These differ from the shell launch config in that they\n * are set internally to the terminal component, not from the outside.\n */\nexport interface ITerminalProcessOptions {\n\tshellIntegration: {\n\t\tenabled: boolean;\n\t\tsuggestEnabled: boolean;\n\t\tnonce: string;\n\t};\n\twindowsEnableConpty: boolean;\n\tenvironmentVariableCollections: ISerializableEnvironmentVariableCollections | undefined;\n\tworkspaceFolder: IWorkspaceFolder | undefined;\n}\n\nexport interface ITerminalEnvironment {\n\t[key: string]: string | null | undefined;\n}\n\nexport interface ITerminalLaunchError {\n\tmessage: string;\n\tcode?: number;\n}\n\nexport interface IProcessReadyEvent {\n\tpid: number;\n\tcwd: string;\n\twindowsPty: IProcessReadyWindowsPty | undefined;\n}\n\nexport interface IProcessReadyWindowsPty {\n\t/**\n\t * What pty emulation backend is being used.\n\t */\n\tbackend: 'conpty' | 'winpty';\n\t/**\n\t * The Windows build version (eg. 19045)\n\t */\n\tbuildNumber: number;\n}\n\n/**\n * An interface representing a raw terminal child process, this contains a subset of the\n * child_process.ChildProcess node.js interface.\n */\nexport interface ITerminalChildProcess {\n\t/**\n\t * A unique identifier for the terminal process. Note that the uniqueness only applies to a\n\t * given pty service connection, IDs will be duplicated for remote and local terminals for\n\t * example. The ID will be 0 if it does not support reconnection.\n\t */\n\tid: number;\n\n\t/**\n\t * Whether the process should be persisted across reloads.\n\t */\n\tshouldPersist: boolean;\n\n\tonProcessData: Event<IProcessDataEvent | string>;\n\tonProcessReady: Event<IProcessReadyEvent>;\n\tonProcessReplayComplete?: Event<void>;\n\tonDidChangeProperty: Event<IProcessProperty<any>>;\n\tonProcessExit: Event<number | undefined>;\n\tonRestoreCommands?: Event<ISerializedCommandDetectionCapability>;\n\n\t/**\n\t * Starts the process.\n\t *\n\t * @returns undefined when the process was successfully started, otherwise an object containing\n\t * information on what went wrong.\n\t */\n\tstart(): Promise<ITerminalLaunchError | { injectedArgs: string[] } | undefined>;\n\n\t/**\n\t * Detach the process from the UI and await reconnect.\n\t * @param forcePersist Whether to force the process to persist if it supports persistence.\n\t */\n\tdetach?(forcePersist?: boolean): Promise<void>;\n\n\t/**\n\t * Frees the port and kills the process\n\t */\n\tfreePortKillProcess?(port: string): Promise<{ port: string; processId: string }>;\n\n\t/**\n\t * Shutdown the terminal process.\n\t *\n\t * @param immediate When true the process will be killed immediately, otherwise the process will\n\t * be given some time to make sure no additional data comes through.\n\t */\n\tshutdown(immediate: boolean): void;\n\tinput(data: string): void;\n\tprocessBinary(data: string): Promise<void>;\n\tresize(cols: number, rows: number): void;\n\tclearBuffer(): void | Promise<void>;\n\n\t/**\n\t * Acknowledge a data event has been parsed by the terminal, this is used to implement flow\n\t * control to ensure remote processes to not get too far ahead of the client and flood the\n\t * connection.\n\t * @param charCount The number of characters being acknowledged.\n\t */\n\tacknowledgeDataEvent(charCount: number): void;\n\n\t/**\n\t * Sets the unicode version for the process, this drives the size of some characters in the\n\t * xterm-headless instance.\n\t */\n\tsetUnicodeVersion(version: '6' | '11'): Promise<void>;\n\n\tgetInitialCwd(): Promise<string>;\n\tgetCwd(): Promise<string>;\n\trefreshProperty<T extends ProcessPropertyType>(property: T): Promise<IProcessPropertyMap[T]>;\n\tupdateProperty<T extends ProcessPropertyType>(property: T, value: IProcessPropertyMap[T]): Promise<void>;\n}\n\nexport interface IReconnectConstants {\n\tgraceTime: number;\n\tshortGraceTime: number;\n\tscrollback: number;\n}\n\nexport const enum LocalReconnectConstants {\n\t/**\n\t * If there is no reconnection within this time-frame, consider the connection permanently closed...\n\t*/\n\tGraceTime = 60000, // 60 seconds\n\t/**\n\t * Maximal grace time between the first and the last reconnection...\n\t*/\n\tShortGraceTime = 6000, // 6 seconds\n}\n\nexport const enum FlowControlConstants {\n\t/**\n\t * The number of _unacknowledged_ chars to have been sent before the pty is paused in order for\n\t * the client to catch up.\n\t */\n\tHighWatermarkChars = 100000,\n\t/**\n\t * After flow control pauses the pty for the client the catch up, this is the number of\n\t * _unacknowledged_ chars to have been caught up to on the client before resuming the pty again.\n\t * This is used to attempt to prevent pauses in the flowing data; ideally while the pty is\n\t * paused the number of unacknowledged chars would always be greater than 0 or the client will\n\t * appear to stutter. In reality this balance is hard to accomplish though so heavy commands\n\t * will likely pause as latency grows, not flooding the connection is the important thing as\n\t * it's shared with other core functionality.\n\t */\n\tLowWatermarkChars = 5000,\n\t/**\n\t * The number characters that are accumulated on the client side before sending an ack event.\n\t * This must be less than or equal to LowWatermarkChars or the terminal max never unpause.\n\t */\n\tCharCountAckSize = 5000\n}\n\nexport interface IProcessDataEvent {\n\tdata: string;\n\ttrackCommit: boolean;\n\t/**\n\t * When trackCommit is set, this will be set to a promise that resolves when the data is parsed.\n\t */\n\twritePromise?: Promise<void>;\n}\n\nexport interface ITerminalDimensions {\n\t/**\n\t * The columns of the terminal.\n\t */\n\tcols: number;\n\n\t/**\n\t * The rows of the terminal.\n\t */\n\trows: number;\n}\n\nexport interface ITerminalProfile {\n\tprofileName: string;\n\tpath: string;\n\tisDefault: boolean;\n\t/**\n\t * Whether the terminal profile contains a potentially unsafe {@link path}. For example, the path\n\t * `C:\\Cygwin` is the default install for Cygwin on Windows, but it could be created by any\n\t * user in a multi-user environment. As such, we don't want to blindly present it as a profile\n\t * without a warning.\n\t */\n\tisUnsafePath?: boolean;\n\t/**\n\t * An additional unsafe path that must exist, for example a script that appears in {@link args}.\n\t */\n\trequiresUnsafePath?: string;\n\tisAutoDetected?: boolean;\n\t/**\n\t * Whether the profile path was found on the `$PATH` environment variable, if so it will be\n\t * cleaner to display this profile in the UI using only `basename(path)`.\n\t */\n\tisFromPath?: boolean;\n\targs?: string | string[] | undefined;\n\tenv?: ITerminalEnvironment;\n\toverrideName?: boolean;\n\tcolor?: string;\n\ticon?: ThemeIcon | URI | { light: URI; dark: URI };\n}\n\nexport interface ITerminalDimensionsOverride extends Readonly<ITerminalDimensions> {\n\t/**\n\t * indicate that xterm must receive these exact dimensions, even if they overflow the ui!\n\t */\n\tforceExactSize?: boolean;\n}\n\nexport const enum ProfileSource {\n\tGitBash = 'Git Bash',\n\tPwsh = 'PowerShell'\n}\n\nexport interface IBaseUnresolvedTerminalProfile {\n\targs?: string | string[] | undefined;\n\tisAutoDetected?: boolean;\n\toverrideName?: boolean;\n\ticon?: string | ThemeIcon | URI | { light: URI; dark: URI };\n\tcolor?: string;\n\tenv?: ITerminalEnvironment;\n\trequiresPath?: string | ITerminalUnsafePath;\n}\n\ntype OneOrN<T> = T | T[];\n\nexport interface ITerminalUnsafePath {\n\tpath: string;\n\tisUnsafe: true;\n}\n\nexport interface ITerminalExecutable extends IBaseUnresolvedTerminalProfile {\n\tpath: OneOrN<string | ITerminalUnsafePath>;\n}\n\nexport interface ITerminalProfileSource extends IBaseUnresolvedTerminalProfile {\n\tsource: ProfileSource;\n}\n\nexport interface ITerminalProfileContribution {\n\ttitle: string;\n\tid: string;\n\ticon?: URI | { light: URI; dark: URI } | string;\n\tcolor?: string;\n}\n\nexport interface IExtensionTerminalProfile extends ITerminalProfileContribution {\n\textensionIdentifier: string;\n}\n\nexport type ITerminalProfileObject = ITerminalExecutable | ITerminalProfileSource | IExtensionTerminalProfile | null;\n\nexport interface IShellIntegration {\n\treadonly capabilities: ITerminalCapabilityStore;\n\treadonly status: ShellIntegrationStatus;\n\n\treadonly onDidChangeStatus: Event<ShellIntegrationStatus>;\n\n\tdeserialize(serialized: ISerializedCommandDetectionCapability): void;\n}\n\nexport interface ITerminalContributions {\n\tprofiles?: ITerminalProfileContribution[];\n}\n\nexport const enum ShellIntegrationStatus {\n\t/** No shell integration sequences have been encountered. */\n\tOff,\n\t/** Final term shell integration sequences have been encountered. */\n\tFinalTerm,\n\t/** VS Code shell integration sequences have been encountered. Supercedes FinalTerm. */\n\tVSCode\n}\n\nexport enum TerminalExitReason {\n\tUnknown = 0,\n\tShutdown = 1,\n\tProcess = 2,\n\tUser = 3,\n\tExtension = 4,\n}\n\nexport interface ITerminalOutputMatch {\n\tregexMatch: RegExpMatchArray;\n\toutputLines: string[];\n}\n\n/**\n * A matcher that runs on a sub-section of a terminal command's output\n */\nexport interface ITerminalOutputMatcher {\n\t/**\n\t * A string or regex to match against the unwrapped line. If this is a regex with the multiline\n\t * flag, it will scan an amount of lines equal to `\\n` instances in the regex + 1.\n\t */\n\tlineMatcher: string | RegExp;\n\t/**\n\t * Which side of the output to anchor the {@link offset} and {@link length} against.\n\t */\n\tanchor: 'top' | 'bottom';\n\t/**\n\t * The number of rows above or below the {@link anchor} to start matching against.\n\t */\n\toffset: number;\n\t/**\n\t * The number of rows to match against, this should be as small as possible for performance\n\t * reasons. This is capped at 40.\n\t */\n\tlength: number;\n\n\t/**\n\t * If multiple matches are expected - this will result in {@link outputLines} being returned\n\t * when there's a {@link regexMatch} from {@link offset} to {@link length}\n\t */\n\tmultipleMatches?: boolean;\n}\n\nexport interface ITerminalCommandSelector {\n\tid: string;\n\tcommandLineMatcher: string | RegExp;\n\toutputMatcher?: ITerminalOutputMatcher;\n\texitStatus: boolean;\n\tcommandExitResult: 'success' | 'error';\n\tkind?: 'fix' | 'explain';\n}\n\nexport interface ITerminalBackend {\n\treadonly remoteAuthority: string | undefined;\n\n\treadonly isResponsive: boolean;\n\n\t/**\n\t * A promise that resolves when the backend is ready to be used, ie. after terminal persistence\n\t * has been actioned.\n\t */\n\treadonly whenReady: Promise<void>;\n\t/**\n\t * Signal to the backend that persistence has been actioned and is ready for use.\n\t */\n\tsetReady(): void;\n\n\t/**\n\t * Fired when the ptyHost process becomes non-responsive, this should disable stdin for all\n\t * terminals using this pty host connection and mark them as disconnected.\n\t */\n\tonPtyHostUnresponsive: Event<void>;\n\t/**\n\t * Fired when the ptyHost process becomes responsive after being non-responsive. Allowing\n\t * previously disconnected terminals to reconnect.\n\t */\n\tonPtyHostResponsive: Event<void>;\n\t/**\n\t * Fired when the ptyHost has been restarted, this is used as a signal for listening terminals\n\t * that its pty has been lost and will remain disconnected.\n\t */\n\tonPtyHostRestart: Event<void>;\n\n\tonDidRequestDetach: Event<{ requestId: number; workspaceId: string; instanceId: number }>;\n\n\tattachToProcess(id: number): Promise<ITerminalChildProcess | undefined>;\n\tattachToRevivedProcess(id: number): Promise<ITerminalChildProcess | undefined>;\n\tlistProcesses(): Promise<IProcessDetails[]>;\n\tgetLatency(): Promise<IPtyHostLatencyMeasurement[]>;\n\tgetDefaultSystemShell(osOverride?: OperatingSystem): Promise<string>;\n\tgetProfiles(profiles: unknown, defaultProfile: unknown, includeDetectedProfiles?: boolean): Promise<ITerminalProfile[]>;\n\tgetWslPath(original: string, direction: 'unix-to-win' | 'win-to-unix'): Promise<string>;\n\tgetEnvironment(): Promise<IProcessEnvironment>;\n\tgetShellEnvironment(): Promise<IProcessEnvironment | undefined>;\n\tsetTerminalLayoutInfo(layoutInfo?: ITerminalsLayoutInfoById): Promise<void>;\n\tupdateTitle(id: number, title: string, titleSource: TitleEventSource): Promise<void>;\n\tupdateIcon(id: number, userInitiated: boolean, icon: TerminalIcon, color?: string): Promise<void>;\n\tgetTerminalLayoutInfo(): Promise<ITerminalsLayoutInfo | undefined>;\n\tgetPerformanceMarks(): Promise<performance.PerformanceMark[]>;\n\treduceConnectionGraceTime(): Promise<void>;\n\trequestDetachInstance(workspaceId: string, instanceId: number): Promise<IProcessDetails | undefined>;\n\tacceptDetachInstanceReply(requestId: number, persistentProcessId?: number): Promise<void>;\n\tpersistTerminalState(): Promise<void>;\n\n\tcreateProcess(\n\t\tshellLaunchConfig: IShellLaunchConfig,\n\t\tcwd: string,\n\t\tcols: number,\n\t\trows: number,\n\t\tunicodeVersion: '6' | '11',\n\t\tenv: IProcessEnvironment,\n\t\toptions: ITerminalProcessOptions,\n\t\tshouldPersist: boolean\n\t): Promise<ITerminalChildProcess>;\n\n\trestartPtyHost(): void;\n}\n\nexport const TerminalExtensions = {\n\tBackend: 'workbench.contributions.terminal.processBackend'\n};\n\nexport interface ITerminalBackendRegistry {\n\t/**\n\t * Gets all backends in the registry.\n\t */\n\tbackends: ReadonlyMap<string, ITerminalBackend>;\n\n\t/**\n\t * Registers a terminal backend for a remote authority.\n\t */\n\tregisterTerminalBackend(backend: ITerminalBackend): void;\n\n\t/**\n\t * Returns the registered terminal backend for a remote authority.\n\t */\n\tgetTerminalBackend(remoteAuthority?: string): ITerminalBackend | undefined;\n}\n\nclass TerminalBackendRegistry implements ITerminalBackendRegistry {\n\tprivate readonly _backends = new Map<string, ITerminalBackend>();\n\n\tget backends(): ReadonlyMap<string, ITerminalBackend> { return this._backends; }\n\n\tregisterTerminalBackend(backend: ITerminalBackend): void {\n\t\tconst key = this._sanitizeRemoteAuthority(backend.remoteAuthority);\n\t\tif (this._backends.has(key)) {\n\t\t\tthrow new Error(`A terminal backend with remote authority '${key}' was already registered.`);\n\t\t}\n\t\tthis._backends.set(key, backend);\n\t}\n\n\tgetTerminalBackend(remoteAuthority: string | undefined): ITerminalBackend | undefined {\n\t\treturn this._backends.get(this._sanitizeRemoteAuthority(remoteAuthority));\n\t}\n\n\tprivate _sanitizeRemoteAuthority(remoteAuthority: string | undefined) {\n\t\t// Normalize the key to lowercase as the authority is case-insensitive\n\t\treturn remoteAuthority?.toLowerCase() ?? '';\n\t}\n}\nRegistry.add(TerminalExtensions.Backend, new TerminalBackendRegistry());\n\nexport const ILocalPtyService = createDecorator<ILocalPtyService>('localPtyService');\n\n/**\n * A service responsible for communicating with the pty host process on Electron.\n *\n * **This service should only be used within the terminal component.**\n */\nexport interface ILocalPtyService extends IPtyHostService { }\n\nexport const ITerminalLogService = createDecorator<ITerminalLogService>('terminalLogService');\nexport interface ITerminalLogService extends ILogService {\n\t/**\n\t * Similar to _serviceBrand but used to differentiate this service at compile time from\n\t * ILogService; ITerminalLogService is an ILogService, but ILogService is not an\n\t * ITerminalLogService.\n\t */\n\treadonly _logBrand: undefined;\n}\n"]}