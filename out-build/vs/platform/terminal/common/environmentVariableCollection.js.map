{"version":3,"sources":["file:///workspace/appflow/src/vs/platform/terminal/common/environmentVariableCollection.ts"],"names":[],"mappings":"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","file":"environmentVariableCollection.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IProcessEnvironment, isWindows } from 'vs/base/common/platform';\nimport { EnvironmentVariableMutatorType, EnvironmentVariableScope, IEnvironmentVariableCollection, IExtensionOwnedEnvironmentDescriptionMutator, IExtensionOwnedEnvironmentVariableMutator, IMergedEnvironmentVariableCollection, IMergedEnvironmentVariableCollectionDiff } from 'vs/platform/terminal/common/environmentVariable';\n\ntype VariableResolver = (str: string) => Promise<string>;\n\nconst mutatorTypeToLabelMap: Map<EnvironmentVariableMutatorType, string> = new Map([\n\t[EnvironmentVariableMutatorType.Append, 'APPEND'],\n\t[EnvironmentVariableMutatorType.Prepend, 'PREPEND'],\n\t[EnvironmentVariableMutatorType.Replace, 'REPLACE']\n]);\n\nexport class MergedEnvironmentVariableCollection implements IMergedEnvironmentVariableCollection {\n\tprivate readonly map: Map<string, IExtensionOwnedEnvironmentVariableMutator[]> = new Map();\n\tprivate readonly descriptionMap: Map<string, IExtensionOwnedEnvironmentDescriptionMutator[]> = new Map();\n\n\tconstructor(\n\t\treadonly collections: ReadonlyMap<string, IEnvironmentVariableCollection>,\n\t) {\n\t\tcollections.forEach((collection, extensionIdentifier) => {\n\t\t\tthis.populateDescriptionMap(collection, extensionIdentifier);\n\t\t\tconst it = collection.map.entries();\n\t\t\tlet next = it.next();\n\t\t\twhile (!next.done) {\n\t\t\t\tconst mutator = next.value[1];\n\t\t\t\tconst key = next.value[0];\n\t\t\t\tlet entry = this.map.get(key);\n\t\t\t\tif (!entry) {\n\t\t\t\t\tentry = [];\n\t\t\t\t\tthis.map.set(key, entry);\n\t\t\t\t}\n\n\t\t\t\t// If the first item in the entry is replace ignore any other entries as they would\n\t\t\t\t// just get replaced by this one.\n\t\t\t\tif (entry.length > 0 && entry[0].type === EnvironmentVariableMutatorType.Replace) {\n\t\t\t\t\tnext = it.next();\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst extensionMutator = {\n\t\t\t\t\textensionIdentifier,\n\t\t\t\t\tvalue: mutator.value,\n\t\t\t\t\ttype: mutator.type,\n\t\t\t\t\tscope: mutator.scope,\n\t\t\t\t\tvariable: mutator.variable,\n\t\t\t\t\toptions: mutator.options\n\t\t\t\t};\n\t\t\t\tif (!extensionMutator.scope) {\n\t\t\t\t\tdelete extensionMutator.scope; // Convenient for tests\n\t\t\t\t}\n\t\t\t\t// Mutators get applied in the reverse order than they are created\n\t\t\t\tentry.unshift(extensionMutator);\n\n\t\t\t\tnext = it.next();\n\t\t\t}\n\t\t});\n\t}\n\n\tasync applyToProcessEnvironment(env: IProcessEnvironment, scope: EnvironmentVariableScope | undefined, variableResolver?: VariableResolver): Promise<void> {\n\t\tlet lowerToActualVariableNames: { [lowerKey: string]: string | undefined } | undefined;\n\t\tif (isWindows) {\n\t\t\tlowerToActualVariableNames = {};\n\t\t\tObject.keys(env).forEach(e => lowerToActualVariableNames![e.toLowerCase()] = e);\n\t\t}\n\t\tfor (const [variable, mutators] of this.getVariableMap(scope)) {\n\t\t\tconst actualVariable = isWindows ? lowerToActualVariableNames![variable.toLowerCase()] || variable : variable;\n\t\t\tfor (const mutator of mutators) {\n\t\t\t\tconst value = variableResolver ? await variableResolver(mutator.value) : mutator.value;\n\t\t\t\t// Default: true\n\t\t\t\tif (mutator.options?.applyAtProcessCreation ?? true) {\n\t\t\t\t\tswitch (mutator.type) {\n\t\t\t\t\t\tcase EnvironmentVariableMutatorType.Append:\n\t\t\t\t\t\t\tenv[actualVariable] = (env[actualVariable] || '') + value;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase EnvironmentVariableMutatorType.Prepend:\n\t\t\t\t\t\t\tenv[actualVariable] = value + (env[actualVariable] || '');\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase EnvironmentVariableMutatorType.Replace:\n\t\t\t\t\t\t\tenv[actualVariable] = value;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Default: false\n\t\t\t\tif (mutator.options?.applyAtShellIntegration ?? false) {\n\t\t\t\t\tconst key = `VSCODE_ENV_${mutatorTypeToLabelMap.get(mutator.type)!}`;\n\t\t\t\t\tenv[key] = (env[key] ? env[key] + ':' : '') + variable + '=' + this._encodeColons(value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _encodeColons(value: string): string {\n\t\treturn value.replaceAll(':', '\\\\x3a');\n\t}\n\n\tdiff(other: IMergedEnvironmentVariableCollection, scope: EnvironmentVariableScope | undefined): IMergedEnvironmentVariableCollectionDiff | undefined {\n\t\tconst added: Map<string, IExtensionOwnedEnvironmentVariableMutator[]> = new Map();\n\t\tconst changed: Map<string, IExtensionOwnedEnvironmentVariableMutator[]> = new Map();\n\t\tconst removed: Map<string, IExtensionOwnedEnvironmentVariableMutator[]> = new Map();\n\n\t\t// Find added\n\t\tother.getVariableMap(scope).forEach((otherMutators, variable) => {\n\t\t\tconst currentMutators = this.getVariableMap(scope).get(variable);\n\t\t\tconst result = getMissingMutatorsFromArray(otherMutators, currentMutators);\n\t\t\tif (result) {\n\t\t\t\tadded.set(variable, result);\n\t\t\t}\n\t\t});\n\n\t\t// Find removed\n\t\tthis.getVariableMap(scope).forEach((currentMutators, variable) => {\n\t\t\tconst otherMutators = other.getVariableMap(scope).get(variable);\n\t\t\tconst result = getMissingMutatorsFromArray(currentMutators, otherMutators);\n\t\t\tif (result) {\n\t\t\t\tremoved.set(variable, result);\n\t\t\t}\n\t\t});\n\n\t\t// Find changed\n\t\tthis.getVariableMap(scope).forEach((currentMutators, variable) => {\n\t\t\tconst otherMutators = other.getVariableMap(scope).get(variable);\n\t\t\tconst result = getChangedMutatorsFromArray(currentMutators, otherMutators);\n\t\t\tif (result) {\n\t\t\t\tchanged.set(variable, result);\n\t\t\t}\n\t\t});\n\n\t\tif (added.size === 0 && changed.size === 0 && removed.size === 0) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn { added, changed, removed };\n\t}\n\n\tgetVariableMap(scope: EnvironmentVariableScope | undefined): Map<string, IExtensionOwnedEnvironmentVariableMutator[]> {\n\t\tconst result = new Map<string, IExtensionOwnedEnvironmentVariableMutator[]>();\n\t\tfor (const mutators of this.map.values()) {\n\t\t\tconst filteredMutators = mutators.filter(m => filterScope(m, scope));\n\t\t\tif (filteredMutators.length > 0) {\n\t\t\t\t// All of these mutators are for the same variable because they are in the same scope, hence choose anyone to form a key.\n\t\t\t\tresult.set(filteredMutators[0].variable, filteredMutators);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tgetDescriptionMap(scope: EnvironmentVariableScope | undefined): Map<string, string | undefined> {\n\t\tconst result = new Map<string, string | undefined>();\n\t\tfor (const mutators of this.descriptionMap.values()) {\n\t\t\tconst filteredMutators = mutators.filter(m => filterScope(m, scope, true));\n\t\t\tfor (const mutator of filteredMutators) {\n\t\t\t\tresult.set(mutator.extensionIdentifier, mutator.description);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate populateDescriptionMap(collection: IEnvironmentVariableCollection, extensionIdentifier: string): void {\n\t\tif (!collection.descriptionMap) {\n\t\t\treturn;\n\t\t}\n\t\tconst it = collection.descriptionMap.entries();\n\t\tlet next = it.next();\n\t\twhile (!next.done) {\n\t\t\tconst mutator = next.value[1];\n\t\t\tconst key = next.value[0];\n\t\t\tlet entry = this.descriptionMap.get(key);\n\t\t\tif (!entry) {\n\t\t\t\tentry = [];\n\t\t\t\tthis.descriptionMap.set(key, entry);\n\t\t\t}\n\t\t\tconst extensionMutator = {\n\t\t\t\textensionIdentifier,\n\t\t\t\tscope: mutator.scope,\n\t\t\t\tdescription: mutator.description\n\t\t\t};\n\t\t\tif (!extensionMutator.scope) {\n\t\t\t\tdelete extensionMutator.scope; // Convenient for tests\n\t\t\t}\n\t\t\tentry.push(extensionMutator);\n\n\t\t\tnext = it.next();\n\t\t}\n\n\t}\n}\n\n/**\n * Returns whether a mutator matches with the scope provided.\n * @param mutator Mutator to filter\n * @param scope Scope to be used for querying\n * @param strictFilter If true, mutators with global scope is not returned when querying for workspace scope.\n * i.e whether mutator scope should always exactly match with query scope.\n */\nfunction filterScope(\n\tmutator: IExtensionOwnedEnvironmentVariableMutator | IExtensionOwnedEnvironmentDescriptionMutator,\n\tscope: EnvironmentVariableScope | undefined,\n\tstrictFilter = false\n): boolean {\n\tif (!mutator.scope) {\n\t\tif (strictFilter) {\n\t\t\treturn scope === mutator.scope;\n\t\t}\n\t\treturn true;\n\t}\n\t// If a mutator is scoped to a workspace folder, only apply it if the workspace\n\t// folder matches.\n\tif (mutator.scope.workspaceFolder && scope?.workspaceFolder && mutator.scope.workspaceFolder.index === scope.workspaceFolder.index) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nfunction getMissingMutatorsFromArray(\n\tcurrent: IExtensionOwnedEnvironmentVariableMutator[],\n\tother: IExtensionOwnedEnvironmentVariableMutator[] | undefined\n): IExtensionOwnedEnvironmentVariableMutator[] | undefined {\n\t// If it doesn't exist, all are removed\n\tif (!other) {\n\t\treturn current;\n\t}\n\n\t// Create a map to help\n\tconst otherMutatorExtensions = new Set<string>();\n\tother.forEach(m => otherMutatorExtensions.add(m.extensionIdentifier));\n\n\t// Find entries removed from other\n\tconst result: IExtensionOwnedEnvironmentVariableMutator[] = [];\n\tcurrent.forEach(mutator => {\n\t\tif (!otherMutatorExtensions.has(mutator.extensionIdentifier)) {\n\t\t\tresult.push(mutator);\n\t\t}\n\t});\n\n\treturn result.length === 0 ? undefined : result;\n}\n\nfunction getChangedMutatorsFromArray(\n\tcurrent: IExtensionOwnedEnvironmentVariableMutator[],\n\tother: IExtensionOwnedEnvironmentVariableMutator[] | undefined\n): IExtensionOwnedEnvironmentVariableMutator[] | undefined {\n\t// If it doesn't exist, none are changed (they are removed)\n\tif (!other) {\n\t\treturn undefined;\n\t}\n\n\t// Create a map to help\n\tconst otherMutatorExtensions = new Map<string, IExtensionOwnedEnvironmentVariableMutator>();\n\tother.forEach(m => otherMutatorExtensions.set(m.extensionIdentifier, m));\n\n\t// Find entries that exist in both but are not equal\n\tconst result: IExtensionOwnedEnvironmentVariableMutator[] = [];\n\tcurrent.forEach(mutator => {\n\t\tconst otherMutator = otherMutatorExtensions.get(mutator.extensionIdentifier);\n\t\tif (otherMutator && (mutator.type !== otherMutator.type || mutator.value !== otherMutator.value || mutator.scope?.workspaceFolder?.index !== otherMutator.scope?.workspaceFolder?.index)) {\n\t\t\t// Return the new result, not the old one\n\t\t\tresult.push(otherMutator);\n\t\t}\n\t});\n\n\treturn result.length === 0 ? undefined : result;\n}\n"]}