{"version":3,"sources":["file:///workspace/appflow/src/vs/platform/undoRedo/common/undoRedo.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;IAMnF,QAAA,GAAG,GAAgB,IAAA,mBAAG,EAA+B,iBAAiB,CAAC,CAAC;IAErF,IAAkB,mBAGjB;IAHD,WAAkB,mBAAmB;QACpC,qEAAQ,CAAA;QACR,uEAAS,CAAA;IACV,CAAC,EAHiB,mBAAmB,mCAAnB,mBAAmB,QAGpC;IAqED,MAAa,GAAG;QACf,YACiB,QAAa,EACb,QAAkB;YADlB,aAAQ,GAAR,QAAQ,CAAK;YACb,aAAQ,GAAR,QAAQ,CAAU;QAC/B,CAAC;KACL;IALD,kBAKC;IAED,MAAa,GAAG;iBACA,MAAC,GAAK,CAAC,CAAC;QAKvB;YACC,IAAI,CAAC,EAAE,GAAG,GAAG,CAAW,CAAC,EAAI,CAAC;YAC9B,IAAI,CAAC,CAAC,GAAO,CAAC,CAAC;QAChB,CAAC;QAEM,SAAS;YACf,IAAI,IAAI,CAAC,EAAE,KAAK,CAAC,EAAE;gBAClB,OAAO,CAAC,CAAC;aACT;YACD,OAAO,IAAI,CAAC,CAAC,EAAM,CAAC;QACrB,CAAC;iBAEa,SAAI,GAAG,IAAI,GAAG,EAAY,CAAC;;IAlB1C,kBAmBC;IAED,MAAa,GAAG;iBACA,MAAC,GAAK,CAAC,CAAC;QAKvB;YACC,IAAI,CAAC,EAAE,GAAG,GAAG,CAAY,CAAC,EAAI,CAAC;YAC/B,IAAI,CAAC,CAAC,GAAO,CAAC,CAAC;QAChB,CAAC;QAEM,SAAS;YACf,IAAI,IAAI,CAAC,EAAE,KAAK,CAAC,EAAE;gBAClB,OAAO,CAAC,CAAC;aACT;YACD,OAAO,IAAI,CAAC,CAAC,EAAM,CAAC;QACrB,CAAC;iBAEa,SAAI,GAAG,IAAI,GAAG,EAAa,CAAC;;IAlB3C,kBAmBC","file":"undoRedo.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IDisposable } from 'vs/base/common/lifecycle';\nimport { URI } from 'vs/base/common/uri';\nimport { createDecorator } from 'vs/platform/instantiation/common/instantiation';\n\nexport const IUndoRedoService = createDecorator<IUndoRedoService>('undoRedoService');\n\nexport const enum UndoRedoElementType {\n\tResource,\n\tWorkspace\n}\n\nexport interface IResourceUndoRedoElement {\n\treadonly type: UndoRedoElementType.Resource;\n\t/**\n\t * The resource impacted by this element.\n\t */\n\treadonly resource: URI;\n\t/**\n\t * A user presentable label. May be localized.\n\t */\n\treadonly label: string;\n\t/**\n\t * A code describing the operation. Will not be localized.\n\t */\n\treadonly code: string;\n\t/**\n\t * Show a message to the user confirming when trying to undo this element\n\t */\n\treadonly confirmBeforeUndo?: boolean;\n\tundo(): Promise<void> | void;\n\tredo(): Promise<void> | void;\n}\n\nexport interface IWorkspaceUndoRedoElement {\n\treadonly type: UndoRedoElementType.Workspace;\n\t/**\n\t * The resources impacted by this element.\n\t */\n\treadonly resources: readonly URI[];\n\t/**\n\t * A user presentable label. May be localized.\n\t */\n\treadonly label: string;\n\t/**\n\t * A code describing the operation. Will not be localized.\n\t */\n\treadonly code: string;\n\t/**\n\t * Show a message to the user confirming when trying to undo this element\n\t */\n\treadonly confirmBeforeUndo?: boolean;\n\tundo(): Promise<void> | void;\n\tredo(): Promise<void> | void;\n\n\t/**\n\t * If implemented, indicates that this undo/redo element can be split into multiple per resource elements.\n\t */\n\tsplit?(): IResourceUndoRedoElement[];\n\n\t/**\n\t * If implemented, will be invoked before calling `undo()` or `redo()`.\n\t * This is a good place to prepare everything such that the calls to `undo()` or `redo()` are synchronous.\n\t * If a disposable is returned, it will be invoked to clean things up.\n\t */\n\tprepareUndoRedo?(): Promise<IDisposable> | IDisposable | void;\n}\n\nexport type IUndoRedoElement = IResourceUndoRedoElement | IWorkspaceUndoRedoElement;\n\nexport interface IPastFutureElements {\n\tpast: IUndoRedoElement[];\n\tfuture: IUndoRedoElement[];\n}\n\nexport interface UriComparisonKeyComputer {\n\tgetComparisonKey(uri: URI): string;\n}\n\nexport class ResourceEditStackSnapshot {\n\tconstructor(\n\t\tpublic readonly resource: URI,\n\t\tpublic readonly elements: number[]\n\t) { }\n}\n\nexport class UndoRedoGroup {\n\tprivate static _ID = 0;\n\n\tpublic readonly id: number;\n\tprivate order: number;\n\n\tconstructor() {\n\t\tthis.id = UndoRedoGroup._ID++;\n\t\tthis.order = 1;\n\t}\n\n\tpublic nextOrder(): number {\n\t\tif (this.id === 0) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn this.order++;\n\t}\n\n\tpublic static None = new UndoRedoGroup();\n}\n\nexport class UndoRedoSource {\n\tprivate static _ID = 0;\n\n\tpublic readonly id: number;\n\tprivate order: number;\n\n\tconstructor() {\n\t\tthis.id = UndoRedoSource._ID++;\n\t\tthis.order = 1;\n\t}\n\n\tpublic nextOrder(): number {\n\t\tif (this.id === 0) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn this.order++;\n\t}\n\n\tpublic static None = new UndoRedoSource();\n}\n\nexport interface IUndoRedoService {\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Register an URI -> string hasher.\n\t * This is useful for making multiple URIs share the same undo-redo stack.\n\t */\n\tregisterUriComparisonKeyComputer(scheme: string, uriComparisonKeyComputer: UriComparisonKeyComputer): IDisposable;\n\n\t/**\n\t * Get the hash used internally for a certain URI.\n\t * This uses any registered `UriComparisonKeyComputer`.\n\t */\n\tgetUriComparisonKey(resource: URI): string;\n\n\t/**\n\t * Add a new element to the `undo` stack.\n\t * This will destroy the `redo` stack.\n\t */\n\tpushElement(element: IUndoRedoElement, group?: UndoRedoGroup, source?: UndoRedoSource): void;\n\n\t/**\n\t * Get the last pushed element for a resource.\n\t * If the last pushed element has been undone, returns null.\n\t */\n\tgetLastElement(resource: URI): IUndoRedoElement | null;\n\n\t/**\n\t * Get all the elements associated with a resource.\n\t * This includes the past and the future.\n\t */\n\tgetElements(resource: URI): IPastFutureElements;\n\n\t/**\n\t * Validate or invalidate stack elements associated with a resource.\n\t */\n\tsetElementsValidFlag(resource: URI, isValid: boolean, filter: (element: IUndoRedoElement) => boolean): void;\n\n\t/**\n\t * Remove elements that target `resource`.\n\t */\n\tremoveElements(resource: URI): void;\n\n\t/**\n\t * Create a snapshot of the current elements on the undo-redo stack for a resource.\n\t */\n\tcreateSnapshot(resource: URI): ResourceEditStackSnapshot;\n\t/**\n\t * Attempt (as best as possible) to restore a certain snapshot previously created with `createSnapshot` for a resource.\n\t */\n\trestoreSnapshot(snapshot: ResourceEditStackSnapshot): void;\n\n\tcanUndo(resource: URI | UndoRedoSource): boolean;\n\tundo(resource: URI | UndoRedoSource): Promise<void> | void;\n\n\tcanRedo(resource: URI | UndoRedoSource): boolean;\n\tredo(resource: URI | UndoRedoSource): Promise<void> | void;\n}\n"]}