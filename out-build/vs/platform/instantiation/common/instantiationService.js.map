{"version":3,"sources":["file:///workspace/appflow/src/vs/platform/instantiation/common/instantiationService.ts"],"names":[],"mappings":"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","file":"instantiationService.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IdleValue } from 'vs/base/common/async';\nimport { Event } from 'vs/base/common/event';\nimport { illegalState } from 'vs/base/common/errors';\nimport { toDisposable } from 'vs/base/common/lifecycle';\nimport { SyncDescriptor, SyncDescriptor0 } from 'vs/platform/instantiation/common/descriptors';\nimport { Graph } from 'vs/platform/instantiation/common/graph';\nimport { GetLeadingNonServiceArgs, IInstantiationService, ServiceIdentifier, ServicesAccessor, _util } from 'vs/platform/instantiation/common/instantiation';\nimport { ServiceCollection } from 'vs/platform/instantiation/common/serviceCollection';\nimport { LinkedList } from 'vs/base/common/linkedList';\n\n// TRACING\nconst _enableAllTracing = false\n\t// || \"TRUE\" // DO NOT CHECK IN!\n\t;\n\nclass CyclicDependencyError extends Error {\n\tconstructor(graph: Graph<any>) {\n\t\tsuper('cyclic dependency between services');\n\t\tthis.message = graph.findCycleSlow() ?? `UNABLE to detect cycle, dumping graph: \\n${graph.toString()}`;\n\t}\n}\n\nexport class InstantiationService implements IInstantiationService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\treadonly _globalGraph?: Graph<string>;\n\tprivate _globalGraphImplicitDependency?: string;\n\n\tconstructor(\n\t\tprivate readonly _services: ServiceCollection = new ServiceCollection(),\n\t\tprivate readonly _strict: boolean = false,\n\t\tprivate readonly _parent?: InstantiationService,\n\t\tprivate readonly _enableTracing: boolean = _enableAllTracing\n\t) {\n\n\t\tthis._services.set(IInstantiationService, this);\n\t\tthis._globalGraph = _enableTracing ? _parent?._globalGraph ?? new Graph(e => e) : undefined;\n\t}\n\n\tcreateChild(services: ServiceCollection): IInstantiationService {\n\t\treturn new InstantiationService(services, this._strict, this, this._enableTracing);\n\t}\n\n\tinvokeFunction<R, TS extends any[] = []>(fn: (accessor: ServicesAccessor, ...args: TS) => R, ...args: TS): R {\n\t\tconst _trace = Trace.traceInvocation(this._enableTracing, fn);\n\t\tlet _done = false;\n\t\ttry {\n\t\t\tconst accessor: ServicesAccessor = {\n\t\t\t\tget: <T>(id: ServiceIdentifier<T>) => {\n\n\t\t\t\t\tif (_done) {\n\t\t\t\t\t\tthrow illegalState('service accessor is only valid during the invocation of its target method');\n\t\t\t\t\t}\n\n\t\t\t\t\tconst result = this._getOrCreateServiceInstance(id, _trace);\n\t\t\t\t\tif (!result) {\n\t\t\t\t\t\tthrow new Error(`[invokeFunction] unknown service '${id}'`);\n\t\t\t\t\t}\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn fn(accessor, ...args);\n\t\t} finally {\n\t\t\t_done = true;\n\t\t\t_trace.stop();\n\t\t}\n\t}\n\n\tcreateInstance<T>(descriptor: SyncDescriptor0<T>): T;\n\tcreateInstance<Ctor extends new (...args: any[]) => any, R extends InstanceType<Ctor>>(ctor: Ctor, ...args: GetLeadingNonServiceArgs<ConstructorParameters<Ctor>>): R;\n\tcreateInstance(ctorOrDescriptor: any | SyncDescriptor<any>, ...rest: any[]): any {\n\t\tlet _trace: Trace;\n\t\tlet result: any;\n\t\tif (ctorOrDescriptor instanceof SyncDescriptor) {\n\t\t\t_trace = Trace.traceCreation(this._enableTracing, ctorOrDescriptor.ctor);\n\t\t\tresult = this._createInstance(ctorOrDescriptor.ctor, ctorOrDescriptor.staticArguments.concat(rest), _trace);\n\t\t} else {\n\t\t\t_trace = Trace.traceCreation(this._enableTracing, ctorOrDescriptor);\n\t\t\tresult = this._createInstance(ctorOrDescriptor, rest, _trace);\n\t\t}\n\t\t_trace.stop();\n\t\treturn result;\n\t}\n\n\tprivate _createInstance<T>(ctor: any, args: any[] = [], _trace: Trace): T {\n\n\t\t// arguments defined by service decorators\n\t\tconst serviceDependencies = _util.getServiceDependencies(ctor).sort((a, b) => a.index - b.index);\n\t\tconst serviceArgs: any[] = [];\n\t\tfor (const dependency of serviceDependencies) {\n\t\t\tconst service = this._getOrCreateServiceInstance(dependency.id, _trace);\n\t\t\tif (!service) {\n\t\t\t\tthis._throwIfStrict(`[createInstance] ${ctor.name} depends on UNKNOWN service ${dependency.id}.`, false);\n\t\t\t}\n\t\t\tserviceArgs.push(service);\n\t\t}\n\n\t\tconst firstServiceArgPos = serviceDependencies.length > 0 ? serviceDependencies[0].index : args.length;\n\n\t\t// check for argument mismatches, adjust static args if needed\n\t\tif (args.length !== firstServiceArgPos) {\n\t\t\tconsole.trace(`[createInstance] First service dependency of ${ctor.name} at position ${firstServiceArgPos + 1} conflicts with ${args.length} static arguments`);\n\n\t\t\tconst delta = firstServiceArgPos - args.length;\n\t\t\tif (delta > 0) {\n\t\t\t\targs = args.concat(new Array(delta));\n\t\t\t} else {\n\t\t\t\targs = args.slice(0, firstServiceArgPos);\n\t\t\t}\n\t\t}\n\n\t\t// now create the instance\n\t\treturn Reflect.construct<any, T>(ctor, args.concat(serviceArgs));\n\t}\n\n\tprivate _setServiceInstance<T>(id: ServiceIdentifier<T>, instance: T): void {\n\t\tif (this._services.get(id) instanceof SyncDescriptor) {\n\t\t\tthis._services.set(id, instance);\n\t\t} else if (this._parent) {\n\t\t\tthis._parent._setServiceInstance(id, instance);\n\t\t} else {\n\t\t\tthrow new Error('illegalState - setting UNKNOWN service instance');\n\t\t}\n\t}\n\n\tprivate _getServiceInstanceOrDescriptor<T>(id: ServiceIdentifier<T>): T | SyncDescriptor<T> {\n\t\tconst instanceOrDesc = this._services.get(id);\n\t\tif (!instanceOrDesc && this._parent) {\n\t\t\treturn this._parent._getServiceInstanceOrDescriptor(id);\n\t\t} else {\n\t\t\treturn instanceOrDesc;\n\t\t}\n\t}\n\n\tprotected _getOrCreateServiceInstance<T>(id: ServiceIdentifier<T>, _trace: Trace): T {\n\t\tif (this._globalGraph && this._globalGraphImplicitDependency) {\n\t\t\tthis._globalGraph.insertEdge(this._globalGraphImplicitDependency, String(id));\n\t\t}\n\t\tconst thing = this._getServiceInstanceOrDescriptor(id);\n\t\tif (thing instanceof SyncDescriptor) {\n\t\t\treturn this._safeCreateAndCacheServiceInstance(id, thing, _trace.branch(id, true));\n\t\t} else {\n\t\t\t_trace.branch(id, false);\n\t\t\treturn thing;\n\t\t}\n\t}\n\n\tprivate readonly _activeInstantiations = new Set<ServiceIdentifier<any>>();\n\n\n\tprivate _safeCreateAndCacheServiceInstance<T>(id: ServiceIdentifier<T>, desc: SyncDescriptor<T>, _trace: Trace): T {\n\t\tif (this._activeInstantiations.has(id)) {\n\t\t\tthrow new Error(`illegal state - RECURSIVELY instantiating service '${id}'`);\n\t\t}\n\t\tthis._activeInstantiations.add(id);\n\t\ttry {\n\t\t\treturn this._createAndCacheServiceInstance(id, desc, _trace);\n\t\t} finally {\n\t\t\tthis._activeInstantiations.delete(id);\n\t\t}\n\t}\n\n\tprivate _createAndCacheServiceInstance<T>(id: ServiceIdentifier<T>, desc: SyncDescriptor<T>, _trace: Trace): T {\n\n\t\ttype Triple = { id: ServiceIdentifier<any>; desc: SyncDescriptor<any>; _trace: Trace };\n\t\tconst graph = new Graph<Triple>(data => data.id.toString());\n\n\t\tlet cycleCount = 0;\n\t\tconst stack = [{ id, desc, _trace }];\n\t\twhile (stack.length) {\n\t\t\tconst item = stack.pop()!;\n\t\t\tgraph.lookupOrInsertNode(item);\n\n\t\t\t// a weak but working heuristic for cycle checks\n\t\t\tif (cycleCount++ > 1000) {\n\t\t\t\tthrow new CyclicDependencyError(graph);\n\t\t\t}\n\n\t\t\t// check all dependencies for existence and if they need to be created first\n\t\t\tfor (const dependency of _util.getServiceDependencies(item.desc.ctor)) {\n\n\t\t\t\tconst instanceOrDesc = this._getServiceInstanceOrDescriptor(dependency.id);\n\t\t\t\tif (!instanceOrDesc) {\n\t\t\t\t\tthis._throwIfStrict(`[createInstance] ${id} depends on ${dependency.id} which is NOT registered.`, true);\n\t\t\t\t}\n\n\t\t\t\t// take note of all service dependencies\n\t\t\t\tthis._globalGraph?.insertEdge(String(item.id), String(dependency.id));\n\n\t\t\t\tif (instanceOrDesc instanceof SyncDescriptor) {\n\t\t\t\t\tconst d = { id: dependency.id, desc: instanceOrDesc, _trace: item._trace.branch(dependency.id, true) };\n\t\t\t\t\tgraph.insertEdge(item, d);\n\t\t\t\t\tstack.push(d);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile (true) {\n\t\t\tconst roots = graph.roots();\n\n\t\t\t// if there is no more roots but still\n\t\t\t// nodes in the graph we have a cycle\n\t\t\tif (roots.length === 0) {\n\t\t\t\tif (!graph.isEmpty()) {\n\t\t\t\t\tthrow new CyclicDependencyError(graph);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (const { data } of roots) {\n\t\t\t\t// Repeat the check for this still being a service sync descriptor. That's because\n\t\t\t\t// instantiating a dependency might have side-effect and recursively trigger instantiation\n\t\t\t\t// so that some dependencies are now fullfilled already.\n\t\t\t\tconst instanceOrDesc = this._getServiceInstanceOrDescriptor(data.id);\n\t\t\t\tif (instanceOrDesc instanceof SyncDescriptor) {\n\t\t\t\t\t// create instance and overwrite the service collections\n\t\t\t\t\tconst instance = this._createServiceInstanceWithOwner(data.id, data.desc.ctor, data.desc.staticArguments, data.desc.supportsDelayedInstantiation, data._trace);\n\t\t\t\t\tthis._setServiceInstance(data.id, instance);\n\t\t\t\t}\n\t\t\t\tgraph.removeNode(data);\n\t\t\t}\n\t\t}\n\t\treturn <T>this._getServiceInstanceOrDescriptor(id);\n\t}\n\n\tprivate _createServiceInstanceWithOwner<T>(id: ServiceIdentifier<T>, ctor: any, args: any[] = [], supportsDelayedInstantiation: boolean, _trace: Trace): T {\n\t\tif (this._services.get(id) instanceof SyncDescriptor) {\n\t\t\treturn this._createServiceInstance(id, ctor, args, supportsDelayedInstantiation, _trace);\n\t\t} else if (this._parent) {\n\t\t\treturn this._parent._createServiceInstanceWithOwner(id, ctor, args, supportsDelayedInstantiation, _trace);\n\t\t} else {\n\t\t\tthrow new Error(`illegalState - creating UNKNOWN service instance ${ctor.name}`);\n\t\t}\n\t}\n\n\tprivate _createServiceInstance<T>(id: ServiceIdentifier<T>, ctor: any, args: any[] = [], supportsDelayedInstantiation: boolean, _trace: Trace): T {\n\t\tif (!supportsDelayedInstantiation) {\n\t\t\t// eager instantiation\n\t\t\treturn this._createInstance(ctor, args, _trace);\n\n\t\t} else {\n\t\t\tconst child = new InstantiationService(undefined, this._strict, this, this._enableTracing);\n\t\t\tchild._globalGraphImplicitDependency = String(id);\n\n\t\t\t// Return a proxy object that's backed by an idle value. That\n\t\t\t// strategy is to instantiate services in our idle time or when actually\n\t\t\t// needed but not when injected into a consumer\n\n\t\t\t// return \"empty events\" when the service isn't instantiated yet\n\t\t\tconst earlyListeners = new Map<string, LinkedList<Parameters<Event<any>>>>();\n\n\t\t\tconst idle = new IdleValue<any>(() => {\n\t\t\t\tconst result = child._createInstance<T>(ctor, args, _trace);\n\n\t\t\t\t// early listeners that we kept are now being subscribed to\n\t\t\t\t// the real service\n\t\t\t\tfor (const [key, values] of earlyListeners) {\n\t\t\t\t\tconst candidate = <Event<any>>(<any>result)[key];\n\t\t\t\t\tif (typeof candidate === 'function') {\n\t\t\t\t\t\tfor (const listener of values) {\n\t\t\t\t\t\t\tcandidate.apply(result, listener);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tearlyListeners.clear();\n\n\t\t\t\treturn result;\n\t\t\t});\n\t\t\treturn <T>new Proxy(Object.create(null), {\n\t\t\t\tget(target: any, key: PropertyKey): any {\n\n\t\t\t\t\tif (!idle.isInitialized) {\n\t\t\t\t\t\t// looks like an event\n\t\t\t\t\t\tif (typeof key === 'string' && (key.startsWith('onDid') || key.startsWith('onWill'))) {\n\t\t\t\t\t\t\tlet list = earlyListeners.get(key);\n\t\t\t\t\t\t\tif (!list) {\n\t\t\t\t\t\t\t\tlist = new LinkedList();\n\t\t\t\t\t\t\t\tearlyListeners.set(key, list);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst event: Event<any> = (callback, thisArg, disposables) => {\n\t\t\t\t\t\t\t\tconst rm = list!.push([callback, thisArg, disposables]);\n\t\t\t\t\t\t\t\treturn toDisposable(rm);\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\treturn event;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// value already exists\n\t\t\t\t\tif (key in target) {\n\t\t\t\t\t\treturn target[key];\n\t\t\t\t\t}\n\n\t\t\t\t\t// create value\n\t\t\t\t\tconst obj = idle.value;\n\t\t\t\t\tlet prop = obj[key];\n\t\t\t\t\tif (typeof prop !== 'function') {\n\t\t\t\t\t\treturn prop;\n\t\t\t\t\t}\n\t\t\t\t\tprop = prop.bind(obj);\n\t\t\t\t\ttarget[key] = prop;\n\t\t\t\t\treturn prop;\n\t\t\t\t},\n\t\t\t\tset(_target: T, p: PropertyKey, value: any): boolean {\n\t\t\t\t\tidle.value[p] = value;\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\t\t\t\tgetPrototypeOf(_target: T) {\n\t\t\t\t\treturn ctor.prototype;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\tprivate _throwIfStrict(msg: string, printWarning: boolean): void {\n\t\tif (printWarning) {\n\t\t\tconsole.warn(msg);\n\t\t}\n\t\tif (this._strict) {\n\t\t\tthrow new Error(msg);\n\t\t}\n\t}\n}\n\n//#region -- tracing ---\n\nconst enum TraceType {\n\tNone = 0,\n\tCreation = 1,\n\tInvocation = 2,\n\tBranch = 3,\n}\n\nexport class Trace {\n\n\tstatic all = new Set<string>();\n\n\tprivate static readonly _None = new class extends Trace {\n\t\tconstructor() { super(TraceType.None, null); }\n\t\toverride stop() { }\n\t\toverride branch() { return this; }\n\t};\n\n\tstatic traceInvocation(_enableTracing: boolean, ctor: any): Trace {\n\t\treturn !_enableTracing ? Trace._None : new Trace(TraceType.Invocation, ctor.name || new Error().stack!.split('\\n').slice(3, 4).join('\\n'));\n\t}\n\n\tstatic traceCreation(_enableTracing: boolean, ctor: any): Trace {\n\t\treturn !_enableTracing ? Trace._None : new Trace(TraceType.Creation, ctor.name);\n\t}\n\n\tprivate static _totals: number = 0;\n\tprivate readonly _start: number = Date.now();\n\tprivate readonly _dep: [ServiceIdentifier<any>, boolean, Trace?][] = [];\n\n\tprivate constructor(\n\t\treadonly type: TraceType,\n\t\treadonly name: string | null\n\t) { }\n\n\tbranch(id: ServiceIdentifier<any>, first: boolean): Trace {\n\t\tconst child = new Trace(TraceType.Branch, id.toString());\n\t\tthis._dep.push([id, first, child]);\n\t\treturn child;\n\t}\n\n\tstop() {\n\t\tconst dur = Date.now() - this._start;\n\t\tTrace._totals += dur;\n\n\t\tlet causedCreation = false;\n\n\t\tfunction printChild(n: number, trace: Trace) {\n\t\t\tconst res: string[] = [];\n\t\t\tconst prefix = new Array(n + 1).join('\\t');\n\t\t\tfor (const [id, first, child] of trace._dep) {\n\t\t\t\tif (first && child) {\n\t\t\t\t\tcausedCreation = true;\n\t\t\t\t\tres.push(`${prefix}CREATES -> ${id}`);\n\t\t\t\t\tconst nested = printChild(n + 1, child);\n\t\t\t\t\tif (nested) {\n\t\t\t\t\t\tres.push(nested);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tres.push(`${prefix}uses -> ${id}`);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res.join('\\n');\n\t\t}\n\n\t\tconst lines = [\n\t\t\t`${this.type === TraceType.Creation ? 'CREATE' : 'CALL'} ${this.name}`,\n\t\t\t`${printChild(1, this)}`,\n\t\t\t`DONE, took ${dur.toFixed(2)}ms (grand total ${Trace._totals.toFixed(2)}ms)`\n\t\t];\n\n\t\tif (dur > 2 || causedCreation) {\n\t\t\tTrace.all.add(lines.join('\\n'));\n\t\t}\n\t}\n}\n\n//#endregion\n"]}