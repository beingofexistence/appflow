{"version":3,"sources":["file:///workspace/appflow/src/vs/platform/secrets/common/secrets.ts"],"names":[],"mappings":"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","file":"secrets.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { SequencerByKey } from 'vs/base/common/async';\nimport { IEncryptionService } from 'vs/platform/encryption/common/encryptionService';\nimport { createDecorator } from 'vs/platform/instantiation/common/instantiation';\nimport { IStorageService, InMemoryStorageService, StorageScope, StorageTarget } from 'vs/platform/storage/common/storage';\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { ILogService } from 'vs/platform/log/common/log';\nimport { Disposable, DisposableStore } from 'vs/base/common/lifecycle';\nimport { Lazy } from 'vs/base/common/lazy';\n\nexport const ISecretStorageService = createDecorator<ISecretStorageService>('secretStorageService');\n\nexport interface ISecretStorageProvider {\n\ttype: 'in-memory' | 'persisted' | 'unknown';\n\tget(key: string): Promise<string | undefined>;\n\tset(key: string, value: string): Promise<void>;\n\tdelete(key: string): Promise<void>;\n}\n\nexport interface ISecretStorageService extends ISecretStorageProvider {\n\treadonly _serviceBrand: undefined;\n\tonDidChangeSecret: Event<string>;\n}\n\nexport class BaseSecretStorageService extends Disposable implements ISecretStorageService {\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate readonly _storagePrefix = 'secret://';\n\n\tprotected readonly onDidChangeSecretEmitter = this._register(new Emitter<string>());\n\tonDidChangeSecret: Event<string> = this.onDidChangeSecretEmitter.event;\n\n\tprotected readonly _sequencer = new SequencerByKey<string>();\n\n\tprivate _type: 'in-memory' | 'persisted' | 'unknown' = 'unknown';\n\n\tprivate readonly _onDidChangeValueDisposable = this._register(new DisposableStore());\n\n\tconstructor(\n\t\tprivate readonly _useInMemoryStorage: boolean,\n\t\t@IStorageService private _storageService: IStorageService,\n\t\t@IEncryptionService protected _encryptionService: IEncryptionService,\n\t\t@ILogService protected readonly _logService: ILogService,\n\t) {\n\t\tsuper();\n\t}\n\n\t/**\n\t * @Note initialize must be called first so that this can be resolved properly\n\t * otherwise it will return 'unknown'.\n\t */\n\tget type() {\n\t\treturn this._type;\n\t}\n\n\tprivate _lazyStorageService: Lazy<Promise<IStorageService>> = new Lazy(() => this.initialize());\n\tprotected get resolvedStorageService() {\n\t\treturn this._lazyStorageService.value;\n\t}\n\n\tget(key: string): Promise<string | undefined> {\n\t\treturn this._sequencer.queue(key, async () => {\n\t\t\tconst storageService = await this.resolvedStorageService;\n\n\t\t\tconst fullKey = this.getKey(key);\n\t\t\tthis._logService.trace('[secrets] getting secret for key:', fullKey);\n\t\t\tconst encrypted = storageService.get(fullKey, StorageScope.APPLICATION);\n\t\t\tif (!encrypted) {\n\t\t\t\tthis._logService.trace('[secrets] no secret found for key:', fullKey);\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tthis._logService.trace('[secrets] decrypting gotten secret for key:', fullKey);\n\t\t\t\t// If the storage service is in-memory, we don't need to decrypt\n\t\t\t\tconst result = this._type === 'in-memory'\n\t\t\t\t\t? encrypted\n\t\t\t\t\t: await this._encryptionService.decrypt(encrypted);\n\t\t\t\tthis._logService.trace('[secrets] decrypted secret for key:', fullKey);\n\t\t\t\treturn result;\n\t\t\t} catch (e) {\n\t\t\t\tthis._logService.error(e);\n\t\t\t\tthis.delete(key);\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t});\n\t}\n\n\tset(key: string, value: string): Promise<void> {\n\t\treturn this._sequencer.queue(key, async () => {\n\t\t\tconst storageService = await this.resolvedStorageService;\n\n\t\t\tthis._logService.trace('[secrets] encrypting secret for key:', key);\n\t\t\tlet encrypted;\n\t\t\ttry {\n\t\t\t\t// If the storage service is in-memory, we don't need to encrypt\n\t\t\t\tencrypted = this._type === 'in-memory'\n\t\t\t\t\t? value\n\t\t\t\t\t: await this._encryptionService.encrypt(value);\n\t\t\t} catch (e) {\n\t\t\t\tthis._logService.error(e);\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t\tconst fullKey = this.getKey(key);\n\t\t\tthis._logService.trace('[secrets] storing encrypted secret for key:', fullKey);\n\t\t\tstorageService.store(fullKey, encrypted, StorageScope.APPLICATION, StorageTarget.MACHINE);\n\t\t\tthis._logService.trace('[secrets] stored encrypted secret for key:', fullKey);\n\t\t});\n\t}\n\n\tdelete(key: string): Promise<void> {\n\t\treturn this._sequencer.queue(key, async () => {\n\t\t\tconst storageService = await this.resolvedStorageService;\n\n\t\t\tconst fullKey = this.getKey(key);\n\t\t\tthis._logService.trace('[secrets] deleting secret for key:', fullKey);\n\t\t\tstorageService.remove(fullKey, StorageScope.APPLICATION);\n\t\t\tthis._logService.trace('[secrets] deleted secret for key:', fullKey);\n\t\t});\n\t}\n\n\tprivate async initialize(): Promise<IStorageService> {\n\t\tlet storageService;\n\t\tif (!this._useInMemoryStorage && await this._encryptionService.isEncryptionAvailable()) {\n\t\t\tthis._logService.trace(`[SecretStorageService] Encryption is available, using persisted storage`);\n\t\t\tthis._type = 'persisted';\n\t\t\tstorageService = this._storageService;\n\t\t} else {\n\t\t\t// If we already have an in-memory storage service, we don't need to recreate it\n\t\t\tif (this._type === 'in-memory') {\n\t\t\t\treturn this._storageService;\n\t\t\t}\n\t\t\tthis._logService.trace('[SecretStorageService] Encryption is not available, falling back to in-memory storage');\n\t\t\tthis._type = 'in-memory';\n\t\t\tstorageService = this._register(new InMemoryStorageService());\n\t\t}\n\n\t\tthis._onDidChangeValueDisposable.clear();\n\t\tthis._onDidChangeValueDisposable.add(storageService.onDidChangeValue(StorageScope.APPLICATION, undefined, this._onDidChangeValueDisposable)(e => {\n\t\t\tthis.onDidChangeValue(e.key);\n\t\t}));\n\t\treturn storageService;\n\t}\n\n\tprotected reinitialize(): void {\n\t\tthis._lazyStorageService = new Lazy(() => this.initialize());\n\t}\n\n\tprivate onDidChangeValue(key: string): void {\n\t\tif (!key.startsWith(this._storagePrefix)) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst secretKey = key.slice(this._storagePrefix.length);\n\n\t\tthis._logService.trace(`[SecretStorageService] Notifying change in value for secret: ${secretKey}`);\n\t\tthis.onDidChangeSecretEmitter.fire(secretKey);\n\t}\n\n\tprivate getKey(key: string): string {\n\t\treturn `${this._storagePrefix}${key}`;\n\t}\n}\n"]}