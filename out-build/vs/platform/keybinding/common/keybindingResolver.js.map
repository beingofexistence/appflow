{"version":3,"sources":["file:///workspace/appflow/src/vs/platform/keybinding/common/keybindingResolver.ts"],"names":[],"mappings":"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","file":"keybindingResolver.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { implies, ContextKeyExpression, ContextKeyExprType, IContext, IContextKeyService, expressionsAreEqualWithConstantSubstitution } from 'vs/platform/contextkey/common/contextkey';\nimport { ResolvedKeybindingItem } from 'vs/platform/keybinding/common/resolvedKeybindingItem';\n\n//#region resolution-result\n\nexport const enum ResultKind {\n\t/** No keybinding found this sequence of chords */\n\tNoMatchingKb,\n\n\t/** There're several keybindings that have the given sequence of chords as a prefix */\n\tMoreChordsNeeded,\n\n\t/** A single keybinding found to be dispatched/invoked */\n\tKbFound\n}\n\nexport type ResolutionResult =\n\t| { kind: ResultKind.NoMatchingKb }\n\t| { kind: ResultKind.MoreChordsNeeded }\n\t| { kind: ResultKind.KbFound; commandId: string | null; commandArgs: any; isBubble: boolean };\n\n\n// util definitions to make working with the above types easier within this module:\n\nexport const NoMatchingKb: ResolutionResult = { kind: ResultKind.NoMatchingKb };\nconst MoreChordsNeeded: ResolutionResult = { kind: ResultKind.MoreChordsNeeded };\nfunction KbFound(commandId: string | null, commandArgs: any, isBubble: boolean): ResolutionResult {\n\treturn { kind: ResultKind.KbFound, commandId, commandArgs, isBubble };\n}\n\n//#endregion\n\n/**\n * Stores mappings from keybindings to commands and from commands to keybindings.\n * Given a sequence of chords, `resolve`s which keybinding it matches\n */\nexport class KeybindingResolver {\n\tprivate readonly _log: (str: string) => void;\n\tprivate readonly _defaultKeybindings: ResolvedKeybindingItem[];\n\tprivate readonly _keybindings: ResolvedKeybindingItem[];\n\tprivate readonly _defaultBoundCommands: Map</* commandId */ string, boolean>;\n\tprivate readonly _map: Map</* 1st chord's keypress */ string, ResolvedKeybindingItem[]>;\n\tprivate readonly _lookupMap: Map</* commandId */ string, ResolvedKeybindingItem[]>;\n\n\tconstructor(\n\t\t/** built-in and extension-provided keybindings */\n\t\tdefaultKeybindings: ResolvedKeybindingItem[],\n\t\t/** user's keybindings */\n\t\toverrides: ResolvedKeybindingItem[],\n\t\tlog: (str: string) => void\n\t) {\n\t\tthis._log = log;\n\t\tthis._defaultKeybindings = defaultKeybindings;\n\n\t\tthis._defaultBoundCommands = new Map<string, boolean>();\n\t\tfor (const defaultKeybinding of defaultKeybindings) {\n\t\t\tconst command = defaultKeybinding.command;\n\t\t\tif (command && command.charAt(0) !== '-') {\n\t\t\t\tthis._defaultBoundCommands.set(command, true);\n\t\t\t}\n\t\t}\n\n\t\tthis._map = new Map<string, ResolvedKeybindingItem[]>();\n\t\tthis._lookupMap = new Map<string, ResolvedKeybindingItem[]>();\n\n\t\tthis._keybindings = KeybindingResolver.handleRemovals(([] as ResolvedKeybindingItem[]).concat(defaultKeybindings).concat(overrides));\n\t\tfor (let i = 0, len = this._keybindings.length; i < len; i++) {\n\t\t\tconst k = this._keybindings[i];\n\t\t\tif (k.chords.length === 0) {\n\t\t\t\t// unbound\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// substitute with constants that are registered after startup - https://github.com/microsoft/vscode/issues/174218#issuecomment-1437972127\n\t\t\tconst when = k.when?.substituteConstants();\n\n\t\t\tif (when && when.type === ContextKeyExprType.False) {\n\t\t\t\t// when condition is false\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthis._addKeyPress(k.chords[0], k);\n\t\t}\n\t}\n\n\tprivate static _isTargetedForRemoval(defaultKb: ResolvedKeybindingItem, keypress: string[] | null, when: ContextKeyExpression | undefined): boolean {\n\t\tif (keypress) {\n\t\t\tfor (let i = 0; i < keypress.length; i++) {\n\t\t\t\tif (keypress[i] !== defaultKb.chords[i]) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// `true` means always, as does `undefined`\n\t\t// so we will treat `true` === `undefined`\n\t\tif (when && when.type !== ContextKeyExprType.True) {\n\t\t\tif (!defaultKb.when) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!expressionsAreEqualWithConstantSubstitution(when, defaultKb.when)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\n\t}\n\n\t/**\n\t * Looks for rules containing \"-commandId\" and removes them.\n\t */\n\tpublic static handleRemovals(rules: ResolvedKeybindingItem[]): ResolvedKeybindingItem[] {\n\t\t// Do a first pass and construct a hash-map for removals\n\t\tconst removals = new Map</* commandId */ string, ResolvedKeybindingItem[]>();\n\t\tfor (let i = 0, len = rules.length; i < len; i++) {\n\t\t\tconst rule = rules[i];\n\t\t\tif (rule.command && rule.command.charAt(0) === '-') {\n\t\t\t\tconst command = rule.command.substring(1);\n\t\t\t\tif (!removals.has(command)) {\n\t\t\t\t\tremovals.set(command, [rule]);\n\t\t\t\t} else {\n\t\t\t\t\tremovals.get(command)!.push(rule);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (removals.size === 0) {\n\t\t\t// There are no removals\n\t\t\treturn rules;\n\t\t}\n\n\t\t// Do a second pass and keep only non-removed keybindings\n\t\tconst result: ResolvedKeybindingItem[] = [];\n\t\tfor (let i = 0, len = rules.length; i < len; i++) {\n\t\t\tconst rule = rules[i];\n\n\t\t\tif (!rule.command || rule.command.length === 0) {\n\t\t\t\tresult.push(rule);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (rule.command.charAt(0) === '-') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst commandRemovals = removals.get(rule.command);\n\t\t\tif (!commandRemovals || !rule.isDefault) {\n\t\t\t\tresult.push(rule);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlet isRemoved = false;\n\t\t\tfor (const commandRemoval of commandRemovals) {\n\t\t\t\tconst when = commandRemoval.when;\n\t\t\t\tif (this._isTargetedForRemoval(rule, commandRemoval.chords, when)) {\n\t\t\t\t\tisRemoved = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!isRemoved) {\n\t\t\t\tresult.push(rule);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate _addKeyPress(keypress: string, item: ResolvedKeybindingItem): void {\n\n\t\tconst conflicts = this._map.get(keypress);\n\n\t\tif (typeof conflicts === 'undefined') {\n\t\t\t// There is no conflict so far\n\t\t\tthis._map.set(keypress, [item]);\n\t\t\tthis._addToLookupMap(item);\n\t\t\treturn;\n\t\t}\n\n\t\tfor (let i = conflicts.length - 1; i >= 0; i--) {\n\t\t\tconst conflict = conflicts[i];\n\n\t\t\tif (conflict.command === item.command) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Test if the shorter keybinding is a prefix of the longer one.\n\t\t\t// If the shorter keybinding is a prefix, it effectively will shadow the longer one and is considered a conflict.\n\t\t\tlet isShorterKbPrefix = true;\n\t\t\tfor (let i = 1; i < conflict.chords.length && i < item.chords.length; i++) {\n\t\t\t\tif (conflict.chords[i] !== item.chords[i]) {\n\t\t\t\t\t// The ith step does not conflict\n\t\t\t\t\tisShorterKbPrefix = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!isShorterKbPrefix) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (KeybindingResolver.whenIsEntirelyIncluded(conflict.when, item.when)) {\n\t\t\t\t// `item` completely overwrites `conflict`\n\t\t\t\t// Remove conflict from the lookupMap\n\t\t\t\tthis._removeFromLookupMap(conflict);\n\t\t\t}\n\t\t}\n\n\t\tconflicts.push(item);\n\t\tthis._addToLookupMap(item);\n\t}\n\n\tprivate _addToLookupMap(item: ResolvedKeybindingItem): void {\n\t\tif (!item.command) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet arr = this._lookupMap.get(item.command);\n\t\tif (typeof arr === 'undefined') {\n\t\t\tarr = [item];\n\t\t\tthis._lookupMap.set(item.command, arr);\n\t\t} else {\n\t\t\tarr.push(item);\n\t\t}\n\t}\n\n\tprivate _removeFromLookupMap(item: ResolvedKeybindingItem): void {\n\t\tif (!item.command) {\n\t\t\treturn;\n\t\t}\n\t\tconst arr = this._lookupMap.get(item.command);\n\t\tif (typeof arr === 'undefined') {\n\t\t\treturn;\n\t\t}\n\t\tfor (let i = 0, len = arr.length; i < len; i++) {\n\t\t\tif (arr[i] === item) {\n\t\t\t\tarr.splice(i, 1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Returns true if it is provable `a` implies `b`.\n\t */\n\tpublic static whenIsEntirelyIncluded(a: ContextKeyExpression | null | undefined, b: ContextKeyExpression | null | undefined): boolean {\n\t\tif (!b || b.type === ContextKeyExprType.True) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!a || a.type === ContextKeyExprType.True) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn implies(a, b);\n\t}\n\n\tpublic getDefaultBoundCommands(): Map<string, boolean> {\n\t\treturn this._defaultBoundCommands;\n\t}\n\n\tpublic getDefaultKeybindings(): readonly ResolvedKeybindingItem[] {\n\t\treturn this._defaultKeybindings;\n\t}\n\n\tpublic getKeybindings(): readonly ResolvedKeybindingItem[] {\n\t\treturn this._keybindings;\n\t}\n\n\tpublic lookupKeybindings(commandId: string): ResolvedKeybindingItem[] {\n\t\tconst items = this._lookupMap.get(commandId);\n\t\tif (typeof items === 'undefined' || items.length === 0) {\n\t\t\treturn [];\n\t\t}\n\n\t\t// Reverse to get the most specific item first\n\t\tconst result: ResolvedKeybindingItem[] = [];\n\t\tlet resultLen = 0;\n\t\tfor (let i = items.length - 1; i >= 0; i--) {\n\t\t\tresult[resultLen++] = items[i];\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic lookupPrimaryKeybinding(commandId: string, context: IContextKeyService): ResolvedKeybindingItem | null {\n\t\tconst items = this._lookupMap.get(commandId);\n\t\tif (typeof items === 'undefined' || items.length === 0) {\n\t\t\treturn null;\n\t\t}\n\t\tif (items.length === 1) {\n\t\t\treturn items[0];\n\t\t}\n\n\t\tfor (let i = items.length - 1; i >= 0; i--) {\n\t\t\tconst item = items[i];\n\t\t\tif (context.contextMatchesRules(item.when)) {\n\t\t\t\treturn item;\n\t\t\t}\n\t\t}\n\n\t\treturn items[items.length - 1];\n\t}\n\n\t/**\n\t * Looks up a keybinding trigged as a result of pressing a sequence of chords - `[...currentChords, keypress]`\n\t *\n\t * Example: resolving 3 chords pressed sequentially - `cmd+k cmd+p cmd+i`:\n\t * \t`currentChords = [ 'cmd+k' , 'cmd+p' ]` and `keypress = `cmd+i` - last pressed chord\n\t */\n\tpublic resolve(context: IContext, currentChords: string[], keypress: string): ResolutionResult {\n\n\t\tconst pressedChords = [...currentChords, keypress];\n\n\t\tthis._log(`| Resolving ${pressedChords}`);\n\n\t\tconst kbCandidates = this._map.get(pressedChords[0]);\n\t\tif (kbCandidates === undefined) {\n\t\t\t// No bindings with such 0-th chord\n\t\t\tthis._log(`\\\\ No keybinding entries.`);\n\t\t\treturn NoMatchingKb;\n\t\t}\n\n\t\tlet lookupMap: ResolvedKeybindingItem[] | null = null;\n\n\t\tif (pressedChords.length < 2) {\n\t\t\tlookupMap = kbCandidates;\n\t\t} else {\n\t\t\t// Fetch all chord bindings for `currentChords`\n\t\t\tlookupMap = [];\n\t\t\tfor (let i = 0, len = kbCandidates.length; i < len; i++) {\n\n\t\t\t\tconst candidate = kbCandidates[i];\n\n\t\t\t\tif (pressedChords.length > candidate.chords.length) { // # of pressed chords can't be less than # of chords in a keybinding to invoke\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tlet prefixMatches = true;\n\t\t\t\tfor (let i = 1; i < pressedChords.length; i++) {\n\t\t\t\t\tif (candidate.chords[i] !== pressedChords[i]) {\n\t\t\t\t\t\tprefixMatches = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (prefixMatches) {\n\t\t\t\t\tlookupMap.push(candidate);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// check there's a keybinding with a matching when clause\n\t\tconst result = this._findCommand(context, lookupMap);\n\t\tif (!result) {\n\t\t\tthis._log(`\\\\ From ${lookupMap.length} keybinding entries, no when clauses matched the context.`);\n\t\t\treturn NoMatchingKb;\n\t\t}\n\n\t\t// check we got all chords necessary to be sure a particular keybinding needs to be invoked\n\t\tif (pressedChords.length < result.chords.length) {\n\t\t\t// The chord sequence is not complete\n\t\t\tthis._log(`\\\\ From ${lookupMap.length} keybinding entries, awaiting ${result.chords.length - pressedChords.length} more chord(s), when: ${printWhenExplanation(result.when)}, source: ${printSourceExplanation(result)}.`);\n\t\t\treturn MoreChordsNeeded;\n\t\t}\n\n\t\tthis._log(`\\\\ From ${lookupMap.length} keybinding entries, matched ${result.command}, when: ${printWhenExplanation(result.when)}, source: ${printSourceExplanation(result)}.`);\n\n\t\treturn KbFound(result.command, result.commandArgs, result.bubble);\n\t}\n\n\tprivate _findCommand(context: IContext, matches: ResolvedKeybindingItem[]): ResolvedKeybindingItem | null {\n\t\tfor (let i = matches.length - 1; i >= 0; i--) {\n\t\t\tconst k = matches[i];\n\n\t\t\tif (!KeybindingResolver._contextMatchesRules(context, k.when)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\treturn k;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate static _contextMatchesRules(context: IContext, rules: ContextKeyExpression | null | undefined): boolean {\n\t\tif (!rules) {\n\t\t\treturn true;\n\t\t}\n\t\treturn rules.evaluate(context);\n\t}\n}\n\nfunction printWhenExplanation(when: ContextKeyExpression | undefined): string {\n\tif (!when) {\n\t\treturn `no when condition`;\n\t}\n\treturn `${when.serialize()}`;\n}\n\nfunction printSourceExplanation(kb: ResolvedKeybindingItem): string {\n\treturn (\n\t\tkb.extensionId\n\t\t\t? (kb.isBuiltinExtension ? `built-in extension ${kb.extensionId}` : `user extension ${kb.extensionId}`)\n\t\t\t: (kb.isDefault ? `built-in` : `user`)\n\t);\n}\n"]}