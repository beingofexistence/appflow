{"version":3,"sources":["vs/platform/contextkey/common/contextkey.ts"],"names":[],"mappings":"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","file":"contextkey.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from 'vs/base/common/charCode';\nimport { Event } from 'vs/base/common/event';\nimport { isChrome, isEdge, isFirefox, isLinux, isMacintosh, isSafari, isWeb, isWindows } from 'vs/base/common/platform';\nimport { isFalsyOrWhitespace } from 'vs/base/common/strings';\nimport { Scanner, LexingError, Token, TokenType } from 'vs/platform/contextkey/common/scanner';\nimport { createDecorator } from 'vs/platform/instantiation/common/instantiation';\nimport { localize } from 'vs/nls';\nimport { IDisposable } from 'vs/base/common/lifecycle';\nimport { illegalArgument } from 'vs/base/common/errors';\n\nconst CONSTANT_VALUES = new Map<string, boolean>();\nCONSTANT_VALUES.set('false', false);\nCONSTANT_VALUES.set('true', true);\nCONSTANT_VALUES.set('isMac', isMacintosh);\nCONSTANT_VALUES.set('isLinux', isLinux);\nCONSTANT_VALUES.set('isWindows', isWindows);\nCONSTANT_VALUES.set('isWeb', isWeb);\nCONSTANT_VALUES.set('isMacNative', isMacintosh && !isWeb);\nCONSTANT_VALUES.set('isEdge', isEdge);\nCONSTANT_VALUES.set('isFirefox', isFirefox);\nCONSTANT_VALUES.set('isChrome', isChrome);\nCONSTANT_VALUES.set('isSafari', isSafari);\n\n/** allow register constant context keys that are known only after startup; requires running `substituteConstants` on the context key - https://github.com/microsoft/vscode/issues/174218#issuecomment-1437972127 */\nexport function setConstant(key: string, value: boolean) {\n\tif (CONSTANT_VALUES.get(key) !== undefined) { throw illegalArgument('contextkey.setConstant(k, v) invoked with already set constant `k`'); }\n\n\tCONSTANT_VALUES.set(key, value);\n}\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\nexport const enum ContextKeyExprType {\n\tFalse = 0,\n\tTrue = 1,\n\tDefined = 2,\n\tNot = 3,\n\tEquals = 4,\n\tNotEquals = 5,\n\tAnd = 6,\n\tRegex = 7,\n\tNotRegex = 8,\n\tOr = 9,\n\tIn = 10,\n\tNotIn = 11,\n\tGreater = 12,\n\tGreaterEquals = 13,\n\tSmaller = 14,\n\tSmallerEquals = 15,\n}\n\nexport interface IContextKeyExprMapper {\n\tmapDefined(key: string): ContextKeyExpression;\n\tmapNot(key: string): ContextKeyExpression;\n\tmapEquals(key: string, value: any): ContextKeyExpression;\n\tmapNotEquals(key: string, value: any): ContextKeyExpression;\n\tmapGreater(key: string, value: any): ContextKeyExpression;\n\tmapGreaterEquals(key: string, value: any): ContextKeyExpression;\n\tmapSmaller(key: string, value: any): ContextKeyExpression;\n\tmapSmallerEquals(key: string, value: any): ContextKeyExpression;\n\tmapRegex(key: string, regexp: RegExp | null): ContextKeyRegexExpr;\n\tmapIn(key: string, valueKey: string): ContextKeyInExpr;\n\tmapNotIn(key: string, valueKey: string): ContextKeyNotInExpr;\n}\n\nexport interface IContextKeyExpression {\n\tcmp(other: ContextKeyExpression): number;\n\tequals(other: ContextKeyExpression): boolean;\n\tsubstituteConstants(): ContextKeyExpression | undefined;\n\tevaluate(context: IContext): boolean;\n\tserialize(): string;\n\tkeys(): string[];\n\tmap(mapFnc: IContextKeyExprMapper): ContextKeyExpression;\n\tnegate(): ContextKeyExpression;\n\n}\n\nexport type ContextKeyExpression = (\n\tContextKeyFalseExpr | ContextKeyTrueExpr | ContextKeyDefinedExpr | ContextKeyNotExpr\n\t| ContextKeyEqualsExpr | ContextKeyNotEqualsExpr | ContextKeyRegexExpr\n\t| ContextKeyNotRegexExpr | ContextKeyAndExpr | ContextKeyOrExpr | ContextKeyInExpr\n\t| ContextKeyNotInExpr | ContextKeyGreaterExpr | ContextKeyGreaterEqualsExpr\n\t| ContextKeySmallerExpr | ContextKeySmallerEqualsExpr\n);\n\n\n/*\n\nSyntax grammar:\n\n```ebnf\n\nexpression ::= or\n\nor ::= and { '||' and }*\n\nand ::= term { '&&' term }*\n\nterm ::=\n\t| '!' (KEY | true | false | parenthesized)\n\t| primary\n\nprimary ::=\n\t| 'true'\n\t| 'false'\n\t| parenthesized\n\t| KEY '=~' REGEX\n\t| KEY [ ('==' | '!=' | '<' | '<=' | '>' | '>=' | 'not' 'in' | 'in') value ]\n\nparenthesized ::=\n\t| '(' expression ')'\n\nvalue ::=\n\t| 'true'\n\t| 'false'\n\t| 'in'      \t// we support `in` as a value because there's an extension that uses it, ie \"when\": \"languageId == in\"\n\t| VALUE \t\t// matched by the same regex as KEY; consider putting the value in single quotes if it's a string (e.g., with spaces)\n\t| SINGLE_QUOTED_STR\n\t| EMPTY_STR  \t// this allows \"when\": \"foo == \" which's used by existing extensions\n\n```\n*/\n\nexport type ParserConfig = {\n\t/**\n\t * with this option enabled, the parser can recover from regex parsing errors, e.g., unescaped slashes: `/src//` is accepted as `/src\\//` would be\n\t */\n\tregexParsingWithErrorRecovery: boolean;\n};\n\nconst defaultConfig: ParserConfig = {\n\tregexParsingWithErrorRecovery: true\n};\n\nexport type ParsingError = {\n\tmessage: string;\n\toffset: number;\n\tlexeme: string;\n\tadditionalInfo?: string;\n};\n\nconst errorEmptyString = localize('contextkey.parser.error.emptyString', \"Empty context key expression\");\nconst hintEmptyString = localize('contextkey.parser.error.emptyString.hint', \"Did you forget to write an expression? You can also put 'false' or 'true' to always evaluate to false or true, respectively.\");\nconst errorNoInAfterNot = localize('contextkey.parser.error.noInAfterNot', \"'in' after 'not'.\");\nconst errorClosingParenthesis = localize('contextkey.parser.error.closingParenthesis', \"closing parenthesis ')'\");\nconst errorUnexpectedToken = localize('contextkey.parser.error.unexpectedToken', \"Unexpected token\");\nconst hintUnexpectedToken = localize('contextkey.parser.error.unexpectedToken.hint', \"Did you forget to put && or || before the token?\");\nconst errorUnexpectedEOF = localize('contextkey.parser.error.unexpectedEOF', \"Unexpected end of expression\");\nconst hintUnexpectedEOF = localize('contextkey.parser.error.unexpectedEOF.hint', \"Did you forget to put a context key?\");\n\n/**\n * A parser for context key expressions.\n *\n * Example:\n * ```ts\n * const parser = new Parser();\n * const expr = parser.parse('foo == \"bar\" && baz == true');\n *\n * if (expr === undefined) {\n * \t// there were lexing or parsing errors\n * \t// process lexing errors with `parser.lexingErrors`\n *  // process parsing errors with `parser.parsingErrors`\n * } else {\n * \t// expr is a valid expression\n * }\n * ```\n */\nexport class Parser {\n\t// Note: this doesn't produce an exact syntax tree but a normalized one\n\t// ContextKeyExpression's that we use as AST nodes do not expose constructors that do not normalize\n\n\tprivate static _parseError = new Error();\n\n\t// lifetime note: `_scanner` lives as long as the parser does, i.e., is not reset between calls to `parse`\n\tprivate readonly _scanner = new Scanner();\n\n\t// lifetime note: `_tokens`, `_current`, and `_parsingErrors` must be reset between calls to `parse`\n\tprivate _tokens: Token[] = [];\n\tprivate _current = 0; \t\t\t\t\t// invariant: 0 <= this._current < this._tokens.length ; any incrementation of this value must first call `_isAtEnd`\n\tprivate _parsingErrors: ParsingError[] = [];\n\n\tget lexingErrors(): Readonly<LexingError[]> {\n\t\treturn this._scanner.errors;\n\t}\n\n\tget parsingErrors(): Readonly<ParsingError[]> {\n\t\treturn this._parsingErrors;\n\t}\n\n\tconstructor(private readonly _config: ParserConfig = defaultConfig) {\n\t}\n\n\t/**\n\t * Parse a context key expression.\n\t *\n\t * @param input the expression to parse\n\t * @returns the parsed expression or `undefined` if there's an error - call `lexingErrors` and `parsingErrors` to see the errors\n\t */\n\tparse(input: string): ContextKeyExpression | undefined {\n\n\t\tif (input === '') {\n\t\t\tthis._parsingErrors.push({ message: errorEmptyString, offset: 0, lexeme: '', additionalInfo: hintEmptyString });\n\t\t\treturn undefined;\n\t\t}\n\n\t\tthis._tokens = this._scanner.reset(input).scan();\n\t\t// @ulugbekna: we do not stop parsing if there are lexing errors to be able to reconstruct regexes with unescaped slashes; TODO@ulugbekna: make this respect config option for recovery\n\n\t\tthis._current = 0;\n\t\tthis._parsingErrors = [];\n\n\t\ttry {\n\t\t\tconst expr = this._expr();\n\t\t\tif (!this._isAtEnd()) {\n\t\t\t\tconst peek = this._peek();\n\t\t\t\tconst additionalInfo = peek.type === TokenType.Str ? hintUnexpectedToken : undefined;\n\t\t\t\tthis._parsingErrors.push({ message: errorUnexpectedToken, offset: peek.offset, lexeme: Scanner.getLexeme(peek), additionalInfo });\n\t\t\t\tthrow Parser._parseError;\n\t\t\t}\n\t\t\treturn expr;\n\t\t} catch (e) {\n\t\t\tif (!(e === Parser._parseError)) {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\tprivate _expr(): ContextKeyExpression | undefined {\n\t\treturn this._or();\n\t}\n\n\tprivate _or(): ContextKeyExpression | undefined {\n\t\tconst expr = [this._and()];\n\n\t\twhile (this._matchOne(TokenType.Or)) {\n\t\t\tconst right = this._and();\n\t\t\texpr.push(right);\n\t\t}\n\n\t\treturn expr.length === 1 ? expr[0] : ContextKeyExpr.or(...expr);\n\t}\n\n\tprivate _and(): ContextKeyExpression | undefined {\n\t\tconst expr = [this._term()];\n\n\t\twhile (this._matchOne(TokenType.And)) {\n\t\t\tconst right = this._term();\n\t\t\texpr.push(right);\n\t\t}\n\n\t\treturn expr.length === 1 ? expr[0] : ContextKeyExpr.and(...expr);\n\t}\n\n\tprivate _term(): ContextKeyExpression | undefined {\n\t\tif (this._matchOne(TokenType.Neg)) {\n\t\t\tconst peek = this._peek();\n\t\t\tswitch (peek.type) {\n\t\t\t\tcase TokenType.True:\n\t\t\t\t\tthis._advance();\n\t\t\t\t\treturn ContextKeyFalseExpr.INSTANCE;\n\t\t\t\tcase TokenType.False:\n\t\t\t\t\tthis._advance();\n\t\t\t\t\treturn ContextKeyTrueExpr.INSTANCE;\n\t\t\t\tcase TokenType.LParen: {\n\t\t\t\t\tthis._advance();\n\t\t\t\t\tconst expr = this._expr();\n\t\t\t\t\tthis._consume(TokenType.RParen, errorClosingParenthesis);\n\t\t\t\t\treturn expr?.negate();\n\t\t\t\t}\n\t\t\t\tcase TokenType.Str:\n\t\t\t\t\tthis._advance();\n\t\t\t\t\treturn ContextKeyNotExpr.create(peek.lexeme);\n\t\t\t\tdefault:\n\t\t\t\t\tthrow this._errExpectedButGot(`KEY | true | false | '(' expression ')'`, peek);\n\t\t\t}\n\t\t}\n\t\treturn this._primary();\n\t}\n\n\tprivate _primary(): ContextKeyExpression | undefined {\n\n\t\tconst peek = this._peek();\n\t\tswitch (peek.type) {\n\t\t\tcase TokenType.True:\n\t\t\t\tthis._advance();\n\t\t\t\treturn ContextKeyExpr.true();\n\n\t\t\tcase TokenType.False:\n\t\t\t\tthis._advance();\n\t\t\t\treturn ContextKeyExpr.false();\n\n\t\t\tcase TokenType.LParen: {\n\t\t\t\tthis._advance();\n\t\t\t\tconst expr = this._expr();\n\t\t\t\tthis._consume(TokenType.RParen, errorClosingParenthesis);\n\t\t\t\treturn expr;\n\t\t\t}\n\n\t\t\tcase TokenType.Str: {\n\t\t\t\t// KEY\n\t\t\t\tconst key = peek.lexeme;\n\t\t\t\tthis._advance();\n\n\t\t\t\t// =~ regex\n\t\t\t\tif (this._matchOne(TokenType.RegexOp)) {\n\n\t\t\t\t\t// @ulugbekna: we need to reconstruct the regex from the tokens because some extensions use unescaped slashes in regexes\n\t\t\t\t\tconst expr = this._peek();\n\n\t\t\t\t\tif (!this._config.regexParsingWithErrorRecovery) {\n\t\t\t\t\t\tthis._advance();\n\t\t\t\t\t\tif (expr.type !== TokenType.RegexStr) {\n\t\t\t\t\t\t\tthrow this._errExpectedButGot(`REGEX`, expr);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst regexLexeme = expr.lexeme;\n\t\t\t\t\t\tconst closingSlashIndex = regexLexeme.lastIndexOf('/');\n\t\t\t\t\t\tconst flags = closingSlashIndex === regexLexeme.length - 1 ? undefined : this._removeFlagsGY(regexLexeme.substring(closingSlashIndex + 1));\n\t\t\t\t\t\tlet regexp: RegExp | null;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tregexp = new RegExp(regexLexeme.substring(1, closingSlashIndex), flags);\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\tthrow this._errExpectedButGot(`REGEX`, expr);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn ContextKeyRegexExpr.create(key, regexp);\n\t\t\t\t\t}\n\n\t\t\t\t\tswitch (expr.type) {\n\t\t\t\t\t\tcase TokenType.RegexStr:\n\t\t\t\t\t\tcase TokenType.Error: { // also handle an ErrorToken in case of smth such as /(/file)/\n\t\t\t\t\t\t\tconst lexemeReconstruction = [expr.lexeme]; // /REGEX/ or /REGEX/FLAGS\n\t\t\t\t\t\t\tthis._advance();\n\n\t\t\t\t\t\t\tlet followingToken = this._peek();\n\t\t\t\t\t\t\tlet parenBalance = 0;\n\t\t\t\t\t\t\tfor (let i = 0; i < expr.lexeme.length; i++) {\n\t\t\t\t\t\t\t\tif (expr.lexeme.charCodeAt(i) === CharCode.OpenParen) {\n\t\t\t\t\t\t\t\t\tparenBalance++;\n\t\t\t\t\t\t\t\t} else if (expr.lexeme.charCodeAt(i) === CharCode.CloseParen) {\n\t\t\t\t\t\t\t\t\tparenBalance--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\twhile (!this._isAtEnd() && followingToken.type !== TokenType.And && followingToken.type !== TokenType.Or) {\n\t\t\t\t\t\t\t\tswitch (followingToken.type) {\n\t\t\t\t\t\t\t\t\tcase TokenType.LParen:\n\t\t\t\t\t\t\t\t\t\tparenBalance++;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase TokenType.RParen:\n\t\t\t\t\t\t\t\t\t\tparenBalance--;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase TokenType.RegexStr:\n\t\t\t\t\t\t\t\t\tcase TokenType.QuotedStr:\n\t\t\t\t\t\t\t\t\t\tfor (let i = 0; i < followingToken.lexeme.length; i++) {\n\t\t\t\t\t\t\t\t\t\t\tif (followingToken.lexeme.charCodeAt(i) === CharCode.OpenParen) {\n\t\t\t\t\t\t\t\t\t\t\t\tparenBalance++;\n\t\t\t\t\t\t\t\t\t\t\t} else if (expr.lexeme.charCodeAt(i) === CharCode.CloseParen) {\n\t\t\t\t\t\t\t\t\t\t\t\tparenBalance--;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (parenBalance < 0) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlexemeReconstruction.push(Scanner.getLexeme(followingToken));\n\t\t\t\t\t\t\t\tthis._advance();\n\t\t\t\t\t\t\t\tfollowingToken = this._peek();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tconst regexLexeme = lexemeReconstruction.join('');\n\t\t\t\t\t\t\tconst closingSlashIndex = regexLexeme.lastIndexOf('/');\n\t\t\t\t\t\t\tconst flags = closingSlashIndex === regexLexeme.length - 1 ? undefined : this._removeFlagsGY(regexLexeme.substring(closingSlashIndex + 1));\n\t\t\t\t\t\t\tlet regexp: RegExp | null;\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tregexp = new RegExp(regexLexeme.substring(1, closingSlashIndex), flags);\n\t\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\t\tthrow this._errExpectedButGot(`REGEX`, expr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn ContextKeyExpr.regex(key, regexp);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcase TokenType.QuotedStr: {\n\t\t\t\t\t\t\tconst serializedValue = expr.lexeme;\n\t\t\t\t\t\t\tthis._advance();\n\t\t\t\t\t\t\t// replicate old regex parsing behavior\n\n\t\t\t\t\t\t\tlet regex: RegExp | null = null;\n\n\t\t\t\t\t\t\tif (!isFalsyOrWhitespace(serializedValue)) {\n\t\t\t\t\t\t\t\tconst start = serializedValue.indexOf('/');\n\t\t\t\t\t\t\t\tconst end = serializedValue.lastIndexOf('/');\n\t\t\t\t\t\t\t\tif (start !== end && start >= 0) {\n\n\t\t\t\t\t\t\t\t\tconst value = serializedValue.slice(start + 1, end);\n\t\t\t\t\t\t\t\t\tconst caseIgnoreFlag = serializedValue[end + 1] === 'i' ? 'i' : '';\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tregex = new RegExp(value, caseIgnoreFlag);\n\t\t\t\t\t\t\t\t\t} catch (_e) {\n\t\t\t\t\t\t\t\t\t\tthrow this._errExpectedButGot(`REGEX`, expr);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (regex === null) {\n\t\t\t\t\t\t\t\tthrow this._errExpectedButGot('REGEX', expr);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn ContextKeyRegexExpr.create(key, regex);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthrow this._errExpectedButGot('REGEX', this._peek());\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// [ 'not' 'in' value ]\n\t\t\t\tif (this._matchOne(TokenType.Not)) {\n\t\t\t\t\tthis._consume(TokenType.In, errorNoInAfterNot);\n\t\t\t\t\tconst right = this._value();\n\t\t\t\t\treturn ContextKeyExpr.notIn(key, right);\n\t\t\t\t}\n\n\t\t\t\t// [ ('==' | '!=' | '<' | '<=' | '>' | '>=' | 'in') value ]\n\t\t\t\tconst maybeOp = this._peek().type;\n\t\t\t\tswitch (maybeOp) {\n\t\t\t\t\tcase TokenType.Eq: {\n\t\t\t\t\t\tthis._advance();\n\n\t\t\t\t\t\tconst right = this._value();\n\t\t\t\t\t\tif (this._previous().type === TokenType.QuotedStr) { // to preserve old parser behavior: \"foo == 'true'\" is preserved as \"foo == 'true'\", but \"foo == true\" is optimized as \"foo\"\n\t\t\t\t\t\t\treturn ContextKeyExpr.equals(key, right);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tswitch (right) {\n\t\t\t\t\t\t\tcase 'true':\n\t\t\t\t\t\t\t\treturn ContextKeyExpr.has(key);\n\t\t\t\t\t\t\tcase 'false':\n\t\t\t\t\t\t\t\treturn ContextKeyExpr.not(key);\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\treturn ContextKeyExpr.equals(key, right);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcase TokenType.NotEq: {\n\t\t\t\t\t\tthis._advance();\n\n\t\t\t\t\t\tconst right = this._value();\n\t\t\t\t\t\tif (this._previous().type === TokenType.QuotedStr) { // same as above with \"foo != 'true'\"\n\t\t\t\t\t\t\treturn ContextKeyExpr.notEquals(key, right);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tswitch (right) {\n\t\t\t\t\t\t\tcase 'true':\n\t\t\t\t\t\t\t\treturn ContextKeyExpr.not(key);\n\t\t\t\t\t\t\tcase 'false':\n\t\t\t\t\t\t\t\treturn ContextKeyExpr.has(key);\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\treturn ContextKeyExpr.notEquals(key, right);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// TODO: ContextKeyExpr.smaller(key, right) accepts only `number` as `right` AND during eval of this node, we just eval to `false` if `right` is not a number\n\t\t\t\t\t// consequently, package.json linter should _warn_ the user if they're passing undesired things to ops\n\t\t\t\t\tcase TokenType.Lt:\n\t\t\t\t\t\tthis._advance();\n\t\t\t\t\t\treturn ContextKeySmallerExpr.create(key, this._value());\n\n\t\t\t\t\tcase TokenType.LtEq:\n\t\t\t\t\t\tthis._advance();\n\t\t\t\t\t\treturn ContextKeySmallerEqualsExpr.create(key, this._value());\n\n\t\t\t\t\tcase TokenType.Gt:\n\t\t\t\t\t\tthis._advance();\n\t\t\t\t\t\treturn ContextKeyGreaterExpr.create(key, this._value());\n\n\t\t\t\t\tcase TokenType.GtEq:\n\t\t\t\t\t\tthis._advance();\n\t\t\t\t\t\treturn ContextKeyGreaterEqualsExpr.create(key, this._value());\n\n\t\t\t\t\tcase TokenType.In:\n\t\t\t\t\t\tthis._advance();\n\t\t\t\t\t\treturn ContextKeyExpr.in(key, this._value());\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn ContextKeyExpr.has(key);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcase TokenType.EOF:\n\t\t\t\tthis._parsingErrors.push({ message: errorUnexpectedEOF, offset: peek.offset, lexeme: '', additionalInfo: hintUnexpectedEOF });\n\t\t\t\tthrow Parser._parseError;\n\n\t\t\tdefault:\n\t\t\t\tthrow this._errExpectedButGot(`true | false | KEY \\n\\t| KEY '=~' REGEX \\n\\t| KEY ('==' | '!=' | '<' | '<=' | '>' | '>=' | 'in' | 'not' 'in') value`, this._peek());\n\n\t\t}\n\t}\n\n\tprivate _value(): string {\n\t\tconst token = this._peek();\n\t\tswitch (token.type) {\n\t\t\tcase TokenType.Str:\n\t\t\tcase TokenType.QuotedStr:\n\t\t\t\tthis._advance();\n\t\t\t\treturn token.lexeme;\n\t\t\tcase TokenType.True:\n\t\t\t\tthis._advance();\n\t\t\t\treturn 'true';\n\t\t\tcase TokenType.False:\n\t\t\t\tthis._advance();\n\t\t\t\treturn 'false';\n\t\t\tcase TokenType.In: // we support `in` as a value, e.g., \"when\": \"languageId == in\" - exists in existing extensions\n\t\t\t\tthis._advance();\n\t\t\t\treturn 'in';\n\t\t\tdefault:\n\t\t\t\t// this allows \"when\": \"foo == \" which's used by existing extensions\n\t\t\t\t// we do not call `_advance` on purpose - we don't want to eat unintended tokens\n\t\t\t\treturn '';\n\t\t}\n\t}\n\n\tprivate _flagsGYRe = /g|y/g;\n\tprivate _removeFlagsGY(flags: string): string {\n\t\treturn flags.replaceAll(this._flagsGYRe, '');\n\t}\n\n\t// careful: this can throw if current token is the initial one (ie index = 0)\n\tprivate _previous() {\n\t\treturn this._tokens[this._current - 1];\n\t}\n\n\tprivate _matchOne(token: TokenType) {\n\t\tif (this._check(token)) {\n\t\t\tthis._advance();\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tprivate _advance() {\n\t\tif (!this._isAtEnd()) {\n\t\t\tthis._current++;\n\t\t}\n\t\treturn this._previous();\n\t}\n\n\tprivate _consume(type: TokenType, message: string) {\n\t\tif (this._check(type)) {\n\t\t\treturn this._advance();\n\t\t}\n\n\t\tthrow this._errExpectedButGot(message, this._peek());\n\t}\n\n\tprivate _errExpectedButGot(expected: string, got: Token, additionalInfo?: string) {\n\t\tconst message = localize('contextkey.parser.error.expectedButGot', \"Expected: {0}\\nReceived: '{1}'.\", expected, Scanner.getLexeme(got));\n\t\tconst offset = got.offset;\n\t\tconst lexeme = Scanner.getLexeme(got);\n\t\tthis._parsingErrors.push({ message, offset, lexeme, additionalInfo });\n\t\treturn Parser._parseError;\n\t}\n\n\tprivate _check(type: TokenType) {\n\t\treturn this._peek().type === type;\n\t}\n\n\tprivate _peek() {\n\t\treturn this._tokens[this._current];\n\t}\n\n\tprivate _isAtEnd() {\n\t\treturn this._peek().type === TokenType.EOF;\n\t}\n}\n\nexport abstract class ContextKeyExpr {\n\n\tpublic static false(): ContextKeyExpression {\n\t\treturn ContextKeyFalseExpr.INSTANCE;\n\t}\n\tpublic static true(): ContextKeyExpression {\n\t\treturn ContextKeyTrueExpr.INSTANCE;\n\t}\n\tpublic static has(key: string): ContextKeyExpression {\n\t\treturn ContextKeyDefinedExpr.create(key);\n\t}\n\tpublic static equals(key: string, value: any): ContextKeyExpression {\n\t\treturn ContextKeyEqualsExpr.create(key, value);\n\t}\n\tpublic static notEquals(key: string, value: any): ContextKeyExpression {\n\t\treturn ContextKeyNotEqualsExpr.create(key, value);\n\t}\n\tpublic static regex(key: string, value: RegExp): ContextKeyExpression {\n\t\treturn ContextKeyRegexExpr.create(key, value);\n\t}\n\tpublic static in(key: string, value: string): ContextKeyExpression {\n\t\treturn ContextKeyInExpr.create(key, value);\n\t}\n\tpublic static notIn(key: string, value: string): ContextKeyExpression {\n\t\treturn ContextKeyNotInExpr.create(key, value);\n\t}\n\tpublic static not(key: string): ContextKeyExpression {\n\t\treturn ContextKeyNotExpr.create(key);\n\t}\n\tpublic static and(...expr: Array<ContextKeyExpression | undefined | null>): ContextKeyExpression | undefined {\n\t\treturn ContextKeyAndExpr.create(expr, null, true);\n\t}\n\tpublic static or(...expr: Array<ContextKeyExpression | undefined | null>): ContextKeyExpression | undefined {\n\t\treturn ContextKeyOrExpr.create(expr, null, true);\n\t}\n\tpublic static greater(key: string, value: number): ContextKeyExpression {\n\t\treturn ContextKeyGreaterExpr.create(key, value);\n\t}\n\tpublic static greaterEquals(key: string, value: number): ContextKeyExpression {\n\t\treturn ContextKeyGreaterEqualsExpr.create(key, value);\n\t}\n\tpublic static smaller(key: string, value: number): ContextKeyExpression {\n\t\treturn ContextKeySmallerExpr.create(key, value);\n\t}\n\tpublic static smallerEquals(key: string, value: number): ContextKeyExpression {\n\t\treturn ContextKeySmallerEqualsExpr.create(key, value);\n\t}\n\n\tprivate static _parser = new Parser({ regexParsingWithErrorRecovery: false });\n\tpublic static deserialize(serialized: string | null | undefined): ContextKeyExpression | undefined {\n\t\tif (serialized === undefined || serialized === null) { // an empty string needs to be handled by the parser to get a corresponding parsing error reported\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst expr = this._parser.parse(serialized);\n\t\treturn expr;\n\t}\n\n}\n\n\nexport function validateWhenClauses(whenClauses: string[]): any {\n\n\tconst parser = new Parser({ regexParsingWithErrorRecovery: false }); // we run with no recovery to guide users to use correct regexes\n\n\treturn whenClauses.map(whenClause => {\n\t\tparser.parse(whenClause);\n\n\t\tif (parser.lexingErrors.length > 0) {\n\t\t\treturn parser.lexingErrors.map((se: LexingError) => ({\n\t\t\t\terrorMessage: se.additionalInfo ?\n\t\t\t\t\tlocalize('contextkey.scanner.errorForLinterWithHint', \"Unexpected token. Hint: {0}\", se.additionalInfo) :\n\t\t\t\t\tlocalize('contextkey.scanner.errorForLinter', \"Unexpected token.\"),\n\t\t\t\toffset: se.offset,\n\t\t\t\tlength: se.lexeme.length,\n\t\t\t}));\n\t\t} else if (parser.parsingErrors.length > 0) {\n\t\t\treturn parser.parsingErrors.map((pe: ParsingError) => ({\n\t\t\t\terrorMessage: pe.additionalInfo ? `${pe.message}. ${pe.additionalInfo}` : pe.message,\n\t\t\t\toffset: pe.offset,\n\t\t\t\tlength: pe.lexeme.length,\n\t\t\t}));\n\t\t} else {\n\t\t\treturn [];\n\t\t}\n\t});\n}\n\nexport function expressionsAreEqualWithConstantSubstitution(a: ContextKeyExpression | null | undefined, b: ContextKeyExpression | null | undefined): boolean {\n\tconst aExpr = a ? a.substituteConstants() : undefined;\n\tconst bExpr = b ? b.substituteConstants() : undefined;\n\tif (!aExpr && !bExpr) {\n\t\treturn true;\n\t}\n\tif (!aExpr || !bExpr) {\n\t\treturn false;\n\t}\n\treturn aExpr.equals(bExpr);\n}\n\nfunction cmp(a: ContextKeyExpression, b: ContextKeyExpression): number {\n\treturn a.cmp(b);\n}\n\nexport class ContextKeyFalseExpr implements IContextKeyExpression {\n\tpublic static INSTANCE = new ContextKeyFalseExpr();\n\n\tpublic readonly type = ContextKeyExprType.False;\n\n\tprotected constructor() {\n\t}\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\treturn this.type - other.type;\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\treturn (other.type === this.type);\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\treturn this;\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\treturn false;\n\t}\n\n\tpublic serialize(): string {\n\t\treturn 'false';\n\t}\n\n\tpublic keys(): string[] {\n\t\treturn [];\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyExpression {\n\t\treturn this;\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\treturn ContextKeyTrueExpr.INSTANCE;\n\t}\n}\n\nexport class ContextKeyTrueExpr implements IContextKeyExpression {\n\tpublic static INSTANCE = new ContextKeyTrueExpr();\n\n\tpublic readonly type = ContextKeyExprType.True;\n\n\tprotected constructor() {\n\t}\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\treturn this.type - other.type;\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\treturn (other.type === this.type);\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\treturn this;\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\treturn true;\n\t}\n\n\tpublic serialize(): string {\n\t\treturn 'true';\n\t}\n\n\tpublic keys(): string[] {\n\t\treturn [];\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyExpression {\n\t\treturn this;\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\treturn ContextKeyFalseExpr.INSTANCE;\n\t}\n}\n\nexport class ContextKeyDefinedExpr implements IContextKeyExpression {\n\tpublic static create(key: string, negated: ContextKeyExpression | null = null): ContextKeyExpression {\n\t\tconst constantValue = CONSTANT_VALUES.get(key);\n\t\tif (typeof constantValue === 'boolean') {\n\t\t\treturn constantValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;\n\t\t}\n\t\treturn new ContextKeyDefinedExpr(key, negated);\n\t}\n\n\tpublic readonly type = ContextKeyExprType.Defined;\n\n\tprotected constructor(\n\t\treadonly key: string,\n\t\tprivate negated: ContextKeyExpression | null\n\t) {\n\t}\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\tif (other.type !== this.type) {\n\t\t\treturn this.type - other.type;\n\t\t}\n\t\treturn cmp1(this.key, other.key);\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\tif (other.type === this.type) {\n\t\t\treturn (this.key === other.key);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\tconst constantValue = CONSTANT_VALUES.get(this.key);\n\t\tif (typeof constantValue === 'boolean') {\n\t\t\treturn constantValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;\n\t\t}\n\t\treturn this;\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\treturn (!!context.getValue(this.key));\n\t}\n\n\tpublic serialize(): string {\n\t\treturn this.key;\n\t}\n\n\tpublic keys(): string[] {\n\t\treturn [this.key];\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyExpression {\n\t\treturn mapFnc.mapDefined(this.key);\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\tif (!this.negated) {\n\t\t\tthis.negated = ContextKeyNotExpr.create(this.key, this);\n\t\t}\n\t\treturn this.negated;\n\t}\n}\n\nexport class ContextKeyEqualsExpr implements IContextKeyExpression {\n\n\tpublic static create(key: string, value: any, negated: ContextKeyExpression | null = null): ContextKeyExpression {\n\t\tif (typeof value === 'boolean') {\n\t\t\treturn (value ? ContextKeyDefinedExpr.create(key, negated) : ContextKeyNotExpr.create(key, negated));\n\t\t}\n\t\tconst constantValue = CONSTANT_VALUES.get(key);\n\t\tif (typeof constantValue === 'boolean') {\n\t\t\tconst trueValue = constantValue ? 'true' : 'false';\n\t\t\treturn (value === trueValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE);\n\t\t}\n\t\treturn new ContextKeyEqualsExpr(key, value, negated);\n\t}\n\n\tpublic readonly type = ContextKeyExprType.Equals;\n\n\tprivate constructor(\n\t\tprivate readonly key: string,\n\t\tprivate readonly value: any,\n\t\tprivate negated: ContextKeyExpression | null\n\t) {\n\t}\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\tif (other.type !== this.type) {\n\t\t\treturn this.type - other.type;\n\t\t}\n\t\treturn cmp2(this.key, this.value, other.key, other.value);\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\tif (other.type === this.type) {\n\t\t\treturn (this.key === other.key && this.value === other.value);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\tconst constantValue = CONSTANT_VALUES.get(this.key);\n\t\tif (typeof constantValue === 'boolean') {\n\t\t\tconst trueValue = constantValue ? 'true' : 'false';\n\t\t\treturn (this.value === trueValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE);\n\t\t}\n\t\treturn this;\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\t// Intentional ==\n\t\t// eslint-disable-next-line eqeqeq\n\t\treturn (context.getValue(this.key) == this.value);\n\t}\n\n\tpublic serialize(): string {\n\t\treturn `${this.key} == '${this.value}'`;\n\t}\n\n\tpublic keys(): string[] {\n\t\treturn [this.key];\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyExpression {\n\t\treturn mapFnc.mapEquals(this.key, this.value);\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\tif (!this.negated) {\n\t\t\tthis.negated = ContextKeyNotEqualsExpr.create(this.key, this.value, this);\n\t\t}\n\t\treturn this.negated;\n\t}\n}\n\nexport class ContextKeyInExpr implements IContextKeyExpression {\n\n\tpublic static create(key: string, valueKey: string): ContextKeyInExpr {\n\t\treturn new ContextKeyInExpr(key, valueKey);\n\t}\n\n\tpublic readonly type = ContextKeyExprType.In;\n\tprivate negated: ContextKeyExpression | null = null;\n\n\tprivate constructor(\n\t\tprivate readonly key: string,\n\t\tprivate readonly valueKey: string,\n\t) {\n\t}\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\tif (other.type !== this.type) {\n\t\t\treturn this.type - other.type;\n\t\t}\n\t\treturn cmp2(this.key, this.valueKey, other.key, other.valueKey);\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\tif (other.type === this.type) {\n\t\t\treturn (this.key === other.key && this.valueKey === other.valueKey);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\treturn this;\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\tconst source = context.getValue(this.valueKey);\n\n\t\tconst item = context.getValue(this.key);\n\n\t\tif (Array.isArray(source)) {\n\t\t\treturn source.includes(item as any);\n\t\t}\n\n\t\tif (typeof item === 'string' && typeof source === 'object' && source !== null) {\n\t\t\treturn hasOwnProperty.call(source, item);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic serialize(): string {\n\t\treturn `${this.key} in '${this.valueKey}'`;\n\t}\n\n\tpublic keys(): string[] {\n\t\treturn [this.key, this.valueKey];\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyInExpr {\n\t\treturn mapFnc.mapIn(this.key, this.valueKey);\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\tif (!this.negated) {\n\t\t\tthis.negated = ContextKeyNotInExpr.create(this.key, this.valueKey);\n\t\t}\n\t\treturn this.negated;\n\t}\n}\n\nexport class ContextKeyNotInExpr implements IContextKeyExpression {\n\n\tpublic static create(key: string, valueKey: string): ContextKeyNotInExpr {\n\t\treturn new ContextKeyNotInExpr(key, valueKey);\n\t}\n\n\tpublic readonly type = ContextKeyExprType.NotIn;\n\n\tprivate readonly _negated: ContextKeyInExpr;\n\n\tprivate constructor(\n\t\tprivate readonly key: string,\n\t\tprivate readonly valueKey: string,\n\t) {\n\t\tthis._negated = ContextKeyInExpr.create(key, valueKey);\n\t}\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\tif (other.type !== this.type) {\n\t\t\treturn this.type - other.type;\n\t\t}\n\t\treturn this._negated.cmp(other._negated);\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\tif (other.type === this.type) {\n\t\t\treturn this._negated.equals(other._negated);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\treturn this;\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\treturn !this._negated.evaluate(context);\n\t}\n\n\tpublic serialize(): string {\n\t\treturn `${this.key} not in '${this.valueKey}'`;\n\t}\n\n\tpublic keys(): string[] {\n\t\treturn this._negated.keys();\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyExpression {\n\t\treturn mapFnc.mapNotIn(this.key, this.valueKey);\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\treturn this._negated;\n\t}\n}\n\nexport class ContextKeyNotEqualsExpr implements IContextKeyExpression {\n\n\tpublic static create(key: string, value: any, negated: ContextKeyExpression | null = null): ContextKeyExpression {\n\t\tif (typeof value === 'boolean') {\n\t\t\tif (value) {\n\t\t\t\treturn ContextKeyNotExpr.create(key, negated);\n\t\t\t}\n\t\t\treturn ContextKeyDefinedExpr.create(key, negated);\n\t\t}\n\t\tconst constantValue = CONSTANT_VALUES.get(key);\n\t\tif (typeof constantValue === 'boolean') {\n\t\t\tconst falseValue = constantValue ? 'true' : 'false';\n\t\t\treturn (value === falseValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE);\n\t\t}\n\t\treturn new ContextKeyNotEqualsExpr(key, value, negated);\n\t}\n\n\tpublic readonly type = ContextKeyExprType.NotEquals;\n\n\tprivate constructor(\n\t\tprivate readonly key: string,\n\t\tprivate readonly value: any,\n\t\tprivate negated: ContextKeyExpression | null\n\t) {\n\t}\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\tif (other.type !== this.type) {\n\t\t\treturn this.type - other.type;\n\t\t}\n\t\treturn cmp2(this.key, this.value, other.key, other.value);\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\tif (other.type === this.type) {\n\t\t\treturn (this.key === other.key && this.value === other.value);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\tconst constantValue = CONSTANT_VALUES.get(this.key);\n\t\tif (typeof constantValue === 'boolean') {\n\t\t\tconst falseValue = constantValue ? 'true' : 'false';\n\t\t\treturn (this.value === falseValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE);\n\t\t}\n\t\treturn this;\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\t// Intentional !=\n\t\t// eslint-disable-next-line eqeqeq\n\t\treturn (context.getValue(this.key) != this.value);\n\t}\n\n\tpublic serialize(): string {\n\t\treturn `${this.key} != '${this.value}'`;\n\t}\n\n\tpublic keys(): string[] {\n\t\treturn [this.key];\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyExpression {\n\t\treturn mapFnc.mapNotEquals(this.key, this.value);\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\tif (!this.negated) {\n\t\t\tthis.negated = ContextKeyEqualsExpr.create(this.key, this.value, this);\n\t\t}\n\t\treturn this.negated;\n\t}\n}\n\nexport class ContextKeyNotExpr implements IContextKeyExpression {\n\n\tpublic static create(key: string, negated: ContextKeyExpression | null = null): ContextKeyExpression {\n\t\tconst constantValue = CONSTANT_VALUES.get(key);\n\t\tif (typeof constantValue === 'boolean') {\n\t\t\treturn (constantValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE);\n\t\t}\n\t\treturn new ContextKeyNotExpr(key, negated);\n\t}\n\n\tpublic readonly type = ContextKeyExprType.Not;\n\n\tprivate constructor(\n\t\tprivate readonly key: string,\n\t\tprivate negated: ContextKeyExpression | null\n\t) {\n\t}\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\tif (other.type !== this.type) {\n\t\t\treturn this.type - other.type;\n\t\t}\n\t\treturn cmp1(this.key, other.key);\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\tif (other.type === this.type) {\n\t\t\treturn (this.key === other.key);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\tconst constantValue = CONSTANT_VALUES.get(this.key);\n\t\tif (typeof constantValue === 'boolean') {\n\t\t\treturn (constantValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE);\n\t\t}\n\t\treturn this;\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\treturn (!context.getValue(this.key));\n\t}\n\n\tpublic serialize(): string {\n\t\treturn `!${this.key}`;\n\t}\n\n\tpublic keys(): string[] {\n\t\treturn [this.key];\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyExpression {\n\t\treturn mapFnc.mapNot(this.key);\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\tif (!this.negated) {\n\t\t\tthis.negated = ContextKeyDefinedExpr.create(this.key, this);\n\t\t}\n\t\treturn this.negated;\n\t}\n}\n\nfunction withFloatOrStr<T extends ContextKeyExpression>(value: any, callback: (value: number | string) => T): T | ContextKeyFalseExpr {\n\tif (typeof value === 'string') {\n\t\tconst n = parseFloat(value);\n\t\tif (!isNaN(n)) {\n\t\t\tvalue = n;\n\t\t}\n\t}\n\tif (typeof value === 'string' || typeof value === 'number') {\n\t\treturn callback(value);\n\t}\n\treturn ContextKeyFalseExpr.INSTANCE;\n}\n\nexport class ContextKeyGreaterExpr implements IContextKeyExpression {\n\n\tpublic static create(key: string, _value: any, negated: ContextKeyExpression | null = null): ContextKeyExpression {\n\t\treturn withFloatOrStr(_value, (value) => new ContextKeyGreaterExpr(key, value, negated));\n\t}\n\n\tpublic readonly type = ContextKeyExprType.Greater;\n\n\tprivate constructor(\n\t\tprivate readonly key: string,\n\t\tprivate readonly value: number | string,\n\t\tprivate negated: ContextKeyExpression | null\n\t) { }\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\tif (other.type !== this.type) {\n\t\t\treturn this.type - other.type;\n\t\t}\n\t\treturn cmp2(this.key, this.value, other.key, other.value);\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\tif (other.type === this.type) {\n\t\t\treturn (this.key === other.key && this.value === other.value);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\treturn this;\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\tif (typeof this.value === 'string') {\n\t\t\treturn false;\n\t\t}\n\t\treturn (parseFloat(<any>context.getValue(this.key)) > this.value);\n\t}\n\n\tpublic serialize(): string {\n\t\treturn `${this.key} > ${this.value}`;\n\t}\n\n\tpublic keys(): string[] {\n\t\treturn [this.key];\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyExpression {\n\t\treturn mapFnc.mapGreater(this.key, this.value);\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\tif (!this.negated) {\n\t\t\tthis.negated = ContextKeySmallerEqualsExpr.create(this.key, this.value, this);\n\t\t}\n\t\treturn this.negated;\n\t}\n}\n\nexport class ContextKeyGreaterEqualsExpr implements IContextKeyExpression {\n\n\tpublic static create(key: string, _value: any, negated: ContextKeyExpression | null = null): ContextKeyExpression {\n\t\treturn withFloatOrStr(_value, (value) => new ContextKeyGreaterEqualsExpr(key, value, negated));\n\t}\n\n\tpublic readonly type = ContextKeyExprType.GreaterEquals;\n\n\tprivate constructor(\n\t\tprivate readonly key: string,\n\t\tprivate readonly value: number | string,\n\t\tprivate negated: ContextKeyExpression | null\n\t) { }\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\tif (other.type !== this.type) {\n\t\t\treturn this.type - other.type;\n\t\t}\n\t\treturn cmp2(this.key, this.value, other.key, other.value);\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\tif (other.type === this.type) {\n\t\t\treturn (this.key === other.key && this.value === other.value);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\treturn this;\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\tif (typeof this.value === 'string') {\n\t\t\treturn false;\n\t\t}\n\t\treturn (parseFloat(<any>context.getValue(this.key)) >= this.value);\n\t}\n\n\tpublic serialize(): string {\n\t\treturn `${this.key} >= ${this.value}`;\n\t}\n\n\tpublic keys(): string[] {\n\t\treturn [this.key];\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyExpression {\n\t\treturn mapFnc.mapGreaterEquals(this.key, this.value);\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\tif (!this.negated) {\n\t\t\tthis.negated = ContextKeySmallerExpr.create(this.key, this.value, this);\n\t\t}\n\t\treturn this.negated;\n\t}\n}\n\nexport class ContextKeySmallerExpr implements IContextKeyExpression {\n\n\tpublic static create(key: string, _value: any, negated: ContextKeyExpression | null = null): ContextKeyExpression {\n\t\treturn withFloatOrStr(_value, (value) => new ContextKeySmallerExpr(key, value, negated));\n\t}\n\n\tpublic readonly type = ContextKeyExprType.Smaller;\n\n\tprivate constructor(\n\t\tprivate readonly key: string,\n\t\tprivate readonly value: number | string,\n\t\tprivate negated: ContextKeyExpression | null\n\t) {\n\t}\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\tif (other.type !== this.type) {\n\t\t\treturn this.type - other.type;\n\t\t}\n\t\treturn cmp2(this.key, this.value, other.key, other.value);\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\tif (other.type === this.type) {\n\t\t\treturn (this.key === other.key && this.value === other.value);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\treturn this;\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\tif (typeof this.value === 'string') {\n\t\t\treturn false;\n\t\t}\n\t\treturn (parseFloat(<any>context.getValue(this.key)) < this.value);\n\t}\n\n\tpublic serialize(): string {\n\t\treturn `${this.key} < ${this.value}`;\n\t}\n\n\tpublic keys(): string[] {\n\t\treturn [this.key];\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyExpression {\n\t\treturn mapFnc.mapSmaller(this.key, this.value);\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\tif (!this.negated) {\n\t\t\tthis.negated = ContextKeyGreaterEqualsExpr.create(this.key, this.value, this);\n\t\t}\n\t\treturn this.negated;\n\t}\n}\n\nexport class ContextKeySmallerEqualsExpr implements IContextKeyExpression {\n\n\tpublic static create(key: string, _value: any, negated: ContextKeyExpression | null = null): ContextKeyExpression {\n\t\treturn withFloatOrStr(_value, (value) => new ContextKeySmallerEqualsExpr(key, value, negated));\n\t}\n\n\tpublic readonly type = ContextKeyExprType.SmallerEquals;\n\n\tprivate constructor(\n\t\tprivate readonly key: string,\n\t\tprivate readonly value: number | string,\n\t\tprivate negated: ContextKeyExpression | null\n\t) {\n\t}\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\tif (other.type !== this.type) {\n\t\t\treturn this.type - other.type;\n\t\t}\n\t\treturn cmp2(this.key, this.value, other.key, other.value);\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\tif (other.type === this.type) {\n\t\t\treturn (this.key === other.key && this.value === other.value);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\treturn this;\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\tif (typeof this.value === 'string') {\n\t\t\treturn false;\n\t\t}\n\t\treturn (parseFloat(<any>context.getValue(this.key)) <= this.value);\n\t}\n\n\tpublic serialize(): string {\n\t\treturn `${this.key} <= ${this.value}`;\n\t}\n\n\tpublic keys(): string[] {\n\t\treturn [this.key];\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyExpression {\n\t\treturn mapFnc.mapSmallerEquals(this.key, this.value);\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\tif (!this.negated) {\n\t\t\tthis.negated = ContextKeyGreaterExpr.create(this.key, this.value, this);\n\t\t}\n\t\treturn this.negated;\n\t}\n}\n\nexport class ContextKeyRegexExpr implements IContextKeyExpression {\n\n\tpublic static create(key: string, regexp: RegExp | null): ContextKeyRegexExpr {\n\t\treturn new ContextKeyRegexExpr(key, regexp);\n\t}\n\n\tpublic readonly type = ContextKeyExprType.Regex;\n\tprivate negated: ContextKeyExpression | null = null;\n\n\tprivate constructor(\n\t\tprivate readonly key: string,\n\t\tprivate readonly regexp: RegExp | null\n\t) {\n\t\t//\n\t}\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\tif (other.type !== this.type) {\n\t\t\treturn this.type - other.type;\n\t\t}\n\t\tif (this.key < other.key) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (this.key > other.key) {\n\t\t\treturn 1;\n\t\t}\n\t\tconst thisSource = this.regexp ? this.regexp.source : '';\n\t\tconst otherSource = other.regexp ? other.regexp.source : '';\n\t\tif (thisSource < otherSource) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (thisSource > otherSource) {\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\tif (other.type === this.type) {\n\t\t\tconst thisSource = this.regexp ? this.regexp.source : '';\n\t\t\tconst otherSource = other.regexp ? other.regexp.source : '';\n\t\t\treturn (this.key === other.key && thisSource === otherSource);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\treturn this;\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\tconst value = context.getValue<any>(this.key);\n\t\treturn this.regexp ? this.regexp.test(value) : false;\n\t}\n\n\tpublic serialize(): string {\n\t\tconst value = this.regexp\n\t\t\t? `/${this.regexp.source}/${this.regexp.flags}`\n\t\t\t: '/invalid/';\n\t\treturn `${this.key} =~ ${value}`;\n\t}\n\n\tpublic keys(): string[] {\n\t\treturn [this.key];\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyRegexExpr {\n\t\treturn mapFnc.mapRegex(this.key, this.regexp);\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\tif (!this.negated) {\n\t\t\tthis.negated = ContextKeyNotRegexExpr.create(this);\n\t\t}\n\t\treturn this.negated;\n\t}\n}\n\nexport class ContextKeyNotRegexExpr implements IContextKeyExpression {\n\n\tpublic static create(actual: ContextKeyRegexExpr): ContextKeyExpression {\n\t\treturn new ContextKeyNotRegexExpr(actual);\n\t}\n\n\tpublic readonly type = ContextKeyExprType.NotRegex;\n\n\tprivate constructor(private readonly _actual: ContextKeyRegexExpr) {\n\t\t//\n\t}\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\tif (other.type !== this.type) {\n\t\t\treturn this.type - other.type;\n\t\t}\n\t\treturn this._actual.cmp(other._actual);\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\tif (other.type === this.type) {\n\t\t\treturn this._actual.equals(other._actual);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\treturn this;\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\treturn !this._actual.evaluate(context);\n\t}\n\n\tpublic serialize(): string {\n\t\treturn `!(${this._actual.serialize()})`;\n\t}\n\n\tpublic keys(): string[] {\n\t\treturn this._actual.keys();\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyExpression {\n\t\treturn new ContextKeyNotRegexExpr(this._actual.map(mapFnc));\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\treturn this._actual;\n\t}\n}\n\n/**\n * @returns the same instance if nothing changed.\n */\nfunction eliminateConstantsInArray(arr: ContextKeyExpression[]): (ContextKeyExpression | undefined)[] {\n\t// Allocate array only if there is a difference\n\tlet newArr: (ContextKeyExpression | undefined)[] | null = null;\n\tfor (let i = 0, len = arr.length; i < len; i++) {\n\t\tconst newExpr = arr[i].substituteConstants();\n\n\t\tif (arr[i] !== newExpr) {\n\t\t\t// something has changed!\n\n\t\t\t// allocate array on first difference\n\t\t\tif (newArr === null) {\n\t\t\t\tnewArr = [];\n\t\t\t\tfor (let j = 0; j < i; j++) {\n\t\t\t\t\tnewArr[j] = arr[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (newArr !== null) {\n\t\t\tnewArr[i] = newExpr;\n\t\t}\n\t}\n\n\tif (newArr === null) {\n\t\treturn arr;\n\t}\n\treturn newArr;\n}\n\nexport class ContextKeyAndExpr implements IContextKeyExpression {\n\n\tpublic static create(_expr: ReadonlyArray<ContextKeyExpression | null | undefined>, negated: ContextKeyExpression | null, extraRedundantCheck: boolean): ContextKeyExpression | undefined {\n\t\treturn ContextKeyAndExpr._normalizeArr(_expr, negated, extraRedundantCheck);\n\t}\n\n\tpublic readonly type = ContextKeyExprType.And;\n\n\tprivate constructor(\n\t\tpublic readonly expr: ContextKeyExpression[],\n\t\tprivate negated: ContextKeyExpression | null\n\t) {\n\t}\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\tif (other.type !== this.type) {\n\t\t\treturn this.type - other.type;\n\t\t}\n\t\tif (this.expr.length < other.expr.length) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (this.expr.length > other.expr.length) {\n\t\t\treturn 1;\n\t\t}\n\t\tfor (let i = 0, len = this.expr.length; i < len; i++) {\n\t\t\tconst r = cmp(this.expr[i], other.expr[i]);\n\t\t\tif (r !== 0) {\n\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\tif (other.type === this.type) {\n\t\t\tif (this.expr.length !== other.expr.length) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (let i = 0, len = this.expr.length; i < len; i++) {\n\t\t\t\tif (!this.expr[i].equals(other.expr[i])) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\tconst exprArr = eliminateConstantsInArray(this.expr);\n\t\tif (exprArr === this.expr) {\n\t\t\t// no change\n\t\t\treturn this;\n\t\t}\n\t\treturn ContextKeyAndExpr.create(exprArr, this.negated, false);\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\tfor (let i = 0, len = this.expr.length; i < len; i++) {\n\t\t\tif (!this.expr[i].evaluate(context)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate static _normalizeArr(arr: ReadonlyArray<ContextKeyExpression | null | undefined>, negated: ContextKeyExpression | null, extraRedundantCheck: boolean): ContextKeyExpression | undefined {\n\t\tconst expr: ContextKeyExpression[] = [];\n\t\tlet hasTrue = false;\n\n\t\tfor (const e of arr) {\n\t\t\tif (!e) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (e.type === ContextKeyExprType.True) {\n\t\t\t\t// anything && true ==> anything\n\t\t\t\thasTrue = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (e.type === ContextKeyExprType.False) {\n\t\t\t\t// anything && false ==> false\n\t\t\t\treturn ContextKeyFalseExpr.INSTANCE;\n\t\t\t}\n\n\t\t\tif (e.type === ContextKeyExprType.And) {\n\t\t\t\texpr.push(...e.expr);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\texpr.push(e);\n\t\t}\n\n\t\tif (expr.length === 0 && hasTrue) {\n\t\t\treturn ContextKeyTrueExpr.INSTANCE;\n\t\t}\n\n\t\tif (expr.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (expr.length === 1) {\n\t\t\treturn expr[0];\n\t\t}\n\n\t\texpr.sort(cmp);\n\n\t\t// eliminate duplicate terms\n\t\tfor (let i = 1; i < expr.length; i++) {\n\t\t\tif (expr[i - 1].equals(expr[i])) {\n\t\t\t\texpr.splice(i, 1);\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\n\t\tif (expr.length === 1) {\n\t\t\treturn expr[0];\n\t\t}\n\n\t\t// We must distribute any OR expression because we don't support parens\n\t\t// OR extensions will be at the end (due to sorting rules)\n\t\twhile (expr.length > 1) {\n\t\t\tconst lastElement = expr[expr.length - 1];\n\t\t\tif (lastElement.type !== ContextKeyExprType.Or) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// pop the last element\n\t\t\texpr.pop();\n\n\t\t\t// pop the second to last element\n\t\t\tconst secondToLastElement = expr.pop()!;\n\n\t\t\tconst isFinished = (expr.length === 0);\n\n\t\t\t// distribute `lastElement` over `secondToLastElement`\n\t\t\tconst resultElement = ContextKeyOrExpr.create(\n\t\t\t\tlastElement.expr.map(el => ContextKeyAndExpr.create([el, secondToLastElement], null, extraRedundantCheck)),\n\t\t\t\tnull,\n\t\t\t\tisFinished\n\t\t\t);\n\n\t\t\tif (resultElement) {\n\t\t\t\texpr.push(resultElement);\n\t\t\t\texpr.sort(cmp);\n\t\t\t}\n\t\t}\n\n\t\tif (expr.length === 1) {\n\t\t\treturn expr[0];\n\t\t}\n\n\t\t// resolve false AND expressions\n\t\tif (extraRedundantCheck) {\n\t\t\tfor (let i = 0; i < expr.length; i++) {\n\t\t\t\tfor (let j = i + 1; j < expr.length; j++) {\n\t\t\t\t\tif (expr[i].negate().equals(expr[j])) {\n\t\t\t\t\t\t// A && !A case\n\t\t\t\t\t\treturn ContextKeyFalseExpr.INSTANCE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (expr.length === 1) {\n\t\t\t\treturn expr[0];\n\t\t\t}\n\t\t}\n\n\t\treturn new ContextKeyAndExpr(expr, negated);\n\t}\n\n\tpublic serialize(): string {\n\t\treturn this.expr.map(e => e.serialize()).join(' && ');\n\t}\n\n\tpublic keys(): string[] {\n\t\tconst result: string[] = [];\n\t\tfor (const expr of this.expr) {\n\t\t\tresult.push(...expr.keys());\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyExpression {\n\t\treturn new ContextKeyAndExpr(this.expr.map(expr => expr.map(mapFnc)), null);\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\tif (!this.negated) {\n\t\t\tconst result: ContextKeyExpression[] = [];\n\t\t\tfor (const expr of this.expr) {\n\t\t\t\tresult.push(expr.negate());\n\t\t\t}\n\t\t\tthis.negated = ContextKeyOrExpr.create(result, this, true)!;\n\t\t}\n\t\treturn this.negated;\n\t}\n}\n\nexport class ContextKeyOrExpr implements IContextKeyExpression {\n\n\tpublic static create(_expr: ReadonlyArray<ContextKeyExpression | null | undefined>, negated: ContextKeyExpression | null, extraRedundantCheck: boolean): ContextKeyExpression | undefined {\n\t\treturn ContextKeyOrExpr._normalizeArr(_expr, negated, extraRedundantCheck);\n\t}\n\n\tpublic readonly type = ContextKeyExprType.Or;\n\n\tprivate constructor(\n\t\tpublic readonly expr: ContextKeyExpression[],\n\t\tprivate negated: ContextKeyExpression | null\n\t) {\n\t}\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\tif (other.type !== this.type) {\n\t\t\treturn this.type - other.type;\n\t\t}\n\t\tif (this.expr.length < other.expr.length) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (this.expr.length > other.expr.length) {\n\t\t\treturn 1;\n\t\t}\n\t\tfor (let i = 0, len = this.expr.length; i < len; i++) {\n\t\t\tconst r = cmp(this.expr[i], other.expr[i]);\n\t\t\tif (r !== 0) {\n\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\tif (other.type === this.type) {\n\t\t\tif (this.expr.length !== other.expr.length) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (let i = 0, len = this.expr.length; i < len; i++) {\n\t\t\t\tif (!this.expr[i].equals(other.expr[i])) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\tconst exprArr = eliminateConstantsInArray(this.expr);\n\t\tif (exprArr === this.expr) {\n\t\t\t// no change\n\t\t\treturn this;\n\t\t}\n\t\treturn ContextKeyOrExpr.create(exprArr, this.negated, false);\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\tfor (let i = 0, len = this.expr.length; i < len; i++) {\n\t\t\tif (this.expr[i].evaluate(context)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate static _normalizeArr(arr: ReadonlyArray<ContextKeyExpression | null | undefined>, negated: ContextKeyExpression | null, extraRedundantCheck: boolean): ContextKeyExpression | undefined {\n\t\tlet expr: ContextKeyExpression[] = [];\n\t\tlet hasFalse = false;\n\n\t\tif (arr) {\n\t\t\tfor (let i = 0, len = arr.length; i < len; i++) {\n\t\t\t\tconst e = arr[i];\n\t\t\t\tif (!e) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (e.type === ContextKeyExprType.False) {\n\t\t\t\t\t// anything || false ==> anything\n\t\t\t\t\thasFalse = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (e.type === ContextKeyExprType.True) {\n\t\t\t\t\t// anything || true ==> true\n\t\t\t\t\treturn ContextKeyTrueExpr.INSTANCE;\n\t\t\t\t}\n\n\t\t\t\tif (e.type === ContextKeyExprType.Or) {\n\t\t\t\t\texpr = expr.concat(e.expr);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\texpr.push(e);\n\t\t\t}\n\n\t\t\tif (expr.length === 0 && hasFalse) {\n\t\t\t\treturn ContextKeyFalseExpr.INSTANCE;\n\t\t\t}\n\n\t\t\texpr.sort(cmp);\n\t\t}\n\n\t\tif (expr.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (expr.length === 1) {\n\t\t\treturn expr[0];\n\t\t}\n\n\t\t// eliminate duplicate terms\n\t\tfor (let i = 1; i < expr.length; i++) {\n\t\t\tif (expr[i - 1].equals(expr[i])) {\n\t\t\t\texpr.splice(i, 1);\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\n\t\tif (expr.length === 1) {\n\t\t\treturn expr[0];\n\t\t}\n\n\t\t// resolve true OR expressions\n\t\tif (extraRedundantCheck) {\n\t\t\tfor (let i = 0; i < expr.length; i++) {\n\t\t\t\tfor (let j = i + 1; j < expr.length; j++) {\n\t\t\t\t\tif (expr[i].negate().equals(expr[j])) {\n\t\t\t\t\t\t// A || !A case\n\t\t\t\t\t\treturn ContextKeyTrueExpr.INSTANCE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (expr.length === 1) {\n\t\t\t\treturn expr[0];\n\t\t\t}\n\t\t}\n\n\t\treturn new ContextKeyOrExpr(expr, negated);\n\t}\n\n\tpublic serialize(): string {\n\t\treturn this.expr.map(e => e.serialize()).join(' || ');\n\t}\n\n\tpublic keys(): string[] {\n\t\tconst result: string[] = [];\n\t\tfor (const expr of this.expr) {\n\t\t\tresult.push(...expr.keys());\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyExpression {\n\t\treturn new ContextKeyOrExpr(this.expr.map(expr => expr.map(mapFnc)), null);\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\tif (!this.negated) {\n\t\t\tconst result: ContextKeyExpression[] = [];\n\t\t\tfor (const expr of this.expr) {\n\t\t\t\tresult.push(expr.negate());\n\t\t\t}\n\n\t\t\t// We don't support parens, so here we distribute the AND over the OR terminals\n\t\t\t// We always take the first 2 AND pairs and distribute them\n\t\t\twhile (result.length > 1) {\n\t\t\t\tconst LEFT = result.shift()!;\n\t\t\t\tconst RIGHT = result.shift()!;\n\n\t\t\t\tconst all: ContextKeyExpression[] = [];\n\t\t\t\tfor (const left of getTerminals(LEFT)) {\n\t\t\t\t\tfor (const right of getTerminals(RIGHT)) {\n\t\t\t\t\t\tall.push(ContextKeyAndExpr.create([left, right], null, false)!);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tresult.unshift(ContextKeyOrExpr.create(all, null, false)!);\n\t\t\t}\n\n\t\t\tthis.negated = ContextKeyOrExpr.create(result, this, true)!;\n\t\t}\n\t\treturn this.negated;\n\t}\n}\n\nexport interface ContextKeyInfo {\n\treadonly key: string;\n\treadonly type?: string;\n\treadonly description?: string;\n}\n\nexport class RawContextKey<T extends ContextKeyValue> extends ContextKeyDefinedExpr {\n\n\tprivate static _info: ContextKeyInfo[] = [];\n\n\tstatic all(): IterableIterator<ContextKeyInfo> {\n\t\treturn RawContextKey._info.values();\n\t}\n\n\tprivate readonly _defaultValue: T | undefined;\n\n\tconstructor(key: string, defaultValue: T | undefined, metaOrHide?: string | true | { type: string; description: string }) {\n\t\tsuper(key, null);\n\t\tthis._defaultValue = defaultValue;\n\n\t\t// collect all context keys into a central place\n\t\tif (typeof metaOrHide === 'object') {\n\t\t\tRawContextKey._info.push({ ...metaOrHide, key });\n\t\t} else if (metaOrHide !== true) {\n\t\t\tRawContextKey._info.push({ key, description: metaOrHide, type: defaultValue !== null && defaultValue !== undefined ? typeof defaultValue : undefined });\n\t\t}\n\t}\n\n\tpublic bindTo(target: IContextKeyService): IContextKey<T> {\n\t\treturn target.createKey(this.key, this._defaultValue);\n\t}\n\n\tpublic getValue(target: IContextKeyService): T | undefined {\n\t\treturn target.getContextKeyValue<T>(this.key);\n\t}\n\n\tpublic toNegated(): ContextKeyExpression {\n\t\treturn this.negate();\n\t}\n\n\tpublic isEqualTo(value: any): ContextKeyExpression {\n\t\treturn ContextKeyEqualsExpr.create(this.key, value);\n\t}\n\n\tpublic notEqualsTo(value: any): ContextKeyExpression {\n\t\treturn ContextKeyNotEqualsExpr.create(this.key, value);\n\t}\n}\n\nexport type ContextKeyValue = null | undefined | boolean | number | string\n\t| Array<null | undefined | boolean | number | string>\n\t| Record<string, null | undefined | boolean | number | string>;\n\nexport interface IContext {\n\tgetValue<T extends ContextKeyValue = ContextKeyValue>(key: string): T | undefined;\n}\n\nexport interface IContextKey<T extends ContextKeyValue = ContextKeyValue> {\n\tset(value: T): void;\n\treset(): void;\n\tget(): T | undefined;\n}\n\nexport interface IContextKeyServiceTarget {\n\tparentElement: IContextKeyServiceTarget | null;\n\tsetAttribute(attr: string, value: string): void;\n\tremoveAttribute(attr: string): void;\n\thasAttribute(attr: string): boolean;\n\tgetAttribute(attr: string): string | null;\n}\n\nexport const IContextKeyService = createDecorator<IContextKeyService>('contextKeyService');\n\nexport interface IReadableSet<T> {\n\thas(value: T): boolean;\n}\n\nexport interface IContextKeyChangeEvent {\n\taffectsSome(keys: IReadableSet<string>): boolean;\n\tallKeysContainedIn(keys: IReadableSet<string>): boolean;\n}\n\nexport type IScopedContextKeyService = IContextKeyService & IDisposable;\n\nexport interface IContextKeyService {\n\treadonly _serviceBrand: undefined;\n\n\tonDidChangeContext: Event<IContextKeyChangeEvent>;\n\tbufferChangeEvents(callback: Function): void;\n\n\tcreateKey<T extends ContextKeyValue>(key: string, defaultValue: T | undefined): IContextKey<T>;\n\tcontextMatchesRules(rules: ContextKeyExpression | undefined): boolean;\n\tgetContextKeyValue<T>(key: string): T | undefined;\n\n\tcreateScoped(target: IContextKeyServiceTarget): IScopedContextKeyService;\n\tcreateOverlay(overlay: Iterable<[string, any]>): IContextKeyService;\n\tgetContext(target: IContextKeyServiceTarget | null): IContext;\n\n\tupdateParent(parentContextKeyService: IContextKeyService): void;\n}\n\nfunction cmp1(key1: string, key2: string): number {\n\tif (key1 < key2) {\n\t\treturn -1;\n\t}\n\tif (key1 > key2) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nfunction cmp2(key1: string, value1: any, key2: string, value2: any): number {\n\tif (key1 < key2) {\n\t\treturn -1;\n\t}\n\tif (key1 > key2) {\n\t\treturn 1;\n\t}\n\tif (value1 < value2) {\n\t\treturn -1;\n\t}\n\tif (value1 > value2) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/**\n * Returns true if it is provable `p` implies `q`.\n */\nexport function implies(p: ContextKeyExpression, q: ContextKeyExpression): boolean {\n\n\tif (p.type === ContextKeyExprType.False || q.type === ContextKeyExprType.True) {\n\t\t// false implies anything\n\t\t// anything implies true\n\t\treturn true;\n\t}\n\n\tif (p.type === ContextKeyExprType.Or) {\n\t\tif (q.type === ContextKeyExprType.Or) {\n\t\t\t// `a || b || c` can only imply something like `a || b || c || d`\n\t\t\treturn allElementsIncluded(p.expr, q.expr);\n\t\t}\n\t\treturn false;\n\t}\n\n\tif (q.type === ContextKeyExprType.Or) {\n\t\tfor (const element of q.expr) {\n\t\t\tif (implies(p, element)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tif (p.type === ContextKeyExprType.And) {\n\t\tif (q.type === ContextKeyExprType.And) {\n\t\t\t// `a && b && c` implies `a && c`\n\t\t\treturn allElementsIncluded(q.expr, p.expr);\n\t\t}\n\t\tfor (const element of p.expr) {\n\t\t\tif (implies(element, q)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\treturn p.equals(q);\n}\n\n/**\n * Returns true if all elements in `p` are also present in `q`.\n * The two arrays are assumed to be sorted\n */\nfunction allElementsIncluded(p: ContextKeyExpression[], q: ContextKeyExpression[]): boolean {\n\tlet pIndex = 0;\n\tlet qIndex = 0;\n\twhile (pIndex < p.length && qIndex < q.length) {\n\t\tconst cmp = p[pIndex].cmp(q[qIndex]);\n\n\t\tif (cmp < 0) {\n\t\t\t// an element from `p` is missing from `q`\n\t\t\treturn false;\n\t\t} else if (cmp === 0) {\n\t\t\tpIndex++;\n\t\t\tqIndex++;\n\t\t} else {\n\t\t\tqIndex++;\n\t\t}\n\t}\n\treturn (pIndex === p.length);\n}\n\nfunction getTerminals(node: ContextKeyExpression) {\n\tif (node.type === ContextKeyExprType.Or) {\n\t\treturn node.expr;\n\t}\n\treturn [node];\n}\n"]}