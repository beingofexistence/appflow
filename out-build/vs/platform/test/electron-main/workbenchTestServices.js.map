{"version":3,"sources":["file:///workspace/appflow/src/vs/platform/test/electron-main/workbenchTestServices.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;IAShG,MAAa,IAAI;QAAjB;YAIC,qBAAgB,GAAG,aAAK,CAAC,IAAI,CAAC;YAEb,MAAC,GAAiB,IAAI,WAAG,EAAqB,CAAC;YACvD,mBAAc,GAAG,IAAI,CAAC,CAAC,CAAe,KAAK,CAAC;YAerD,qBAAgB,GAAG,aAAK,CAAC,IAAI,CAAC;YAC9B,wBAAmB,GAAG,aAAK,CAAC,IAAI,CAAC;YAEjC,iBAAY,GAAG,KAAK,CAAC;YACrB,kBAAa,GAAG,KAAK,CAAC;YAEtB,UAAK,oCAA4B;QAUlC,CAAC;QA7BA,KAAK,CAAC,kBAAkB;YACvB,MAAM,OAAO,GAAoB,EAAE,CAAC;YAEpC,IAAI,CAAC,CAAC,CAAe,IAAI,CAAC;gBACzB,MAAM,6BAAqB;gBAC3B,IAAI,CAAC,EAAE,EAAE,OAAO;oBACf,OAAO,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;gBACvB,CAAC;aACD,CAAC,CAAC;YAEH,MAAM,gBAAQ,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC;QACjC,CAAC;QAUD,cAAc,CAAC,MAAmB,IAAU,CAAC;QAC7C,KAAK,CAAC,MAAM,CAAC,MAAmB,EAAE,GAAsB,IAAmB,CAAC;QAC5E,KAAK,CAAC,MAAM,CAAC,MAAmB,EAAE,MAAoB,IAAsB,OAAO,IAAI,CAAC,CAAC,CAAC;QAC1F,kBAAkB,CAAC,OAAyB,IAAU,CAAC;QACvD,KAAK,CAAC,QAAQ,CAAC,OAA+E,IAAmB,CAAC;QAClH,KAAK,CAAC,IAAI,CAAC,WAAqB,IAAsB,OAAO,IAAI,CAAC,CAAC,CAAC;QACpE,KAAK,CAAC,IAAI,CAAC,IAAa,IAAmB,CAAC;QAC5C,KAAK,CAAC,IAAI,CAAC,KAAyB,IAAmB,CAAC;KACxD;IAtCD,oBAsCC;IAED,MAAa,IAAI;QAAjB;YAIkB,MAAC,GAAM,IAAI,GAAG,EAAiE,CAAC;QAqBlG,CAAC;QAnBA,OAAO,CAAC,GAAW,EAAE,IAA4D;YAChF,IAAI,CAAC,CAAC,CAAI,GAAG,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;QAC1B,CAAC;QAED,QAAQ,CAAC,KAA+F;YACvG,KAAK,MAAM,EAAE,GAAG,EAAE,IAAI,EAAE,IAAI,KAAK,EAAE;gBAClC,IAAI,CAAC,CAAC,CAAI,GAAG,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;aACzB;QACF,CAAC;QAED,OAAO,CAAI,GAAW;YACrB,OAAO,IAAI,CAAC,CAAC,CAAI,GAAG,CAAC,GAAG,CAAkB,CAAC;QAC5C,CAAC;QAED,UAAU,CAAC,GAAW;YACrB,IAAI,CAAC,CAAC,CAAI,MAAM,CAAC,GAAG,CAAC,CAAC;QACvB,CAAC;QAED,KAAK,CAAC,KAAK,KAAoB,CAAC;KAChC;IAzBD,oBAyBC","file":"workbenchTestServices.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Promises } from 'vs/base/common/async';\nimport { Event, Emitter } from 'vs/base/common/event';\nimport { NativeParsedArgs } from 'vs/platform/environment/common/argv';\nimport { ILifecycleMainService, IRelaunchHandler, LifecycleMainPhase, ShutdownEvent, ShutdownReason } from 'vs/platform/lifecycle/electron-main/lifecycleMainService';\nimport { IStateService } from 'vs/platform/state/node/state';\nimport { ICodeWindow, UnloadReason } from 'vs/platform/window/electron-main/window';\n\nexport class TestLifecycleMainService implements ILifecycleMainService {\n\n\t_serviceBrand: undefined;\n\n\tonBeforeShutdown = Event.None;\n\n\tprivate readonly _onWillShutdown = new Emitter<ShutdownEvent>();\n\treadonly onWillShutdown = this._onWillShutdown.event;\n\n\tasync fireOnWillShutdown(): Promise<void> {\n\t\tconst joiners: Promise<void>[] = [];\n\n\t\tthis._onWillShutdown.fire({\n\t\t\treason: ShutdownReason.QUIT,\n\t\t\tjoin(id, promise) {\n\t\t\t\tjoiners.push(promise);\n\t\t\t}\n\t\t});\n\n\t\tawait Promises.settled(joiners);\n\t}\n\n\tonWillLoadWindow = Event.None;\n\tonBeforeCloseWindow = Event.None;\n\n\twasRestarted = false;\n\tquitRequested = false;\n\n\tphase = LifecycleMainPhase.Ready;\n\n\tregisterWindow(window: ICodeWindow): void { }\n\tasync reload(window: ICodeWindow, cli?: NativeParsedArgs): Promise<void> { }\n\tasync unload(window: ICodeWindow, reason: UnloadReason): Promise<boolean> { return true; }\n\tsetRelaunchHandler(handler: IRelaunchHandler): void { }\n\tasync relaunch(options?: { addArgs?: string[] | undefined; removeArgs?: string[] | undefined }): Promise<void> { }\n\tasync quit(willRestart?: boolean): Promise<boolean> { return true; }\n\tasync kill(code?: number): Promise<void> { }\n\tasync when(phase: LifecycleMainPhase): Promise<void> { }\n}\n\nexport class InMemoryTestStateMainService implements IStateService {\n\n\t_serviceBrand: undefined;\n\n\tprivate readonly data = new Map<string, object | string | number | boolean | undefined | null>();\n\n\tsetItem(key: string, data?: object | string | number | boolean | undefined | null): void {\n\t\tthis.data.set(key, data);\n\t}\n\n\tsetItems(items: readonly { key: string; data?: object | string | number | boolean | undefined | null }[]): void {\n\t\tfor (const { key, data } of items) {\n\t\t\tthis.data.set(key, data);\n\t\t}\n\t}\n\n\tgetItem<T>(key: string): T | undefined {\n\t\treturn this.data.get(key) as T | undefined;\n\t}\n\n\tremoveItem(key: string): void {\n\t\tthis.data.delete(key);\n\t}\n\n\tasync close(): Promise<void> { }\n}\n"]}