{"version":3,"sources":["file:///workspace/appflow/src/vs/platform/backup/electron-main/backupMainService.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;;;;;;;;;;;IAoBzF,IAAM,IAAI,GAAV,MAAM,IAAI;;iBAIQ,MAAC,GAAoC,kBAApC,AAAsD,CAAC;QAchF,YAC0B,CAA6C,EAC/C,CAA0C,EACpD,CAAgC,EAC9B,CAAkC;YAHP,MAAC,GAAD,CAAC,CAA2B;YAC9B,MAAC,GAAD,CAAC,CAAwB;YACnC,MAAC,GAAD,CAAC,CAAc;YACb,MAAC,GAAD,CAAC,CAAgB;YAhBxC,MAAC,GAAY,IAAI,CAAC,CAAC,CAAsB,UAAU,CAAC;YAEtD,MAAC,GAAoC,EAAE,CAAC;YACxC,MAAC,GAA8B,EAAE,CAAC;YAClC,MAAC,GAAwC,EAAE,CAAC;YAEpD,8CAA8C;YAC9C,wCAAwC;YACxC,iCAAiC;YAChB,MAAC,GAAmB,eAAG,CAAwB;YAC/C,MAAC,GAAoB,EAAE,OAAO,EAAE,CAAC,KAAa,EAAE,KAAa,EAAE,EAAE,CAAC,IAAA,aAAG,EAAK,KAAK,EAAE,KAAK,EAAE,CAAC,aAAE,CAAM,EAAE,CAAC;QAQrH,CAAC;QAED,KAAK,CAAC,UAAU;YAEf,yBAAyB;YACzB,MAAM,0BAA0B,GAAG,IAAI,CAAC,CAAC,CAAY,OAAO,CAA8B,MAAI,CAAc,CAAC,CAAkC,IAAI,EAAE,UAAU,EAAE,EAAE,EAAE,OAAO,EAAE,EAAE,EAAE,YAAY,EAAE,EAAE,EAAE,CAAC;YAErM,0CAA0C;YAC1C,IAAI,CAAC,CAAC,GAAc,MAAM,IAAI,CAAC,CAAC,CAAuB,0BAA0B,CAAC,YAAY,CAAC,CAAC;YAEhG,6BAA6B;YAC7B,IAAI,CAAC,CAAC,GAAY,MAAM,IAAI,CAAC,CAAC,CAAkB,IAAA,aAAI,EAAsB,0BAA0B,CAAC,CAAC,CAAC;YAEvG,0BAA0B;YAC1B,IAAI,CAAC,CAAC,GAAS,MAAM,IAAI,CAAC,CAAC,CAAe,IAAA,aAAI,EAAmB,0BAA0B,CAAC,CAAC,CAAC;YAE9F,sEAAsE;YACtE,IAAI,CAAC,CAAC,EAAwB,CAAC;QAChC,CAAC;QAES,CAAC;YACV,IAAI,IAAI,CAAC,CAAC,EAA8B,EAAE;gBACzC,mEAAmE;gBACnE,kDAAkD;gBAClD,OAAO,EAAE,CAAC;aACV;YAED,OAAO,IAAI,CAAC,CAAC,CAAU,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,gBAAgB;QAClD,CAAC;QAES,CAAC;YACV,IAAI,IAAI,CAAC,CAAC,EAA8B,EAAE;gBACzC,mEAAmE;gBACnE,kDAAkD;gBAClD,OAAO,EAAE,CAAC;aACV;YAED,OAAO,IAAI,CAAC,CAAC,CAAO,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,gBAAgB;QAC/C,CAAC;QAED,gBAAgB;YACf,OAAO,IAAI,CAAC,CAAC,EAAiB,KAAK,WAAG,CAAkB,GAAG,CAAC;QAC7D,CAAC;QAEO,CAAC;YACR,OAAO,IAAI,CAAC,CAAC,EAAiB,KAAK,WAAG,CAAkB,wBAAwB,CAAC;QAClF,CAAC;QAEO,CAAC;YACR,MAAM,MAAM,GAAG,IAAI,CAAC,CAAC,CAAoB,QAAQ,EAAuB,CAAC;YAEzE,OAAO,MAAM,EAAE,KAAK,EAAE,OAAO,IAAI,WAAG,CAAkB,OAAO,CAAC;QAC/D,CAAC;QAED,qBAAqB;YACpB,OAAO,IAAI,CAAC,CAAC,CAAY,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,gBAAgB;QACpD,CAAC;QAID,uBAAuB,CAAC,aAAmC,EAAE,WAAoB;YAChF,IAAI,CAAC,IAAI,CAAC,CAAC,CAAU,IAAI,CAAC,SAAS,CAAC,EAAE,CAAC,aAAa,CAAC,SAAS,CAAC,EAAE,KAAK,SAAS,CAAC,SAAS,CAAC,EAAE,CAAC,EAAE;gBAC9F,IAAI,CAAC,CAAC,CAAU,IAAI,CAAC,aAAa,CAAC,CAAC;gBACpC,IAAI,CAAC,CAAC,EAAwB,CAAC;aAC/B;YAED,MAAM,UAAU,GAAG,IAAA,UAAG,EAAE,IAAI,CAAC,CAAC,EAAW,aAAa,CAAC,SAAS,CAAC,EAAE,CAAC,CAAC;YAErE,IAAI,WAAW,EAAE;gBAChB,OAAO,IAAI,CAAC,CAAC,CAAgB,UAAU,EAAE,WAAW,CAAC,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC,UAAU,CAAC,CAAC;aAC7E;YAED,OAAO,UAAU,CAAC;QACnB,CAAC;QAEO,KAAK,CAAC,CAAC,CAAgB,UAAkB,EAAE,YAAoB;YAEtE,+EAA+E;YAC/E,IAAI,MAAM,cAAQ,CAAC,MAAM,CAAC,UAAU,CAAC,EAAE;gBACtC,MAAM,IAAI,CAAC,CAAC,CAA0B,UAAU,CAAC,CAAC;aAClD;YAED,yEAAyE;YACzE,IAAI,MAAM,cAAQ,CAAC,MAAM,CAAC,YAAY,CAAC,EAAE;gBACxC,IAAI;oBACH,MAAM,cAAQ,CAAC,MAAM,CAAC,YAAY,EAAE,UAAU,EAAE,KAAK,CAAC,cAAc,CAAC,CAAC;iBACtE;gBAAC,OAAO,KAAK,EAAE;oBACf,IAAI,CAAC,CAAC,CAAU,KAAK,CAAC,yDAAyD,KAAK,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC;iBACnG;aACD;QACF,CAAC;QAED,oBAAoB,CAAC,UAA6B;YACjD,IAAI,CAAC,IAAI,CAAC,CAAC,CAAO,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,IAAI,CAAC,CAAC,CAAiB,OAAO,CAAC,UAAU,CAAC,SAAS,EAAE,MAAM,CAAC,SAAS,CAAC,CAAC,EAAE;gBACzG,IAAI,CAAC,CAAC,CAAO,IAAI,CAAC,UAAU,CAAC,CAAC;gBAC9B,IAAI,CAAC,CAAC,EAAwB,CAAC;aAC/B;YAED,OAAO,IAAA,UAAG,EAAE,IAAI,CAAC,CAAC,EAAW,IAAI,CAAC,CAAC,CAAa,UAAU,CAAC,CAAC,CAAC;QAC9D,CAAC;QAED,yBAAyB,CAAC,eAAuC;YAChE,IAAI,CAAC,IAAI,CAAC,CAAC,CAAY,IAAI,CAAC,WAAW,CAAC,EAAE,CAAC,CAAC,CAAC,WAAW,CAAC,YAAY,IAAI,IAAI,CAAC,CAAC,CAAkB,OAAO,CAAC,WAAW,CAAC,YAAY,EAAE,eAAe,CAAC,YAAY,CAAC,CAAC,EAAE;gBAClK,IAAI,CAAC,CAAC,CAAY,IAAI,CAAC,eAAe,CAAC,CAAC;gBACxC,IAAI,CAAC,CAAC,EAAwB,CAAC;aAC/B;YAED,OAAO,IAAA,UAAG,EAAE,IAAI,CAAC,CAAC,EAAW,eAAe,CAAC,YAAY,CAAC,CAAC;QAC5D,CAAC;QAEO,KAAK,CAAC,CAAC,CAAkB,cAAsC;YACtE,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,cAAc,CAAC,EAAE;gBACnC,OAAO,EAAE,CAAC;aACV;YAED,MAAM,OAAO,GAAgB,IAAI,GAAG,EAAE,CAAC;YACvC,MAAM,MAAM,GAA2B,EAAE,CAAC;YAE1C,sBAAsB;YACtB,KAAK,MAAM,aAAa,IAAI,cAAc,EAAE;gBAC3C,MAAM,SAAS,GAAG,aAAa,CAAC,SAAS,CAAC;gBAC1C,IAAI,CAAC,IAAA,eAAG,EAAmB,SAAS,CAAC,EAAE;oBACtC,OAAO,EAAE,CAAC,CAAC,iCAAiC;iBAC5C;gBAED,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,SAAS,CAAC,EAAE,CAAC,EAAE;oBAC/B,OAAO,CAAC,GAAG,CAAC,SAAS,CAAC,EAAE,CAAC,CAAC;oBAE1B,MAAM,UAAU,GAAG,IAAA,UAAG,EAAE,IAAI,CAAC,CAAC,EAAW,SAAS,CAAC,EAAE,CAAC,CAAC;oBACvD,MAAM,UAAU,GAAG,MAAM,IAAI,CAAC,CAAC,CAAY,UAAU,CAAC,CAAC;oBAEvD,6CAA6C;oBAC7C,IAAI,UAAU,EAAE;wBACf,IAAI,SAAS,CAAC,UAAU,CAAC,MAAM,KAAK,iBAAO,CAAC,IAAI,IAAI,MAAM,cAAQ,CAAC,MAAM,CAAC,SAAS,CAAC,UAAU,CAAC,MAAM,CAAC,EAAE;4BACvG,MAAM,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;yBAC3B;6BAAM;4BACN,mGAAmG;4BACnG,MAAM,IAAI,CAAC,CAAC,CAA0B,UAAU,CAAC,CAAC;yBAClD;qBACD;yBAAM;wBACN,MAAM,IAAI,CAAC,CAAC,CAAiB,UAAU,CAAC,CAAC;qBACzC;iBACD;aACD;YAED,OAAO,MAAM,CAAC;QACf,CAAC;QAEO,KAAK,CAAC,CAAC,CAAe,gBAAqC;YAClE,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,gBAAgB,CAAC,EAAE;gBACrC,OAAO,EAAE,CAAC;aACV;YAED,MAAM,MAAM,GAAwB,EAAE,CAAC;YACvC,MAAM,OAAO,GAAgB,IAAI,GAAG,EAAE,CAAC;YACvC,KAAK,MAAM,UAAU,IAAI,gBAAgB,EAAE;gBAC1C,MAAM,SAAS,GAAG,UAAU,CAAC,SAAS,CAAC;gBACvC,MAAM,GAAG,GAAG,IAAI,CAAC,CAAC,CAAiB,gBAAgB,CAAC,SAAS,CAAC,CAAC;gBAC/D,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE;oBACtB,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;oBAEjB,MAAM,UAAU,GAAG,IAAA,UAAG,EAAE,IAAI,CAAC,CAAC,EAAW,IAAI,CAAC,CAAC,CAAa,UAAU,CAAC,CAAC,CAAC;oBACzE,MAAM,UAAU,GAAG,MAAM,IAAI,CAAC,CAAC,CAAY,UAAU,CAAC,CAAC;oBAEvD,0CAA0C;oBAC1C,IAAI,UAAU,EAAE;wBACf,IAAI,SAAS,CAAC,MAAM,KAAK,iBAAO,CAAC,IAAI,IAAI,MAAM,cAAQ,CAAC,MAAM,CAAC,SAAS,CAAC,MAAM,CAAC,EAAE;4BACjF,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;yBACxB;6BAAM;4BACN,gGAAgG;4BAChG,MAAM,IAAI,CAAC,CAAC,CAA0B,UAAU,CAAC,CAAC;yBAClD;qBACD;yBAAM;wBACN,MAAM,IAAI,CAAC,CAAC,CAAiB,UAAU,CAAC,CAAC;qBACzC;iBACD;aACD;YAED,OAAO,MAAM,CAAC;QACf,CAAC;QAEO,KAAK,CAAC,CAAC,CAAuB,eAAyC;YAC9E,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,eAAe,CAAC,EAAE;gBACpC,OAAO,EAAE,CAAC;aACV;YAED,MAAM,MAAM,GAA6B,EAAE,CAAC;YAC5C,MAAM,OAAO,GAAgB,IAAI,GAAG,EAAE,CAAC;YAEvC,yBAAyB;YACzB,KAAK,MAAM,UAAU,IAAI,eAAe,EAAE;gBACzC,MAAM,YAAY,GAAG,UAAU,CAAC,YAAY,CAAC;gBAC7C,IAAI,OAAO,YAAY,KAAK,QAAQ,EAAE;oBACrC,OAAO,EAAE,CAAC;iBACV;gBAED,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,YAAY,CAAC,EAAE;oBAC/B,OAAO,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC;oBAE1B,MAAM,UAAU,GAAG,IAAA,UAAG,EAAE,IAAI,CAAC,CAAC,EAAW,YAAY,CAAC,CAAC;oBACvD,IAAI,MAAM,IAAI,CAAC,CAAC,CAAY,UAAU,CAAC,EAAE;wBACxC,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;qBACxB;yBAAM;wBACN,MAAM,IAAI,CAAC,CAAC,CAAiB,UAAU,CAAC,CAAC;qBACzC;iBACD;aACD;YAED,OAAO,MAAM,CAAC;QACf,CAAC;QAEO,KAAK,CAAC,CAAC,CAAiB,UAAkB;YACjD,IAAI;gBACH,MAAM,cAAQ,CAAC,EAAE,CAAC,UAAU,EAAE,gBAAU,CAAC,IAAI,CAAC,CAAC;aAC/C;YAAC,OAAO,KAAK,EAAE;gBACf,IAAI,CAAC,CAAC,CAAU,KAAK,CAAC,0CAA0C,KAAK,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC;aACpF;QACF,CAAC;QAEO,CAAC;YAER,4DAA4D;YAC5D,4DAA4D;YAC5D,8DAA8D;YAC9D,+BAA+B;YAE/B,IAAI,wBAAwB,GAAG,IAAA,iBAAI,GAA4B,CAAC;YAChE,OAAO,IAAI,CAAC,CAAC,CAAY,IAAI,CAAC,WAAW,CAAC,EAAE,CAAC,CAAC,CAAC,WAAW,CAAC,YAAY,IAAI,IAAI,CAAC,CAAC,CAAkB,OAAO,CAAC,WAAW,CAAC,YAAY,EAAE,wBAAwB,CAAC,EAAE,CAAC,CAAC,EAAE;gBACnK,wBAAwB,GAAG,IAAA,iBAAI,GAA4B,CAAC;aAC5D;YAED,OAAO,EAAE,YAAY,EAAE,wBAAwB,CAAC,EAAE,EAAE,CAAC;QACtD,CAAC;QAEO,KAAK,CAAC,CAAC,CAA0B,UAAkB;YAC1D,MAAM,wBAAwB,GAAG,IAAI,CAAC,CAAC,EAA4B,CAAC;YAEpE,oDAAoD;YACpD,MAAM,wBAAwB,GAAG,IAAA,UAAG,EAAE,IAAI,CAAC,CAAC,EAAW,wBAAwB,CAAC,YAAY,CAAC,CAAC;YAC9F,IAAI;gBACH,MAAM,cAAQ,CAAC,MAAM,CAAC,UAAU,EAAE,wBAAwB,EAAE,KAAK,CAAC,cAAc,CAAC,CAAC;aAClF;YAAC,OAAO,KAAK,EAAE;gBACf,IAAI,CAAC,CAAC,CAAU,KAAK,CAAC,2CAA2C,KAAK,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC;gBACrF,OAAO,KAAK,CAAC;aACb;YACD,IAAI,CAAC,CAAC,CAAY,IAAI,CAAC,wBAAwB,CAAC,CAAC;YAEjD,OAAO,IAAI,CAAC;QACb,CAAC;QAED,KAAK,CAAC,kBAAkB;YACvB,MAAM,eAAe,GAAoD,EAAE,CAAC;YAE5E,0BAA0B;YAC1B,KAAK,MAAM,SAAS,IAAI,IAAI,CAAC,CAAC,EAAW;gBACxC,IAAI,CAAC,MAAM,IAAI,CAAC,CAAC,CAAU,SAAS,CAAC,CAAC,EAAE;oBACvC,eAAe,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;iBAChC;aACD;YAED,uBAAuB;YACvB,KAAK,MAAM,MAAM,IAAI,IAAI,CAAC,CAAC,EAAQ;gBAClC,IAAI,CAAC,MAAM,IAAI,CAAC,CAAC,CAAU,MAAM,CAAC,CAAC,EAAE;oBACpC,eAAe,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;iBAC7B;aACD;YAED,OAAO,eAAe,CAAC;QACxB,CAAC;QAEO,CAAC,CAAU,cAAiF;YACnG,IAAI,UAAkB,CAAC;YAEvB,QAAQ;YACR,IAAI,IAAA,aAAI,EAAoB,cAAc,CAAC,EAAE;gBAC5C,UAAU,GAAG,IAAA,UAAG,EAAE,IAAI,CAAC,CAAC,EAAW,cAAc,CAAC,YAAY,CAAC,CAAC;aAChE;YAED,SAAS;iBACJ,IAAI,IAAA,YAAG,EAAgB,cAAc,CAAC,EAAE;gBAC5C,UAAU,GAAG,IAAA,UAAG,EAAE,IAAI,CAAC,CAAC,EAAW,IAAI,CAAC,CAAC,CAAa,cAAc,CAAC,CAAC,CAAC;aACvE;YAED,YAAY;iBACP;gBACJ,UAAU,GAAG,IAAA,UAAG,EAAE,IAAI,CAAC,CAAC,EAAW,cAAc,CAAC,SAAS,CAAC,EAAE,CAAC,CAAC;aAChE;YAED,OAAO,IAAI,CAAC,CAAC,CAAY,UAAU,CAAC,CAAC;QACtC,CAAC;QAEO,KAAK,CAAC,CAAC,CAAY,UAAkB;YAC5C,IAAI;gBACH,MAAM,aAAa,GAAG,MAAM,cAAQ,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC;gBAEzD,KAAK,MAAM,YAAY,IAAI,aAAa,EAAE;oBACzC,IAAI;wBACH,MAAM,oBAAoB,GAAG,MAAM,cAAQ,CAAC,OAAO,CAAC,IAAA,UAAG,EAAE,UAAU,EAAE,YAAY,CAAC,CAAC,CAAC;wBACpF,IAAI,oBAAoB,CAAC,MAAM,GAAG,CAAC,EAAE;4BACpC,OAAO,IAAI,CAAC;yBACZ;qBACD;oBAAC,OAAO,KAAK,EAAE;wBACf,iBAAiB;qBACjB;iBACD;aACD;YAAC,OAAO,KAAK,EAAE;gBACf,6BAA6B;aAC7B;YAED,OAAO,KAAK,CAAC;QACd,CAAC;QAGO,CAAC;YACR,MAAM,0BAA0B,GAAgC;gBAC/D,UAAU,EAAE,IAAI,CAAC,CAAC,CAAU,GAAG,CAAC,CAAC,EAAE,SAAS,EAAE,eAAe,EAAE,EAAE,EAAE;oBAClE,MAAM,6BAA6B,GAAmC;wBACrE,EAAE,EAAE,SAAS,CAAC,EAAE;wBAChB,aAAa,EAAE,SAAS,CAAC,UAAU,CAAC,QAAQ,EAAE;qBAC9C,CAAC;oBAEF,IAAI,eAAe,EAAE;wBACpB,6BAA6B,CAAC,eAAe,GAAG,eAAe,CAAC;qBAChE;oBAED,OAAO,6BAA6B,CAAC;gBACtC,CAAC,CAAC;gBACF,OAAO,EAAE,IAAI,CAAC,CAAC,CAAO,GAAG,CAAC,CAAC,EAAE,SAAS,EAAE,eAAe,EAAE,EAAE,EAAE;oBAC5D,MAAM,0BAA0B,GAChC;wBACC,SAAS,EAAE,SAAS,CAAC,QAAQ,EAAE;qBAC/B,CAAC;oBAEF,IAAI,eAAe,EAAE;wBACpB,0BAA0B,CAAC,eAAe,GAAG,eAAe,CAAC;qBAC7D;oBAED,OAAO,0BAA0B,CAAC;gBACnC,CAAC,CAAC;gBACF,YAAY,EAAE,IAAI,CAAC,CAAC,CAAY,GAAG,CAAC,CAAC,EAAE,YAAY,EAAE,eAAe,EAAE,EAAE,EAAE;oBACzE,MAAM,+BAA+B,GAAqC;wBACzE,YAAY;qBACZ,CAAC;oBAEF,IAAI,eAAe,EAAE;wBACpB,+BAA+B,CAAC,eAAe,GAAG,eAAe,CAAC;qBAClE;oBAED,OAAO,+BAA+B,CAAC;gBACxC,CAAC,CAAC;aACF,CAAC;YAEF,IAAI,CAAC,CAAC,CAAY,OAAO,CAAC,MAAI,CAAc,CAAC,EAAmC,0BAA0B,CAAC,CAAC;QAC7G,CAAC;QAES,CAAC,CAAa,MAAyB;YAChD,MAAM,SAAS,GAAG,MAAM,CAAC,SAAS,CAAC;YAEnC,IAAI,GAAW,CAAC;YAChB,IAAI,SAAS,CAAC,MAAM,KAAK,iBAAO,CAAC,IAAI,EAAE;gBACtC,GAAG,GAAG,aAAE,CAAM,CAAC,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC,SAAS,CAAC,MAAM,CAAC,WAAW,EAAE,CAAC,CAAC,oDAAoD;aACvH;iBAAM;gBACN,GAAG,GAAG,SAAS,CAAC,QAAQ,EAAE,CAAC,WAAW,EAAE,CAAC;aACzC;YAED,OAAO,IAAA,mBAAU,EAAC,KAAK,CAAC,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;QACpD,CAAC;;IAtYW,oBAAI;mBAAJ,IAAI;QAmBd,WAAA,6BAAI,CAAA;QACJ,WAAA,mBAAG,CAAA;QACH,WAAA,SAAG,CAAA;QACH,WAAA,WAAG,CAAA;OAtBO,IAAI,CAuYhB","file":"backupMainService.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { createHash } from 'crypto';\nimport { isEqual } from 'vs/base/common/extpath';\nimport { Schemas } from 'vs/base/common/network';\nimport { join } from 'vs/base/common/path';\nimport { isLinux } from 'vs/base/common/platform';\nimport { extUriBiasedIgnorePathCase } from 'vs/base/common/resources';\nimport { Promises, RimRafMode } from 'vs/base/node/pfs';\nimport { IBackupMainService } from 'vs/platform/backup/electron-main/backup';\nimport { ISerializedBackupWorkspaces, IEmptyWindowBackupInfo, isEmptyWindowBackupInfo, deserializeWorkspaceInfos, deserializeFolderInfos, ISerializedWorkspaceBackupInfo, ISerializedFolderBackupInfo, ISerializedEmptyWindowBackupInfo } from 'vs/platform/backup/node/backup';\nimport { IConfigurationService } from 'vs/platform/configuration/common/configuration';\nimport { IEnvironmentMainService } from 'vs/platform/environment/electron-main/environmentMainService';\nimport { IStateService } from 'vs/platform/state/node/state';\nimport { HotExitConfiguration, IFilesConfiguration } from 'vs/platform/files/common/files';\nimport { ILogService } from 'vs/platform/log/common/log';\nimport { IFolderBackupInfo, isFolderBackupInfo, IWorkspaceBackupInfo } from 'vs/platform/backup/common/backup';\nimport { isWorkspaceIdentifier } from 'vs/platform/workspace/common/workspace';\nimport { createEmptyWorkspaceIdentifier } from 'vs/platform/workspaces/node/workspaces';\n\nexport class BackupMainService implements IBackupMainService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate static readonly backupWorkspacesMetadataStorageKey = 'backupWorkspaces';\n\n\tprotected backupHome = this.environmentMainService.backupHome;\n\n\tprivate workspaces: IWorkspaceBackupInfo[] = [];\n\tprivate folders: IFolderBackupInfo[] = [];\n\tprivate emptyWindows: IEmptyWindowBackupInfo[] = [];\n\n\t// Comparers for paths and resources that will\n\t// - ignore path casing on Windows/macOS\n\t// - respect path casing on Linux\n\tprivate readonly backupUriComparer = extUriBiasedIgnorePathCase;\n\tprivate readonly backupPathComparer = { isEqual: (pathA: string, pathB: string) => isEqual(pathA, pathB, !isLinux) };\n\n\tconstructor(\n\t\t@IEnvironmentMainService private readonly environmentMainService: IEnvironmentMainService,\n\t\t@IConfigurationService private readonly configurationService: IConfigurationService,\n\t\t@ILogService private readonly logService: ILogService,\n\t\t@IStateService private readonly stateService: IStateService\n\t) {\n\t}\n\n\tasync initialize(): Promise<void> {\n\n\t\t// read backup workspaces\n\t\tconst serializedBackupWorkspaces = this.stateService.getItem<ISerializedBackupWorkspaces>(BackupMainService.backupWorkspacesMetadataStorageKey) ?? { workspaces: [], folders: [], emptyWindows: [] };\n\n\t\t// validate empty workspaces backups first\n\t\tthis.emptyWindows = await this.validateEmptyWorkspaces(serializedBackupWorkspaces.emptyWindows);\n\n\t\t// validate workspace backups\n\t\tthis.workspaces = await this.validateWorkspaces(deserializeWorkspaceInfos(serializedBackupWorkspaces));\n\n\t\t// validate folder backups\n\t\tthis.folders = await this.validateFolders(deserializeFolderInfos(serializedBackupWorkspaces));\n\n\t\t// store metadata in case some workspaces or folders have been removed\n\t\tthis.storeWorkspacesMetadata();\n\t}\n\n\tprotected getWorkspaceBackups(): IWorkspaceBackupInfo[] {\n\t\tif (this.isHotExitOnExitAndWindowClose()) {\n\t\t\t// Only non-folder windows are restored on main process launch when\n\t\t\t// hot exit is configured as onExitAndWindowClose.\n\t\t\treturn [];\n\t\t}\n\n\t\treturn this.workspaces.slice(0); // return a copy\n\t}\n\n\tprotected getFolderBackups(): IFolderBackupInfo[] {\n\t\tif (this.isHotExitOnExitAndWindowClose()) {\n\t\t\t// Only non-folder windows are restored on main process launch when\n\t\t\t// hot exit is configured as onExitAndWindowClose.\n\t\t\treturn [];\n\t\t}\n\n\t\treturn this.folders.slice(0); // return a copy\n\t}\n\n\tisHotExitEnabled(): boolean {\n\t\treturn this.getHotExitConfig() !== HotExitConfiguration.OFF;\n\t}\n\n\tprivate isHotExitOnExitAndWindowClose(): boolean {\n\t\treturn this.getHotExitConfig() === HotExitConfiguration.ON_EXIT_AND_WINDOW_CLOSE;\n\t}\n\n\tprivate getHotExitConfig(): string {\n\t\tconst config = this.configurationService.getValue<IFilesConfiguration>();\n\n\t\treturn config?.files?.hotExit || HotExitConfiguration.ON_EXIT;\n\t}\n\n\tgetEmptyWindowBackups(): IEmptyWindowBackupInfo[] {\n\t\treturn this.emptyWindows.slice(0); // return a copy\n\t}\n\n\tregisterWorkspaceBackup(workspaceInfo: IWorkspaceBackupInfo): string;\n\tregisterWorkspaceBackup(workspaceInfo: IWorkspaceBackupInfo, migrateFrom: string): Promise<string>;\n\tregisterWorkspaceBackup(workspaceInfo: IWorkspaceBackupInfo, migrateFrom?: string): string | Promise<string> {\n\t\tif (!this.workspaces.some(workspace => workspaceInfo.workspace.id === workspace.workspace.id)) {\n\t\t\tthis.workspaces.push(workspaceInfo);\n\t\t\tthis.storeWorkspacesMetadata();\n\t\t}\n\n\t\tconst backupPath = join(this.backupHome, workspaceInfo.workspace.id);\n\n\t\tif (migrateFrom) {\n\t\t\treturn this.moveBackupFolder(backupPath, migrateFrom).then(() => backupPath);\n\t\t}\n\n\t\treturn backupPath;\n\t}\n\n\tprivate async moveBackupFolder(backupPath: string, moveFromPath: string): Promise<void> {\n\n\t\t// Target exists: make sure to convert existing backups to empty window backups\n\t\tif (await Promises.exists(backupPath)) {\n\t\t\tawait this.convertToEmptyWindowBackup(backupPath);\n\t\t}\n\n\t\t// When we have data to migrate from, move it over to the target location\n\t\tif (await Promises.exists(moveFromPath)) {\n\t\t\ttry {\n\t\t\t\tawait Promises.rename(moveFromPath, backupPath, false /* no retry */);\n\t\t\t} catch (error) {\n\t\t\t\tthis.logService.error(`Backup: Could not move backup folder to new location: ${error.toString()}`);\n\t\t\t}\n\t\t}\n\t}\n\n\tregisterFolderBackup(folderInfo: IFolderBackupInfo): string {\n\t\tif (!this.folders.some(folder => this.backupUriComparer.isEqual(folderInfo.folderUri, folder.folderUri))) {\n\t\t\tthis.folders.push(folderInfo);\n\t\t\tthis.storeWorkspacesMetadata();\n\t\t}\n\n\t\treturn join(this.backupHome, this.getFolderHash(folderInfo));\n\t}\n\n\tregisterEmptyWindowBackup(emptyWindowInfo: IEmptyWindowBackupInfo): string {\n\t\tif (!this.emptyWindows.some(emptyWindow => !!emptyWindow.backupFolder && this.backupPathComparer.isEqual(emptyWindow.backupFolder, emptyWindowInfo.backupFolder))) {\n\t\t\tthis.emptyWindows.push(emptyWindowInfo);\n\t\t\tthis.storeWorkspacesMetadata();\n\t\t}\n\n\t\treturn join(this.backupHome, emptyWindowInfo.backupFolder);\n\t}\n\n\tprivate async validateWorkspaces(rootWorkspaces: IWorkspaceBackupInfo[]): Promise<IWorkspaceBackupInfo[]> {\n\t\tif (!Array.isArray(rootWorkspaces)) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst seenIds: Set<string> = new Set();\n\t\tconst result: IWorkspaceBackupInfo[] = [];\n\n\t\t// Validate Workspaces\n\t\tfor (const workspaceInfo of rootWorkspaces) {\n\t\t\tconst workspace = workspaceInfo.workspace;\n\t\t\tif (!isWorkspaceIdentifier(workspace)) {\n\t\t\t\treturn []; // wrong format, skip all entries\n\t\t\t}\n\n\t\t\tif (!seenIds.has(workspace.id)) {\n\t\t\t\tseenIds.add(workspace.id);\n\n\t\t\t\tconst backupPath = join(this.backupHome, workspace.id);\n\t\t\t\tconst hasBackups = await this.doHasBackups(backupPath);\n\n\t\t\t\t// If the workspace has no backups, ignore it\n\t\t\t\tif (hasBackups) {\n\t\t\t\t\tif (workspace.configPath.scheme !== Schemas.file || await Promises.exists(workspace.configPath.fsPath)) {\n\t\t\t\t\t\tresult.push(workspaceInfo);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// If the workspace has backups, but the target workspace is missing, convert backups to empty ones\n\t\t\t\t\t\tawait this.convertToEmptyWindowBackup(backupPath);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tawait this.deleteStaleBackup(backupPath);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate async validateFolders(folderWorkspaces: IFolderBackupInfo[]): Promise<IFolderBackupInfo[]> {\n\t\tif (!Array.isArray(folderWorkspaces)) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst result: IFolderBackupInfo[] = [];\n\t\tconst seenIds: Set<string> = new Set();\n\t\tfor (const folderInfo of folderWorkspaces) {\n\t\t\tconst folderURI = folderInfo.folderUri;\n\t\t\tconst key = this.backupUriComparer.getComparisonKey(folderURI);\n\t\t\tif (!seenIds.has(key)) {\n\t\t\t\tseenIds.add(key);\n\n\t\t\t\tconst backupPath = join(this.backupHome, this.getFolderHash(folderInfo));\n\t\t\t\tconst hasBackups = await this.doHasBackups(backupPath);\n\n\t\t\t\t// If the folder has no backups, ignore it\n\t\t\t\tif (hasBackups) {\n\t\t\t\t\tif (folderURI.scheme !== Schemas.file || await Promises.exists(folderURI.fsPath)) {\n\t\t\t\t\t\tresult.push(folderInfo);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// If the folder has backups, but the target workspace is missing, convert backups to empty ones\n\t\t\t\t\t\tawait this.convertToEmptyWindowBackup(backupPath);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tawait this.deleteStaleBackup(backupPath);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate async validateEmptyWorkspaces(emptyWorkspaces: IEmptyWindowBackupInfo[]): Promise<IEmptyWindowBackupInfo[]> {\n\t\tif (!Array.isArray(emptyWorkspaces)) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst result: IEmptyWindowBackupInfo[] = [];\n\t\tconst seenIds: Set<string> = new Set();\n\n\t\t// Validate Empty Windows\n\t\tfor (const backupInfo of emptyWorkspaces) {\n\t\t\tconst backupFolder = backupInfo.backupFolder;\n\t\t\tif (typeof backupFolder !== 'string') {\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\tif (!seenIds.has(backupFolder)) {\n\t\t\t\tseenIds.add(backupFolder);\n\n\t\t\t\tconst backupPath = join(this.backupHome, backupFolder);\n\t\t\t\tif (await this.doHasBackups(backupPath)) {\n\t\t\t\t\tresult.push(backupInfo);\n\t\t\t\t} else {\n\t\t\t\t\tawait this.deleteStaleBackup(backupPath);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate async deleteStaleBackup(backupPath: string): Promise<void> {\n\t\ttry {\n\t\t\tawait Promises.rm(backupPath, RimRafMode.MOVE);\n\t\t} catch (error) {\n\t\t\tthis.logService.error(`Backup: Could not delete stale backup: ${error.toString()}`);\n\t\t}\n\t}\n\n\tprivate prepareNewEmptyWindowBackup(): IEmptyWindowBackupInfo {\n\n\t\t// We are asked to prepare a new empty window backup folder.\n\t\t// Empty windows backup folders are derived from a workspace\n\t\t// identifier, so we generate a new empty workspace identifier\n\t\t// until we found a unique one.\n\n\t\tlet emptyWorkspaceIdentifier = createEmptyWorkspaceIdentifier();\n\t\twhile (this.emptyWindows.some(emptyWindow => !!emptyWindow.backupFolder && this.backupPathComparer.isEqual(emptyWindow.backupFolder, emptyWorkspaceIdentifier.id))) {\n\t\t\temptyWorkspaceIdentifier = createEmptyWorkspaceIdentifier();\n\t\t}\n\n\t\treturn { backupFolder: emptyWorkspaceIdentifier.id };\n\t}\n\n\tprivate async convertToEmptyWindowBackup(backupPath: string): Promise<boolean> {\n\t\tconst newEmptyWindowBackupInfo = this.prepareNewEmptyWindowBackup();\n\n\t\t// Rename backupPath to new empty window backup path\n\t\tconst newEmptyWindowBackupPath = join(this.backupHome, newEmptyWindowBackupInfo.backupFolder);\n\t\ttry {\n\t\t\tawait Promises.rename(backupPath, newEmptyWindowBackupPath, false /* no retry */);\n\t\t} catch (error) {\n\t\t\tthis.logService.error(`Backup: Could not rename backup folder: ${error.toString()}`);\n\t\t\treturn false;\n\t\t}\n\t\tthis.emptyWindows.push(newEmptyWindowBackupInfo);\n\n\t\treturn true;\n\t}\n\n\tasync getDirtyWorkspaces(): Promise<Array<IWorkspaceBackupInfo | IFolderBackupInfo>> {\n\t\tconst dirtyWorkspaces: Array<IWorkspaceBackupInfo | IFolderBackupInfo> = [];\n\n\t\t// Workspaces with backups\n\t\tfor (const workspace of this.workspaces) {\n\t\t\tif ((await this.hasBackups(workspace))) {\n\t\t\t\tdirtyWorkspaces.push(workspace);\n\t\t\t}\n\t\t}\n\n\t\t// Folders with backups\n\t\tfor (const folder of this.folders) {\n\t\t\tif ((await this.hasBackups(folder))) {\n\t\t\t\tdirtyWorkspaces.push(folder);\n\t\t\t}\n\t\t}\n\n\t\treturn dirtyWorkspaces;\n\t}\n\n\tprivate hasBackups(backupLocation: IWorkspaceBackupInfo | IEmptyWindowBackupInfo | IFolderBackupInfo): Promise<boolean> {\n\t\tlet backupPath: string;\n\n\t\t// Empty\n\t\tif (isEmptyWindowBackupInfo(backupLocation)) {\n\t\t\tbackupPath = join(this.backupHome, backupLocation.backupFolder);\n\t\t}\n\n\t\t// Folder\n\t\telse if (isFolderBackupInfo(backupLocation)) {\n\t\t\tbackupPath = join(this.backupHome, this.getFolderHash(backupLocation));\n\t\t}\n\n\t\t// Workspace\n\t\telse {\n\t\t\tbackupPath = join(this.backupHome, backupLocation.workspace.id);\n\t\t}\n\n\t\treturn this.doHasBackups(backupPath);\n\t}\n\n\tprivate async doHasBackups(backupPath: string): Promise<boolean> {\n\t\ttry {\n\t\t\tconst backupSchemas = await Promises.readdir(backupPath);\n\n\t\t\tfor (const backupSchema of backupSchemas) {\n\t\t\t\ttry {\n\t\t\t\t\tconst backupSchemaChildren = await Promises.readdir(join(backupPath, backupSchema));\n\t\t\t\t\tif (backupSchemaChildren.length > 0) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\t// invalid folder\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (error) {\n\t\t\t// backup path does not exist\n\t\t}\n\n\t\treturn false;\n\t}\n\n\n\tprivate storeWorkspacesMetadata(): void {\n\t\tconst serializedBackupWorkspaces: ISerializedBackupWorkspaces = {\n\t\t\tworkspaces: this.workspaces.map(({ workspace, remoteAuthority }) => {\n\t\t\t\tconst serializedWorkspaceBackupInfo: ISerializedWorkspaceBackupInfo = {\n\t\t\t\t\tid: workspace.id,\n\t\t\t\t\tconfigURIPath: workspace.configPath.toString()\n\t\t\t\t};\n\n\t\t\t\tif (remoteAuthority) {\n\t\t\t\t\tserializedWorkspaceBackupInfo.remoteAuthority = remoteAuthority;\n\t\t\t\t}\n\n\t\t\t\treturn serializedWorkspaceBackupInfo;\n\t\t\t}),\n\t\t\tfolders: this.folders.map(({ folderUri, remoteAuthority }) => {\n\t\t\t\tconst serializedFolderBackupInfo: ISerializedFolderBackupInfo =\n\t\t\t\t{\n\t\t\t\t\tfolderUri: folderUri.toString()\n\t\t\t\t};\n\n\t\t\t\tif (remoteAuthority) {\n\t\t\t\t\tserializedFolderBackupInfo.remoteAuthority = remoteAuthority;\n\t\t\t\t}\n\n\t\t\t\treturn serializedFolderBackupInfo;\n\t\t\t}),\n\t\t\temptyWindows: this.emptyWindows.map(({ backupFolder, remoteAuthority }) => {\n\t\t\t\tconst serializedEmptyWindowBackupInfo: ISerializedEmptyWindowBackupInfo = {\n\t\t\t\t\tbackupFolder\n\t\t\t\t};\n\n\t\t\t\tif (remoteAuthority) {\n\t\t\t\t\tserializedEmptyWindowBackupInfo.remoteAuthority = remoteAuthority;\n\t\t\t\t}\n\n\t\t\t\treturn serializedEmptyWindowBackupInfo;\n\t\t\t})\n\t\t};\n\n\t\tthis.stateService.setItem(BackupMainService.backupWorkspacesMetadataStorageKey, serializedBackupWorkspaces);\n\t}\n\n\tprotected getFolderHash(folder: IFolderBackupInfo): string {\n\t\tconst folderUri = folder.folderUri;\n\n\t\tlet key: string;\n\t\tif (folderUri.scheme === Schemas.file) {\n\t\t\tkey = isLinux ? folderUri.fsPath : folderUri.fsPath.toLowerCase(); // for backward compatibility, use the fspath as key\n\t\t} else {\n\t\t\tkey = folderUri.toString().toLowerCase();\n\t\t}\n\n\t\treturn createHash('md5').update(key).digest('hex');\n\t}\n}\n"]}