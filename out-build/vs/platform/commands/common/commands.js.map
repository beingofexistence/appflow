{"version":3,"sources":["file:///workspace/appflow/src/vs/platform/commands/common/commands.ts"],"names":[],"mappings":"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","file":"commands.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { Iterable } from 'vs/base/common/iterator';\nimport { IJSONSchema } from 'vs/base/common/jsonSchema';\nimport { IDisposable, toDisposable } from 'vs/base/common/lifecycle';\nimport { LinkedList } from 'vs/base/common/linkedList';\nimport { TypeConstraint, validateConstraints } from 'vs/base/common/types';\nimport { createDecorator, ServicesAccessor } from 'vs/platform/instantiation/common/instantiation';\n\nexport const ICommandService = createDecorator<ICommandService>('commandService');\n\nexport interface ICommandEvent {\n\tcommandId: string;\n\targs: any[];\n}\n\nexport interface ICommandService {\n\treadonly _serviceBrand: undefined;\n\tonWillExecuteCommand: Event<ICommandEvent>;\n\tonDidExecuteCommand: Event<ICommandEvent>;\n\texecuteCommand<T = any>(commandId: string, ...args: any[]): Promise<T | undefined>;\n}\n\nexport type ICommandsMap = Map<string, ICommand>;\n\nexport interface ICommandHandler {\n\t(accessor: ServicesAccessor, ...args: any[]): void;\n}\n\nexport interface ICommand {\n\tid: string;\n\thandler: ICommandHandler;\n\tdescription?: ICommandHandlerDescription | null;\n}\n\nexport interface ICommandHandlerDescription {\n\treadonly description: string;\n\treadonly args: ReadonlyArray<{\n\t\treadonly name: string;\n\t\treadonly isOptional?: boolean;\n\t\treadonly description?: string;\n\t\treadonly constraint?: TypeConstraint;\n\t\treadonly schema?: IJSONSchema;\n\t}>;\n\treadonly returns?: string;\n}\n\nexport interface ICommandRegistry {\n\tonDidRegisterCommand: Event<string>;\n\tregisterCommand(id: string, command: ICommandHandler): IDisposable;\n\tregisterCommand(command: ICommand): IDisposable;\n\tregisterCommandAlias(oldId: string, newId: string): IDisposable;\n\tgetCommand(id: string): ICommand | undefined;\n\tgetCommands(): ICommandsMap;\n}\n\nexport const CommandsRegistry: ICommandRegistry = new class implements ICommandRegistry {\n\n\tprivate readonly _commands = new Map<string, LinkedList<ICommand>>();\n\n\tprivate readonly _onDidRegisterCommand = new Emitter<string>();\n\treadonly onDidRegisterCommand: Event<string> = this._onDidRegisterCommand.event;\n\n\tregisterCommand(idOrCommand: string | ICommand, handler?: ICommandHandler): IDisposable {\n\n\t\tif (!idOrCommand) {\n\t\t\tthrow new Error(`invalid command`);\n\t\t}\n\n\t\tif (typeof idOrCommand === 'string') {\n\t\t\tif (!handler) {\n\t\t\t\tthrow new Error(`invalid command`);\n\t\t\t}\n\t\t\treturn this.registerCommand({ id: idOrCommand, handler });\n\t\t}\n\n\t\t// add argument validation if rich command metadata is provided\n\t\tif (idOrCommand.description) {\n\t\t\tconst constraints: Array<TypeConstraint | undefined> = [];\n\t\t\tfor (const arg of idOrCommand.description.args) {\n\t\t\t\tconstraints.push(arg.constraint);\n\t\t\t}\n\t\t\tconst actualHandler = idOrCommand.handler;\n\t\t\tidOrCommand.handler = function (accessor, ...args: any[]) {\n\t\t\t\tvalidateConstraints(args, constraints);\n\t\t\t\treturn actualHandler(accessor, ...args);\n\t\t\t};\n\t\t}\n\n\t\t// find a place to store the command\n\t\tconst { id } = idOrCommand;\n\n\t\tlet commands = this._commands.get(id);\n\t\tif (!commands) {\n\t\t\tcommands = new LinkedList<ICommand>();\n\t\t\tthis._commands.set(id, commands);\n\t\t}\n\n\t\tconst removeFn = commands.unshift(idOrCommand);\n\n\t\tconst ret = toDisposable(() => {\n\t\t\tremoveFn();\n\t\t\tconst command = this._commands.get(id);\n\t\t\tif (command?.isEmpty()) {\n\t\t\t\tthis._commands.delete(id);\n\t\t\t}\n\t\t});\n\n\t\t// tell the world about this command\n\t\tthis._onDidRegisterCommand.fire(id);\n\n\t\treturn ret;\n\t}\n\n\tregisterCommandAlias(oldId: string, newId: string): IDisposable {\n\t\treturn CommandsRegistry.registerCommand(oldId, (accessor, ...args) => accessor.get(ICommandService).executeCommand(newId, ...args));\n\t}\n\n\tgetCommand(id: string): ICommand | undefined {\n\t\tconst list = this._commands.get(id);\n\t\tif (!list || list.isEmpty()) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn Iterable.first(list);\n\t}\n\n\tgetCommands(): ICommandsMap {\n\t\tconst result = new Map<string, ICommand>();\n\t\tfor (const key of this._commands.keys()) {\n\t\t\tconst command = this.getCommand(key);\n\t\t\tif (command) {\n\t\t\t\tresult.set(key, command);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n};\n\nCommandsRegistry.registerCommand('noop', () => { });\n"]}