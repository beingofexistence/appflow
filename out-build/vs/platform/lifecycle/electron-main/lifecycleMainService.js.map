{"version":3,"sources":["file:///workspace/appflow/src/vs/platform/lifecycle/electron-main/lifecycleMainService.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;;;;;;;;;;;IAkBnF,QAAA,IAAI,GAAoB,IAAA,mBAAG,EAAoC,sBAAsB,CAAC,CAAC;IAoBpG,IAAkB,cAajB;IAbD,WAAkB,cAAc;QAE/B;;WAEG;QACH,mDAAQ,CAAA;QAER;;;;WAIG;QACH,mDAAI,CAAA;IACL,CAAC,EAbiB,cAAc,8BAAd,cAAc,QAa/B;IA6HD,IAAkB,kBAwBjB;IAxBD,WAAkB,kBAAkB;QAEnC;;WAEG;QACH,mEAAY,CAAA;QAEZ;;WAEG;QACH,6DAAS,CAAA;QAET;;;;WAIG;QACH,iFAAmB,CAAA;QAEnB;;;WAGG;QACH,uEAAc,CAAA;IACf,CAAC,EAxBiB,kBAAkB,kCAAlB,kBAAkB,QAwBnC;IAEM,IAAM,IAAI,GAAV,MAAM,IAAqB,SAAQ,eAAG;;iBAIpB,MAAC,GAAsB,0BAAtB,AAAgD,CAAC;QAe1E,IAAI,aAAa,KAAc,OAAO,IAAI,CAAC,CAAC,CAAc,CAAC,CAAC;QAG5D,IAAI,YAAY,KAAc,OAAO,IAAI,CAAC,CAAC,CAAa,CAAC,CAAC;QAG1D,IAAI,KAAK,KAAyB,OAAO,IAAI,CAAC,CAAC,CAAM,CAAC,CAAC;QAiBvD,YACc,CAAgC,EAC9B,CAAkC,EACxB,CAA6C;YAEtE,KAAK,EAAE,CAAC;YAJsB,MAAC,GAAD,CAAC,CAAc;YACb,MAAC,GAAD,CAAC,CAAgB;YACP,MAAC,GAAD,CAAC,CAA2B;YAvCtD,MAAC,GAAmB,IAAI,CAAC,CAAC,CAAS,IAAI,WAAG,EAAY,CAAC,CAAC;YAChE,qBAAgB,GAAG,IAAI,CAAC,CAAC,CAAiB,KAAK,CAAC;YAExC,MAAC,GAAiB,IAAI,CAAC,CAAC,CAAS,IAAI,WAAG,EAAqB,CAAC,CAAC;YACvE,mBAAc,GAAG,IAAI,CAAC,CAAC,CAAe,KAAK,CAAC;YAEpC,MAAC,GAAmB,IAAI,CAAC,CAAC,CAAS,IAAI,WAAG,EAAuB,CAAC,CAAC;YAC3E,qBAAgB,GAAG,IAAI,CAAC,CAAC,CAAiB,KAAK,CAAC;YAExC,MAAC,GAAsB,IAAI,CAAC,CAAC,CAAS,IAAI,WAAG,EAAmB,CAAC,CAAC;YAC1E,wBAAmB,GAAG,IAAI,CAAC,CAAC,CAAoB,KAAK,CAAC;YAEvD,MAAC,GAAgB,KAAK,CAAC;YAGvB,MAAC,GAAwB,KAAK,CAAC;YAG/B,MAAC,uCAAoC;YAG5B,MAAC,GAAsB,IAAI,GAAG,EAAU,CAAC;YAClD,MAAC,GAA+B,CAAC,CAAC;YAClC,MAAC,GAAe,CAAC,CAAC;YAElB,MAAC,GAAkD,SAAS,CAAC;YAC7D,MAAC,GAAkE,SAAS,CAAC;YAE7E,MAAC,GAAuD,SAAS,CAAC;YAEzD,MAAC,GAA4B,IAAI,GAAG,EAA4B,CAAC;YAEjE,MAAC,GAAW,IAAI,GAAG,EAA+B,CAAC;YAE5D,MAAC,GAA+C,SAAS,CAAC;YASjE,IAAI,CAAC,CAAC,EAAiB,CAAC;YACxB,IAAI,CAAC,IAAI,kCAA0B,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,CAAC,EAAkB,CAAC,CAAC;QAC1E,CAAC;QAEO,CAAC;YACR,IAAI,CAAC,CAAC,GAAe,CAAC,CAAC,IAAI,CAAC,CAAC,CAAY,OAAO,CAAC,MAAI,CAAiB,CAAC,CAAoB,CAAC;YAE5F,IAAI,IAAI,CAAC,CAAC,EAAc;gBACvB,yCAAyC;gBACzC,IAAI,CAAC,CAAC,CAAY,UAAU,CAAC,MAAI,CAAiB,CAAC,CAAoB,CAAC;aACxE;QACF,CAAC;QAEO,CAAC;YAER,8DAA8D;YAC9D,8CAA8C;YAC9C,MAAM,kBAAkB,GAAG,GAAG,EAAE;gBAC/B,IAAI,IAAI,CAAC,CAAC,EAAe;oBACxB,OAAO;iBACP;gBAED,IAAI,CAAC,CAAC,CAAK,+BAA+B,CAAC,CAAC;gBAC5C,IAAI,CAAC,CAAC,GAAgB,IAAI,CAAC;gBAE3B,uDAAuD;gBACvD,IAAI,CAAC,CAAC,CAAK,mCAAmC,CAAC,CAAC;gBAChD,IAAI,CAAC,CAAC,CAAiB,IAAI,EAAE,CAAC;gBAE9B,+DAA+D;gBAC/D,+DAA+D;gBAC/D,kBAAkB;gBAClB,IAAI,aAAE,IAAa,IAAI,CAAC,CAAC,KAAiB,CAAC,EAAE;oBAC5C,IAAI,CAAC,CAAC,6BAAsC,CAAC;iBAC7C;YACF,CAAC,CAAC;YACF,cAAG,CAAC,WAAW,CAAC,aAAa,EAAE,kBAAkB,CAAC,CAAC;YAEnD,mEAAmE;YACnE,mEAAmE;YACnE,2BAA2B;YAC3B,MAAM,uBAAuB,GAAG,GAAG,EAAE;gBACpC,IAAI,CAAC,CAAC,CAAK,qCAAqC,CAAC,CAAC;gBAElD,sDAAsD;gBACtD,4CAA4C;gBAC5C,IAAI,IAAI,CAAC,CAAC,IAAiB,CAAC,aAAE,EAAW;oBACxC,cAAG,CAAC,IAAI,EAAE,CAAC;iBACX;YACF,CAAC,CAAC;YACF,cAAG,CAAC,WAAW,CAAC,mBAAmB,EAAE,uBAAuB,CAAC,CAAC;YAE9D,gEAAgE;YAChE,wCAAwC;YACxC,cAAG,CAAC,IAAI,CAAC,WAAW,EAAE,CAAC,CAAC,EAAE;gBACzB,IAAI,CAAC,CAAC,CAAK,qCAAqC,CAAC,CAAC;gBAElD,2DAA2D;gBAC3D,CAAC,CAAC,cAAc,EAAE,CAAC;gBAEnB,0BAA0B;gBAC1B,MAAM,eAAe,GAAG,IAAI,CAAC,CAAC,6BAAsC,CAAC;gBAErE,iDAAiD;gBACjD,eAAe,CAAC,OAAO,CAAC,GAAG,EAAE;oBAC5B,IAAI,CAAC,CAAC,CAAK,wDAAwD,CAAC,CAAC;oBAErE,gDAAgD;oBAChD,IAAI,CAAC,CAAC,CAAyB,KAAK,CAAC,aAAa,CAAC,CAAC;oBAEpD,uDAAuD;oBACvD,oDAAoD;oBACpD,uDAAuD;oBAEvD,cAAG,CAAC,cAAc,CAAC,aAAa,EAAE,kBAAkB,CAAC,CAAC;oBACtD,cAAG,CAAC,cAAc,CAAC,mBAAmB,EAAE,uBAAuB,CAAC,CAAC;oBAEjE,IAAI,CAAC,CAAC,CAAK,kDAAkD,CAAC,CAAC;oBAE/D,cAAG,CAAC,IAAI,EAAE,CAAC;gBACZ,CAAC,CAAC,CAAC;YACJ,CAAC,CAAC,CAAC;QACJ,CAAC;QAEO,CAAC,CAAkB,MAAsB;YAChD,IAAI,IAAI,CAAC,CAAC,EAA2B;gBACpC,OAAO,IAAI,CAAC,CAAC,CAA0B,CAAC,8BAA8B;aACtE;YAED,MAAM,UAAU,GAAG,IAAI,CAAC,CAAC,CAAU;YACnC,IAAI,CAAC,CAAC,CAAK,iCAAiC,CAAC,CAAC;YAE9C,MAAM,OAAO,GAAoB,EAAE,CAAC;YAEpC,IAAI,CAAC,CAAC,CAAe,IAAI,CAAC;gBACzB,MAAM;gBACN,IAAI,CAAC,EAAE,EAAE,OAAO;oBACf,UAAU,CAAC,KAAK,CAAC,qCAAqC,EAAE,GAAG,CAAC,CAAC;oBAC7D,OAAO,CAAC,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,GAAG,EAAE;wBACjC,UAAU,CAAC,KAAK,CAAC,mCAAmC,EAAE,GAAG,CAAC,CAAC;oBAC5D,CAAC,CAAC,CAAC,CAAC;gBACL,CAAC;aACD,CAAC,CAAC;YAEH,IAAI,CAAC,CAAC,GAA4B,CAAC,KAAK,IAAI,EAAE;gBAE7C,oCAAoC;gBACpC,IAAI;oBACH,MAAM,gBAAQ,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC;iBAChC;gBAAC,OAAO,KAAK,EAAE;oBACf,IAAI,CAAC,CAAC,CAAU,KAAK,CAAC,KAAK,CAAC,CAAC;iBAC7B;gBAED,oCAAoC;gBACpC,gCAAgC;gBAChC,IAAI;oBACH,MAAM,IAAI,CAAC,CAAC,CAAY,KAAK,EAAE,CAAC;iBAChC;gBAAC,OAAO,KAAK,EAAE;oBACf,IAAI,CAAC,CAAC,CAAU,KAAK,CAAC,KAAK,CAAC,CAAC;iBAC7B;YACF,CAAC,CAAC,EAAE,CAAC;YAEL,OAAO,IAAI,CAAC,CAAC,CAA0B;QACxC,CAAC;QAED,IAAI,KAAK,CAAC,KAAyB;YAClC,IAAI,KAAK,GAAG,IAAI,CAAC,KAAK,EAAE;gBACvB,MAAM,IAAI,KAAK,CAAC,+BAA+B,CAAC,CAAC;aACjD;YAED,IAAI,IAAI,CAAC,CAAC,KAAU,KAAK,EAAE;gBAC1B,OAAO;aACP;YAED,IAAI,CAAC,CAAC,CAAK,2CAA2C,KAAK,GAAG,CAAC,CAAC;YAEhE,IAAI,CAAC,CAAC,GAAQ,KAAK,CAAC;YAEpB,MAAM,OAAO,GAAG,IAAI,CAAC,CAAC,CAAS,GAAG,CAAC,IAAI,CAAC,CAAC,CAAM,CAAC;YAChD,IAAI,OAAO,EAAE;gBACZ,OAAO,CAAC,IAAI,EAAE,CAAC;gBACf,IAAI,CAAC,CAAC,CAAS,MAAM,CAAC,IAAI,CAAC,CAAC,CAAM,CAAC;aACnC;QACF,CAAC;QAED,KAAK,CAAC,IAAI,CAAC,KAAyB;YACnC,IAAI,KAAK,IAAI,IAAI,CAAC,CAAC,EAAO;gBACzB,OAAO;aACP;YAED,IAAI,OAAO,GAAG,IAAI,CAAC,CAAC,CAAS,GAAG,CAAC,KAAK,CAAC,CAAC;YACxC,IAAI,CAAC,OAAO,EAAE;gBACb,OAAO,GAAG,IAAI,WAAG,EAAM,CAAC;gBACxB,IAAI,CAAC,CAAC,CAAS,GAAG,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;aACnC;YAED,MAAM,OAAO,CAAC,IAAI,EAAE,CAAC;QACtB,CAAC;QAED,cAAc,CAAC,MAAmB;YACjC,MAAM,eAAe,GAAG,IAAI,eAAG,EAAc,CAAC;YAE9C,qBAAqB;YACrB,IAAI,CAAC,CAAC,EAAc,CAAC;YAErB,mBAAmB;YACnB,eAAe,CAAC,GAAG,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC,CAAC,CAAiB,IAAI,CAAC,EAAE,MAAM,EAAE,SAAS,EAAE,CAAC,CAAC,SAAS,EAAE,MAAM,EAAE,CAAC,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC,CAAC;YAE/H,0CAA0C;YAC1C,MAAM,GAAG,GAAG,IAAA,WAAG,EAAa,MAAM,CAAC,GAAG,CAAC,CAAC;YACxC,GAAG,CAAC,EAAE,CAAC,OAAO,EAAE,CAAC,CAAC,EAAE;gBAEnB,+CAA+C;gBAC/C,MAAM,QAAQ,GAAG,MAAM,CAAC,EAAE,CAAC;gBAC3B,IAAI,IAAI,CAAC,CAAC,CAAoB,GAAG,CAAC,QAAQ,CAAC,EAAE;oBAC5C,IAAI,CAAC,CAAC,CAAoB,MAAM,CAAC,QAAQ,CAAC,CAAC;oBAE3C,OAAO;iBACP;gBAED,IAAI,CAAC,CAAC,CAAK,4CAA4C,MAAM,CAAC,EAAE,EAAE,CAAC,CAAC;gBAEpE,qDAAqD;gBACrD,CAAC,CAAC,cAAc,EAAE,CAAC;gBACnB,IAAI,CAAC,MAAM,CAAC,MAAM,6BAAqB,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE;oBACnD,IAAI,IAAI,EAAE;wBACT,IAAI,CAAC,CAAC,CAAoB,MAAM,CAAC,QAAQ,CAAC,CAAC;wBAC3C,OAAO;qBACP;oBAED,IAAI,CAAC,CAAC,CAAoB,GAAG,CAAC,QAAQ,CAAC,CAAC;oBAExC,mDAAmD;oBACnD,IAAI,CAAC,CAAC,CAAK,oDAAoD,QAAQ,EAAE,CAAC,CAAC;oBAC3E,IAAI,CAAC,CAAC,CAAoB,IAAI,CAAC,MAAM,CAAC,CAAC;oBAEvC,4BAA4B;oBAC5B,MAAM,CAAC,KAAK,EAAE,CAAC;gBAChB,CAAC,CAAC,CAAC;YACJ,CAAC,CAAC,CAAC;YAEH,uBAAuB;YACvB,GAAG,CAAC,EAAE,CAAC,QAAQ,EAAE,GAAG,EAAE;gBACrB,IAAI,CAAC,CAAC,CAAK,6CAA6C,MAAM,CAAC,EAAE,EAAE,CAAC,CAAC;gBAErE,sBAAsB;gBACtB,IAAI,CAAC,CAAC,EAAc,CAAC;gBAErB,yBAAyB;gBACzB,eAAe,CAAC,OAAO,EAAE,CAAC;gBAE1B,kFAAkF;gBAClF,0EAA0E;gBAC1E,yEAAyE;gBACzE,IAAI,IAAI,CAAC,CAAC,KAAiB,CAAC,IAAI,CAAC,CAAC,aAAE,IAAa,IAAI,CAAC,CAAC,CAAc,EAAE;oBACtE,IAAI,CAAC,CAAC,6BAAsC,CAAC;iBAC7C;YACF,CAAC,CAAC,CAAC;QACJ,CAAC;QAED,KAAK,CAAC,MAAM,CAAC,MAAmB,EAAE,GAAsB;YAEvD,kDAAkD;YAClD,MAAM,IAAI,GAAG,MAAM,IAAI,CAAC,MAAM,CAAC,MAAM,8BAAsB,CAAC;YAC5D,IAAI,CAAC,IAAI,EAAE;gBACV,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;aACnB;QACF,CAAC;QAED,MAAM,CAAC,MAAmB,EAAE,MAAoB;YAE/C,yDAAyD;YACzD,MAAM,oBAAoB,GAAG,IAAI,CAAC,CAAC,CAA0B,GAAG,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;YAC5E,IAAI,oBAAoB,EAAE;gBACzB,OAAO,oBAAoB,CAAC;aAC5B;YAED,kDAAkD;YAClD,MAAM,aAAa,GAAG,IAAI,CAAC,CAAC,CAAQ,MAAM,EAAE,MAAM,CAAC,CAAC,OAAO,CAAC,GAAG,EAAE;gBAChE,IAAI,CAAC,CAAC,CAA0B,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;YACnD,CAAC,CAAC,CAAC;YACH,IAAI,CAAC,CAAC,CAA0B,GAAG,CAAC,MAAM,CAAC,EAAE,EAAE,aAAa,CAAC,CAAC;YAE9D,OAAO,aAAa,CAAC;QACtB,CAAC;QAEO,KAAK,CAAC,CAAC,CAAQ,MAAmB,EAAE,MAAoB;YAE/D,wDAAwD;YACxD,IAAI,CAAC,MAAM,CAAC,OAAO,EAAE;gBACpB,OAAO,KAAK,CAAC;aACb;YAED,IAAI,CAAC,CAAC,CAAK,kCAAkC,MAAM,CAAC,EAAE,EAAE,CAAC,CAAC;YAE1D,qDAAqD;YACrD,MAAM,kBAAkB,GAAG,IAAI,CAAC,CAAC,CAAc,CAAC,2BAAmB,CAAC,CAAC,MAAM,CAAC;YAC5E,MAAM,IAAI,GAAG,MAAM,IAAI,CAAC,CAAC,CAA8B,MAAM,EAAE,kBAAkB,CAAC,CAAC;YACnF,IAAI,IAAI,EAAE;gBACT,IAAI,CAAC,CAAC,CAAK,oDAAoD,MAAM,CAAC,EAAE,GAAG,CAAC,CAAC;gBAE7E,OAAO,IAAI,CAAC,CAAC,CAAsB,IAAI,CAAC,CAAC;aACzC;YAED,qDAAqD;YACrD,MAAM,IAAI,CAAC,CAAC,CAA4B,MAAM,EAAE,kBAAkB,CAAC,CAAC;YAEpE,OAAO,KAAK,CAAC;QACd,CAAC;QAEO,CAAC,CAAsB,IAAa;YAC3C,IAAI,CAAC,IAAI,EAAE;gBACV,OAAO,KAAK,CAAC,CAAC,UAAU;aACxB;YAED,6CAA6C;YAC7C,IAAI,CAAC,CAAC,CAAyB,IAAI,CAAC,UAAU,CAAC,CAAC;YAEhD,8CAA8C;YAC9C,IAAI,CAAC,CAAC,GAAgB,KAAK,CAAC;YAE5B,OAAO,IAAI,CAAC,CAAC,OAAO;QACrB,CAAC;QAEO,CAAC,CAAyB,IAAa;YAC9C,IAAI,IAAI,CAAC,CAAC,EAA0B;gBACnC,IAAI,CAAC,CAAC,CAAyB,IAAI,CAAC,CAAC;gBACrC,IAAI,CAAC,CAAC,GAA2B,SAAS,CAAC;gBAC3C,IAAI,CAAC,CAAC,GAAoB,SAAS,CAAC;aACpC;QACF,CAAC;QAEO,CAAC,CAA8B,MAAmB,EAAE,MAAoB;YAC/E,OAAO,IAAI,OAAO,CAAU,OAAO,CAAC,EAAE;gBACrC,MAAM,iBAAiB,GAAG,IAAI,CAAC,CAAC,EAA8B,CAAC;gBAC/D,MAAM,SAAS,GAAG,YAAY,iBAAiB,EAAE,CAAC;gBAClD,MAAM,aAAa,GAAG,gBAAgB,iBAAiB,EAAE,CAAC;gBAE1D,aAAG,CAAc,IAAI,CAAC,SAAS,EAAE,GAAG,EAAE;oBACrC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,UAAU;gBAC3B,CAAC,CAAC,CAAC;gBAEH,aAAG,CAAc,IAAI,CAAC,aAAa,EAAE,GAAG,EAAE;oBACzC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,OAAO;gBACvB,CAAC,CAAC,CAAC;gBAEH,MAAM,CAAC,IAAI,CAAC,uBAAuB,EAAE,EAAE,SAAS,EAAE,aAAa,EAAE,MAAM,EAAE,CAAC,CAAC;YAC5E,CAAC,CAAC,CAAC;QACJ,CAAC;QAEO,CAAC,CAA4B,MAAmB,EAAE,MAAoB;YAC7E,OAAO,IAAI,OAAO,CAAO,OAAO,CAAC,EAAE;gBAClC,MAAM,iBAAiB,GAAG,IAAI,CAAC,CAAC,EAA8B,CAAC;gBAC/D,MAAM,YAAY,GAAG,eAAe,iBAAiB,EAAE,CAAC;gBAExD,aAAG,CAAc,IAAI,CAAC,YAAY,EAAE,GAAG,EAAE,CAAC,OAAO,EAAE,CAAC,CAAC;gBAErD,MAAM,CAAC,IAAI,CAAC,qBAAqB,EAAE,EAAE,YAAY,EAAE,MAAM,EAAE,CAAC,CAAC;YAC9D,CAAC,CAAC,CAAC;QACJ,CAAC;QAED,IAAI,CAAC,WAAqB;YACzB,OAAO,IAAI,CAAC,CAAC,CAAM,WAAW,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE;gBAC3C,IAAI,CAAC,IAAI,IAAI,WAAW,EAAE;oBACzB,+EAA+E;oBAC/E,4EAA4E;oBAC5E,6EAA6E;oBAC7E,uEAAuE;oBACvE,IAAI;wBACH,IAAI,aAAE,EAAS;4BACd,MAAM,iBAAiB,GAAG,IAAA,aAAG,GAAE,CAAC;4BAChC,IAAI,iBAAiB,KAAK,OAAO,CAAC,GAAG,EAAE,EAAE;gCACxC,OAAO,CAAC,KAAK,CAAC,iBAAiB,CAAC,CAAC;6BACjC;yBACD;qBACD;oBAAC,OAAO,GAAG,EAAE;wBACb,IAAI,CAAC,CAAC,CAAU,KAAK,CAAC,GAAG,CAAC,CAAC;qBAC3B;iBACD;gBAED,OAAO,IAAI,CAAC;YACb,CAAC,CAAC,CAAC;QACJ,CAAC;QAEO,CAAC,CAAM,WAAqB;YACnC,IAAI,CAAC,CAAC,CAAK,0CAA0C,WAAW,GAAG,CAAC,CAAC;YAErE,IAAI,IAAI,CAAC,CAAC,EAAmB;gBAC5B,IAAI,CAAC,CAAC,CAAK,mDAAmD,CAAC,CAAC;gBAEhE,OAAO,IAAI,CAAC,CAAC,CAAkB;aAC/B;YAED,sCAAsC;YACtC,IAAI,WAAW,EAAE;gBAChB,IAAI,CAAC,CAAC,CAAY,OAAO,CAAC,MAAI,CAAiB,CAAC,EAAqB,IAAI,CAAC,CAAC;aAC3E;YAED,IAAI,CAAC,CAAC,GAAoB,IAAI,OAAO,CAAC,OAAO,CAAC,EAAE;gBAE/C,yDAAyD;gBACzD,IAAI,CAAC,CAAC,GAA2B,OAAO,CAAC;gBAEzC,2EAA2E;gBAC3E,6EAA6E;gBAC7E,IAAI,CAAC,CAAC,CAAK,uCAAuC,CAAC,CAAC;gBACpD,cAAG,CAAC,IAAI,EAAE,CAAC;YACZ,CAAC,CAAC,CAAC;YAEH,OAAO,IAAI,CAAC,CAAC,CAAkB;QAChC,CAAC;QAEO,CAAC,CAAK,GAAW;YACxB,IAAI,IAAI,CAAC,CAAC,CAAsB,IAAI,CAAC,0BAA0B,CAAC,EAAE;gBACjE,IAAI,CAAC,CAAC,CAAU,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,sDAAsD;aACjF;iBAAM;gBACN,IAAI,CAAC,CAAC,CAAU,KAAK,CAAC,GAAG,CAAC,CAAC;aAC3B;QACF,CAAC;QAED,kBAAkB,CAAC,OAAyB;YAC3C,IAAI,CAAC,CAAC,GAAiB,OAAO,CAAC;QAChC,CAAC;QAED,KAAK,CAAC,QAAQ,CAAC,OAA0B;YACxC,IAAI,CAAC,CAAC,CAAK,sBAAsB,CAAC,CAAC;YAEnC,MAAM,IAAI,GAAG,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;YACnC,IAAI,OAAO,EAAE,OAAO,EAAE;gBACrB,IAAI,CAAC,IAAI,CAAC,GAAG,OAAO,CAAC,OAAO,CAAC,CAAC;aAC9B;YAED,IAAI,OAAO,EAAE,UAAU,EAAE;gBACxB,KAAK,MAAM,CAAC,IAAI,OAAO,CAAC,UAAU,EAAE;oBACnC,MAAM,GAAG,GAAG,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;oBAC5B,IAAI,GAAG,IAAI,CAAC,EAAE;wBACb,IAAI,CAAC,MAAM,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC;qBACpB;iBACD;aACD;YAED,MAAM,YAAY,GAAG,GAAG,EAAE;gBACzB,IAAI,CAAC,IAAI,CAAC,CAAC,EAAgB,cAAc,CAAC,OAAO,CAAC,EAAE;oBACnD,IAAI,CAAC,CAAC,CAAK,+CAA+C,CAAC,CAAC;oBAC5D,cAAG,CAAC,QAAQ,CAAC,EAAE,IAAI,EAAE,CAAC,CAAC;iBACvB;YACF,CAAC,CAAC;YACF,cAAG,CAAC,IAAI,CAAC,MAAM,EAAE,YAAY,CAAC,CAAC;YAE/B,kEAAkE;YAClE,qEAAqE;YACrE,MAAM,IAAI,GAAG,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,kBAAkB,CAAC,CAAC;YACtD,IAAI,IAAI,EAAE;gBACT,cAAG,CAAC,cAAc,CAAC,MAAM,EAAE,YAAY,CAAC,CAAC;aACzC;QACF,CAAC;QAED,KAAK,CAAC,IAAI,CAAC,IAAa;YACvB,IAAI,CAAC,CAAC,CAAK,kBAAkB,CAAC,CAAC;YAE/B,8DAA8D;YAC9D,MAAM,IAAI,CAAC,CAAC,6BAAsC,CAAC;YAEnD,oEAAoE;YACpE,qEAAqE;YACrE,kEAAkE;YAClE,gBAAgB;YAChB,EAAE;YACF,kDAAkD;YAClD,oHAAoH;YAEpH,MAAM,OAAO,CAAC,IAAI,CAAC;gBAElB,kCAAkC;gBAClC,IAAA,WAAG,EAAK,IAAI,CAAC;gBAEb,mEAAmE;gBACnE,kEAAkE;gBAClE,iEAAiE;gBACjE,qCAAqC;gBACrC,CAAC,KAAK,IAAI,EAAE;oBACX,KAAK,MAAM,MAAM,IAAI,wBAAa,CAAC,aAAa,EAAE,EAAE;wBACnD,IAAI,MAAM,IAAI,CAAC,MAAM,CAAC,WAAW,EAAE,EAAE;4BACpC,IAAI,gBAA+B,CAAC;4BACpC,IAAI,MAAM,CAAC,WAAW,IAAI,CAAC,MAAM,CAAC,WAAW,CAAC,WAAW,EAAE,EAAE;gCAC5D,gBAAgB,GAAG,IAAI,OAAO,CAAC,OAAO,CAAC,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC,CAAC;6BAC1E;iCAAM;gCACN,gBAAgB,GAAG,OAAO,CAAC,OAAO,EAAE,CAAC;6BACrC;4BAED,MAAM,CAAC,OAAO,EAAE,CAAC;4BACjB,MAAM,gBAAgB,CAAC;yBACvB;qBACD;gBACF,CAAC,CAAC,EAAE;aACJ,CAAC,CAAC;YAEH,oDAAoD;YACpD,cAAG,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAChB,CAAC;;IA5fW,oBAAI;mBAAJ,IAAI;QA2Cd,WAAA,SAAG,CAAA;QACH,WAAA,WAAG,CAAA;QACH,WAAA,6BAAI,CAAA;OA7CM,IAAI,CA6fhB","file":"lifecycleMainService.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { app, BrowserWindow } from 'electron';\nimport { validatedIpcMain } from 'vs/base/parts/ipc/electron-main/ipcMain';\nimport { Barrier, Promises, timeout } from 'vs/base/common/async';\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { Disposable, DisposableStore } from 'vs/base/common/lifecycle';\nimport { isMacintosh, isWindows } from 'vs/base/common/platform';\nimport { cwd } from 'vs/base/common/process';\nimport { assertIsDefined } from 'vs/base/common/types';\nimport { NativeParsedArgs } from 'vs/platform/environment/common/argv';\nimport { createDecorator } from 'vs/platform/instantiation/common/instantiation';\nimport { ILogService } from 'vs/platform/log/common/log';\nimport { IStateService } from 'vs/platform/state/node/state';\nimport { ICodeWindow, LoadReason, UnloadReason } from 'vs/platform/window/electron-main/window';\nimport { ISingleFolderWorkspaceIdentifier, IWorkspaceIdentifier } from 'vs/platform/workspace/common/workspace';\nimport { IEnvironmentMainService } from 'vs/platform/environment/electron-main/environmentMainService';\n\nexport const ILifecycleMainService = createDecorator<ILifecycleMainService>('lifecycleMainService');\n\ninterface WindowLoadEvent {\n\n\t/**\n\t * The window that is loaded to a new workspace.\n\t */\n\treadonly window: ICodeWindow;\n\n\t/**\n\t * The workspace the window is loaded into.\n\t */\n\treadonly workspace: IWorkspaceIdentifier | ISingleFolderWorkspaceIdentifier | undefined;\n\n\t/**\n\t * More details why the window loads to a new workspace.\n\t */\n\treadonly reason: LoadReason;\n}\n\nexport const enum ShutdownReason {\n\n\t/**\n\t * The application exits normally.\n\t */\n\tQUIT = 1,\n\n\t/**\n\t * The application exits abnormally and is being\n\t * killed with an exit code (e.g. from integration\n\t * test run)\n\t */\n\tKILL\n}\n\nexport interface ShutdownEvent {\n\n\t/**\n\t * More details why the application is shutting down.\n\t */\n\treason: ShutdownReason;\n\n\t/**\n\t * Allows to join the shutdown. The promise can be a long running operation but it\n\t * will block the application from closing.\n\t */\n\tjoin(id: string, promise: Promise<void>): void;\n}\n\nexport interface IRelaunchHandler {\n\n\t/**\n\t * Allows a handler to deal with relaunching the application. The return\n\t * value indicates if the relaunch is handled or not.\n\t */\n\thandleRelaunch(options?: IRelaunchOptions): boolean;\n}\n\nexport interface IRelaunchOptions {\n\treadonly addArgs?: string[];\n\treadonly removeArgs?: string[];\n}\n\nexport interface ILifecycleMainService {\n\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Will be true if the program was restarted (e.g. due to explicit request or update).\n\t */\n\treadonly wasRestarted: boolean;\n\n\t/**\n\t * Will be true if the program was requested to quit.\n\t */\n\treadonly quitRequested: boolean;\n\n\t/**\n\t * A flag indicating in what phase of the lifecycle we currently are.\n\t */\n\tphase: LifecycleMainPhase;\n\n\t/**\n\t * An event that fires when the application is about to shutdown before any window is closed.\n\t * The shutdown can still be prevented by any window that vetos this event.\n\t */\n\treadonly onBeforeShutdown: Event<void>;\n\n\t/**\n\t * An event that fires after the onBeforeShutdown event has been fired and after no window has\n\t * vetoed the shutdown sequence. At this point listeners are ensured that the application will\n\t * quit without veto.\n\t */\n\treadonly onWillShutdown: Event<ShutdownEvent>;\n\n\t/**\n\t * An event that fires when a window is loading. This can either be a window opening for the\n\t * first time or a window reloading or changing to another URL.\n\t */\n\treadonly onWillLoadWindow: Event<WindowLoadEvent>;\n\n\t/**\n\t * An event that fires before a window closes. This event is fired after any veto has been dealt\n\t * with so that listeners know for sure that the window will close without veto.\n\t */\n\treadonly onBeforeCloseWindow: Event<ICodeWindow>;\n\n\t/**\n\t * Make a `ICodeWindow` known to the lifecycle main service.\n\t */\n\tregisterWindow(window: ICodeWindow): void;\n\n\t/**\n\t * Reload a window. All lifecycle event handlers are triggered.\n\t */\n\treload(window: ICodeWindow, cli?: NativeParsedArgs): Promise<void>;\n\n\t/**\n\t * Unload a window for the provided reason. All lifecycle event handlers are triggered.\n\t */\n\tunload(window: ICodeWindow, reason: UnloadReason): Promise<boolean /* veto */>;\n\n\t/**\n\t * Restart the application with optional arguments (CLI). All lifecycle event handlers are triggered.\n\t */\n\trelaunch(options?: IRelaunchOptions): Promise<void>;\n\n\t/**\n\t * Sets a custom handler for relaunching the application.\n\t */\n\tsetRelaunchHandler(handler: IRelaunchHandler): void;\n\n\t/**\n\t * Shutdown the application normally. All lifecycle event handlers are triggered.\n\t */\n\tquit(willRestart?: boolean): Promise<boolean /* veto */>;\n\n\t/**\n\t * Forcefully shutdown the application and optionally set an exit code.\n\t *\n\t * This method should only be used in rare situations where it is important\n\t * to set an exit code (e.g. running tests) or when the application is\n\t * not in a healthy state and should terminate asap.\n\t *\n\t * This method does not fire the normal lifecycle events to the windows,\n\t * that normally can be vetoed. Windows are destroyed without a chance\n\t * of components to participate. The only lifecycle event handler that\n\t * is triggered is `onWillShutdown` in the main process.\n\t */\n\tkill(code?: number): Promise<void>;\n\n\t/**\n\t * Returns a promise that resolves when a certain lifecycle phase\n\t * has started.\n\t */\n\twhen(phase: LifecycleMainPhase): Promise<void>;\n}\n\nexport const enum LifecycleMainPhase {\n\n\t/**\n\t * The first phase signals that we are about to startup.\n\t */\n\tStarting = 1,\n\n\t/**\n\t * Services are ready and first window is about to open.\n\t */\n\tReady = 2,\n\n\t/**\n\t * This phase signals a point in time after the window has opened\n\t * and is typically the best place to do work that is not required\n\t * for the window to open.\n\t */\n\tAfterWindowOpen = 3,\n\n\t/**\n\t * The last phase after a window has opened and some time has passed\n\t * (2-5 seconds).\n\t */\n\tEventually = 4\n}\n\nexport class LifecycleMainService extends Disposable implements ILifecycleMainService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate static readonly QUIT_AND_RESTART_KEY = 'lifecycle.quitAndRestart';\n\n\tprivate readonly _onBeforeShutdown = this._register(new Emitter<void>());\n\treadonly onBeforeShutdown = this._onBeforeShutdown.event;\n\n\tprivate readonly _onWillShutdown = this._register(new Emitter<ShutdownEvent>());\n\treadonly onWillShutdown = this._onWillShutdown.event;\n\n\tprivate readonly _onWillLoadWindow = this._register(new Emitter<WindowLoadEvent>());\n\treadonly onWillLoadWindow = this._onWillLoadWindow.event;\n\n\tprivate readonly _onBeforeCloseWindow = this._register(new Emitter<ICodeWindow>());\n\treadonly onBeforeCloseWindow = this._onBeforeCloseWindow.event;\n\n\tprivate _quitRequested = false;\n\tget quitRequested(): boolean { return this._quitRequested; }\n\n\tprivate _wasRestarted: boolean = false;\n\tget wasRestarted(): boolean { return this._wasRestarted; }\n\n\tprivate _phase = LifecycleMainPhase.Starting;\n\tget phase(): LifecycleMainPhase { return this._phase; }\n\n\tprivate readonly windowToCloseRequest = new Set<number>();\n\tprivate oneTimeListenerTokenGenerator = 0;\n\tprivate windowCounter = 0;\n\n\tprivate pendingQuitPromise: Promise<boolean> | undefined = undefined;\n\tprivate pendingQuitPromiseResolve: { (veto: boolean): void } | undefined = undefined;\n\n\tprivate pendingWillShutdownPromise: Promise<void> | undefined = undefined;\n\n\tprivate readonly mapWindowIdToPendingUnload = new Map<number, Promise<boolean>>();\n\n\tprivate readonly phaseWhen = new Map<LifecycleMainPhase, Barrier>();\n\n\tprivate relaunchHandler: IRelaunchHandler | undefined = undefined;\n\n\tconstructor(\n\t\t@ILogService private readonly logService: ILogService,\n\t\t@IStateService private readonly stateService: IStateService,\n\t\t@IEnvironmentMainService private readonly environmentMainService: IEnvironmentMainService\n\t) {\n\t\tsuper();\n\n\t\tthis.resolveRestarted();\n\t\tthis.when(LifecycleMainPhase.Ready).then(() => this.registerListeners());\n\t}\n\n\tprivate resolveRestarted(): void {\n\t\tthis._wasRestarted = !!this.stateService.getItem(LifecycleMainService.QUIT_AND_RESTART_KEY);\n\n\t\tif (this._wasRestarted) {\n\t\t\t// remove the marker right after if found\n\t\t\tthis.stateService.removeItem(LifecycleMainService.QUIT_AND_RESTART_KEY);\n\t\t}\n\t}\n\n\tprivate registerListeners(): void {\n\n\t\t// before-quit: an event that is fired if application quit was\n\t\t// requested but before any window was closed.\n\t\tconst beforeQuitListener = () => {\n\t\t\tif (this._quitRequested) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.trace('Lifecycle#app.on(before-quit)');\n\t\t\tthis._quitRequested = true;\n\n\t\t\t// Emit event to indicate that we are about to shutdown\n\t\t\tthis.trace('Lifecycle#onBeforeShutdown.fire()');\n\t\t\tthis._onBeforeShutdown.fire();\n\n\t\t\t// macOS: can run without any window open. in that case we fire\n\t\t\t// the onWillShutdown() event directly because there is no veto\n\t\t\t// to be expected.\n\t\t\tif (isMacintosh && this.windowCounter === 0) {\n\t\t\t\tthis.fireOnWillShutdown(ShutdownReason.QUIT);\n\t\t\t}\n\t\t};\n\t\tapp.addListener('before-quit', beforeQuitListener);\n\n\t\t// window-all-closed: an event that only fires when the last window\n\t\t// was closed. We override this event to be in charge if app.quit()\n\t\t// should be called or not.\n\t\tconst windowAllClosedListener = () => {\n\t\t\tthis.trace('Lifecycle#app.on(window-all-closed)');\n\n\t\t\t// Windows/Linux: we quit when all windows have closed\n\t\t\t// Mac: we only quit when quit was requested\n\t\t\tif (this._quitRequested || !isMacintosh) {\n\t\t\t\tapp.quit();\n\t\t\t}\n\t\t};\n\t\tapp.addListener('window-all-closed', windowAllClosedListener);\n\n\t\t// will-quit: an event that is fired after all windows have been\n\t\t// closed, but before actually quitting.\n\t\tapp.once('will-quit', e => {\n\t\t\tthis.trace('Lifecycle#app.on(will-quit) - begin');\n\n\t\t\t// Prevent the quit until the shutdown promise was resolved\n\t\t\te.preventDefault();\n\n\t\t\t// Start shutdown sequence\n\t\t\tconst shutdownPromise = this.fireOnWillShutdown(ShutdownReason.QUIT);\n\n\t\t\t// Wait until shutdown is signaled to be complete\n\t\t\tshutdownPromise.finally(() => {\n\t\t\t\tthis.trace('Lifecycle#app.on(will-quit) - after fireOnWillShutdown');\n\n\t\t\t\t// Resolve pending quit promise now without veto\n\t\t\t\tthis.resolvePendingQuitPromise(false /* no veto */);\n\n\t\t\t\t// Quit again, this time do not prevent this, since our\n\t\t\t\t// will-quit listener is only installed \"once\". Also\n\t\t\t\t// remove any listener we have that is no longer needed\n\n\t\t\t\tapp.removeListener('before-quit', beforeQuitListener);\n\t\t\t\tapp.removeListener('window-all-closed', windowAllClosedListener);\n\n\t\t\t\tthis.trace('Lifecycle#app.on(will-quit) - calling app.quit()');\n\n\t\t\t\tapp.quit();\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate fireOnWillShutdown(reason: ShutdownReason): Promise<void> {\n\t\tif (this.pendingWillShutdownPromise) {\n\t\t\treturn this.pendingWillShutdownPromise; // shutdown is already running\n\t\t}\n\n\t\tconst logService = this.logService;\n\t\tthis.trace('Lifecycle#onWillShutdown.fire()');\n\n\t\tconst joiners: Promise<void>[] = [];\n\n\t\tthis._onWillShutdown.fire({\n\t\t\treason,\n\t\t\tjoin(id, promise) {\n\t\t\t\tlogService.trace(`Lifecycle#onWillShutdown - begin '${id}'`);\n\t\t\t\tjoiners.push(promise.finally(() => {\n\t\t\t\t\tlogService.trace(`Lifecycle#onWillShutdown - end '${id}'`);\n\t\t\t\t}));\n\t\t\t}\n\t\t});\n\n\t\tthis.pendingWillShutdownPromise = (async () => {\n\n\t\t\t// Settle all shutdown event joiners\n\t\t\ttry {\n\t\t\t\tawait Promises.settled(joiners);\n\t\t\t} catch (error) {\n\t\t\t\tthis.logService.error(error);\n\t\t\t}\n\n\t\t\t// Then, always make sure at the end\n\t\t\t// the state service is flushed.\n\t\t\ttry {\n\t\t\t\tawait this.stateService.close();\n\t\t\t} catch (error) {\n\t\t\t\tthis.logService.error(error);\n\t\t\t}\n\t\t})();\n\n\t\treturn this.pendingWillShutdownPromise;\n\t}\n\n\tset phase(value: LifecycleMainPhase) {\n\t\tif (value < this.phase) {\n\t\t\tthrow new Error('Lifecycle cannot go backwards');\n\t\t}\n\n\t\tif (this._phase === value) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.trace(`lifecycle (main): phase changed (value: ${value})`);\n\n\t\tthis._phase = value;\n\n\t\tconst barrier = this.phaseWhen.get(this._phase);\n\t\tif (barrier) {\n\t\t\tbarrier.open();\n\t\t\tthis.phaseWhen.delete(this._phase);\n\t\t}\n\t}\n\n\tasync when(phase: LifecycleMainPhase): Promise<void> {\n\t\tif (phase <= this._phase) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet barrier = this.phaseWhen.get(phase);\n\t\tif (!barrier) {\n\t\t\tbarrier = new Barrier();\n\t\t\tthis.phaseWhen.set(phase, barrier);\n\t\t}\n\n\t\tawait barrier.wait();\n\t}\n\n\tregisterWindow(window: ICodeWindow): void {\n\t\tconst windowListeners = new DisposableStore();\n\n\t\t// track window count\n\t\tthis.windowCounter++;\n\n\t\t// Window Will Load\n\t\twindowListeners.add(window.onWillLoad(e => this._onWillLoadWindow.fire({ window, workspace: e.workspace, reason: e.reason })));\n\n\t\t// Window Before Closing: Main -> Renderer\n\t\tconst win = assertIsDefined(window.win);\n\t\twin.on('close', e => {\n\n\t\t\t// The window already acknowledged to be closed\n\t\t\tconst windowId = window.id;\n\t\t\tif (this.windowToCloseRequest.has(windowId)) {\n\t\t\t\tthis.windowToCloseRequest.delete(windowId);\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.trace(`Lifecycle#window.on('close') - window ID ${window.id}`);\n\n\t\t\t// Otherwise prevent unload and handle it from window\n\t\t\te.preventDefault();\n\t\t\tthis.unload(window, UnloadReason.CLOSE).then(veto => {\n\t\t\t\tif (veto) {\n\t\t\t\t\tthis.windowToCloseRequest.delete(windowId);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis.windowToCloseRequest.add(windowId);\n\n\t\t\t\t// Fire onBeforeCloseWindow before actually closing\n\t\t\t\tthis.trace(`Lifecycle#onBeforeCloseWindow.fire() - window ID ${windowId}`);\n\t\t\t\tthis._onBeforeCloseWindow.fire(window);\n\n\t\t\t\t// No veto, close window now\n\t\t\t\twindow.close();\n\t\t\t});\n\t\t});\n\n\t\t// Window After Closing\n\t\twin.on('closed', () => {\n\t\t\tthis.trace(`Lifecycle#window.on('closed') - window ID ${window.id}`);\n\n\t\t\t// update window count\n\t\t\tthis.windowCounter--;\n\n\t\t\t// clear window listeners\n\t\t\twindowListeners.dispose();\n\n\t\t\t// if there are no more code windows opened, fire the onWillShutdown event, unless\n\t\t\t// we are on macOS where it is perfectly fine to close the last window and\n\t\t\t// the application continues running (unless quit was actually requested)\n\t\t\tif (this.windowCounter === 0 && (!isMacintosh || this._quitRequested)) {\n\t\t\t\tthis.fireOnWillShutdown(ShutdownReason.QUIT);\n\t\t\t}\n\t\t});\n\t}\n\n\tasync reload(window: ICodeWindow, cli?: NativeParsedArgs): Promise<void> {\n\n\t\t// Only reload when the window has not vetoed this\n\t\tconst veto = await this.unload(window, UnloadReason.RELOAD);\n\t\tif (!veto) {\n\t\t\twindow.reload(cli);\n\t\t}\n\t}\n\n\tunload(window: ICodeWindow, reason: UnloadReason): Promise<boolean /* veto */> {\n\n\t\t// Ensure there is only 1 unload running at the same time\n\t\tconst pendingUnloadPromise = this.mapWindowIdToPendingUnload.get(window.id);\n\t\tif (pendingUnloadPromise) {\n\t\t\treturn pendingUnloadPromise;\n\t\t}\n\n\t\t// Start unload and remember in map until finished\n\t\tconst unloadPromise = this.doUnload(window, reason).finally(() => {\n\t\t\tthis.mapWindowIdToPendingUnload.delete(window.id);\n\t\t});\n\t\tthis.mapWindowIdToPendingUnload.set(window.id, unloadPromise);\n\n\t\treturn unloadPromise;\n\t}\n\n\tprivate async doUnload(window: ICodeWindow, reason: UnloadReason): Promise<boolean /* veto */> {\n\n\t\t// Always allow to unload a window that is not yet ready\n\t\tif (!window.isReady) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.trace(`Lifecycle#unload() - window ID ${window.id}`);\n\n\t\t// first ask the window itself if it vetos the unload\n\t\tconst windowUnloadReason = this._quitRequested ? UnloadReason.QUIT : reason;\n\t\tconst veto = await this.onBeforeUnloadWindowInRenderer(window, windowUnloadReason);\n\t\tif (veto) {\n\t\t\tthis.trace(`Lifecycle#unload() - veto in renderer (window ID ${window.id})`);\n\n\t\t\treturn this.handleWindowUnloadVeto(veto);\n\t\t}\n\n\t\t// finally if there are no vetos, unload the renderer\n\t\tawait this.onWillUnloadWindowInRenderer(window, windowUnloadReason);\n\n\t\treturn false;\n\t}\n\n\tprivate handleWindowUnloadVeto(veto: boolean): boolean {\n\t\tif (!veto) {\n\t\t\treturn false; // no veto\n\t\t}\n\n\t\t// a veto resolves any pending quit with veto\n\t\tthis.resolvePendingQuitPromise(true /* veto */);\n\n\t\t// a veto resets the pending quit request flag\n\t\tthis._quitRequested = false;\n\n\t\treturn true; // veto\n\t}\n\n\tprivate resolvePendingQuitPromise(veto: boolean): void {\n\t\tif (this.pendingQuitPromiseResolve) {\n\t\t\tthis.pendingQuitPromiseResolve(veto);\n\t\t\tthis.pendingQuitPromiseResolve = undefined;\n\t\t\tthis.pendingQuitPromise = undefined;\n\t\t}\n\t}\n\n\tprivate onBeforeUnloadWindowInRenderer(window: ICodeWindow, reason: UnloadReason): Promise<boolean /* veto */> {\n\t\treturn new Promise<boolean>(resolve => {\n\t\t\tconst oneTimeEventToken = this.oneTimeListenerTokenGenerator++;\n\t\t\tconst okChannel = `vscode:ok${oneTimeEventToken}`;\n\t\t\tconst cancelChannel = `vscode:cancel${oneTimeEventToken}`;\n\n\t\t\tvalidatedIpcMain.once(okChannel, () => {\n\t\t\t\tresolve(false); // no veto\n\t\t\t});\n\n\t\t\tvalidatedIpcMain.once(cancelChannel, () => {\n\t\t\t\tresolve(true); // veto\n\t\t\t});\n\n\t\t\twindow.send('vscode:onBeforeUnload', { okChannel, cancelChannel, reason });\n\t\t});\n\t}\n\n\tprivate onWillUnloadWindowInRenderer(window: ICodeWindow, reason: UnloadReason): Promise<void> {\n\t\treturn new Promise<void>(resolve => {\n\t\t\tconst oneTimeEventToken = this.oneTimeListenerTokenGenerator++;\n\t\t\tconst replyChannel = `vscode:reply${oneTimeEventToken}`;\n\n\t\t\tvalidatedIpcMain.once(replyChannel, () => resolve());\n\n\t\t\twindow.send('vscode:onWillUnload', { replyChannel, reason });\n\t\t});\n\t}\n\n\tquit(willRestart?: boolean): Promise<boolean /* veto */> {\n\t\treturn this.doQuit(willRestart).then(veto => {\n\t\t\tif (!veto && willRestart) {\n\t\t\t\t// Windows: we are about to restart and as such we need to restore the original\n\t\t\t\t// current working directory we had on startup to get the exact same startup\n\t\t\t\t// behaviour. As such, we briefly change back to that directory and then when\n\t\t\t\t// Code starts it will set it back to the installation directory again.\n\t\t\t\ttry {\n\t\t\t\t\tif (isWindows) {\n\t\t\t\t\t\tconst currentWorkingDir = cwd();\n\t\t\t\t\t\tif (currentWorkingDir !== process.cwd()) {\n\t\t\t\t\t\t\tprocess.chdir(currentWorkingDir);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch (err) {\n\t\t\t\t\tthis.logService.error(err);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn veto;\n\t\t});\n\t}\n\n\tprivate doQuit(willRestart?: boolean): Promise<boolean /* veto */> {\n\t\tthis.trace(`Lifecycle#quit() - begin (willRestart: ${willRestart})`);\n\n\t\tif (this.pendingQuitPromise) {\n\t\t\tthis.trace('Lifecycle#quit() - returning pending quit promise');\n\n\t\t\treturn this.pendingQuitPromise;\n\t\t}\n\n\t\t// Remember if we are about to restart\n\t\tif (willRestart) {\n\t\t\tthis.stateService.setItem(LifecycleMainService.QUIT_AND_RESTART_KEY, true);\n\t\t}\n\n\t\tthis.pendingQuitPromise = new Promise(resolve => {\n\n\t\t\t// Store as field to access it from a window cancellation\n\t\t\tthis.pendingQuitPromiseResolve = resolve;\n\n\t\t\t// Calling app.quit() will trigger the close handlers of each opened window\n\t\t\t// and only if no window vetoed the shutdown, we will get the will-quit event\n\t\t\tthis.trace('Lifecycle#quit() - calling app.quit()');\n\t\t\tapp.quit();\n\t\t});\n\n\t\treturn this.pendingQuitPromise;\n\t}\n\n\tprivate trace(msg: string): void {\n\t\tif (this.environmentMainService.args['enable-smoke-test-driver']) {\n\t\t\tthis.logService.info(msg); // helps diagnose issues with exiting from smoke tests\n\t\t} else {\n\t\t\tthis.logService.trace(msg);\n\t\t}\n\t}\n\n\tsetRelaunchHandler(handler: IRelaunchHandler): void {\n\t\tthis.relaunchHandler = handler;\n\t}\n\n\tasync relaunch(options?: IRelaunchOptions): Promise<void> {\n\t\tthis.trace('Lifecycle#relaunch()');\n\n\t\tconst args = process.argv.slice(1);\n\t\tif (options?.addArgs) {\n\t\t\targs.push(...options.addArgs);\n\t\t}\n\n\t\tif (options?.removeArgs) {\n\t\t\tfor (const a of options.removeArgs) {\n\t\t\t\tconst idx = args.indexOf(a);\n\t\t\t\tif (idx >= 0) {\n\t\t\t\t\targs.splice(idx, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst quitListener = () => {\n\t\t\tif (!this.relaunchHandler?.handleRelaunch(options)) {\n\t\t\t\tthis.trace('Lifecycle#relaunch() - calling app.relaunch()');\n\t\t\t\tapp.relaunch({ args });\n\t\t\t}\n\t\t};\n\t\tapp.once('quit', quitListener);\n\n\t\t// `app.relaunch()` does not quit automatically, so we quit first,\n\t\t// check for vetoes and then relaunch from the `app.on('quit')` event\n\t\tconst veto = await this.quit(true /* will restart */);\n\t\tif (veto) {\n\t\t\tapp.removeListener('quit', quitListener);\n\t\t}\n\t}\n\n\tasync kill(code?: number): Promise<void> {\n\t\tthis.trace('Lifecycle#kill()');\n\n\t\t// Give main process participants a chance to orderly shutdown\n\t\tawait this.fireOnWillShutdown(ShutdownReason.KILL);\n\n\t\t// From extension tests we have seen issues where calling app.exit()\n\t\t// with an opened window can lead to native crashes (Linux). As such,\n\t\t// we should make sure to destroy any opened window before calling\n\t\t// `app.exit()`.\n\t\t//\n\t\t// Note: Electron implements a similar logic here:\n\t\t// https://github.com/electron/electron/blob/fe5318d753637c3903e23fc1ed1b263025887b6a/spec-main/window-helpers.ts#L5\n\n\t\tawait Promise.race([\n\n\t\t\t// Still do not block more than 1s\n\t\t\ttimeout(1000),\n\n\t\t\t// Destroy any opened window: we do not unload windows here because\n\t\t\t// there is a chance that the unload is veto'd or long running due\n\t\t\t// to a participant within the window. this is not wanted when we\n\t\t\t// are asked to kill the application.\n\t\t\t(async () => {\n\t\t\t\tfor (const window of BrowserWindow.getAllWindows()) {\n\t\t\t\t\tif (window && !window.isDestroyed()) {\n\t\t\t\t\t\tlet whenWindowClosed: Promise<void>;\n\t\t\t\t\t\tif (window.webContents && !window.webContents.isDestroyed()) {\n\t\t\t\t\t\t\twhenWindowClosed = new Promise(resolve => window.once('closed', resolve));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\twhenWindowClosed = Promise.resolve();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\twindow.destroy();\n\t\t\t\t\t\tawait whenWindowClosed;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})()\n\t\t]);\n\n\t\t// Now exit either after 1s or all windows destroyed\n\t\tapp.exit(code);\n\t}\n}\n"]}