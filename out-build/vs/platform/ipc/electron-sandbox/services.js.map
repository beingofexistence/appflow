{"version":3,"sources":["file:///workspace/appflow/src/vs/platform/ipc/electron-sandbox/services.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;;;;;;;;;;IAYhG,MAAe,iBAAiB;QAC/B,YACC,WAAmB,EACnB,OAA+F,EAC/F,MAAc,EACd,oBAAyB;YAEzB,MAAM,OAAO,GAAG,MAAM,CAAC,UAAU,CAAC,WAAW,CAAC,CAAC;YAE/C,IAAI,uCAAuC,CAAC,OAAO,CAAC,EAAE;gBACrD,OAAO,oBAAoB,CAAC,cAAc,CAAC,IAAI,iBAAG,CAAY,OAAO,CAAC,iBAAiB,EAAE,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;aACrG;YAED,OAAO,kBAAY,CAAC,SAAS,CAAC,OAAO,EAAE,OAAO,EAAE,YAAY,CAAC,CAAC;QAC/D,CAAC;KACD;IAUD,SAAS,uCAAuC,CAAI,GAAY;QAC/D,MAAM,SAAS,GAAG,GAA4D,CAAC;QAE/E,OAAO,CAAC,CAAC,SAAS,EAAE,iBAAiB,CAAC;IACvC,CAAC;IAED,sBAAsB;IAEtB,IAAM,4BAA4B,GAAlC,MAAM,4BAA+C,SAAQ,iBAAoB;QAChF,YAAY,WAAmB,EAAE,OAA+F,EAAuB,UAAgB,EAAwC,oBAAyB;YACvO,KAAK,CAAC,WAAW,EAAE,OAAO,EAAE,UAAU,EAAE,oBAAoB,CAAC,CAAC;QAC/D,CAAC;KACD,CAAA;IAJK,4BAA4B;QACkG,WAAA,yBAAI,CAAA;QAAkD,WAAA,mBAAG,CAAA;OADvL,4BAA4B,CAIjC;IAED,SAAgB,IAAI,CAAgC,EAAwB,EAAE,WAAmB,EAAE,OAAoF;QACtL,IAAA,gBAAG,EAAe,EAAE,EAAE,IAAI,iBAAG,CAAY,4BAA4B,EAAE,CAAC,WAAW,EAAE,OAAO,CAAC,EAAE,IAAI,CAAC,CAAC,CAAC;IACvG,CAAC;IAFD,oBAEC;IAED,YAAY;IAEZ,wBAAwB;IAEX,QAAA,IAAI,GAAoB,IAAA,mBAAG,EAAoC,sBAAsB,CAAC,CAAC;IAoBpG,IAAM,8BAA8B,GAApC,MAAM,8BAAiD,SAAQ,iBAAoB;QAClF,YAAY,WAAmB,EAAE,OAA+F,EAAyB,UAAgB,EAA0C,oBAAyB;YAC3O,KAAK,CAAC,WAAW,EAAE,OAAO,EAAE,UAAU,EAAE,oBAAoB,CAAC,CAAC;QAC/D,CAAC;KACD,CAAA;IAJK,8BAA8B;QACgG,WAAA,YAAI,CAAA;QAAsD,WAAA,mBAAG,CAAA;OAD3L,8BAA8B,CAInC;IAED,SAAgB,IAAI,CAAkC,EAAwB,EAAE,WAAmB,EAAE,OAAoF;QACxL,IAAA,gBAAG,EAAe,EAAE,EAAE,IAAI,iBAAG,CAAY,8BAA8B,EAAE,CAAC,WAAW,EAAE,OAAO,CAAC,EAAE,IAAI,CAAC,CAAC,CAAC;IACzG,CAAC;IAFD,oBAEC;;AAED,YAAY","file":"services.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IChannel, ProxyChannel } from 'vs/base/parts/ipc/common/ipc';\nimport { SyncDescriptor } from 'vs/platform/instantiation/common/descriptors';\nimport { registerSingleton } from 'vs/platform/instantiation/common/extensions';\nimport { createDecorator, IInstantiationService, ServiceIdentifier } from 'vs/platform/instantiation/common/instantiation';\nimport { IMainProcessService } from 'vs/platform/ipc/common/mainProcessService';\nimport { IRemoteService } from 'vs/platform/ipc/common/services';\n\ntype ChannelClientCtor<T> = { new(channel: IChannel, ...args: any[]): T };\ntype Remote = { getChannel(channelName: string): IChannel };\n\nabstract class RemoteServiceStub<T extends object> {\n\tconstructor(\n\t\tchannelName: string,\n\t\toptions: IRemoteServiceWithChannelClientOptions<T> | IRemoteServiceWithProxyOptions | undefined,\n\t\tremote: Remote,\n\t\tinstantiationService: IInstantiationService\n\t) {\n\t\tconst channel = remote.getChannel(channelName);\n\n\t\tif (isRemoteServiceWithChannelClientOptions(options)) {\n\t\t\treturn instantiationService.createInstance(new SyncDescriptor(options.channelClientCtor, [channel]));\n\t\t}\n\n\t\treturn ProxyChannel.toService(channel, options?.proxyOptions);\n\t}\n}\n\nexport interface IRemoteServiceWithChannelClientOptions<T> {\n\treadonly channelClientCtor: ChannelClientCtor<T>;\n}\n\nexport interface IRemoteServiceWithProxyOptions {\n\treadonly proxyOptions?: ProxyChannel.ICreateProxyServiceOptions;\n}\n\nfunction isRemoteServiceWithChannelClientOptions<T>(obj: unknown): obj is IRemoteServiceWithChannelClientOptions<T> {\n\tconst candidate = obj as IRemoteServiceWithChannelClientOptions<T> | undefined;\n\n\treturn !!candidate?.channelClientCtor;\n}\n\n//#region Main Process\n\nclass MainProcessRemoteServiceStub<T extends object> extends RemoteServiceStub<T> {\n\tconstructor(channelName: string, options: IRemoteServiceWithChannelClientOptions<T> | IRemoteServiceWithProxyOptions | undefined, @IMainProcessService ipcService: IMainProcessService, @IInstantiationService instantiationService: IInstantiationService) {\n\t\tsuper(channelName, options, ipcService, instantiationService);\n\t}\n}\n\nexport function registerMainProcessRemoteService<T>(id: ServiceIdentifier<T>, channelName: string, options?: IRemoteServiceWithChannelClientOptions<T> | IRemoteServiceWithProxyOptions): void {\n\tregisterSingleton(id, new SyncDescriptor(MainProcessRemoteServiceStub, [channelName, options], true));\n}\n\n//#endregion\n\n//#region Shared Process\n\nexport const ISharedProcessService = createDecorator<ISharedProcessService>('sharedProcessService');\n\nexport interface ISharedProcessService extends IRemoteService {\n\n\t/**\n\t * Allows to create a `MessagePort` connection between the\n\t * shared process and the renderer process.\n\t *\n\t * Use this only when you need raw IPC to the shared process\n\t * via `postMessage` and `on('message')` of special data structures\n\t * like typed arrays.\n\t *\n\t * Callers have to call `port.start()` after having installed\n\t * listeners to enable the data flow.\n\t */\n\tcreateRawConnection(): Promise<MessagePort>;\n\n\tnotifyRestored(): void;\n}\n\nclass SharedProcessRemoteServiceStub<T extends object> extends RemoteServiceStub<T> {\n\tconstructor(channelName: string, options: IRemoteServiceWithChannelClientOptions<T> | IRemoteServiceWithProxyOptions | undefined, @ISharedProcessService ipcService: ISharedProcessService, @IInstantiationService instantiationService: IInstantiationService) {\n\t\tsuper(channelName, options, ipcService, instantiationService);\n\t}\n}\n\nexport function registerSharedProcessRemoteService<T>(id: ServiceIdentifier<T>, channelName: string, options?: IRemoteServiceWithChannelClientOptions<T> | IRemoteServiceWithProxyOptions): void {\n\tregisterSingleton(id, new SyncDescriptor(SharedProcessRemoteServiceStub, [channelName, options], true));\n}\n\n//#endregion\n"]}