{"version":3,"sources":["file:///workspace/appflow/src/vs/editor/contrib/inlineCompletions/browser/utils.ts"],"names":[],"mappings":"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","file":"utils.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { BugIndicatingError } from 'vs/base/common/errors';\nimport { DisposableStore, IDisposable } from 'vs/base/common/lifecycle';\nimport { IObservable, autorunOpts } from 'vs/base/common/observable';\nimport { ICodeEditor } from 'vs/editor/browser/editorBrowser';\nimport { Position } from 'vs/editor/common/core/position';\nimport { IRange, Range } from 'vs/editor/common/core/range';\nimport { IModelDeltaDecoration } from 'vs/editor/common/model';\n\nexport function applyEdits(text: string, edits: { range: IRange; text: string }[]): string {\n\tconst transformer = new PositionOffsetTransformer(text);\n\tconst offsetEdits = edits.map(e => {\n\t\tconst range = Range.lift(e.range);\n\t\treturn ({\n\t\t\tstartOffset: transformer.getOffset(range.getStartPosition()),\n\t\t\tendOffset: transformer.getOffset(range.getEndPosition()),\n\t\t\ttext: e.text\n\t\t});\n\t});\n\n\toffsetEdits.sort((a, b) => b.startOffset - a.startOffset);\n\n\tfor (const edit of offsetEdits) {\n\t\ttext = text.substring(0, edit.startOffset) + edit.text + text.substring(edit.endOffset);\n\t}\n\n\treturn text;\n}\n\nclass PositionOffsetTransformer {\n\tprivate readonly lineStartOffsetByLineIdx: number[];\n\n\tconstructor(text: string) {\n\t\tthis.lineStartOffsetByLineIdx = [];\n\t\tthis.lineStartOffsetByLineIdx.push(0);\n\t\tfor (let i = 0; i < text.length; i++) {\n\t\t\tif (text.charAt(i) === '\\n') {\n\t\t\t\tthis.lineStartOffsetByLineIdx.push(i + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tgetOffset(position: Position): number {\n\t\treturn this.lineStartOffsetByLineIdx[position.lineNumber - 1] + position.column - 1;\n\t}\n}\n\nconst array: ReadonlyArray<any> = [];\nexport function getReadonlyEmptyArray<T>(): readonly T[] {\n\treturn array;\n}\n\nexport class ColumnRange {\n\tconstructor(\n\t\tpublic readonly startColumn: number,\n\t\tpublic readonly endColumnExclusive: number,\n\t) {\n\t\tif (startColumn > endColumnExclusive) {\n\t\t\tthrow new BugIndicatingError(`startColumn ${startColumn} cannot be after endColumnExclusive ${endColumnExclusive}`);\n\t\t}\n\t}\n\n\ttoRange(lineNumber: number): Range {\n\t\treturn new Range(lineNumber, this.startColumn, lineNumber, this.endColumnExclusive);\n\t}\n\n\tequals(other: ColumnRange): boolean {\n\t\treturn this.startColumn === other.startColumn\n\t\t\t&& this.endColumnExclusive === other.endColumnExclusive;\n\t}\n}\n\nexport function applyObservableDecorations(editor: ICodeEditor, decorations: IObservable<IModelDeltaDecoration[]>): IDisposable {\n\tconst d = new DisposableStore();\n\tconst decorationsCollection = editor.createDecorationsCollection();\n\td.add(autorunOpts({ debugName: () => `Apply decorations from ${decorations.debugName}` }, reader => {\n\t\tconst d = decorations.read(reader);\n\t\tdecorationsCollection.set(d);\n\t}));\n\td.add({\n\t\tdispose: () => {\n\t\t\tdecorationsCollection.clear();\n\t\t}\n\t});\n\treturn d;\n}\n\nexport function addPositions(pos1: Position, pos2: Position): Position {\n\treturn new Position(pos1.lineNumber + pos2.lineNumber - 1, pos2.lineNumber === 1 ? pos1.column + pos2.column - 1 : pos2.column);\n}\n\nexport function lengthOfText(text: string): Position {\n\tlet line = 1;\n\tlet column = 1;\n\tfor (const c of text) {\n\t\tif (c === '\\n') {\n\t\t\tline++;\n\t\t\tcolumn = 1;\n\t\t} else {\n\t\t\tcolumn++;\n\t\t}\n\t}\n\treturn new Position(line, column);\n}\n"]}