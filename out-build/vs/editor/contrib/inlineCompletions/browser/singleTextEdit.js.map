{"version":3,"sources":["file:///workspace/appflow/src/vs/editor/contrib/inlineCompletions/browser/singleTextEdit.ts"],"names":[],"mappings":"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","file":"singleTextEdit.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IDiffChange, LcsDiff } from 'vs/base/common/diff/diff';\nimport { commonPrefixLength, getLeadingWhitespace, splitLines } from 'vs/base/common/strings';\nimport { Position } from 'vs/editor/common/core/position';\nimport { Range } from 'vs/editor/common/core/range';\nimport { EndOfLinePreference, ITextModel } from 'vs/editor/common/model';\nimport { GhostText, GhostTextPart } from 'vs/editor/contrib/inlineCompletions/browser/ghostText';\nimport { addPositions, lengthOfText } from 'vs/editor/contrib/inlineCompletions/browser/utils';\n\nexport class SingleTextEdit {\n\tconstructor(\n\t\tpublic readonly range: Range,\n\t\tpublic readonly text: string\n\t) {\n\t}\n\n\tremoveCommonPrefix(model: ITextModel, validModelRange?: Range): SingleTextEdit {\n\t\tconst modelRange = validModelRange ? this.range.intersectRanges(validModelRange) : this.range;\n\t\tif (!modelRange) {\n\t\t\treturn this;\n\t\t}\n\t\tconst valueToReplace = model.getValueInRange(modelRange, EndOfLinePreference.LF);\n\t\tconst commonPrefixLen = commonPrefixLength(valueToReplace, this.text);\n\t\tconst start = addPositions(this.range.getStartPosition(), lengthOfText(valueToReplace.substring(0, commonPrefixLen)));\n\t\tconst text = this.text.substring(commonPrefixLen);\n\t\tconst range = Range.fromPositions(start, this.range.getEndPosition());\n\t\treturn new SingleTextEdit(range, text);\n\t}\n\n\taugments(base: SingleTextEdit): boolean {\n\t\t// The augmented completion must replace the base range, but can replace even more\n\t\treturn this.text.startsWith(base.text) && rangeExtends(this.range, base.range);\n\t}\n\n\t/**\n\t * @param previewSuffixLength Sets where to split `inlineCompletion.text`.\n\t * \tIf the text is `hello` and the suffix length is 2, the non-preview part is `hel` and the preview-part is `lo`.\n\t*/\n\tcomputeGhostText(\n\t\tmodel: ITextModel,\n\t\tmode: 'prefix' | 'subword' | 'subwordSmart',\n\t\tcursorPosition?: Position,\n\t\tpreviewSuffixLength = 0\n\t): GhostText | undefined {\n\t\tlet edit = this.removeCommonPrefix(model);\n\n\t\tif (edit.range.endLineNumber !== edit.range.startLineNumber) {\n\t\t\t// This edit might span multiple lines, but the first lines must be a common prefix.\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst sourceLine = model.getLineContent(edit.range.startLineNumber);\n\t\tconst sourceIndentationLength = getLeadingWhitespace(sourceLine).length;\n\n\t\tconst suggestionTouchesIndentation = edit.range.startColumn - 1 <= sourceIndentationLength;\n\t\tif (suggestionTouchesIndentation) {\n\t\t\t// source:      ··········[······abc]\n\t\t\t//                         ^^^^^^^^^ inlineCompletion.range\n\t\t\t//              ^^^^^^^^^^ ^^^^^^ sourceIndentationLength\n\t\t\t//                         ^^^^^^ replacedIndentation.length\n\t\t\t//                               ^^^ rangeThatDoesNotReplaceIndentation\n\n\t\t\t// inlineCompletion.text: '··foo'\n\t\t\t//                         ^^ suggestionAddedIndentationLength\n\n\t\t\tconst suggestionAddedIndentationLength = getLeadingWhitespace(edit.text).length;\n\n\t\t\tconst replacedIndentation = sourceLine.substring(edit.range.startColumn - 1, sourceIndentationLength);\n\n\t\t\tconst [startPosition, endPosition] = [edit.range.getStartPosition(), edit.range.getEndPosition()];\n\t\t\tconst newStartPosition =\n\t\t\t\tstartPosition.column + replacedIndentation.length <= endPosition.column\n\t\t\t\t\t? startPosition.delta(0, replacedIndentation.length)\n\t\t\t\t\t: endPosition;\n\t\t\tconst rangeThatDoesNotReplaceIndentation = Range.fromPositions(newStartPosition, endPosition);\n\n\t\t\tconst suggestionWithoutIndentationChange =\n\t\t\t\tedit.text.startsWith(replacedIndentation)\n\t\t\t\t\t// Adds more indentation without changing existing indentation: We can add ghost text for this\n\t\t\t\t\t? edit.text.substring(replacedIndentation.length)\n\t\t\t\t\t// Changes or removes existing indentation. Only add ghost text for the non-indentation part.\n\t\t\t\t\t: edit.text.substring(suggestionAddedIndentationLength);\n\n\t\t\tedit = new SingleTextEdit(rangeThatDoesNotReplaceIndentation, suggestionWithoutIndentationChange);\n\t\t}\n\n\t\t// This is a single line string\n\t\tconst valueToBeReplaced = model.getValueInRange(edit.range);\n\n\t\tconst changes = cachingDiff(valueToBeReplaced, edit.text);\n\n\t\tif (!changes) {\n\t\t\t// No ghost text in case the diff would be too slow to compute\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst lineNumber = edit.range.startLineNumber;\n\n\t\tconst parts = new Array<GhostTextPart>();\n\n\t\tif (mode === 'prefix') {\n\t\t\tconst filteredChanges = changes.filter(c => c.originalLength === 0);\n\t\t\tif (filteredChanges.length > 1 || filteredChanges.length === 1 && filteredChanges[0].originalStart !== valueToBeReplaced.length) {\n\t\t\t\t// Prefixes only have a single change.\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t}\n\n\t\tconst previewStartInCompletionText = edit.text.length - previewSuffixLength;\n\n\t\tfor (const c of changes) {\n\t\t\tconst insertColumn = edit.range.startColumn + c.originalStart + c.originalLength;\n\n\t\t\tif (mode === 'subwordSmart' && cursorPosition && cursorPosition.lineNumber === edit.range.startLineNumber && insertColumn < cursorPosition.column) {\n\t\t\t\t// No ghost text before cursor\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tif (c.originalLength > 0) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tif (c.modifiedLength === 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst modifiedEnd = c.modifiedStart + c.modifiedLength;\n\t\t\tconst nonPreviewTextEnd = Math.max(c.modifiedStart, Math.min(modifiedEnd, previewStartInCompletionText));\n\t\t\tconst nonPreviewText = edit.text.substring(c.modifiedStart, nonPreviewTextEnd);\n\t\t\tconst italicText = edit.text.substring(nonPreviewTextEnd, Math.max(c.modifiedStart, modifiedEnd));\n\n\t\t\tif (nonPreviewText.length > 0) {\n\t\t\t\tconst lines = splitLines(nonPreviewText);\n\t\t\t\tparts.push(new GhostTextPart(insertColumn, lines, false));\n\t\t\t}\n\t\t\tif (italicText.length > 0) {\n\t\t\t\tconst lines = splitLines(italicText);\n\t\t\t\tparts.push(new GhostTextPart(insertColumn, lines, true));\n\t\t\t}\n\t\t}\n\n\t\treturn new GhostText(lineNumber, parts);\n\t}\n}\n\nfunction rangeExtends(extendingRange: Range, rangeToExtend: Range): boolean {\n\treturn rangeToExtend.getStartPosition().equals(extendingRange.getStartPosition())\n\t\t&& rangeToExtend.getEndPosition().isBeforeOrEqual(extendingRange.getEndPosition());\n}\n\nlet lastRequest: { originalValue: string; newValue: string; changes: readonly IDiffChange[] | undefined } | undefined = undefined;\nfunction cachingDiff(originalValue: string, newValue: string): readonly IDiffChange[] | undefined {\n\tif (lastRequest?.originalValue === originalValue && lastRequest?.newValue === newValue) {\n\t\treturn lastRequest?.changes;\n\t} else {\n\t\tlet changes = smartDiff(originalValue, newValue, true);\n\t\tif (changes) {\n\t\t\tconst deletedChars = deletedCharacters(changes);\n\t\t\tif (deletedChars > 0) {\n\t\t\t\t// For performance reasons, don't compute diff if there is nothing to improve\n\t\t\t\tconst newChanges = smartDiff(originalValue, newValue, false);\n\t\t\t\tif (newChanges && deletedCharacters(newChanges) < deletedChars) {\n\t\t\t\t\t// Disabling smartness seems to be better here\n\t\t\t\t\tchanges = newChanges;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlastRequest = {\n\t\t\toriginalValue,\n\t\t\tnewValue,\n\t\t\tchanges\n\t\t};\n\t\treturn changes;\n\t}\n}\n\nfunction deletedCharacters(changes: readonly IDiffChange[]): number {\n\tlet sum = 0;\n\tfor (const c of changes) {\n\t\tsum += c.originalLength;\n\t}\n\treturn sum;\n}\n\n/**\n * When matching `if ()` with `if (f() = 1) { g(); }`,\n * align it like this:        `if (       )`\n * Not like this:\t\t\t  `if (  )`\n * Also not like this:\t\t  `if (             )`.\n *\n * The parenthesis are preprocessed to ensure that they match correctly.\n */\nfunction smartDiff(originalValue: string, newValue: string, smartBracketMatching: boolean): (readonly IDiffChange[]) | undefined {\n\tif (originalValue.length > 5000 || newValue.length > 5000) {\n\t\t// We don't want to work on strings that are too big\n\t\treturn undefined;\n\t}\n\n\tfunction getMaxCharCode(val: string): number {\n\t\tlet maxCharCode = 0;\n\t\tfor (let i = 0, len = val.length; i < len; i++) {\n\t\t\tconst charCode = val.charCodeAt(i);\n\t\t\tif (charCode > maxCharCode) {\n\t\t\t\tmaxCharCode = charCode;\n\t\t\t}\n\t\t}\n\t\treturn maxCharCode;\n\t}\n\n\tconst maxCharCode = Math.max(getMaxCharCode(originalValue), getMaxCharCode(newValue));\n\tfunction getUniqueCharCode(id: number): number {\n\t\tif (id < 0) {\n\t\t\tthrow new Error('unexpected');\n\t\t}\n\t\treturn maxCharCode + id + 1;\n\t}\n\n\tfunction getElements(source: string): Int32Array {\n\t\tlet level = 0;\n\t\tlet group = 0;\n\t\tconst characters = new Int32Array(source.length);\n\t\tfor (let i = 0, len = source.length; i < len; i++) {\n\t\t\t// TODO support more brackets\n\t\t\tif (smartBracketMatching && source[i] === '(') {\n\t\t\t\tconst id = group * 100 + level;\n\t\t\t\tcharacters[i] = getUniqueCharCode(2 * id);\n\t\t\t\tlevel++;\n\t\t\t} else if (smartBracketMatching && source[i] === ')') {\n\t\t\t\tlevel = Math.max(level - 1, 0);\n\t\t\t\tconst id = group * 100 + level;\n\t\t\t\tcharacters[i] = getUniqueCharCode(2 * id + 1);\n\t\t\t\tif (level === 0) {\n\t\t\t\t\tgroup++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcharacters[i] = source.charCodeAt(i);\n\t\t\t}\n\t\t}\n\t\treturn characters;\n\t}\n\n\tconst elements1 = getElements(originalValue);\n\tconst elements2 = getElements(newValue);\n\n\treturn new LcsDiff({ getElements: () => elements1 }, { getElements: () => elements2 }).ComputeDiff(false).changes;\n}\n"]}