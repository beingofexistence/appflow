{"version":3,"sources":["file:///workspace/appflow/src/vs/editor/contrib/folding/browser/foldingModel.ts"],"names":[],"mappings":"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","file":"foldingModel.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { IModelDecorationOptions, IModelDecorationsChangeAccessor, IModelDeltaDecoration, ITextModel } from 'vs/editor/common/model';\nimport { FoldingRegion, FoldingRegions, ILineRange, FoldRange, FoldSource } from './foldingRanges';\nimport { hash } from 'vs/base/common/hash';\n\nexport interface IDecorationProvider {\n\tgetDecorationOption(isCollapsed: boolean, isHidden: boolean, isManual: boolean): IModelDecorationOptions;\n\tchangeDecorations<T>(callback: (changeAccessor: IModelDecorationsChangeAccessor) => T): T | null;\n\tremoveDecorations(decorationIds: string[]): void;\n}\n\nexport interface FoldingModelChangeEvent {\n\tmodel: FoldingModel;\n\tcollapseStateChanged?: FoldingRegion[];\n}\n\ninterface ILineMemento extends ILineRange {\n\tchecksum?: number;\n\tisCollapsed?: boolean;\n\tsource?: FoldSource;\n}\n\nexport type CollapseMemento = ILineMemento[];\n\nexport class FoldingModel {\n\tprivate readonly _textModel: ITextModel;\n\tprivate readonly _decorationProvider: IDecorationProvider;\n\n\tprivate _regions: FoldingRegions;\n\tprivate _editorDecorationIds: string[];\n\n\tprivate readonly _updateEventEmitter = new Emitter<FoldingModelChangeEvent>();\n\tpublic readonly onDidChange: Event<FoldingModelChangeEvent> = this._updateEventEmitter.event;\n\n\tpublic get regions(): FoldingRegions { return this._regions; }\n\tpublic get textModel() { return this._textModel; }\n\tpublic get decorationProvider() { return this._decorationProvider; }\n\n\tconstructor(textModel: ITextModel, decorationProvider: IDecorationProvider) {\n\t\tthis._textModel = textModel;\n\t\tthis._decorationProvider = decorationProvider;\n\t\tthis._regions = new FoldingRegions(new Uint32Array(0), new Uint32Array(0));\n\t\tthis._editorDecorationIds = [];\n\t}\n\n\tpublic toggleCollapseState(toggledRegions: FoldingRegion[]) {\n\t\tif (!toggledRegions.length) {\n\t\t\treturn;\n\t\t}\n\t\ttoggledRegions = toggledRegions.sort((r1, r2) => r1.regionIndex - r2.regionIndex);\n\n\t\tconst processed: { [key: string]: boolean | undefined } = {};\n\t\tthis._decorationProvider.changeDecorations(accessor => {\n\t\t\tlet k = 0; // index from [0 ... this.regions.length]\n\t\t\tlet dirtyRegionEndLine = -1; // end of the range where decorations need to be updated\n\t\t\tlet lastHiddenLine = -1; // the end of the last hidden lines\n\t\t\tconst updateDecorationsUntil = (index: number) => {\n\t\t\t\twhile (k < index) {\n\t\t\t\t\tconst endLineNumber = this._regions.getEndLineNumber(k);\n\t\t\t\t\tconst isCollapsed = this._regions.isCollapsed(k);\n\t\t\t\t\tif (endLineNumber <= dirtyRegionEndLine) {\n\t\t\t\t\t\tconst isManual = this.regions.getSource(k) !== FoldSource.provider;\n\t\t\t\t\t\taccessor.changeDecorationOptions(this._editorDecorationIds[k], this._decorationProvider.getDecorationOption(isCollapsed, endLineNumber <= lastHiddenLine, isManual));\n\t\t\t\t\t}\n\t\t\t\t\tif (isCollapsed && endLineNumber > lastHiddenLine) {\n\t\t\t\t\t\tlastHiddenLine = endLineNumber;\n\t\t\t\t\t}\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t};\n\t\t\tfor (const region of toggledRegions) {\n\t\t\t\tconst index = region.regionIndex;\n\t\t\t\tconst editorDecorationId = this._editorDecorationIds[index];\n\t\t\t\tif (editorDecorationId && !processed[editorDecorationId]) {\n\t\t\t\t\tprocessed[editorDecorationId] = true;\n\n\t\t\t\t\tupdateDecorationsUntil(index); // update all decorations up to current index using the old dirtyRegionEndLine\n\n\t\t\t\t\tconst newCollapseState = !this._regions.isCollapsed(index);\n\t\t\t\t\tthis._regions.setCollapsed(index, newCollapseState);\n\n\t\t\t\t\tdirtyRegionEndLine = Math.max(dirtyRegionEndLine, this._regions.getEndLineNumber(index));\n\t\t\t\t}\n\t\t\t}\n\t\t\tupdateDecorationsUntil(this._regions.length);\n\t\t});\n\t\tthis._updateEventEmitter.fire({ model: this, collapseStateChanged: toggledRegions });\n\t}\n\n\tpublic removeManualRanges(ranges: ILineRange[]) {\n\t\tconst newFoldingRanges: FoldRange[] = new Array();\n\t\tconst intersects = (foldRange: FoldRange) => {\n\t\t\tfor (const range of ranges) {\n\t\t\t\tif (!(range.startLineNumber > foldRange.endLineNumber || foldRange.startLineNumber > range.endLineNumber)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t\tfor (let i = 0; i < this._regions.length; i++) {\n\t\t\tconst foldRange = this._regions.toFoldRange(i);\n\t\t\tif (foldRange.source === FoldSource.provider || !intersects(foldRange)) {\n\t\t\t\tnewFoldingRanges.push(foldRange);\n\t\t\t}\n\t\t}\n\t\tthis.updatePost(FoldingRegions.fromFoldRanges(newFoldingRanges));\n\t}\n\n\tpublic update(newRegions: FoldingRegions, blockedLineNumers: number[] = []): void {\n\t\tconst foldedOrManualRanges = this._currentFoldedOrManualRanges(blockedLineNumers);\n\t\tconst newRanges = FoldingRegions.sanitizeAndMerge(newRegions, foldedOrManualRanges, this._textModel.getLineCount());\n\t\tthis.updatePost(FoldingRegions.fromFoldRanges(newRanges));\n\t}\n\n\tpublic updatePost(newRegions: FoldingRegions) {\n\t\tconst newEditorDecorations: IModelDeltaDecoration[] = [];\n\t\tlet lastHiddenLine = -1;\n\t\tfor (let index = 0, limit = newRegions.length; index < limit; index++) {\n\t\t\tconst startLineNumber = newRegions.getStartLineNumber(index);\n\t\t\tconst endLineNumber = newRegions.getEndLineNumber(index);\n\t\t\tconst isCollapsed = newRegions.isCollapsed(index);\n\t\t\tconst isManual = newRegions.getSource(index) !== FoldSource.provider;\n\t\t\tconst decorationRange = {\n\t\t\t\tstartLineNumber: startLineNumber,\n\t\t\t\tstartColumn: this._textModel.getLineMaxColumn(startLineNumber),\n\t\t\t\tendLineNumber: endLineNumber,\n\t\t\t\tendColumn: this._textModel.getLineMaxColumn(endLineNumber) + 1\n\t\t\t};\n\t\t\tnewEditorDecorations.push({ range: decorationRange, options: this._decorationProvider.getDecorationOption(isCollapsed, endLineNumber <= lastHiddenLine, isManual) });\n\t\t\tif (isCollapsed && endLineNumber > lastHiddenLine) {\n\t\t\t\tlastHiddenLine = endLineNumber;\n\t\t\t}\n\t\t}\n\t\tthis._decorationProvider.changeDecorations(accessor => this._editorDecorationIds = accessor.deltaDecorations(this._editorDecorationIds, newEditorDecorations));\n\t\tthis._regions = newRegions;\n\t\tthis._updateEventEmitter.fire({ model: this });\n\t}\n\n\tprivate _currentFoldedOrManualRanges(blockedLineNumers: number[] = []): FoldRange[] {\n\n\t\tconst isBlocked = (startLineNumber: number, endLineNumber: number) => {\n\t\t\tfor (const blockedLineNumber of blockedLineNumers) {\n\t\t\t\tif (startLineNumber < blockedLineNumber && blockedLineNumber <= endLineNumber) { // first line is visible\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t\tconst foldedRanges: FoldRange[] = [];\n\t\tfor (let i = 0, limit = this._regions.length; i < limit; i++) {\n\t\t\tlet isCollapsed = this.regions.isCollapsed(i);\n\t\t\tconst source = this.regions.getSource(i);\n\t\t\tif (isCollapsed || source !== FoldSource.provider) {\n\t\t\t\tconst foldRange = this._regions.toFoldRange(i);\n\t\t\t\tconst decRange = this._textModel.getDecorationRange(this._editorDecorationIds[i]);\n\t\t\t\tif (decRange) {\n\t\t\t\t\tif (isCollapsed && isBlocked(decRange.startLineNumber, decRange.endLineNumber)) {\n\t\t\t\t\t\tisCollapsed = false; // uncollapse is the range is blocked\n\t\t\t\t\t}\n\t\t\t\t\tfoldedRanges.push({\n\t\t\t\t\t\tstartLineNumber: decRange.startLineNumber,\n\t\t\t\t\t\tendLineNumber: decRange.endLineNumber,\n\t\t\t\t\t\ttype: foldRange.type,\n\t\t\t\t\t\tisCollapsed,\n\t\t\t\t\t\tsource\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn foldedRanges;\n\t}\n\n\t/**\n\t * Collapse state memento, for persistence only\n\t */\n\tpublic getMemento(): CollapseMemento | undefined {\n\t\tconst foldedOrManualRanges = this._currentFoldedOrManualRanges();\n\t\tconst result: ILineMemento[] = [];\n\t\tconst maxLineNumber = this._textModel.getLineCount();\n\t\tfor (let i = 0, limit = foldedOrManualRanges.length; i < limit; i++) {\n\t\t\tconst range = foldedOrManualRanges[i];\n\t\t\tif (range.startLineNumber >= range.endLineNumber || range.startLineNumber < 1 || range.endLineNumber > maxLineNumber) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst checksum = this._getLinesChecksum(range.startLineNumber + 1, range.endLineNumber);\n\t\t\tresult.push({\n\t\t\t\tstartLineNumber: range.startLineNumber,\n\t\t\t\tendLineNumber: range.endLineNumber,\n\t\t\t\tisCollapsed: range.isCollapsed,\n\t\t\t\tsource: range.source,\n\t\t\t\tchecksum: checksum\n\t\t\t});\n\t\t}\n\t\treturn (result.length > 0) ? result : undefined;\n\t}\n\n\t/**\n\t * Apply persisted state, for persistence only\n\t */\n\tpublic applyMemento(state: CollapseMemento) {\n\t\tif (!Array.isArray(state)) {\n\t\t\treturn;\n\t\t}\n\t\tconst rangesToRestore: FoldRange[] = [];\n\t\tconst maxLineNumber = this._textModel.getLineCount();\n\t\tfor (const range of state) {\n\t\t\tif (range.startLineNumber >= range.endLineNumber || range.startLineNumber < 1 || range.endLineNumber > maxLineNumber) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst checksum = this._getLinesChecksum(range.startLineNumber + 1, range.endLineNumber);\n\t\t\tif (!range.checksum || checksum === range.checksum) {\n\t\t\t\trangesToRestore.push({\n\t\t\t\t\tstartLineNumber: range.startLineNumber,\n\t\t\t\t\tendLineNumber: range.endLineNumber,\n\t\t\t\t\ttype: undefined,\n\t\t\t\t\tisCollapsed: range.isCollapsed ?? true,\n\t\t\t\t\tsource: range.source ?? FoldSource.provider\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tconst newRanges = FoldingRegions.sanitizeAndMerge(this._regions, rangesToRestore, maxLineNumber);\n\t\tthis.updatePost(FoldingRegions.fromFoldRanges(newRanges));\n\t}\n\n\tprivate _getLinesChecksum(lineNumber1: number, lineNumber2: number): number {\n\t\tconst h = hash(this._textModel.getLineContent(lineNumber1)\n\t\t\t+ this._textModel.getLineContent(lineNumber2));\n\t\treturn h % 1000000; // 6 digits is plenty\n\t}\n\n\tpublic dispose() {\n\t\tthis._decorationProvider.removeDecorations(this._editorDecorationIds);\n\t}\n\n\tgetAllRegionsAtLine(lineNumber: number, filter?: (r: FoldingRegion, level: number) => boolean): FoldingRegion[] {\n\t\tconst result: FoldingRegion[] = [];\n\t\tif (this._regions) {\n\t\t\tlet index = this._regions.findRange(lineNumber);\n\t\t\tlet level = 1;\n\t\t\twhile (index >= 0) {\n\t\t\t\tconst current = this._regions.toRegion(index);\n\t\t\t\tif (!filter || filter(current, level)) {\n\t\t\t\t\tresult.push(current);\n\t\t\t\t}\n\t\t\t\tlevel++;\n\t\t\t\tindex = current.parentIndex;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tgetRegionAtLine(lineNumber: number): FoldingRegion | null {\n\t\tif (this._regions) {\n\t\t\tconst index = this._regions.findRange(lineNumber);\n\t\t\tif (index >= 0) {\n\t\t\t\treturn this._regions.toRegion(index);\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tgetRegionsInside(region: FoldingRegion | null, filter?: RegionFilter | RegionFilterWithLevel): FoldingRegion[] {\n\t\tconst result: FoldingRegion[] = [];\n\t\tconst index = region ? region.regionIndex + 1 : 0;\n\t\tconst endLineNumber = region ? region.endLineNumber : Number.MAX_VALUE;\n\n\t\tif (filter && filter.length === 2) {\n\t\t\tconst levelStack: FoldingRegion[] = [];\n\t\t\tfor (let i = index, len = this._regions.length; i < len; i++) {\n\t\t\t\tconst current = this._regions.toRegion(i);\n\t\t\t\tif (this._regions.getStartLineNumber(i) < endLineNumber) {\n\t\t\t\t\twhile (levelStack.length > 0 && !current.containedBy(levelStack[levelStack.length - 1])) {\n\t\t\t\t\t\tlevelStack.pop();\n\t\t\t\t\t}\n\t\t\t\t\tlevelStack.push(current);\n\t\t\t\t\tif (filter(current, levelStack.length)) {\n\t\t\t\t\t\tresult.push(current);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (let i = index, len = this._regions.length; i < len; i++) {\n\t\t\t\tconst current = this._regions.toRegion(i);\n\t\t\t\tif (this._regions.getStartLineNumber(i) < endLineNumber) {\n\t\t\t\t\tif (!filter || (filter as RegionFilter)(current)) {\n\t\t\t\t\t\tresult.push(current);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n}\n\ntype RegionFilter = (r: FoldingRegion) => boolean;\ntype RegionFilterWithLevel = (r: FoldingRegion, level: number) => boolean;\n\n\n/**\n * Collapse or expand the regions at the given locations\n * @param levels The number of levels. Use 1 to only impact the regions at the location, use Number.MAX_VALUE for all levels.\n * @param lineNumbers the location of the regions to collapse or expand, or if not set, all regions in the model.\n */\nexport function toggleCollapseState(foldingModel: FoldingModel, levels: number, lineNumbers: number[]) {\n\tconst toToggle: FoldingRegion[] = [];\n\tfor (const lineNumber of lineNumbers) {\n\t\tconst region = foldingModel.getRegionAtLine(lineNumber);\n\t\tif (region) {\n\t\t\tconst doCollapse = !region.isCollapsed;\n\t\t\ttoToggle.push(region);\n\t\t\tif (levels > 1) {\n\t\t\t\tconst regionsInside = foldingModel.getRegionsInside(region, (r, level: number) => r.isCollapsed !== doCollapse && level < levels);\n\t\t\t\ttoToggle.push(...regionsInside);\n\t\t\t}\n\t\t}\n\t}\n\tfoldingModel.toggleCollapseState(toToggle);\n}\n\n\n/**\n * Collapse or expand the regions at the given locations including all children.\n * @param doCollapse Whether to collapse or expand\n * @param levels The number of levels. Use 1 to only impact the regions at the location, use Number.MAX_VALUE for all levels.\n * @param lineNumbers the location of the regions to collapse or expand, or if not set, all regions in the model.\n */\nexport function setCollapseStateLevelsDown(foldingModel: FoldingModel, doCollapse: boolean, levels = Number.MAX_VALUE, lineNumbers?: number[]): void {\n\tconst toToggle: FoldingRegion[] = [];\n\tif (lineNumbers && lineNumbers.length > 0) {\n\t\tfor (const lineNumber of lineNumbers) {\n\t\t\tconst region = foldingModel.getRegionAtLine(lineNumber);\n\t\t\tif (region) {\n\t\t\t\tif (region.isCollapsed !== doCollapse) {\n\t\t\t\t\ttoToggle.push(region);\n\t\t\t\t}\n\t\t\t\tif (levels > 1) {\n\t\t\t\t\tconst regionsInside = foldingModel.getRegionsInside(region, (r, level: number) => r.isCollapsed !== doCollapse && level < levels);\n\t\t\t\t\ttoToggle.push(...regionsInside);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tconst regionsInside = foldingModel.getRegionsInside(null, (r, level: number) => r.isCollapsed !== doCollapse && level < levels);\n\t\ttoToggle.push(...regionsInside);\n\t}\n\tfoldingModel.toggleCollapseState(toToggle);\n}\n\n/**\n * Collapse or expand the regions at the given locations including all parents.\n * @param doCollapse Whether to collapse or expand\n * @param levels The number of levels. Use 1 to only impact the regions at the location, use Number.MAX_VALUE for all levels.\n * @param lineNumbers the location of the regions to collapse or expand.\n */\nexport function setCollapseStateLevelsUp(foldingModel: FoldingModel, doCollapse: boolean, levels: number, lineNumbers: number[]): void {\n\tconst toToggle: FoldingRegion[] = [];\n\tfor (const lineNumber of lineNumbers) {\n\t\tconst regions = foldingModel.getAllRegionsAtLine(lineNumber, (region, level) => region.isCollapsed !== doCollapse && level <= levels);\n\t\ttoToggle.push(...regions);\n\t}\n\tfoldingModel.toggleCollapseState(toToggle);\n}\n\n/**\n * Collapse or expand a region at the given locations. If the inner most region is already collapsed/expanded, uses the first parent instead.\n * @param doCollapse Whether to collapse or expand\n * @param lineNumbers the location of the regions to collapse or expand.\n */\nexport function setCollapseStateUp(foldingModel: FoldingModel, doCollapse: boolean, lineNumbers: number[]): void {\n\tconst toToggle: FoldingRegion[] = [];\n\tfor (const lineNumber of lineNumbers) {\n\t\tconst regions = foldingModel.getAllRegionsAtLine(lineNumber, (region,) => region.isCollapsed !== doCollapse);\n\t\tif (regions.length > 0) {\n\t\t\ttoToggle.push(regions[0]);\n\t\t}\n\t}\n\tfoldingModel.toggleCollapseState(toToggle);\n}\n\n/**\n * Folds or unfolds all regions that have a given level, except if they contain one of the blocked lines.\n * @param foldLevel level. Level == 1 is the top level\n * @param doCollapse Whether to collapse or expand\n*/\nexport function setCollapseStateAtLevel(foldingModel: FoldingModel, foldLevel: number, doCollapse: boolean, blockedLineNumbers: number[]): void {\n\tconst filter = (region: FoldingRegion, level: number) => level === foldLevel && region.isCollapsed !== doCollapse && !blockedLineNumbers.some(line => region.containsLine(line));\n\tconst toToggle = foldingModel.getRegionsInside(null, filter);\n\tfoldingModel.toggleCollapseState(toToggle);\n}\n\n/**\n * Folds or unfolds all regions, except if they contain or are contained by a region of one of the blocked lines.\n * @param doCollapse Whether to collapse or expand\n * @param blockedLineNumbers the location of regions to not collapse or expand\n */\nexport function setCollapseStateForRest(foldingModel: FoldingModel, doCollapse: boolean, blockedLineNumbers: number[]): void {\n\tconst filteredRegions: FoldingRegion[] = [];\n\tfor (const lineNumber of blockedLineNumbers) {\n\t\tconst regions = foldingModel.getAllRegionsAtLine(lineNumber, undefined);\n\t\tif (regions.length > 0) {\n\t\t\tfilteredRegions.push(regions[0]);\n\t\t}\n\t}\n\tconst filter = (region: FoldingRegion) => filteredRegions.every((filteredRegion) => !filteredRegion.containedBy(region) && !region.containedBy(filteredRegion)) && region.isCollapsed !== doCollapse;\n\tconst toToggle = foldingModel.getRegionsInside(null, filter);\n\tfoldingModel.toggleCollapseState(toToggle);\n}\n\n/**\n * Folds all regions for which the lines start with a given regex\n * @param foldingModel the folding model\n */\nexport function setCollapseStateForMatchingLines(foldingModel: FoldingModel, regExp: RegExp, doCollapse: boolean): void {\n\tconst editorModel = foldingModel.textModel;\n\tconst regions = foldingModel.regions;\n\tconst toToggle: FoldingRegion[] = [];\n\tfor (let i = regions.length - 1; i >= 0; i--) {\n\t\tif (doCollapse !== regions.isCollapsed(i)) {\n\t\t\tconst startLineNumber = regions.getStartLineNumber(i);\n\t\t\tif (regExp.test(editorModel.getLineContent(startLineNumber))) {\n\t\t\t\ttoToggle.push(regions.toRegion(i));\n\t\t\t}\n\t\t}\n\t}\n\tfoldingModel.toggleCollapseState(toToggle);\n}\n\n/**\n * Folds all regions of the given type\n * @param foldingModel the folding model\n */\nexport function setCollapseStateForType(foldingModel: FoldingModel, type: string, doCollapse: boolean): void {\n\tconst regions = foldingModel.regions;\n\tconst toToggle: FoldingRegion[] = [];\n\tfor (let i = regions.length - 1; i >= 0; i--) {\n\t\tif (doCollapse !== regions.isCollapsed(i) && type === regions.getType(i)) {\n\t\t\ttoToggle.push(regions.toRegion(i));\n\t\t}\n\t}\n\tfoldingModel.toggleCollapseState(toToggle);\n}\n\n/**\n * Get line to go to for parent fold of current line\n * @param lineNumber the current line number\n * @param foldingModel the folding model\n *\n * @return Parent fold start line\n */\nexport function getParentFoldLine(lineNumber: number, foldingModel: FoldingModel): number | null {\n\tlet startLineNumber: number | null = null;\n\tconst foldingRegion = foldingModel.getRegionAtLine(lineNumber);\n\tif (foldingRegion !== null) {\n\t\tstartLineNumber = foldingRegion.startLineNumber;\n\t\t// If current line is not the start of the current fold, go to top line of current fold. If not, go to parent fold\n\t\tif (lineNumber === startLineNumber) {\n\t\t\tconst parentFoldingIdx = foldingRegion.parentIndex;\n\t\t\tif (parentFoldingIdx !== -1) {\n\t\t\t\tstartLineNumber = foldingModel.regions.getStartLineNumber(parentFoldingIdx);\n\t\t\t} else {\n\t\t\t\tstartLineNumber = null;\n\t\t\t}\n\t\t}\n\t}\n\treturn startLineNumber;\n}\n\n/**\n * Get line to go to for previous fold at the same level of current line\n * @param lineNumber the current line number\n * @param foldingModel the folding model\n *\n * @return Previous fold start line\n */\nexport function getPreviousFoldLine(lineNumber: number, foldingModel: FoldingModel): number | null {\n\tlet foldingRegion = foldingModel.getRegionAtLine(lineNumber);\n\t// If on the folding range start line, go to previous sibling.\n\tif (foldingRegion !== null && foldingRegion.startLineNumber === lineNumber) {\n\t\t// If current line is not the start of the current fold, go to top line of current fold. If not, go to previous fold.\n\t\tif (lineNumber !== foldingRegion.startLineNumber) {\n\t\t\treturn foldingRegion.startLineNumber;\n\t\t} else {\n\t\t\t// Find min line number to stay within parent.\n\t\t\tconst expectedParentIndex = foldingRegion.parentIndex;\n\t\t\tlet minLineNumber = 0;\n\t\t\tif (expectedParentIndex !== -1) {\n\t\t\t\tminLineNumber = foldingModel.regions.getStartLineNumber(foldingRegion.parentIndex);\n\t\t\t}\n\n\t\t\t// Find fold at same level.\n\t\t\twhile (foldingRegion !== null) {\n\t\t\t\tif (foldingRegion.regionIndex > 0) {\n\t\t\t\t\tfoldingRegion = foldingModel.regions.toRegion(foldingRegion.regionIndex - 1);\n\n\t\t\t\t\t// Keep at same level.\n\t\t\t\t\tif (foldingRegion.startLineNumber <= minLineNumber) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t} else if (foldingRegion.parentIndex === expectedParentIndex) {\n\t\t\t\t\t\treturn foldingRegion.startLineNumber;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// Go to last fold that's before the current line.\n\t\tif (foldingModel.regions.length > 0) {\n\t\t\tfoldingRegion = foldingModel.regions.toRegion(foldingModel.regions.length - 1);\n\t\t\twhile (foldingRegion !== null) {\n\t\t\t\t// Found fold before current line.\n\t\t\t\tif (foldingRegion.startLineNumber < lineNumber) {\n\t\t\t\t\treturn foldingRegion.startLineNumber;\n\t\t\t\t}\n\t\t\t\tif (foldingRegion.regionIndex > 0) {\n\t\t\t\t\tfoldingRegion = foldingModel.regions.toRegion(foldingRegion.regionIndex - 1);\n\t\t\t\t} else {\n\t\t\t\t\tfoldingRegion = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn null;\n}\n\n/**\n * Get line to go to next fold at the same level of current line\n * @param lineNumber the current line number\n * @param foldingModel the folding model\n *\n * @return Next fold start line\n */\nexport function getNextFoldLine(lineNumber: number, foldingModel: FoldingModel): number | null {\n\tlet foldingRegion = foldingModel.getRegionAtLine(lineNumber);\n\t// If on the folding range start line, go to next sibling.\n\tif (foldingRegion !== null && foldingRegion.startLineNumber === lineNumber) {\n\t\t// Find max line number to stay within parent.\n\t\tconst expectedParentIndex = foldingRegion.parentIndex;\n\t\tlet maxLineNumber = 0;\n\t\tif (expectedParentIndex !== -1) {\n\t\t\tmaxLineNumber = foldingModel.regions.getEndLineNumber(foldingRegion.parentIndex);\n\t\t} else if (foldingModel.regions.length === 0) {\n\t\t\treturn null;\n\t\t} else {\n\t\t\tmaxLineNumber = foldingModel.regions.getEndLineNumber(foldingModel.regions.length - 1);\n\t\t}\n\n\t\t// Find fold at same level.\n\t\twhile (foldingRegion !== null) {\n\t\t\tif (foldingRegion.regionIndex < foldingModel.regions.length) {\n\t\t\t\tfoldingRegion = foldingModel.regions.toRegion(foldingRegion.regionIndex + 1);\n\n\t\t\t\t// Keep at same level.\n\t\t\t\tif (foldingRegion.startLineNumber >= maxLineNumber) {\n\t\t\t\t\treturn null;\n\t\t\t\t} else if (foldingRegion.parentIndex === expectedParentIndex) {\n\t\t\t\t\treturn foldingRegion.startLineNumber;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// Go to first fold that's after the current line.\n\t\tif (foldingModel.regions.length > 0) {\n\t\t\tfoldingRegion = foldingModel.regions.toRegion(0);\n\t\t\twhile (foldingRegion !== null) {\n\t\t\t\t// Found fold after current line.\n\t\t\t\tif (foldingRegion.startLineNumber > lineNumber) {\n\t\t\t\t\treturn foldingRegion.startLineNumber;\n\t\t\t\t}\n\t\t\t\tif (foldingRegion.regionIndex < foldingModel.regions.length) {\n\t\t\t\t\tfoldingRegion = foldingModel.regions.toRegion(foldingRegion.regionIndex + 1);\n\t\t\t\t} else {\n\t\t\t\t\tfoldingRegion = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn null;\n}\n"]}