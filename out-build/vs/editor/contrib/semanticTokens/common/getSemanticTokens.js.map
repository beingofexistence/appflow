{"version":3,"sources":["file:///workspace/appflow/src/vs/editor/contrib/semanticTokens/common/getSemanticTokens.ts"],"names":[],"mappings":"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","file":"getSemanticTokens.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken } from 'vs/base/common/cancellation';\nimport { onUnexpectedExternalError } from 'vs/base/common/errors';\nimport { URI } from 'vs/base/common/uri';\nimport { ITextModel } from 'vs/editor/common/model';\nimport { DocumentSemanticTokensProvider, SemanticTokens, SemanticTokensEdits, SemanticTokensLegend, DocumentRangeSemanticTokensProvider } from 'vs/editor/common/languages';\nimport { IModelService } from 'vs/editor/common/services/model';\nimport { CommandsRegistry, ICommandService } from 'vs/platform/commands/common/commands';\nimport { assertType } from 'vs/base/common/types';\nimport { VSBuffer } from 'vs/base/common/buffer';\nimport { encodeSemanticTokensDto } from 'vs/editor/common/services/semanticTokensDto';\nimport { Range } from 'vs/editor/common/core/range';\nimport { LanguageFeatureRegistry } from 'vs/editor/common/languageFeatureRegistry';\nimport { ILanguageFeaturesService } from 'vs/editor/common/services/languageFeatures';\n\nexport function isSemanticTokens(v: SemanticTokens | SemanticTokensEdits): v is SemanticTokens {\n\treturn v && !!((<SemanticTokens>v).data);\n}\n\nexport function isSemanticTokensEdits(v: SemanticTokens | SemanticTokensEdits): v is SemanticTokensEdits {\n\treturn v && Array.isArray((<SemanticTokensEdits>v).edits);\n}\n\nexport class DocumentSemanticTokensResult {\n\tconstructor(\n\t\tpublic readonly provider: DocumentSemanticTokensProvider,\n\t\tpublic readonly tokens: SemanticTokens | SemanticTokensEdits | null,\n\t\tpublic readonly error: any\n\t) { }\n}\n\nexport function hasDocumentSemanticTokensProvider(registry: LanguageFeatureRegistry<DocumentSemanticTokensProvider>, model: ITextModel): boolean {\n\treturn registry.has(model);\n}\n\nfunction getDocumentSemanticTokensProviders(registry: LanguageFeatureRegistry<DocumentSemanticTokensProvider>, model: ITextModel): DocumentSemanticTokensProvider[] {\n\tconst groups = registry.orderedGroups(model);\n\treturn (groups.length > 0 ? groups[0] : []);\n}\n\nexport async function getDocumentSemanticTokens(registry: LanguageFeatureRegistry<DocumentSemanticTokensProvider>, model: ITextModel, lastProvider: DocumentSemanticTokensProvider | null, lastResultId: string | null, token: CancellationToken): Promise<DocumentSemanticTokensResult | null> {\n\tconst providers = getDocumentSemanticTokensProviders(registry, model);\n\n\t// Get tokens from all providers at the same time.\n\tconst results = await Promise.all(providers.map(async (provider) => {\n\t\tlet result: SemanticTokens | SemanticTokensEdits | null | undefined;\n\t\tlet error: any = null;\n\t\ttry {\n\t\t\tresult = await provider.provideDocumentSemanticTokens(model, (provider === lastProvider ? lastResultId : null), token);\n\t\t} catch (err) {\n\t\t\terror = err;\n\t\t\tresult = null;\n\t\t}\n\n\t\tif (!result || (!isSemanticTokens(result) && !isSemanticTokensEdits(result))) {\n\t\t\tresult = null;\n\t\t}\n\n\t\treturn new DocumentSemanticTokensResult(provider, result, error);\n\t}));\n\n\t// Try to return the first result with actual tokens or\n\t// the first result which threw an error (!!)\n\tfor (const result of results) {\n\t\tif (result.error) {\n\t\t\tthrow result.error;\n\t\t}\n\t\tif (result.tokens) {\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t// Return the first result, even if it doesn't have tokens\n\tif (results.length > 0) {\n\t\treturn results[0];\n\t}\n\n\treturn null;\n}\n\nfunction _getDocumentSemanticTokensProviderHighestGroup(registry: LanguageFeatureRegistry<DocumentSemanticTokensProvider>, model: ITextModel): DocumentSemanticTokensProvider[] | null {\n\tconst result = registry.orderedGroups(model);\n\treturn (result.length > 0 ? result[0] : null);\n}\n\nclass DocumentRangeSemanticTokensResult {\n\tconstructor(\n\t\tpublic readonly provider: DocumentRangeSemanticTokensProvider,\n\t\tpublic readonly tokens: SemanticTokens | null,\n\t) { }\n}\n\nexport function hasDocumentRangeSemanticTokensProvider(providers: LanguageFeatureRegistry<DocumentRangeSemanticTokensProvider>, model: ITextModel): boolean {\n\treturn providers.has(model);\n}\n\nfunction getDocumentRangeSemanticTokensProviders(providers: LanguageFeatureRegistry<DocumentRangeSemanticTokensProvider>, model: ITextModel): DocumentRangeSemanticTokensProvider[] {\n\tconst groups = providers.orderedGroups(model);\n\treturn (groups.length > 0 ? groups[0] : []);\n}\n\nexport async function getDocumentRangeSemanticTokens(registry: LanguageFeatureRegistry<DocumentRangeSemanticTokensProvider>, model: ITextModel, range: Range, token: CancellationToken): Promise<DocumentRangeSemanticTokensResult | null> {\n\tconst providers = getDocumentRangeSemanticTokensProviders(registry, model);\n\n\t// Get tokens from all providers at the same time.\n\tconst results = await Promise.all(providers.map(async (provider) => {\n\t\tlet result: SemanticTokens | null | undefined;\n\t\ttry {\n\t\t\tresult = await provider.provideDocumentRangeSemanticTokens(model, range, token);\n\t\t} catch (err) {\n\t\t\tonUnexpectedExternalError(err);\n\t\t\tresult = null;\n\t\t}\n\n\t\tif (!result || !isSemanticTokens(result)) {\n\t\t\tresult = null;\n\t\t}\n\n\t\treturn new DocumentRangeSemanticTokensResult(provider, result);\n\t}));\n\n\t// Try to return the first result with actual tokens\n\tfor (const result of results) {\n\t\tif (result.tokens) {\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t// Return the first result, even if it doesn't have tokens\n\tif (results.length > 0) {\n\t\treturn results[0];\n\t}\n\n\treturn null;\n}\n\nCommandsRegistry.registerCommand('_provideDocumentSemanticTokensLegend', async (accessor, ...args): Promise<SemanticTokensLegend | undefined> => {\n\tconst [uri] = args;\n\tassertType(uri instanceof URI);\n\n\tconst model = accessor.get(IModelService).getModel(uri);\n\tif (!model) {\n\t\treturn undefined;\n\t}\n\tconst { documentSemanticTokensProvider } = accessor.get(ILanguageFeaturesService);\n\n\tconst providers = _getDocumentSemanticTokensProviderHighestGroup(documentSemanticTokensProvider, model);\n\tif (!providers) {\n\t\t// there is no provider => fall back to a document range semantic tokens provider\n\t\treturn accessor.get(ICommandService).executeCommand('_provideDocumentRangeSemanticTokensLegend', uri);\n\t}\n\n\treturn providers[0].getLegend();\n});\n\nCommandsRegistry.registerCommand('_provideDocumentSemanticTokens', async (accessor, ...args): Promise<VSBuffer | undefined> => {\n\tconst [uri] = args;\n\tassertType(uri instanceof URI);\n\n\tconst model = accessor.get(IModelService).getModel(uri);\n\tif (!model) {\n\t\treturn undefined;\n\t}\n\tconst { documentSemanticTokensProvider } = accessor.get(ILanguageFeaturesService);\n\tif (!hasDocumentSemanticTokensProvider(documentSemanticTokensProvider, model)) {\n\t\t// there is no provider => fall back to a document range semantic tokens provider\n\t\treturn accessor.get(ICommandService).executeCommand('_provideDocumentRangeSemanticTokens', uri, model.getFullModelRange());\n\t}\n\n\tconst r = await getDocumentSemanticTokens(documentSemanticTokensProvider, model, null, null, CancellationToken.None);\n\tif (!r) {\n\t\treturn undefined;\n\t}\n\n\tconst { provider, tokens } = r;\n\n\tif (!tokens || !isSemanticTokens(tokens)) {\n\t\treturn undefined;\n\t}\n\n\tconst buff = encodeSemanticTokensDto({\n\t\tid: 0,\n\t\ttype: 'full',\n\t\tdata: tokens.data\n\t});\n\tif (tokens.resultId) {\n\t\tprovider.releaseDocumentSemanticTokens(tokens.resultId);\n\t}\n\treturn buff;\n});\n\nCommandsRegistry.registerCommand('_provideDocumentRangeSemanticTokensLegend', async (accessor, ...args): Promise<SemanticTokensLegend | undefined> => {\n\tconst [uri, range] = args;\n\tassertType(uri instanceof URI);\n\n\tconst model = accessor.get(IModelService).getModel(uri);\n\tif (!model) {\n\t\treturn undefined;\n\t}\n\tconst { documentRangeSemanticTokensProvider } = accessor.get(ILanguageFeaturesService);\n\tconst providers = getDocumentRangeSemanticTokensProviders(documentRangeSemanticTokensProvider, model);\n\tif (providers.length === 0) {\n\t\t// no providers\n\t\treturn undefined;\n\t}\n\n\tif (providers.length === 1) {\n\t\t// straight forward case, just a single provider\n\t\treturn providers[0].getLegend();\n\t}\n\n\tif (!range || !Range.isIRange(range)) {\n\t\t// if no range is provided, we cannot support multiple providers\n\t\t// as we cannot fall back to the one which would give results\n\t\t// => return the first legend for backwards compatibility and print a warning\n\t\tconsole.warn(`provideDocumentRangeSemanticTokensLegend might be out-of-sync with provideDocumentRangeSemanticTokens unless a range argument is passed in`);\n\t\treturn providers[0].getLegend();\n\t}\n\n\tconst result = await getDocumentRangeSemanticTokens(documentRangeSemanticTokensProvider, model, Range.lift(range), CancellationToken.None);\n\tif (!result) {\n\t\treturn undefined;\n\t}\n\n\treturn result.provider.getLegend();\n});\n\nCommandsRegistry.registerCommand('_provideDocumentRangeSemanticTokens', async (accessor, ...args): Promise<VSBuffer | undefined> => {\n\tconst [uri, range] = args;\n\tassertType(uri instanceof URI);\n\tassertType(Range.isIRange(range));\n\n\tconst model = accessor.get(IModelService).getModel(uri);\n\tif (!model) {\n\t\treturn undefined;\n\t}\n\tconst { documentRangeSemanticTokensProvider } = accessor.get(ILanguageFeaturesService);\n\n\tconst result = await getDocumentRangeSemanticTokens(documentRangeSemanticTokensProvider, model, Range.lift(range), CancellationToken.None);\n\tif (!result || !result.tokens) {\n\t\t// there is no provider or it didn't return tokens\n\t\treturn undefined;\n\t}\n\n\treturn encodeSemanticTokensDto({\n\t\tid: 0,\n\t\ttype: 'full',\n\t\tdata: result.tokens.data\n\t});\n});\n"]}