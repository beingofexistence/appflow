{"version":3,"sources":["file:///workspace/appflow/src/vs/editor/common/tokenizationTextModelPart.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;IAyFhG,IAAkB,2BAGjB;IAHD,WAAkB,2BAA2B;QAC5C,yFAAc,CAAA;QACd,uFAAa,CAAA;IACd,CAAC,EAHiB,2BAA2B,2CAA3B,2BAA2B,QAG5C","file":"tokenizationTextModelPart.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IPosition } from 'vs/editor/common/core/position';\nimport { Range } from 'vs/editor/common/core/range';\nimport { StandardTokenType } from 'vs/editor/common/encodedTokenAttributes';\nimport { LineTokens } from 'vs/editor/common/tokens/lineTokens';\nimport { SparseMultilineTokens } from 'vs/editor/common/tokens/sparseMultilineTokens';\n\n/**\n * Provides tokenization related functionality of the text model.\n*/\nexport interface ITokenizationTextModelPart {\n\treadonly hasTokens: boolean;\n\n\t/**\n\t * Replaces all semantic tokens with the provided `tokens`.\n\t * @internal\n\t */\n\tsetSemanticTokens(tokens: SparseMultilineTokens[] | null, isComplete: boolean): void;\n\n\t/**\n\t * Merges the provided semantic tokens into existing semantic tokens.\n\t * @internal\n\t */\n\tsetPartialSemanticTokens(range: Range, tokens: SparseMultilineTokens[] | null): void;\n\n\t/**\n\t * @internal\n\t */\n\thasCompleteSemanticTokens(): boolean;\n\n\t/**\n\t * @internal\n\t */\n\thasSomeSemanticTokens(): boolean;\n\n\t/**\n\t * Flush all tokenization state.\n\t * @internal\n\t */\n\tresetTokenization(): void;\n\n\t/**\n\t * Force tokenization information for `lineNumber` to be accurate.\n\t * @internal\n\t */\n\tforceTokenization(lineNumber: number): void;\n\n\t/**\n\t * If it is cheap, force tokenization information for `lineNumber` to be accurate.\n\t * This is based on a heuristic.\n\t * @internal\n\t */\n\ttokenizeIfCheap(lineNumber: number): void;\n\n\t/**\n\t * Check if calling `forceTokenization` for this `lineNumber` will be cheap (time-wise).\n\t * This is based on a heuristic.\n\t * @internal\n\t */\n\tisCheapToTokenize(lineNumber: number): boolean;\n\n\t/**\n\t * Get the tokens for the line `lineNumber`.\n\t * The tokens might be inaccurate. Use `forceTokenization` to ensure accurate tokens.\n\t * @internal\n\t */\n\tgetLineTokens(lineNumber: number): LineTokens;\n\n\t/**\n\t* Returns the standard token type for a character if the character were to be inserted at\n\t* the given position. If the result cannot be accurate, it returns null.\n\t* @internal\n\t*/\n\tgetTokenTypeIfInsertingCharacter(lineNumber: number, column: number, character: string): StandardTokenType;\n\n\t/**\n\t * @internal\n\t*/\n\ttokenizeLineWithEdit(position: IPosition, length: number, newText: string): LineTokens | null;\n\n\tgetLanguageId(): string;\n\tgetLanguageIdAtPosition(lineNumber: number, column: number): string;\n\n\tsetLanguageId(languageId: string, source?: string): void;\n\n\treadonly backgroundTokenizationState: BackgroundTokenizationState;\n}\n\nexport const enum BackgroundTokenizationState {\n\tInProgress = 1,\n\tCompleted = 2,\n}\n"]}