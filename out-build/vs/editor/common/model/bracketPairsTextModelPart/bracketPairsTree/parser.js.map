{"version":3,"sources":["file:///workspace/appflow/src/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/parser.ts"],"names":[],"mappings":"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","file":"parser.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { AstNode, AstNodeKind, BracketAstNode, InvalidBracketAstNode, ListAstNode, PairAstNode, TextAstNode } from './ast';\nimport { BeforeEditPositionMapper, TextEditInfo } from './beforeEditPositionMapper';\nimport { SmallImmutableSet } from './smallImmutableSet';\nimport { lengthIsZero, lengthLessThan } from './length';\nimport { concat23Trees, concat23TreesOfSameHeight } from './concat23Trees';\nimport { NodeReader } from './nodeReader';\nimport { OpeningBracketId, Tokenizer, TokenKind } from './tokenizer';\n\n/**\n * Non incrementally built ASTs are immutable.\n*/\nexport function parseDocument(tokenizer: Tokenizer, edits: TextEditInfo[], oldNode: AstNode | undefined, createImmutableLists: boolean): AstNode {\n\tconst parser = new Parser(tokenizer, edits, oldNode, createImmutableLists);\n\treturn parser.parseDocument();\n}\n\n/**\n * Non incrementally built ASTs are immutable.\n*/\nclass Parser {\n\tprivate readonly oldNodeReader?: NodeReader;\n\tprivate readonly positionMapper: BeforeEditPositionMapper;\n\tprivate _itemsConstructed: number = 0;\n\tprivate _itemsFromCache: number = 0;\n\n\t/**\n\t * Reports how many nodes were constructed in the last parse operation.\n\t*/\n\tget nodesConstructed() {\n\t\treturn this._itemsConstructed;\n\t}\n\n\t/**\n\t * Reports how many nodes were reused in the last parse operation.\n\t*/\n\tget nodesReused() {\n\t\treturn this._itemsFromCache;\n\t}\n\n\tconstructor(\n\t\tprivate readonly tokenizer: Tokenizer,\n\t\tedits: TextEditInfo[],\n\t\toldNode: AstNode | undefined,\n\t\tprivate readonly createImmutableLists: boolean,\n\t) {\n\t\tif (oldNode && createImmutableLists) {\n\t\t\tthrow new Error('Not supported');\n\t\t}\n\n\t\tthis.oldNodeReader = oldNode ? new NodeReader(oldNode) : undefined;\n\t\tthis.positionMapper = new BeforeEditPositionMapper(edits);\n\t}\n\n\tparseDocument(): AstNode {\n\t\tthis._itemsConstructed = 0;\n\t\tthis._itemsFromCache = 0;\n\n\t\tlet result = this.parseList(SmallImmutableSet.getEmpty(), 0);\n\t\tif (!result) {\n\t\t\tresult = ListAstNode.getEmpty();\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate parseList(\n\t\topenedBracketIds: SmallImmutableSet<OpeningBracketId>,\n\t\tlevel: number,\n\t): AstNode | null {\n\t\tconst items: AstNode[] = [];\n\n\t\twhile (true) {\n\t\t\tlet child = this.tryReadChildFromCache(openedBracketIds);\n\n\t\t\tif (!child) {\n\t\t\t\tconst token = this.tokenizer.peek();\n\t\t\t\tif (\n\t\t\t\t\t!token ||\n\t\t\t\t\t(token.kind === TokenKind.ClosingBracket &&\n\t\t\t\t\t\ttoken.bracketIds.intersects(openedBracketIds))\n\t\t\t\t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tchild = this.parseChild(openedBracketIds, level + 1);\n\t\t\t}\n\n\t\t\tif (child.kind === AstNodeKind.List && child.childrenLength === 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\titems.push(child);\n\t\t}\n\n\t\t// When there is no oldNodeReader, all items are created from scratch and must have the same height.\n\t\tconst result = this.oldNodeReader ? concat23Trees(items) : concat23TreesOfSameHeight(items, this.createImmutableLists);\n\t\treturn result;\n\t}\n\n\tprivate tryReadChildFromCache(openedBracketIds: SmallImmutableSet<number>): AstNode | undefined {\n\t\tif (this.oldNodeReader) {\n\t\t\tconst maxCacheableLength = this.positionMapper.getDistanceToNextChange(this.tokenizer.offset);\n\t\t\tif (maxCacheableLength === null || !lengthIsZero(maxCacheableLength)) {\n\t\t\t\tconst cachedNode = this.oldNodeReader.readLongestNodeAt(this.positionMapper.getOffsetBeforeChange(this.tokenizer.offset), curNode => {\n\t\t\t\t\t// The edit could extend the ending token, thus we cannot re-use nodes that touch the edit.\n\t\t\t\t\t// If there is no edit anymore, we can re-use the node in any case.\n\t\t\t\t\tif (maxCacheableLength !== null && !lengthLessThan(curNode.length, maxCacheableLength)) {\n\t\t\t\t\t\t// Either the node contains edited text or touches edited text.\n\t\t\t\t\t\t// In the latter case, brackets might have been extended (`end` -> `ending`), so even touching nodes cannot be reused.\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tconst canBeReused = curNode.canBeReused(openedBracketIds);\n\t\t\t\t\treturn canBeReused;\n\t\t\t\t});\n\n\t\t\t\tif (cachedNode) {\n\t\t\t\t\tthis._itemsFromCache++;\n\t\t\t\t\tthis.tokenizer.skip(cachedNode.length);\n\t\t\t\t\treturn cachedNode;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tprivate parseChild(\n\t\topenedBracketIds: SmallImmutableSet<number>,\n\t\tlevel: number,\n\t): AstNode {\n\t\tthis._itemsConstructed++;\n\n\t\tconst token = this.tokenizer.read()!;\n\n\t\tswitch (token.kind) {\n\t\t\tcase TokenKind.ClosingBracket:\n\t\t\t\treturn new InvalidBracketAstNode(token.bracketIds, token.length);\n\n\t\t\tcase TokenKind.Text:\n\t\t\t\treturn token.astNode as TextAstNode;\n\n\t\t\tcase TokenKind.OpeningBracket: {\n\t\t\t\tif (level > 300) {\n\t\t\t\t\t// To prevent stack overflows\n\t\t\t\t\treturn new TextAstNode(token.length);\n\t\t\t\t}\n\n\t\t\t\tconst set = openedBracketIds.merge(token.bracketIds);\n\t\t\t\tconst child = this.parseList(set, level + 1);\n\n\t\t\t\tconst nextToken = this.tokenizer.peek();\n\t\t\t\tif (\n\t\t\t\t\tnextToken &&\n\t\t\t\t\tnextToken.kind === TokenKind.ClosingBracket &&\n\t\t\t\t\t(nextToken.bracketId === token.bracketId || nextToken.bracketIds.intersects(token.bracketIds))\n\t\t\t\t) {\n\t\t\t\t\tthis.tokenizer.read();\n\t\t\t\t\treturn PairAstNode.create(\n\t\t\t\t\t\ttoken.astNode as BracketAstNode,\n\t\t\t\t\t\tchild,\n\t\t\t\t\t\tnextToken.astNode as BracketAstNode\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\treturn PairAstNode.create(\n\t\t\t\t\t\ttoken.astNode as BracketAstNode,\n\t\t\t\t\t\tchild,\n\t\t\t\t\t\tnull\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tthrow new Error('unexpected');\n\t\t}\n\t}\n}\n"]}