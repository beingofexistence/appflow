{"version":3,"sources":["file:///workspace/appflow/src/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/nodeReader.ts"],"names":[],"mappings":"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","file":"nodeReader.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { AstNode } from './ast';\nimport { lengthAdd, lengthZero, Length, lengthLessThan } from './length';\n\n/**\n * Allows to efficiently find a longest child at a given offset in a fixed node.\n * The requested offsets must increase monotonously.\n*/\nexport class NodeReader {\n\tprivate readonly nextNodes: AstNode[];\n\tprivate readonly offsets: Length[];\n\tprivate readonly idxs: number[];\n\tprivate lastOffset: Length = lengthZero;\n\n\tconstructor(node: AstNode) {\n\t\tthis.nextNodes = [node];\n\t\tthis.offsets = [lengthZero];\n\t\tthis.idxs = [];\n\t}\n\n\t/**\n\t * Returns the longest node at `offset` that satisfies the predicate.\n\t * @param offset must be greater than or equal to the last offset this method has been called with!\n\t*/\n\treadLongestNodeAt(offset: Length, predicate: (node: AstNode) => boolean): AstNode | undefined {\n\t\tif (lengthLessThan(offset, this.lastOffset)) {\n\t\t\tthrow new Error('Invalid offset');\n\t\t}\n\t\tthis.lastOffset = offset;\n\n\t\t// Find the longest node of all those that are closest to the current offset.\n\t\twhile (true) {\n\t\t\tconst curNode = lastOrUndefined(this.nextNodes);\n\n\t\t\tif (!curNode) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tconst curNodeOffset = lastOrUndefined(this.offsets)!;\n\n\t\t\tif (lengthLessThan(offset, curNodeOffset)) {\n\t\t\t\t// The next best node is not here yet.\n\t\t\t\t// The reader must advance before a cached node is hit.\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tif (lengthLessThan(curNodeOffset, offset)) {\n\t\t\t\t// The reader is ahead of the current node.\n\t\t\t\tif (lengthAdd(curNodeOffset, curNode.length) <= offset) {\n\t\t\t\t\t// The reader is after the end of the current node.\n\t\t\t\t\tthis.nextNodeAfterCurrent();\n\t\t\t\t} else {\n\t\t\t\t\t// The reader is somewhere in the current node.\n\t\t\t\t\tconst nextChildIdx = getNextChildIdx(curNode);\n\t\t\t\t\tif (nextChildIdx !== -1) {\n\t\t\t\t\t\t// Go to the first child and repeat.\n\t\t\t\t\t\tthis.nextNodes.push(curNode.getChild(nextChildIdx)!);\n\t\t\t\t\t\tthis.offsets.push(curNodeOffset);\n\t\t\t\t\t\tthis.idxs.push(nextChildIdx);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// We don't have children\n\t\t\t\t\t\tthis.nextNodeAfterCurrent();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// readerOffsetBeforeChange === curNodeOffset\n\t\t\t\tif (predicate(curNode)) {\n\t\t\t\t\tthis.nextNodeAfterCurrent();\n\t\t\t\t\treturn curNode;\n\t\t\t\t} else {\n\t\t\t\t\tconst nextChildIdx = getNextChildIdx(curNode);\n\t\t\t\t\t// look for shorter node\n\t\t\t\t\tif (nextChildIdx === -1) {\n\t\t\t\t\t\t// There is no shorter node.\n\t\t\t\t\t\tthis.nextNodeAfterCurrent();\n\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Descend into first child & repeat.\n\t\t\t\t\t\tthis.nextNodes.push(curNode.getChild(nextChildIdx)!);\n\t\t\t\t\t\tthis.offsets.push(curNodeOffset);\n\t\t\t\t\t\tthis.idxs.push(nextChildIdx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Navigates to the longest node that continues after the current node.\n\tprivate nextNodeAfterCurrent(): void {\n\t\twhile (true) {\n\t\t\tconst currentOffset = lastOrUndefined(this.offsets);\n\t\t\tconst currentNode = lastOrUndefined(this.nextNodes);\n\t\t\tthis.nextNodes.pop();\n\t\t\tthis.offsets.pop();\n\n\t\t\tif (this.idxs.length === 0) {\n\t\t\t\t// We just popped the root node, there is no next node.\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Parent is not undefined, because idxs is not empty\n\t\t\tconst parent = lastOrUndefined(this.nextNodes)!;\n\t\t\tconst nextChildIdx = getNextChildIdx(parent, this.idxs[this.idxs.length - 1]);\n\n\t\t\tif (nextChildIdx !== -1) {\n\t\t\t\tthis.nextNodes.push(parent.getChild(nextChildIdx)!);\n\t\t\t\tthis.offsets.push(lengthAdd(currentOffset!, currentNode!.length));\n\t\t\t\tthis.idxs[this.idxs.length - 1] = nextChildIdx;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tthis.idxs.pop();\n\t\t\t}\n\t\t\t// We fully consumed the parent.\n\t\t\t// Current node is now parent, so call nextNodeAfterCurrent again\n\t\t}\n\t}\n}\n\nfunction getNextChildIdx(node: AstNode, curIdx: number = -1): number | -1 {\n\twhile (true) {\n\t\tcurIdx++;\n\t\tif (curIdx >= node.childrenLength) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (node.getChild(curIdx)) {\n\t\t\treturn curIdx;\n\t\t}\n\t}\n}\n\nfunction lastOrUndefined<T>(arr: readonly T[]): T | undefined {\n\treturn arr.length > 0 ? arr[arr.length - 1] : undefined;\n}\n"]}