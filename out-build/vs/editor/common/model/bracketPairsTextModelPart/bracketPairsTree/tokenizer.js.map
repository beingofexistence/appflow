{"version":3,"sources":["file:///workspace/appflow/src/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/tokenizer.ts"],"names":[],"mappings":"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","file":"tokenizer.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { NotSupportedError } from 'vs/base/common/errors';\nimport { StandardTokenType, TokenMetadata } from 'vs/editor/common/encodedTokenAttributes';\nimport { IViewLineTokens } from 'vs/editor/common/tokens/lineTokens';\nimport { BracketAstNode, TextAstNode } from './ast';\nimport { BracketTokens, LanguageAgnosticBracketTokens } from './brackets';\nimport { Length, lengthAdd, lengthDiff, lengthGetColumnCountIfZeroLineCount, lengthToObj, lengthZero, toLength } from './length';\nimport { SmallImmutableSet } from './smallImmutableSet';\n\nexport interface Tokenizer {\n\treadonly offset: Length;\n\treadonly length: Length;\n\n\tread(): Token | null;\n\tpeek(): Token | null;\n\tskip(length: Length): void;\n\n\tgetText(): string;\n}\n\nexport const enum TokenKind {\n\tText = 0,\n\tOpeningBracket = 1,\n\tClosingBracket = 2,\n}\n\nexport type OpeningBracketId = number;\n\nexport class Token {\n\tconstructor(\n\t\treadonly length: Length,\n\t\treadonly kind: TokenKind,\n\t\t/**\n\t\t * If this token is an opening bracket, this is the id of the opening bracket.\n\t\t * If this token is a closing bracket, this is the id of the first opening bracket that is closed by this bracket.\n\t\t * Otherwise, it is -1.\n\t\t */\n\t\treadonly bracketId: OpeningBracketId,\n\t\t/**\n\t\t * If this token is an opening bracket, this just contains `bracketId`.\n\t\t * If this token is a closing bracket, this lists all opening bracket ids, that it closes.\n\t\t * Otherwise, it is empty.\n\t\t */\n\t\treadonly bracketIds: SmallImmutableSet<OpeningBracketId>,\n\t\treadonly astNode: BracketAstNode | TextAstNode | undefined,\n\t) { }\n}\n\nexport interface ITokenizerSource {\n\tgetValue(): string;\n\tgetLineCount(): number;\n\tgetLineLength(lineNumber: number): number;\n\n\ttokenization: {\n\t\tgetLineTokens(lineNumber: number): IViewLineTokens;\n\t};\n}\n\nexport class TextBufferTokenizer implements Tokenizer {\n\tprivate readonly textBufferLineCount: number;\n\tprivate readonly textBufferLastLineLength: number;\n\n\tprivate readonly reader = new NonPeekableTextBufferTokenizer(this.textModel, this.bracketTokens);\n\n\tconstructor(\n\t\tprivate readonly textModel: ITokenizerSource,\n\t\tprivate readonly bracketTokens: LanguageAgnosticBracketTokens\n\t) {\n\t\tthis.textBufferLineCount = textModel.getLineCount();\n\t\tthis.textBufferLastLineLength = textModel.getLineLength(this.textBufferLineCount);\n\t}\n\n\tprivate _offset: Length = lengthZero;\n\n\tget offset() {\n\t\treturn this._offset;\n\t}\n\n\tget length() {\n\t\treturn toLength(this.textBufferLineCount - 1, this.textBufferLastLineLength);\n\t}\n\n\tgetText() {\n\t\treturn this.textModel.getValue();\n\t}\n\n\tskip(length: Length): void {\n\t\tthis.didPeek = false;\n\t\tthis._offset = lengthAdd(this._offset, length);\n\t\tconst obj = lengthToObj(this._offset);\n\t\tthis.reader.setPosition(obj.lineCount, obj.columnCount);\n\t}\n\n\tprivate didPeek = false;\n\tprivate peeked: Token | null = null;\n\n\tread(): Token | null {\n\t\tlet token: Token | null;\n\t\tif (this.peeked) {\n\t\t\tthis.didPeek = false;\n\t\t\ttoken = this.peeked;\n\t\t} else {\n\t\t\ttoken = this.reader.read();\n\t\t}\n\t\tif (token) {\n\t\t\tthis._offset = lengthAdd(this._offset, token.length);\n\t\t}\n\t\treturn token;\n\t}\n\n\tpeek(): Token | null {\n\t\tif (!this.didPeek) {\n\t\t\tthis.peeked = this.reader.read();\n\t\t\tthis.didPeek = true;\n\t\t}\n\t\treturn this.peeked;\n\t}\n}\n\n/**\n * Does not support peek.\n*/\nclass NonPeekableTextBufferTokenizer {\n\tprivate readonly textBufferLineCount: number;\n\tprivate readonly textBufferLastLineLength: number;\n\n\tconstructor(private readonly textModel: ITokenizerSource, private readonly bracketTokens: LanguageAgnosticBracketTokens) {\n\t\tthis.textBufferLineCount = textModel.getLineCount();\n\t\tthis.textBufferLastLineLength = textModel.getLineLength(this.textBufferLineCount);\n\t}\n\n\tprivate lineIdx = 0;\n\tprivate line: string | null = null;\n\tprivate lineCharOffset = 0;\n\tprivate lineTokens: IViewLineTokens | null = null;\n\tprivate lineTokenOffset = 0;\n\n\tpublic setPosition(lineIdx: number, column: number): void {\n\t\t// We must not jump into a token!\n\t\tif (lineIdx === this.lineIdx) {\n\t\t\tthis.lineCharOffset = column;\n\t\t\tif (this.line !== null) {\n\t\t\t\tthis.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens!.findTokenIndexAtOffset(this.lineCharOffset);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.lineIdx = lineIdx;\n\t\t\tthis.lineCharOffset = column;\n\t\t\tthis.line = null;\n\t\t}\n\t\tthis.peekedToken = null;\n\t}\n\n\t/** Must be a zero line token. The end of the document cannot be peeked. */\n\tprivate peekedToken: Token | null = null;\n\n\tpublic read(): Token | null {\n\t\tif (this.peekedToken) {\n\t\t\tconst token = this.peekedToken;\n\t\t\tthis.peekedToken = null;\n\t\t\tthis.lineCharOffset += lengthGetColumnCountIfZeroLineCount(token.length);\n\t\t\treturn token;\n\t\t}\n\n\t\tif (this.lineIdx > this.textBufferLineCount - 1 || (this.lineIdx === this.textBufferLineCount - 1 && this.lineCharOffset >= this.textBufferLastLineLength)) {\n\t\t\t// We are after the end\n\t\t\treturn null;\n\t\t}\n\n\t\tif (this.line === null) {\n\t\t\tthis.lineTokens = this.textModel.tokenization.getLineTokens(this.lineIdx + 1);\n\t\t\tthis.line = this.lineTokens.getLineContent();\n\t\t\tthis.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens!.findTokenIndexAtOffset(this.lineCharOffset);\n\t\t}\n\n\t\tconst startLineIdx = this.lineIdx;\n\t\tconst startLineCharOffset = this.lineCharOffset;\n\n\t\t// limits the length of text tokens.\n\t\t// If text tokens get too long, incremental updates will be slow\n\t\tlet lengthHeuristic = 0;\n\t\twhile (true) {\n\t\t\tconst lineTokens = this.lineTokens!;\n\t\t\tconst tokenCount = lineTokens.getCount();\n\n\t\t\tlet peekedBracketToken: Token | null = null;\n\n\t\t\tif (this.lineTokenOffset < tokenCount) {\n\t\t\t\tconst tokenMetadata = lineTokens.getMetadata(this.lineTokenOffset);\n\t\t\t\twhile (this.lineTokenOffset + 1 < tokenCount && tokenMetadata === lineTokens.getMetadata(this.lineTokenOffset + 1)) {\n\t\t\t\t\t// Skip tokens that are identical.\n\t\t\t\t\t// Sometimes, (bracket) identifiers are split up into multiple tokens.\n\t\t\t\t\tthis.lineTokenOffset++;\n\t\t\t\t}\n\n\t\t\t\tconst isOther = TokenMetadata.getTokenType(tokenMetadata) === StandardTokenType.Other;\n\t\t\t\tconst containsBracketType = TokenMetadata.containsBalancedBrackets(tokenMetadata);\n\n\t\t\t\tconst endOffset = lineTokens.getEndOffset(this.lineTokenOffset);\n\t\t\t\t// Is there a bracket token next? Only consume text.\n\t\t\t\tif (containsBracketType && isOther && this.lineCharOffset < endOffset) {\n\t\t\t\t\tconst languageId = lineTokens.getLanguageId(this.lineTokenOffset);\n\t\t\t\t\tconst text = this.line.substring(this.lineCharOffset, endOffset);\n\n\t\t\t\t\tconst brackets = this.bracketTokens.getSingleLanguageBracketTokens(languageId);\n\t\t\t\t\tconst regexp = brackets.regExpGlobal;\n\t\t\t\t\tif (regexp) {\n\t\t\t\t\t\tregexp.lastIndex = 0;\n\t\t\t\t\t\tconst match = regexp.exec(text);\n\t\t\t\t\t\tif (match) {\n\t\t\t\t\t\t\tpeekedBracketToken = brackets.getToken(match[0])!;\n\t\t\t\t\t\t\tif (peekedBracketToken) {\n\t\t\t\t\t\t\t\t// Consume leading text of the token\n\t\t\t\t\t\t\t\tthis.lineCharOffset += match.index;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlengthHeuristic += endOffset - this.lineCharOffset;\n\n\t\t\t\tif (peekedBracketToken) {\n\t\t\t\t\t// Don't skip the entire token, as a single token could contain multiple brackets.\n\n\t\t\t\t\tif (startLineIdx !== this.lineIdx || startLineCharOffset !== this.lineCharOffset) {\n\t\t\t\t\t\t// There is text before the bracket\n\t\t\t\t\t\tthis.peekedToken = peekedBracketToken;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Consume the peeked token\n\t\t\t\t\t\tthis.lineCharOffset += lengthGetColumnCountIfZeroLineCount(peekedBracketToken.length);\n\t\t\t\t\t\treturn peekedBracketToken;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Skip the entire token, as the token contains no brackets at all.\n\t\t\t\t\tthis.lineTokenOffset++;\n\t\t\t\t\tthis.lineCharOffset = endOffset;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (this.lineIdx === this.textBufferLineCount - 1) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tthis.lineIdx++;\n\t\t\t\tthis.lineTokens = this.textModel.tokenization.getLineTokens(this.lineIdx + 1);\n\t\t\t\tthis.lineTokenOffset = 0;\n\t\t\t\tthis.line = this.lineTokens.getLineContent();\n\t\t\t\tthis.lineCharOffset = 0;\n\n\t\t\t\tlengthHeuristic += 33; // max 1000/33 = 30 lines\n\t\t\t\t// This limits the amount of work to recompute min-indentation\n\n\t\t\t\tif (lengthHeuristic > 1000) {\n\t\t\t\t\t// only break (automatically) at the end of line.\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (lengthHeuristic > 1500) {\n\t\t\t\t// Eventually break regardless of the line length so that\n\t\t\t\t// very long lines do not cause bad performance.\n\t\t\t\t// This effective limits max indentation to 500, as\n\t\t\t\t// indentation is not computed across multiple text nodes.\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// If a token contains some proper indentation, it also contains \\n{INDENTATION+}(?!{INDENTATION}),\n\t\t// unless the line is too long.\n\t\t// Thus, the min indentation of the document is the minimum min indentation of every text node.\n\t\tconst length = lengthDiff(startLineIdx, startLineCharOffset, this.lineIdx, this.lineCharOffset);\n\t\treturn new Token(length, TokenKind.Text, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n\t}\n}\n\nexport class FastTokenizer implements Tokenizer {\n\tprivate _offset: Length = lengthZero;\n\tprivate readonly tokens: readonly Token[];\n\tprivate idx = 0;\n\n\tconstructor(private readonly text: string, brackets: BracketTokens) {\n\t\tconst regExpStr = brackets.getRegExpStr();\n\t\tconst regexp = regExpStr ? new RegExp(regExpStr + '|\\n', 'gi') : null;\n\n\t\tconst tokens: Token[] = [];\n\n\t\tlet match: RegExpExecArray | null;\n\t\tlet curLineCount = 0;\n\t\tlet lastLineBreakOffset = 0;\n\n\t\tlet lastTokenEndOffset = 0;\n\t\tlet lastTokenEndLine = 0;\n\n\t\tconst smallTextTokens0Line: Token[] = [];\n\t\tfor (let i = 0; i < 60; i++) {\n\t\t\tsmallTextTokens0Line.push(\n\t\t\t\tnew Token(\n\t\t\t\t\ttoLength(0, i), TokenKind.Text, -1, SmallImmutableSet.getEmpty(),\n\t\t\t\t\tnew TextAstNode(toLength(0, i))\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\tconst smallTextTokens1Line: Token[] = [];\n\t\tfor (let i = 0; i < 60; i++) {\n\t\t\tsmallTextTokens1Line.push(\n\t\t\t\tnew Token(\n\t\t\t\t\ttoLength(1, i), TokenKind.Text, -1, SmallImmutableSet.getEmpty(),\n\t\t\t\t\tnew TextAstNode(toLength(1, i))\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\tif (regexp) {\n\t\t\tregexp.lastIndex = 0;\n\t\t\t// If a token contains indentation, it also contains \\n{INDENTATION+}(?!{INDENTATION})\n\t\t\twhile ((match = regexp.exec(text)) !== null) {\n\t\t\t\tconst curOffset = match.index;\n\t\t\t\tconst value = match[0];\n\t\t\t\tif (value === '\\n') {\n\t\t\t\t\tcurLineCount++;\n\t\t\t\t\tlastLineBreakOffset = curOffset + 1;\n\t\t\t\t} else {\n\t\t\t\t\tif (lastTokenEndOffset !== curOffset) {\n\t\t\t\t\t\tlet token: Token;\n\t\t\t\t\t\tif (lastTokenEndLine === curLineCount) {\n\t\t\t\t\t\t\tconst colCount = curOffset - lastTokenEndOffset;\n\t\t\t\t\t\t\tif (colCount < smallTextTokens0Line.length) {\n\t\t\t\t\t\t\t\ttoken = smallTextTokens0Line[colCount];\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tconst length = toLength(0, colCount);\n\t\t\t\t\t\t\t\ttoken = new Token(length, TokenKind.Text, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst lineCount = curLineCount - lastTokenEndLine;\n\t\t\t\t\t\t\tconst colCount = curOffset - lastLineBreakOffset;\n\t\t\t\t\t\t\tif (lineCount === 1 && colCount < smallTextTokens1Line.length) {\n\t\t\t\t\t\t\t\ttoken = smallTextTokens1Line[colCount];\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tconst length = toLength(lineCount, colCount);\n\t\t\t\t\t\t\t\ttoken = new Token(length, TokenKind.Text, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttokens.push(token);\n\t\t\t\t\t}\n\n\t\t\t\t\t// value is matched by regexp, so the token must exist\n\t\t\t\t\ttokens.push(brackets.getToken(value)!);\n\n\t\t\t\t\tlastTokenEndOffset = curOffset + value.length;\n\t\t\t\t\tlastTokenEndLine = curLineCount;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst offset = text.length;\n\n\t\tif (lastTokenEndOffset !== offset) {\n\t\t\tconst length = (lastTokenEndLine === curLineCount)\n\t\t\t\t? toLength(0, offset - lastTokenEndOffset)\n\t\t\t\t: toLength(curLineCount - lastTokenEndLine, offset - lastLineBreakOffset);\n\t\t\ttokens.push(new Token(length, TokenKind.Text, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length)));\n\t\t}\n\n\t\tthis.length = toLength(curLineCount, offset - lastLineBreakOffset);\n\t\tthis.tokens = tokens;\n\t}\n\n\tget offset(): Length {\n\t\treturn this._offset;\n\t}\n\n\treadonly length: Length;\n\n\tread(): Token | null {\n\t\treturn this.tokens[this.idx++] || null;\n\t}\n\n\tpeek(): Token | null {\n\t\treturn this.tokens[this.idx] || null;\n\t}\n\n\tskip(length: Length): void {\n\t\tthrow new NotSupportedError();\n\t}\n\n\tgetText(): string {\n\t\treturn this.text;\n\t}\n}\n"]}