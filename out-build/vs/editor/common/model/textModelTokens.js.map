{"version":3,"sources":["file:///workspace/appflow/src/vs/editor/common/model/textModelTokens.ts"],"names":[],"mappings":"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","file":"textModelTokens.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IdleDeadline, runWhenIdle } from 'vs/base/common/async';\nimport { BugIndicatingError, onUnexpectedError } from 'vs/base/common/errors';\nimport { setTimeout0 } from 'vs/base/common/platform';\nimport { StopWatch } from 'vs/base/common/stopwatch';\nimport { countEOL } from 'vs/editor/common/core/eolCounter';\nimport { LineRange } from 'vs/editor/common/core/lineRange';\nimport { OffsetRange } from 'vs/editor/common/core/offsetRange';\nimport { Position } from 'vs/editor/common/core/position';\nimport { StandardTokenType } from 'vs/editor/common/encodedTokenAttributes';\nimport { EncodedTokenizationResult, IBackgroundTokenizationStore, IBackgroundTokenizer, ILanguageIdCodec, IState, ITokenizationSupport } from 'vs/editor/common/languages';\nimport { nullTokenizeEncoded } from 'vs/editor/common/languages/nullTokenize';\nimport { ITextModel } from 'vs/editor/common/model';\nimport { FixedArray } from 'vs/editor/common/model/fixedArray';\nimport { IModelContentChange } from 'vs/editor/common/textModelEvents';\nimport { ContiguousMultilineTokensBuilder } from 'vs/editor/common/tokens/contiguousMultilineTokensBuilder';\nimport { LineTokens } from 'vs/editor/common/tokens/lineTokens';\n\nconst enum Constants {\n\tCHEAP_TOKENIZATION_LENGTH_LIMIT = 2048\n}\n\nexport class TokenizerWithStateStore<TState extends IState = IState> {\n\tprivate readonly initialState = this.tokenizationSupport.getInitialState() as TState;\n\n\tpublic readonly store: TrackingTokenizationStateStore<TState>;\n\n\tconstructor(\n\t\tlineCount: number,\n\t\tpublic readonly tokenizationSupport: ITokenizationSupport\n\t) {\n\t\tthis.store = new TrackingTokenizationStateStore<TState>(lineCount);\n\t}\n\n\tpublic getStartState(lineNumber: number): TState | null {\n\t\treturn this.store.getStartState(lineNumber, this.initialState);\n\t}\n\n\tpublic getFirstInvalidLine(): { lineNumber: number; startState: TState } | null {\n\t\treturn this.store.getFirstInvalidLine(this.initialState);\n\t}\n}\n\nexport class TokenizerWithStateStoreAndTextModel<TState extends IState = IState> extends TokenizerWithStateStore<TState> {\n\tconstructor(\n\t\tlineCount: number,\n\t\ttokenizationSupport: ITokenizationSupport,\n\t\tpublic readonly _textModel: ITextModel,\n\t\tpublic readonly _languageIdCodec: ILanguageIdCodec\n\t) {\n\t\tsuper(lineCount, tokenizationSupport);\n\t}\n\n\tpublic updateTokensUntilLine(builder: ContiguousMultilineTokensBuilder, lineNumber: number): void {\n\t\tconst languageId = this._textModel.getLanguageId();\n\n\t\twhile (true) {\n\t\t\tconst lineToTokenize = this.getFirstInvalidLine();\n\t\t\tif (!lineToTokenize || lineToTokenize.lineNumber > lineNumber) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst text = this._textModel.getLineContent(lineToTokenize.lineNumber);\n\n\t\t\tconst r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, text, true, lineToTokenize.startState);\n\t\t\tbuilder.add(lineToTokenize.lineNumber, r.tokens);\n\t\t\tthis.store.setEndState(lineToTokenize.lineNumber, r.endState as TState);\n\t\t}\n\t}\n\n\t/** assumes state is up to date */\n\tpublic getTokenTypeIfInsertingCharacter(position: Position, character: string): StandardTokenType {\n\t\t// TODO@hediet: use tokenizeLineWithEdit\n\t\tconst lineStartState = this.getStartState(position.lineNumber);\n\t\tif (!lineStartState) {\n\t\t\treturn StandardTokenType.Other;\n\t\t}\n\n\t\tconst languageId = this._textModel.getLanguageId();\n\t\tconst lineContent = this._textModel.getLineContent(position.lineNumber);\n\n\t\t// Create the text as if `character` was inserted\n\t\tconst text = (\n\t\t\tlineContent.substring(0, position.column - 1)\n\t\t\t+ character\n\t\t\t+ lineContent.substring(position.column - 1)\n\t\t);\n\n\t\tconst r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, text, true, lineStartState);\n\t\tconst lineTokens = new LineTokens(r.tokens, text, this._languageIdCodec);\n\t\tif (lineTokens.getCount() === 0) {\n\t\t\treturn StandardTokenType.Other;\n\t\t}\n\n\t\tconst tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n\t\treturn lineTokens.getStandardTokenType(tokenIndex);\n\t}\n\n\t/** assumes state is up to date */\n\tpublic tokenizeLineWithEdit(position: Position, length: number, newText: string): LineTokens | null {\n\t\tconst lineNumber = position.lineNumber;\n\t\tconst column = position.column;\n\n\t\tconst lineStartState = this.getStartState(lineNumber);\n\t\tif (!lineStartState) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst curLineContent = this._textModel.getLineContent(lineNumber);\n\t\tconst newLineContent = curLineContent.substring(0, column - 1)\n\t\t\t+ newText + curLineContent.substring(column - 1 + length);\n\n\t\tconst languageId = this._textModel.getLanguageIdAtPosition(lineNumber, 0);\n\t\tconst result = safeTokenize(\n\t\t\tthis._languageIdCodec,\n\t\t\tlanguageId,\n\t\t\tthis.tokenizationSupport,\n\t\t\tnewLineContent,\n\t\t\ttrue,\n\t\t\tlineStartState\n\t\t);\n\n\t\tconst lineTokens = new LineTokens(result.tokens, newLineContent, this._languageIdCodec);\n\t\treturn lineTokens;\n\t}\n\n\tpublic isCheapToTokenize(lineNumber: number): boolean {\n\t\tconst firstInvalidLineNumber = this.store.getFirstInvalidEndStateLineNumberOrMax();\n\t\tif (lineNumber < firstInvalidLineNumber) {\n\t\t\treturn true;\n\t\t}\n\t\tif (lineNumber === firstInvalidLineNumber\n\t\t\t&& this._textModel.getLineLength(lineNumber) < Constants.CHEAP_TOKENIZATION_LENGTH_LIMIT) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * The result is not cached.\n\t */\n\tpublic tokenizeHeuristically(builder: ContiguousMultilineTokensBuilder, startLineNumber: number, endLineNumber: number): { heuristicTokens: boolean } {\n\t\tif (endLineNumber <= this.store.getFirstInvalidEndStateLineNumberOrMax()) {\n\t\t\t// nothing to do\n\t\t\treturn { heuristicTokens: false };\n\t\t}\n\n\t\tif (startLineNumber <= this.store.getFirstInvalidEndStateLineNumberOrMax()) {\n\t\t\t// tokenization has reached the viewport start...\n\t\t\tthis.updateTokensUntilLine(builder, endLineNumber);\n\t\t\treturn { heuristicTokens: false };\n\t\t}\n\n\t\tlet state = this.guessStartState(startLineNumber);\n\t\tconst languageId = this._textModel.getLanguageId();\n\n\t\tfor (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n\t\t\tconst text = this._textModel.getLineContent(lineNumber);\n\t\t\tconst r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, text, true, state);\n\t\t\tbuilder.add(lineNumber, r.tokens);\n\t\t\tstate = r.endState;\n\t\t}\n\n\t\treturn { heuristicTokens: true };\n\t}\n\n\tprivate guessStartState(lineNumber: number): IState {\n\t\tlet nonWhitespaceColumn = this._textModel.getLineFirstNonWhitespaceColumn(lineNumber);\n\t\tconst likelyRelevantLines: string[] = [];\n\t\tlet initialState: IState | null = null;\n\t\tfor (let i = lineNumber - 1; nonWhitespaceColumn > 1 && i >= 1; i--) {\n\t\t\tconst newNonWhitespaceIndex = this._textModel.getLineFirstNonWhitespaceColumn(i);\n\t\t\t// Ignore lines full of whitespace\n\t\t\tif (newNonWhitespaceIndex === 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (newNonWhitespaceIndex < nonWhitespaceColumn) {\n\t\t\t\tlikelyRelevantLines.push(this._textModel.getLineContent(i));\n\t\t\t\tnonWhitespaceColumn = newNonWhitespaceIndex;\n\t\t\t\tinitialState = this.getStartState(i);\n\t\t\t\tif (initialState) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!initialState) {\n\t\t\tinitialState = this.tokenizationSupport.getInitialState();\n\t\t}\n\t\tlikelyRelevantLines.reverse();\n\n\t\tconst languageId = this._textModel.getLanguageId();\n\t\tlet state = initialState;\n\t\tfor (const line of likelyRelevantLines) {\n\t\t\tconst r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, line, false, state);\n\t\t\tstate = r.endState;\n\t\t}\n\t\treturn state;\n\t}\n}\n\n/**\n * **Invariant:**\n * If the text model is retokenized from line 1 to {@link getFirstInvalidEndStateLineNumber}() - 1,\n * then the recomputed end state for line l will be equal to {@link getEndState}(l).\n */\nexport class TrackingTokenizationStateStore<TState extends IState> {\n\tprivate readonly _tokenizationStateStore = new TokenizationStateStore<TState>();\n\tprivate readonly _invalidEndStatesLineNumbers = new RangePriorityQueueImpl();\n\n\tconstructor(private lineCount: number) {\n\t\tthis._invalidEndStatesLineNumbers.addRange(new OffsetRange(1, lineCount + 1));\n\t}\n\n\tpublic getEndState(lineNumber: number): TState | null {\n\t\treturn this._tokenizationStateStore.getEndState(lineNumber);\n\t}\n\n\t/**\n\t * @returns if the end state has changed.\n\t */\n\tpublic setEndState(lineNumber: number, state: TState): boolean {\n\t\tif (!state) {\n\t\t\tthrow new BugIndicatingError('Cannot set null/undefined state');\n\t\t}\n\n\t\tthis._invalidEndStatesLineNumbers.delete(lineNumber);\n\t\tconst r = this._tokenizationStateStore.setEndState(lineNumber, state);\n\t\tif (r && lineNumber < this.lineCount) {\n\t\t\t// because the state changed, we cannot trust the next state anymore and have to invalidate it.\n\t\t\tthis._invalidEndStatesLineNumbers.addRange(new OffsetRange(lineNumber + 1, lineNumber + 2));\n\t\t}\n\n\t\treturn r;\n\t}\n\n\tpublic acceptChange(range: LineRange, newLineCount: number): void {\n\t\tthis.lineCount += newLineCount - range.length;\n\t\tthis._tokenizationStateStore.acceptChange(range, newLineCount);\n\t\tthis._invalidEndStatesLineNumbers.addRangeAndResize(new OffsetRange(range.startLineNumber, range.endLineNumberExclusive), newLineCount);\n\t}\n\n\tpublic acceptChanges(changes: IModelContentChange[]) {\n\t\tfor (const c of changes) {\n\t\t\tconst [eolCount] = countEOL(c.text);\n\t\t\tthis.acceptChange(new LineRange(c.range.startLineNumber, c.range.endLineNumber + 1), eolCount + 1);\n\t\t}\n\t}\n\n\tpublic invalidateEndStateRange(range: LineRange): void {\n\t\tthis._invalidEndStatesLineNumbers.addRange(new OffsetRange(range.startLineNumber, range.endLineNumberExclusive));\n\t}\n\n\tpublic getFirstInvalidEndStateLineNumber(): number | null { return this._invalidEndStatesLineNumbers.min; }\n\n\tpublic getFirstInvalidEndStateLineNumberOrMax(): number {\n\t\treturn this.getFirstInvalidEndStateLineNumber() || Number.MAX_SAFE_INTEGER;\n\t}\n\n\tpublic allStatesValid(): boolean { return this._invalidEndStatesLineNumbers.min === null; }\n\n\tpublic getStartState(lineNumber: number, initialState: TState): TState | null {\n\t\tif (lineNumber === 1) { return initialState; }\n\t\treturn this.getEndState(lineNumber - 1);\n\t}\n\n\tpublic getFirstInvalidLine(initialState: TState): { lineNumber: number; startState: TState } | null {\n\t\tconst lineNumber = this.getFirstInvalidEndStateLineNumber();\n\t\tif (lineNumber === null) {\n\t\t\treturn null;\n\t\t}\n\t\tconst startState = this.getStartState(lineNumber, initialState);\n\t\tif (!startState) {\n\t\t\tthrow new BugIndicatingError('Start state must be defined');\n\t\t}\n\n\t\treturn { lineNumber, startState };\n\t}\n}\n\nexport class TokenizationStateStore<TState extends IState> {\n\tprivate readonly _lineEndStates = new FixedArray<TState | null>(null);\n\n\tpublic getEndState(lineNumber: number): TState | null {\n\t\treturn this._lineEndStates.get(lineNumber);\n\t}\n\n\tpublic setEndState(lineNumber: number, state: TState): boolean {\n\t\tconst oldState = this._lineEndStates.get(lineNumber);\n\t\tif (oldState && oldState.equals(state)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis._lineEndStates.set(lineNumber, state);\n\t\treturn true;\n\t}\n\n\tpublic acceptChange(range: LineRange, newLineCount: number): void {\n\t\tlet length = range.length;\n\t\tif (newLineCount > 0 && length > 0) {\n\t\t\t// Keep the last state, even though it is unrelated.\n\t\t\t// But if the new state happens to agree with this last state, then we know we can stop tokenizing.\n\t\t\tlength--;\n\t\t\tnewLineCount--;\n\t\t}\n\n\t\tthis._lineEndStates.replace(range.startLineNumber, length, newLineCount);\n\t}\n\n\tpublic acceptChanges(changes: IModelContentChange[]) {\n\t\tfor (const c of changes) {\n\t\t\tconst [eolCount] = countEOL(c.text);\n\t\t\tthis.acceptChange(new LineRange(c.range.startLineNumber, c.range.endLineNumber + 1), eolCount + 1);\n\t\t}\n\t}\n}\n\ninterface RangePriorityQueue {\n\tget min(): number | null;\n\tremoveMin(): number | null;\n\n\taddRange(range: OffsetRange): void;\n\n\taddRangeAndResize(range: OffsetRange, newLength: number): void;\n}\n\nexport class RangePriorityQueueImpl implements RangePriorityQueue {\n\tprivate readonly _ranges: OffsetRange[] = [];\n\n\tpublic getRanges(): OffsetRange[] {\n\t\treturn this._ranges;\n\t}\n\n\tpublic get min(): number | null {\n\t\tif (this._ranges.length === 0) {\n\t\t\treturn null;\n\t\t}\n\t\treturn this._ranges[0].start;\n\t}\n\n\tpublic removeMin(): number | null {\n\t\tif (this._ranges.length === 0) {\n\t\t\treturn null;\n\t\t}\n\t\tconst range = this._ranges[0];\n\t\tif (range.start + 1 === range.endExclusive) {\n\t\t\tthis._ranges.shift();\n\t\t} else {\n\t\t\tthis._ranges[0] = new OffsetRange(range.start + 1, range.endExclusive);\n\t\t}\n\t\treturn range.start;\n\t}\n\n\tpublic delete(value: number): void {\n\t\tconst idx = this._ranges.findIndex(r => r.contains(value));\n\t\tif (idx !== -1) {\n\t\t\tconst range = this._ranges[idx];\n\t\t\tif (range.start === value) {\n\t\t\t\tif (range.endExclusive === value + 1) {\n\t\t\t\t\tthis._ranges.splice(idx, 1);\n\t\t\t\t} else {\n\t\t\t\t\tthis._ranges[idx] = new OffsetRange(value + 1, range.endExclusive);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (range.endExclusive === value + 1) {\n\t\t\t\t\tthis._ranges[idx] = new OffsetRange(range.start, value);\n\t\t\t\t} else {\n\t\t\t\t\tthis._ranges.splice(idx, 1, new OffsetRange(range.start, value), new OffsetRange(value + 1, range.endExclusive));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic addRange(range: OffsetRange): void {\n\t\tOffsetRange.addRange(range, this._ranges);\n\t}\n\n\tpublic addRangeAndResize(range: OffsetRange, newLength: number): void {\n\t\tlet idxFirstMightBeIntersecting = 0;\n\t\twhile (!(idxFirstMightBeIntersecting >= this._ranges.length || range.start <= this._ranges[idxFirstMightBeIntersecting].endExclusive)) {\n\t\t\tidxFirstMightBeIntersecting++;\n\t\t}\n\t\tlet idxFirstIsAfter = idxFirstMightBeIntersecting;\n\t\twhile (!(idxFirstIsAfter >= this._ranges.length || range.endExclusive < this._ranges[idxFirstIsAfter].start)) {\n\t\t\tidxFirstIsAfter++;\n\t\t}\n\t\tconst delta = newLength - range.length;\n\n\t\tfor (let i = idxFirstIsAfter; i < this._ranges.length; i++) {\n\t\t\tthis._ranges[i] = this._ranges[i].delta(delta);\n\t\t}\n\n\t\tif (idxFirstMightBeIntersecting === idxFirstIsAfter) {\n\t\t\tconst newRange = new OffsetRange(range.start, range.start + newLength);\n\t\t\tif (!newRange.isEmpty) {\n\t\t\t\tthis._ranges.splice(idxFirstMightBeIntersecting, 0, newRange);\n\t\t\t}\n\t\t} else {\n\t\t\tconst start = Math.min(range.start, this._ranges[idxFirstMightBeIntersecting].start);\n\t\t\tconst endEx = Math.max(range.endExclusive, this._ranges[idxFirstIsAfter - 1].endExclusive);\n\n\t\t\tconst newRange = new OffsetRange(start, endEx + delta);\n\t\t\tif (!newRange.isEmpty) {\n\t\t\t\tthis._ranges.splice(idxFirstMightBeIntersecting, idxFirstIsAfter - idxFirstMightBeIntersecting, newRange);\n\t\t\t} else {\n\t\t\t\tthis._ranges.splice(idxFirstMightBeIntersecting, idxFirstIsAfter - idxFirstMightBeIntersecting);\n\t\t\t}\n\t\t}\n\t}\n\n\ttoString() {\n\t\treturn this._ranges.map(r => r.toString()).join(' + ');\n\t}\n}\n\n\nfunction safeTokenize(languageIdCodec: ILanguageIdCodec, languageId: string, tokenizationSupport: ITokenizationSupport | null, text: string, hasEOL: boolean, state: IState): EncodedTokenizationResult {\n\tlet r: EncodedTokenizationResult | null = null;\n\n\tif (tokenizationSupport) {\n\t\ttry {\n\t\t\tr = tokenizationSupport.tokenizeEncoded(text, hasEOL, state.clone());\n\t\t} catch (e) {\n\t\t\tonUnexpectedError(e);\n\t\t}\n\t}\n\n\tif (!r) {\n\t\tr = nullTokenizeEncoded(languageIdCodec.encodeLanguageId(languageId), state);\n\t}\n\n\tLineTokens.convertToEndOffset(r.tokens, text.length);\n\treturn r;\n}\n\nexport class DefaultBackgroundTokenizer implements IBackgroundTokenizer {\n\tprivate _isDisposed = false;\n\n\tconstructor(\n\t\tprivate readonly _tokenizerWithStateStore: TokenizerWithStateStoreAndTextModel,\n\t\tprivate readonly _backgroundTokenStore: IBackgroundTokenizationStore,\n\t) {\n\t}\n\n\tpublic dispose(): void {\n\t\tthis._isDisposed = true;\n\t}\n\n\tpublic handleChanges(): void {\n\t\tthis._beginBackgroundTokenization();\n\t}\n\n\tprivate _isScheduled = false;\n\tprivate _beginBackgroundTokenization(): void {\n\t\tif (this._isScheduled || !this._tokenizerWithStateStore._textModel.isAttachedToEditor() || !this._hasLinesToTokenize()) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._isScheduled = true;\n\t\trunWhenIdle((deadline) => {\n\t\t\tthis._isScheduled = false;\n\n\t\t\tthis._backgroundTokenizeWithDeadline(deadline);\n\t\t});\n\t}\n\n\t/**\n\t * Tokenize until the deadline occurs, but try to yield every 1-2ms.\n\t */\n\tprivate _backgroundTokenizeWithDeadline(deadline: IdleDeadline): void {\n\t\t// Read the time remaining from the `deadline` immediately because it is unclear\n\t\t// if the `deadline` object will be valid after execution leaves this function.\n\t\tconst endTime = Date.now() + deadline.timeRemaining();\n\n\t\tconst execute = () => {\n\t\t\tif (this._isDisposed || !this._tokenizerWithStateStore._textModel.isAttachedToEditor() || !this._hasLinesToTokenize()) {\n\t\t\t\t// disposed in the meantime or detached or finished\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._backgroundTokenizeForAtLeast1ms();\n\n\t\t\tif (Date.now() < endTime) {\n\t\t\t\t// There is still time before reaching the deadline, so yield to the browser and then\n\t\t\t\t// continue execution\n\t\t\t\tsetTimeout0(execute);\n\t\t\t} else {\n\t\t\t\t// The deadline has been reached, so schedule a new idle callback if necessary\n\t\t\t\tthis._beginBackgroundTokenization();\n\t\t\t}\n\t\t};\n\t\texecute();\n\t}\n\n\t/**\n\t * Tokenize for at least 1ms.\n\t */\n\tprivate _backgroundTokenizeForAtLeast1ms(): void {\n\t\tconst lineCount = this._tokenizerWithStateStore._textModel.getLineCount();\n\t\tconst builder = new ContiguousMultilineTokensBuilder();\n\t\tconst sw = StopWatch.create(false);\n\n\t\tdo {\n\t\t\tif (sw.elapsed() > 1) {\n\t\t\t\t// the comparison is intentionally > 1 and not >= 1 to ensure that\n\t\t\t\t// a full millisecond has elapsed, given how microseconds are rounded\n\t\t\t\t// to milliseconds\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst tokenizedLineNumber = this._tokenizeOneInvalidLine(builder);\n\n\t\t\tif (tokenizedLineNumber >= lineCount) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (this._hasLinesToTokenize());\n\n\t\tthis._backgroundTokenStore.setTokens(builder.finalize());\n\t\tthis.checkFinished();\n\t}\n\n\tprivate _hasLinesToTokenize(): boolean {\n\t\tif (!this._tokenizerWithStateStore) {\n\t\t\treturn false;\n\t\t}\n\t\treturn !this._tokenizerWithStateStore.store.allStatesValid();\n\t}\n\n\tprivate _tokenizeOneInvalidLine(builder: ContiguousMultilineTokensBuilder): number {\n\t\tconst firstInvalidLine = this._tokenizerWithStateStore?.getFirstInvalidLine();\n\t\tif (!firstInvalidLine) {\n\t\t\treturn this._tokenizerWithStateStore._textModel.getLineCount() + 1;\n\t\t}\n\t\tthis._tokenizerWithStateStore.updateTokensUntilLine(builder, firstInvalidLine.lineNumber);\n\t\treturn firstInvalidLine.lineNumber;\n\t}\n\n\tpublic checkFinished(): void {\n\t\tif (this._isDisposed) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._tokenizerWithStateStore.store.allStatesValid()) {\n\t\t\tthis._backgroundTokenStore.backgroundTokenizationFinished();\n\t\t}\n\t}\n\n\tpublic requestTokens(startLineNumber: number, endLineNumberExclusive: number): void {\n\t\tthis._tokenizerWithStateStore.store.invalidateEndStateRange(new LineRange(startLineNumber, endLineNumberExclusive));\n\t}\n}\n"]}