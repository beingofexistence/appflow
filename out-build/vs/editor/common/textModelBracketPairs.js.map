{"version":3,"sources":["file:///workspace/appflow/src/vs/editor/common/textModelBracketPairs.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;IAsEhG,MAAa,GAAG;QACf,YACiB,KAAU;QAC1B,oBAAoB;QACJ,YAAoB,EACpB,8BAAsC,EACtC,SAAkB;YAJlB,UAAK,GAAL,KAAK,CAAK;YAEV,iBAAY,GAAZ,YAAY,CAAQ;YACpB,mCAA8B,GAA9B,8BAA8B,CAAQ;YACtC,cAAS,GAAT,SAAS,CAAS;QAC/B,CAAC;KACL;IARD,kBAQC;IAED,MAAa,GAAG;QACf,YACiB,KAAU,EACV,mBAAwB,EACxB,mBAAsC;QACtD,cAAc;QACE,YAAoB,EACpB,8BAAsC,EACrC,CAAoB;YANrB,UAAK,GAAL,KAAK,CAAK;YACV,wBAAmB,GAAnB,mBAAmB,CAAK;YACxB,wBAAmB,GAAnB,mBAAmB,CAAmB;YAEtC,iBAAY,GAAZ,YAAY,CAAQ;YACpB,mCAA8B,GAA9B,8BAA8B,CAAQ;YACrC,MAAC,GAAD,CAAC,CAAmB;QAGtC,CAAC;QAED,IAAW,kBAAkB;YAC5B,OAAO,IAAI,CAAC,CAAC,CAAe,cAAc,CAAC,WAAkB,CAAgB;QAC9E,CAAC;QAED,IAAW,kBAAkB;YAC5B,OAAO,IAAI,CAAC,CAAC,CAAe,cAAc,EAAE,WAA6C,CAAC;QAC3F,CAAC;KACD;IApBD,kBAoBC;IAED,MAAa,GAAkC,SAAQ,GAAG;QACzD,YACC,KAAU,EACV,mBAAwB,EACxB,mBAAsC;QACtC;;UAEE;QACF,YAAoB,EACpB,8BAAsC,EACtC,eAAoB;QACpB;;UAEE;QACc,2BAAmC;YAEnD,KAAK,CAAC,KAAK,EAAE,mBAAmB,EAAE,mBAAmB,EAAE,YAAY,EAAE,8BAA8B,EAAE,eAAe,CAAC,CAAC;YAFtG,gCAA2B,GAA3B,2BAA2B,CAAQ;QAGpD,CAAC;KACD;IAlBD,kBAkBC","file":"textModelBracketPairs.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CallbackIterable } from 'vs/base/common/arrays';\nimport { Event } from 'vs/base/common/event';\nimport { IPosition } from 'vs/editor/common/core/position';\nimport { IRange, Range } from 'vs/editor/common/core/range';\nimport { ClosingBracketKind, OpeningBracketKind } from 'vs/editor/common/languages/supports/languageBracketsConfiguration';\nimport { PairAstNode } from 'vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/ast';\n\nexport interface IBracketPairsTextModelPart {\n\t/**\n\t * Is fired when bracket pairs change, either due to a text or a settings change.\n\t*/\n\tonDidChange: Event<void>;\n\n\t/**\n\t * Gets all bracket pairs that intersect the given position.\n\t * The result is sorted by the start position.\n\t */\n\tgetBracketPairsInRange(range: IRange): CallbackIterable<BracketPairInfo>;\n\n\t/**\n\t * Gets all bracket pairs that intersect the given position.\n\t * The result is sorted by the start position.\n\t */\n\tgetBracketPairsInRangeWithMinIndentation(range: IRange): CallbackIterable<BracketPairWithMinIndentationInfo>;\n\n\tgetBracketsInRange(range: IRange, onlyColorizedBrackets?: boolean): CallbackIterable<BracketInfo>;\n\n\t/**\n\t * Find the matching bracket of `request` up, counting brackets.\n\t * @param request The bracket we're searching for\n\t * @param position The position at which to start the search.\n\t * @return The range of the matching bracket, or null if the bracket match was not found.\n\t */\n\tfindMatchingBracketUp(bracket: string, position: IPosition, maxDuration?: number): Range | null;\n\n\t/**\n\t * Find the first bracket in the model before `position`.\n\t * @param position The position at which to start the search.\n\t * @return The info for the first bracket before `position`, or null if there are no more brackets before `positions`.\n\t */\n\tfindPrevBracket(position: IPosition): IFoundBracket | null;\n\n\t/**\n\t * Find the first bracket in the model after `position`.\n\t * @param position The position at which to start the search.\n\t * @return The info for the first bracket after `position`, or null if there are no more brackets after `positions`.\n\t */\n\tfindNextBracket(position: IPosition): IFoundBracket | null;\n\n\t/**\n\t * Find the enclosing brackets that contain `position`.\n\t * @param position The position at which to start the search.\n\t */\n\tfindEnclosingBrackets(position: IPosition, maxDuration?: number): [Range, Range] | null;\n\n\t/**\n\t * Given a `position`, if the position is on top or near a bracket,\n\t * find the matching bracket of that bracket and return the ranges of both brackets.\n\t * @param position The position at which to look for a bracket.\n\t */\n\tmatchBracket(position: IPosition, maxDuration?: number): [Range, Range] | null;\n}\n\nexport interface IFoundBracket {\n\trange: Range;\n\tbracketInfo: OpeningBracketKind | ClosingBracketKind;\n}\n\nexport class BracketInfo {\n\tconstructor(\n\t\tpublic readonly range: Range,\n\t\t/** 0-based level */\n\t\tpublic readonly nestingLevel: number,\n\t\tpublic readonly nestingLevelOfEqualBracketType: number,\n\t\tpublic readonly isInvalid: boolean,\n\t) { }\n}\n\nexport class BracketPairInfo {\n\tconstructor(\n\t\tpublic readonly range: Range,\n\t\tpublic readonly openingBracketRange: Range,\n\t\tpublic readonly closingBracketRange: Range | undefined,\n\t\t/** 0-based */\n\t\tpublic readonly nestingLevel: number,\n\t\tpublic readonly nestingLevelOfEqualBracketType: number,\n\t\tprivate readonly bracketPairNode: PairAstNode,\n\n\t) {\n\t}\n\n\tpublic get openingBracketInfo(): OpeningBracketKind {\n\t\treturn this.bracketPairNode.openingBracket.bracketInfo as OpeningBracketKind;\n\t}\n\n\tpublic get closingBracketInfo(): ClosingBracketKind | undefined {\n\t\treturn this.bracketPairNode.closingBracket?.bracketInfo as ClosingBracketKind | undefined;\n\t}\n}\n\nexport class BracketPairWithMinIndentationInfo extends BracketPairInfo {\n\tconstructor(\n\t\trange: Range,\n\t\topeningBracketRange: Range,\n\t\tclosingBracketRange: Range | undefined,\n\t\t/**\n\t\t * 0-based\n\t\t*/\n\t\tnestingLevel: number,\n\t\tnestingLevelOfEqualBracketType: number,\n\t\tbracketPairNode: PairAstNode,\n\t\t/**\n\t\t * -1 if not requested, otherwise the size of the minimum indentation in the bracket pair in terms of visible columns.\n\t\t*/\n\t\tpublic readonly minVisibleColumnIndentation: number,\n\t) {\n\t\tsuper(range, openingBracketRange, closingBracketRange, nestingLevel, nestingLevelOfEqualBracketType, bracketPairNode);\n\t}\n}\n"]}