{"version":3,"sources":["file:///workspace/appflow/src/vs/editor/common/tokens/sparseTokensStore.ts"],"names":[],"mappings":"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","file":"sparseTokensStore.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as arrays from 'vs/base/common/arrays';\nimport { IRange, Range } from 'vs/editor/common/core/range';\nimport { LineTokens } from 'vs/editor/common/tokens/lineTokens';\nimport { SparseMultilineTokens } from 'vs/editor/common/tokens/sparseMultilineTokens';\nimport { ILanguageIdCodec } from 'vs/editor/common/languages';\nimport { MetadataConsts } from 'vs/editor/common/encodedTokenAttributes';\n\n/**\n * Represents sparse tokens in a text model.\n */\nexport class SparseTokensStore {\n\n\tprivate _pieces: SparseMultilineTokens[];\n\tprivate _isComplete: boolean;\n\tprivate readonly _languageIdCodec: ILanguageIdCodec;\n\n\tconstructor(languageIdCodec: ILanguageIdCodec) {\n\t\tthis._pieces = [];\n\t\tthis._isComplete = false;\n\t\tthis._languageIdCodec = languageIdCodec;\n\t}\n\n\tpublic flush(): void {\n\t\tthis._pieces = [];\n\t\tthis._isComplete = false;\n\t}\n\n\tpublic isEmpty(): boolean {\n\t\treturn (this._pieces.length === 0);\n\t}\n\n\tpublic set(pieces: SparseMultilineTokens[] | null, isComplete: boolean): void {\n\t\tthis._pieces = pieces || [];\n\t\tthis._isComplete = isComplete;\n\t}\n\n\tpublic setPartial(_range: Range, pieces: SparseMultilineTokens[]): Range {\n\t\t// console.log(`setPartial ${_range} ${pieces.map(p => p.toString()).join(', ')}`);\n\n\t\tlet range = _range;\n\t\tif (pieces.length > 0) {\n\t\t\tconst _firstRange = pieces[0].getRange();\n\t\t\tconst _lastRange = pieces[pieces.length - 1].getRange();\n\t\t\tif (!_firstRange || !_lastRange) {\n\t\t\t\treturn _range;\n\t\t\t}\n\t\t\trange = _range.plusRange(_firstRange).plusRange(_lastRange);\n\t\t}\n\n\t\tlet insertPosition: { index: number } | null = null;\n\t\tfor (let i = 0, len = this._pieces.length; i < len; i++) {\n\t\t\tconst piece = this._pieces[i];\n\t\t\tif (piece.endLineNumber < range.startLineNumber) {\n\t\t\t\t// this piece is before the range\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (piece.startLineNumber > range.endLineNumber) {\n\t\t\t\t// this piece is after the range, so mark the spot before this piece\n\t\t\t\t// as a good insertion position and stop looping\n\t\t\t\tinsertPosition = insertPosition || { index: i };\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// this piece might intersect with the range\n\t\t\tpiece.removeTokens(range);\n\n\t\t\tif (piece.isEmpty()) {\n\t\t\t\t// remove the piece if it became empty\n\t\t\t\tthis._pieces.splice(i, 1);\n\t\t\t\ti--;\n\t\t\t\tlen--;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (piece.endLineNumber < range.startLineNumber) {\n\t\t\t\t// after removal, this piece is before the range\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (piece.startLineNumber > range.endLineNumber) {\n\t\t\t\t// after removal, this piece is after the range\n\t\t\t\tinsertPosition = insertPosition || { index: i };\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// after removal, this piece contains the range\n\t\t\tconst [a, b] = piece.split(range);\n\t\t\tif (a.isEmpty()) {\n\t\t\t\t// this piece is actually after the range\n\t\t\t\tinsertPosition = insertPosition || { index: i };\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (b.isEmpty()) {\n\t\t\t\t// this piece is actually before the range\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tthis._pieces.splice(i, 1, a, b);\n\t\t\ti++;\n\t\t\tlen++;\n\n\t\t\tinsertPosition = insertPosition || { index: i };\n\t\t}\n\n\t\tinsertPosition = insertPosition || { index: this._pieces.length };\n\n\t\tif (pieces.length > 0) {\n\t\t\tthis._pieces = arrays.arrayInsert(this._pieces, insertPosition.index, pieces);\n\t\t}\n\n\t\t// console.log(`I HAVE ${this._pieces.length} pieces`);\n\t\t// console.log(`${this._pieces.map(p => p.toString()).join('\\n')}`);\n\n\t\treturn range;\n\t}\n\n\tpublic isComplete(): boolean {\n\t\treturn this._isComplete;\n\t}\n\n\tpublic addSparseTokens(lineNumber: number, aTokens: LineTokens): LineTokens {\n\t\tif (aTokens.getLineContent().length === 0) {\n\t\t\t// Don't do anything for empty lines\n\t\t\treturn aTokens;\n\t\t}\n\n\t\tconst pieces = this._pieces;\n\n\t\tif (pieces.length === 0) {\n\t\t\treturn aTokens;\n\t\t}\n\n\t\tconst pieceIndex = SparseTokensStore._findFirstPieceWithLine(pieces, lineNumber);\n\t\tconst bTokens = pieces[pieceIndex].getLineTokens(lineNumber);\n\n\t\tif (!bTokens) {\n\t\t\treturn aTokens;\n\t\t}\n\n\t\tconst aLen = aTokens.getCount();\n\t\tconst bLen = bTokens.getCount();\n\n\t\tlet aIndex = 0;\n\t\tconst result: number[] = [];\n\t\tlet resultLen = 0;\n\t\tlet lastEndOffset = 0;\n\n\t\tconst emitToken = (endOffset: number, metadata: number) => {\n\t\t\tif (endOffset === lastEndOffset) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlastEndOffset = endOffset;\n\t\t\tresult[resultLen++] = endOffset;\n\t\t\tresult[resultLen++] = metadata;\n\t\t};\n\n\t\tfor (let bIndex = 0; bIndex < bLen; bIndex++) {\n\t\t\tconst bStartCharacter = bTokens.getStartCharacter(bIndex);\n\t\t\tconst bEndCharacter = bTokens.getEndCharacter(bIndex);\n\t\t\tconst bMetadata = bTokens.getMetadata(bIndex);\n\n\t\t\tconst bMask = (\n\t\t\t\t((bMetadata & MetadataConsts.SEMANTIC_USE_ITALIC) ? MetadataConsts.ITALIC_MASK : 0)\n\t\t\t\t| ((bMetadata & MetadataConsts.SEMANTIC_USE_BOLD) ? MetadataConsts.BOLD_MASK : 0)\n\t\t\t\t| ((bMetadata & MetadataConsts.SEMANTIC_USE_UNDERLINE) ? MetadataConsts.UNDERLINE_MASK : 0)\n\t\t\t\t| ((bMetadata & MetadataConsts.SEMANTIC_USE_STRIKETHROUGH) ? MetadataConsts.STRIKETHROUGH_MASK : 0)\n\t\t\t\t| ((bMetadata & MetadataConsts.SEMANTIC_USE_FOREGROUND) ? MetadataConsts.FOREGROUND_MASK : 0)\n\t\t\t\t| ((bMetadata & MetadataConsts.SEMANTIC_USE_BACKGROUND) ? MetadataConsts.BACKGROUND_MASK : 0)\n\t\t\t) >>> 0;\n\t\t\tconst aMask = (~bMask) >>> 0;\n\n\t\t\t// push any token from `a` that is before `b`\n\t\t\twhile (aIndex < aLen && aTokens.getEndOffset(aIndex) <= bStartCharacter) {\n\t\t\t\temitToken(aTokens.getEndOffset(aIndex), aTokens.getMetadata(aIndex));\n\t\t\t\taIndex++;\n\t\t\t}\n\n\t\t\t// push the token from `a` if it intersects the token from `b`\n\t\t\tif (aIndex < aLen && aTokens.getStartOffset(aIndex) < bStartCharacter) {\n\t\t\t\temitToken(bStartCharacter, aTokens.getMetadata(aIndex));\n\t\t\t}\n\n\t\t\t// skip any tokens from `a` that are contained inside `b`\n\t\t\twhile (aIndex < aLen && aTokens.getEndOffset(aIndex) < bEndCharacter) {\n\t\t\t\temitToken(aTokens.getEndOffset(aIndex), (aTokens.getMetadata(aIndex) & aMask) | (bMetadata & bMask));\n\t\t\t\taIndex++;\n\t\t\t}\n\n\t\t\tif (aIndex < aLen) {\n\t\t\t\temitToken(bEndCharacter, (aTokens.getMetadata(aIndex) & aMask) | (bMetadata & bMask));\n\t\t\t\tif (aTokens.getEndOffset(aIndex) === bEndCharacter) {\n\t\t\t\t\t// `a` ends exactly at the same spot as `b`!\n\t\t\t\t\taIndex++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst aMergeIndex = Math.min(Math.max(0, aIndex - 1), aLen - 1);\n\n\t\t\t\t// push the token from `b`\n\t\t\t\temitToken(bEndCharacter, (aTokens.getMetadata(aMergeIndex) & aMask) | (bMetadata & bMask));\n\t\t\t}\n\t\t}\n\n\t\t// push the remaining tokens from `a`\n\t\twhile (aIndex < aLen) {\n\t\t\temitToken(aTokens.getEndOffset(aIndex), aTokens.getMetadata(aIndex));\n\t\t\taIndex++;\n\t\t}\n\n\t\treturn new LineTokens(new Uint32Array(result), aTokens.getLineContent(), this._languageIdCodec);\n\t}\n\n\tprivate static _findFirstPieceWithLine(pieces: SparseMultilineTokens[], lineNumber: number): number {\n\t\tlet low = 0;\n\t\tlet high = pieces.length - 1;\n\n\t\twhile (low < high) {\n\t\t\tlet mid = low + Math.floor((high - low) / 2);\n\n\t\t\tif (pieces[mid].endLineNumber < lineNumber) {\n\t\t\t\tlow = mid + 1;\n\t\t\t} else if (pieces[mid].startLineNumber > lineNumber) {\n\t\t\t\thigh = mid - 1;\n\t\t\t} else {\n\t\t\t\twhile (mid > low && pieces[mid - 1].startLineNumber <= lineNumber && lineNumber <= pieces[mid - 1].endLineNumber) {\n\t\t\t\t\tmid--;\n\t\t\t\t}\n\t\t\t\treturn mid;\n\t\t\t}\n\t\t}\n\n\t\treturn low;\n\t}\n\n\tpublic acceptEdit(range: IRange, eolCount: number, firstLineLength: number, lastLineLength: number, firstCharCode: number): void {\n\t\tfor (const piece of this._pieces) {\n\t\t\tpiece.acceptEdit(range, eolCount, firstLineLength, lastLineLength, firstCharCode);\n\t\t}\n\t}\n}\n"]}