{"version":3,"sources":["file:///workspace/appflow/src/vs/editor/common/tokens/contiguousTokensStore.ts"],"names":[],"mappings":"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","file":"contiguousTokensStore.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as arrays from 'vs/base/common/arrays';\nimport { Position } from 'vs/editor/common/core/position';\nimport { IRange } from 'vs/editor/common/core/range';\nimport { ContiguousTokensEditing, EMPTY_LINE_TOKENS, toUint32Array } from 'vs/editor/common/tokens/contiguousTokensEditing';\nimport { LineTokens } from 'vs/editor/common/tokens/lineTokens';\nimport { ILanguageIdCodec } from 'vs/editor/common/languages';\nimport { LanguageId, FontStyle, ColorId, StandardTokenType, MetadataConsts, TokenMetadata } from 'vs/editor/common/encodedTokenAttributes';\nimport { ITextModel } from 'vs/editor/common/model';\nimport { ContiguousMultilineTokens } from 'vs/editor/common/tokens/contiguousMultilineTokens';\n\n/**\n * Represents contiguous tokens in a text model.\n */\nexport class ContiguousTokensStore {\n\tprivate _lineTokens: (Uint32Array | ArrayBuffer | null)[];\n\tprivate _len: number;\n\tprivate readonly _languageIdCodec: ILanguageIdCodec;\n\n\tconstructor(languageIdCodec: ILanguageIdCodec) {\n\t\tthis._lineTokens = [];\n\t\tthis._len = 0;\n\t\tthis._languageIdCodec = languageIdCodec;\n\t}\n\n\tpublic flush(): void {\n\t\tthis._lineTokens = [];\n\t\tthis._len = 0;\n\t}\n\n\tget hasTokens(): boolean {\n\t\treturn this._lineTokens.length > 0;\n\t}\n\n\tpublic getTokens(topLevelLanguageId: string, lineIndex: number, lineText: string): LineTokens {\n\t\tlet rawLineTokens: Uint32Array | ArrayBuffer | null = null;\n\t\tif (lineIndex < this._len) {\n\t\t\trawLineTokens = this._lineTokens[lineIndex];\n\t\t}\n\n\t\tif (rawLineTokens !== null && rawLineTokens !== EMPTY_LINE_TOKENS) {\n\t\t\treturn new LineTokens(toUint32Array(rawLineTokens), lineText, this._languageIdCodec);\n\t\t}\n\n\t\tconst lineTokens = new Uint32Array(2);\n\t\tlineTokens[0] = lineText.length;\n\t\tlineTokens[1] = getDefaultMetadata(this._languageIdCodec.encodeLanguageId(topLevelLanguageId));\n\t\treturn new LineTokens(lineTokens, lineText, this._languageIdCodec);\n\t}\n\n\tprivate static _massageTokens(topLevelLanguageId: LanguageId, lineTextLength: number, _tokens: Uint32Array | ArrayBuffer | null): Uint32Array | ArrayBuffer {\n\n\t\tconst tokens = _tokens ? toUint32Array(_tokens) : null;\n\n\t\tif (lineTextLength === 0) {\n\t\t\tlet hasDifferentLanguageId = false;\n\t\t\tif (tokens && tokens.length > 1) {\n\t\t\t\thasDifferentLanguageId = (TokenMetadata.getLanguageId(tokens[1]) !== topLevelLanguageId);\n\t\t\t}\n\n\t\t\tif (!hasDifferentLanguageId) {\n\t\t\t\treturn EMPTY_LINE_TOKENS;\n\t\t\t}\n\t\t}\n\n\t\tif (!tokens || tokens.length === 0) {\n\t\t\tconst tokens = new Uint32Array(2);\n\t\t\ttokens[0] = lineTextLength;\n\t\t\ttokens[1] = getDefaultMetadata(topLevelLanguageId);\n\t\t\treturn tokens.buffer;\n\t\t}\n\n\t\t// Ensure the last token covers the end of the text\n\t\ttokens[tokens.length - 2] = lineTextLength;\n\n\t\tif (tokens.byteOffset === 0 && tokens.byteLength === tokens.buffer.byteLength) {\n\t\t\t// Store directly the ArrayBuffer pointer to save an object\n\t\t\treturn tokens.buffer;\n\t\t}\n\t\treturn tokens;\n\t}\n\n\tprivate _ensureLine(lineIndex: number): void {\n\t\twhile (lineIndex >= this._len) {\n\t\t\tthis._lineTokens[this._len] = null;\n\t\t\tthis._len++;\n\t\t}\n\t}\n\n\tprivate _deleteLines(start: number, deleteCount: number): void {\n\t\tif (deleteCount === 0) {\n\t\t\treturn;\n\t\t}\n\t\tif (start + deleteCount > this._len) {\n\t\t\tdeleteCount = this._len - start;\n\t\t}\n\t\tthis._lineTokens.splice(start, deleteCount);\n\t\tthis._len -= deleteCount;\n\t}\n\n\tprivate _insertLines(insertIndex: number, insertCount: number): void {\n\t\tif (insertCount === 0) {\n\t\t\treturn;\n\t\t}\n\t\tconst lineTokens: (Uint32Array | ArrayBuffer | null)[] = [];\n\t\tfor (let i = 0; i < insertCount; i++) {\n\t\t\tlineTokens[i] = null;\n\t\t}\n\t\tthis._lineTokens = arrays.arrayInsert(this._lineTokens, insertIndex, lineTokens);\n\t\tthis._len += insertCount;\n\t}\n\n\tpublic setTokens(topLevelLanguageId: string, lineIndex: number, lineTextLength: number, _tokens: Uint32Array | ArrayBuffer | null, checkEquality: boolean): boolean {\n\t\tconst tokens = ContiguousTokensStore._massageTokens(this._languageIdCodec.encodeLanguageId(topLevelLanguageId), lineTextLength, _tokens);\n\t\tthis._ensureLine(lineIndex);\n\t\tconst oldTokens = this._lineTokens[lineIndex];\n\t\tthis._lineTokens[lineIndex] = tokens;\n\n\t\tif (checkEquality) {\n\t\t\treturn !ContiguousTokensStore._equals(oldTokens, tokens);\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate static _equals(_a: Uint32Array | ArrayBuffer | null, _b: Uint32Array | ArrayBuffer | null) {\n\t\tif (!_a || !_b) {\n\t\t\treturn !_a && !_b;\n\t\t}\n\n\t\tconst a = toUint32Array(_a);\n\t\tconst b = toUint32Array(_b);\n\n\t\tif (a.length !== b.length) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (let i = 0, len = a.length; i < len; i++) {\n\t\t\tif (a[i] !== b[i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t//#region Editing\n\n\tpublic acceptEdit(range: IRange, eolCount: number, firstLineLength: number): void {\n\t\tthis._acceptDeleteRange(range);\n\t\tthis._acceptInsertText(new Position(range.startLineNumber, range.startColumn), eolCount, firstLineLength);\n\t}\n\n\tprivate _acceptDeleteRange(range: IRange): void {\n\n\t\tconst firstLineIndex = range.startLineNumber - 1;\n\t\tif (firstLineIndex >= this._len) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (range.startLineNumber === range.endLineNumber) {\n\t\t\tif (range.startColumn === range.endColumn) {\n\t\t\t\t// Nothing to delete\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._lineTokens[firstLineIndex] = ContiguousTokensEditing.delete(this._lineTokens[firstLineIndex], range.startColumn - 1, range.endColumn - 1);\n\t\t\treturn;\n\t\t}\n\n\t\tthis._lineTokens[firstLineIndex] = ContiguousTokensEditing.deleteEnding(this._lineTokens[firstLineIndex], range.startColumn - 1);\n\n\t\tconst lastLineIndex = range.endLineNumber - 1;\n\t\tlet lastLineTokens: Uint32Array | ArrayBuffer | null = null;\n\t\tif (lastLineIndex < this._len) {\n\t\t\tlastLineTokens = ContiguousTokensEditing.deleteBeginning(this._lineTokens[lastLineIndex], range.endColumn - 1);\n\t\t}\n\n\t\t// Take remaining text on last line and append it to remaining text on first line\n\t\tthis._lineTokens[firstLineIndex] = ContiguousTokensEditing.append(this._lineTokens[firstLineIndex], lastLineTokens);\n\n\t\t// Delete middle lines\n\t\tthis._deleteLines(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n\t}\n\n\tprivate _acceptInsertText(position: Position, eolCount: number, firstLineLength: number): void {\n\n\t\tif (eolCount === 0 && firstLineLength === 0) {\n\t\t\t// Nothing to insert\n\t\t\treturn;\n\t\t}\n\n\t\tconst lineIndex = position.lineNumber - 1;\n\t\tif (lineIndex >= this._len) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (eolCount === 0) {\n\t\t\t// Inserting text on one line\n\t\t\tthis._lineTokens[lineIndex] = ContiguousTokensEditing.insert(this._lineTokens[lineIndex], position.column - 1, firstLineLength);\n\t\t\treturn;\n\t\t}\n\n\t\tthis._lineTokens[lineIndex] = ContiguousTokensEditing.deleteEnding(this._lineTokens[lineIndex], position.column - 1);\n\t\tthis._lineTokens[lineIndex] = ContiguousTokensEditing.insert(this._lineTokens[lineIndex], position.column - 1, firstLineLength);\n\n\t\tthis._insertLines(position.lineNumber, eolCount);\n\t}\n\n\t//#endregion\n\n\tpublic setMultilineTokens(tokens: ContiguousMultilineTokens[], textModel: ITextModel): { changes: { fromLineNumber: number; toLineNumber: number }[] } {\n\t\tif (tokens.length === 0) {\n\t\t\treturn { changes: [] };\n\t\t}\n\n\t\tconst ranges: { fromLineNumber: number; toLineNumber: number }[] = [];\n\n\t\tfor (let i = 0, len = tokens.length; i < len; i++) {\n\t\t\tconst element = tokens[i];\n\t\t\tlet minChangedLineNumber = 0;\n\t\t\tlet maxChangedLineNumber = 0;\n\t\t\tlet hasChange = false;\n\t\t\tfor (let lineNumber = element.startLineNumber; lineNumber <= element.endLineNumber; lineNumber++) {\n\t\t\t\tif (hasChange) {\n\t\t\t\t\tthis.setTokens(textModel.getLanguageId(), lineNumber - 1, textModel.getLineLength(lineNumber), element.getLineTokens(lineNumber), false);\n\t\t\t\t\tmaxChangedLineNumber = lineNumber;\n\t\t\t\t} else {\n\t\t\t\t\tconst lineHasChange = this.setTokens(textModel.getLanguageId(), lineNumber - 1, textModel.getLineLength(lineNumber), element.getLineTokens(lineNumber), true);\n\t\t\t\t\tif (lineHasChange) {\n\t\t\t\t\t\thasChange = true;\n\t\t\t\t\t\tminChangedLineNumber = lineNumber;\n\t\t\t\t\t\tmaxChangedLineNumber = lineNumber;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hasChange) {\n\t\t\t\tranges.push({ fromLineNumber: minChangedLineNumber, toLineNumber: maxChangedLineNumber, });\n\t\t\t}\n\t\t}\n\n\t\treturn { changes: ranges };\n\t}\n}\n\nfunction getDefaultMetadata(topLevelLanguageId: LanguageId): number {\n\treturn (\n\t\t(topLevelLanguageId << MetadataConsts.LANGUAGEID_OFFSET)\n\t\t| (StandardTokenType.Other << MetadataConsts.TOKEN_TYPE_OFFSET)\n\t\t| (FontStyle.None << MetadataConsts.FONT_STYLE_OFFSET)\n\t\t| (ColorId.DefaultForeground << MetadataConsts.FOREGROUND_OFFSET)\n\t\t| (ColorId.DefaultBackground << MetadataConsts.BACKGROUND_OFFSET)\n\t\t// If there is no grammar, we just take a guess and try to match brackets.\n\t\t| (MetadataConsts.BALANCED_BRACKETS_MASK)\n\t) >>> 0;\n}\n"]}