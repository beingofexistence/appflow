{"version":3,"sources":["file:///workspace/appflow/src/vs/editor/common/languages/supports/richEditBrackets.ts"],"names":[],"mappings":"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","file":"richEditBrackets.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as strings from 'vs/base/common/strings';\nimport * as stringBuilder from 'vs/editor/common/core/stringBuilder';\nimport { Range } from 'vs/editor/common/core/range';\nimport { CharacterPair } from 'vs/editor/common/languages/languageConfiguration';\n\ninterface InternalBracket {\n\topen: string[];\n\tclose: string[];\n}\n\n/**\n * Represents a grouping of colliding bracket pairs.\n *\n * Most of the times this contains a single bracket pair,\n * but sometimes this contains multiple bracket pairs in cases\n * where the same string appears as a closing bracket for multiple\n * bracket pairs, or the same string appears an opening bracket for\n * multiple bracket pairs.\n *\n * e.g. of a group containing a single pair:\n *   open: ['{'], close: ['}']\n *\n * e.g. of a group containing multiple pairs:\n *   open: ['if', 'for'], close: ['end', 'end']\n */\nexport class RichEditBracket {\n\t_richEditBracketBrand: void = undefined;\n\n\treadonly languageId: string;\n\t/**\n\t * A 0-based consecutive unique identifier for this bracket pair.\n\t * If a language has 5 bracket pairs, out of which 2 are grouped together,\n\t * it is expected that the `index` goes from 0 to 4.\n\t */\n\treadonly index: number;\n\t/**\n\t * The open sequence for each bracket pair contained in this group.\n\t *\n\t * The open sequence at a specific index corresponds to the\n\t * closing sequence at the same index.\n\t *\n\t * [ open[i], closed[i] ] represent a bracket pair.\n\t */\n\treadonly open: string[];\n\t/**\n\t * The close sequence for each bracket pair contained in this group.\n\t *\n\t * The close sequence at a specific index corresponds to the\n\t * opening sequence at the same index.\n\t *\n\t * [ open[i], closed[i] ] represent a bracket pair.\n\t */\n\treadonly close: string[];\n\t/**\n\t * A regular expression that is useful to search for this bracket pair group in a string.\n\t *\n\t * This regular expression is built in a way that it is aware of the other bracket\n\t * pairs defined for the language, so it might match brackets from other groups.\n\t *\n\t * See the fine details in `getRegexForBracketPair`.\n\t */\n\treadonly forwardRegex: RegExp;\n\t/**\n\t * A regular expression that is useful to search for this bracket pair group in a string backwards.\n\t *\n\t * This regular expression is built in a way that it is aware of the other bracket\n\t * pairs defined for the language, so it might match brackets from other groups.\n\t *\n\t * See the fine defails in `getReversedRegexForBracketPair`.\n\t */\n\treadonly reversedRegex: RegExp;\n\tprivate readonly _openSet: Set<string>;\n\tprivate readonly _closeSet: Set<string>;\n\n\tconstructor(languageId: string, index: number, open: string[], close: string[], forwardRegex: RegExp, reversedRegex: RegExp) {\n\t\tthis.languageId = languageId;\n\t\tthis.index = index;\n\t\tthis.open = open;\n\t\tthis.close = close;\n\t\tthis.forwardRegex = forwardRegex;\n\t\tthis.reversedRegex = reversedRegex;\n\t\tthis._openSet = RichEditBracket._toSet(this.open);\n\t\tthis._closeSet = RichEditBracket._toSet(this.close);\n\t}\n\n\t/**\n\t * Check if the provided `text` is an open bracket in this group.\n\t */\n\tpublic isOpen(text: string) {\n\t\treturn this._openSet.has(text);\n\t}\n\n\t/**\n\t * Check if the provided `text` is a close bracket in this group.\n\t */\n\tpublic isClose(text: string) {\n\t\treturn this._closeSet.has(text);\n\t}\n\n\tprivate static _toSet(arr: string[]): Set<string> {\n\t\tconst result = new Set<string>();\n\t\tfor (const element of arr) {\n\t\t\tresult.add(element);\n\t\t}\n\t\treturn result;\n\t}\n}\n\n/**\n * Groups together brackets that have equal open or close sequences.\n *\n * For example, if the following brackets are defined:\n *   ['IF','END']\n *   ['for','end']\n *   ['{','}']\n *\n * Then the grouped brackets would be:\n *   { open: ['if', 'for'], close: ['end', 'end'] }\n *   { open: ['{'], close: ['}'] }\n *\n */\nfunction groupFuzzyBrackets(brackets: readonly CharacterPair[]): InternalBracket[] {\n\tconst N = brackets.length;\n\n\tbrackets = brackets.map(b => [b[0].toLowerCase(), b[1].toLowerCase()]);\n\n\tconst group: number[] = [];\n\tfor (let i = 0; i < N; i++) {\n\t\tgroup[i] = i;\n\t}\n\n\tconst areOverlapping = (a: CharacterPair, b: CharacterPair) => {\n\t\tconst [aOpen, aClose] = a;\n\t\tconst [bOpen, bClose] = b;\n\t\treturn (aOpen === bOpen || aOpen === bClose || aClose === bOpen || aClose === bClose);\n\t};\n\n\tconst mergeGroups = (g1: number, g2: number) => {\n\t\tconst newG = Math.min(g1, g2);\n\t\tconst oldG = Math.max(g1, g2);\n\t\tfor (let i = 0; i < N; i++) {\n\t\t\tif (group[i] === oldG) {\n\t\t\t\tgroup[i] = newG;\n\t\t\t}\n\t\t}\n\t};\n\n\t// group together brackets that have the same open or the same close sequence\n\tfor (let i = 0; i < N; i++) {\n\t\tconst a = brackets[i];\n\t\tfor (let j = i + 1; j < N; j++) {\n\t\t\tconst b = brackets[j];\n\t\t\tif (areOverlapping(a, b)) {\n\t\t\t\tmergeGroups(group[i], group[j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tconst result: InternalBracket[] = [];\n\tfor (let g = 0; g < N; g++) {\n\t\tconst currentOpen: string[] = [];\n\t\tconst currentClose: string[] = [];\n\t\tfor (let i = 0; i < N; i++) {\n\t\t\tif (group[i] === g) {\n\t\t\t\tconst [open, close] = brackets[i];\n\t\t\t\tcurrentOpen.push(open);\n\t\t\t\tcurrentClose.push(close);\n\t\t\t}\n\t\t}\n\t\tif (currentOpen.length > 0) {\n\t\t\tresult.push({\n\t\t\t\topen: currentOpen,\n\t\t\t\tclose: currentClose\n\t\t\t});\n\t\t}\n\t}\n\treturn result;\n}\n\nexport class RichEditBrackets {\n\t_richEditBracketsBrand: void = undefined;\n\n\t/**\n\t * All groups of brackets defined for this language.\n\t */\n\tpublic readonly brackets: RichEditBracket[];\n\t/**\n\t * A regular expression that is useful to search for all bracket pairs in a string.\n\t *\n\t * See the fine details in `getRegexForBrackets`.\n\t */\n\tpublic readonly forwardRegex: RegExp;\n\t/**\n\t * A regular expression that is useful to search for all bracket pairs in a string backwards.\n\t *\n\t * See the fine details in `getReversedRegexForBrackets`.\n\t */\n\tpublic readonly reversedRegex: RegExp;\n\t/**\n\t * The length (i.e. str.length) for the longest bracket pair.\n\t */\n\tpublic readonly maxBracketLength: number;\n\t/**\n\t * A map useful for decoding a regex match and finding which bracket group was matched.\n\t */\n\tpublic readonly textIsBracket: { [text: string]: RichEditBracket };\n\t/**\n\t * A set useful for decoding if a regex match is the open bracket of a bracket pair.\n\t */\n\tpublic readonly textIsOpenBracket: { [text: string]: boolean };\n\n\tconstructor(languageId: string, _brackets: readonly CharacterPair[]) {\n\t\tconst brackets = groupFuzzyBrackets(_brackets);\n\n\t\tthis.brackets = brackets.map((b, index) => {\n\t\t\treturn new RichEditBracket(\n\t\t\t\tlanguageId,\n\t\t\t\tindex,\n\t\t\t\tb.open,\n\t\t\t\tb.close,\n\t\t\t\tgetRegexForBracketPair(b.open, b.close, brackets, index),\n\t\t\t\tgetReversedRegexForBracketPair(b.open, b.close, brackets, index)\n\t\t\t);\n\t\t});\n\n\t\tthis.forwardRegex = getRegexForBrackets(this.brackets);\n\t\tthis.reversedRegex = getReversedRegexForBrackets(this.brackets);\n\n\t\tthis.textIsBracket = {};\n\t\tthis.textIsOpenBracket = {};\n\n\t\tthis.maxBracketLength = 0;\n\t\tfor (const bracket of this.brackets) {\n\t\t\tfor (const open of bracket.open) {\n\t\t\t\tthis.textIsBracket[open] = bracket;\n\t\t\t\tthis.textIsOpenBracket[open] = true;\n\t\t\t\tthis.maxBracketLength = Math.max(this.maxBracketLength, open.length);\n\t\t\t}\n\t\t\tfor (const close of bracket.close) {\n\t\t\t\tthis.textIsBracket[close] = bracket;\n\t\t\t\tthis.textIsOpenBracket[close] = false;\n\t\t\t\tthis.maxBracketLength = Math.max(this.maxBracketLength, close.length);\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction collectSuperstrings(str: string, brackets: InternalBracket[], currentIndex: number, dest: string[]): void {\n\tfor (let i = 0, len = brackets.length; i < len; i++) {\n\t\tif (i === currentIndex) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst bracket = brackets[i];\n\t\tfor (const open of bracket.open) {\n\t\t\tif (open.indexOf(str) >= 0) {\n\t\t\t\tdest.push(open);\n\t\t\t}\n\t\t}\n\t\tfor (const close of bracket.close) {\n\t\t\tif (close.indexOf(str) >= 0) {\n\t\t\t\tdest.push(close);\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction lengthcmp(a: string, b: string) {\n\treturn a.length - b.length;\n}\n\nfunction unique(arr: string[]): string[] {\n\tif (arr.length <= 1) {\n\t\treturn arr;\n\t}\n\tconst result: string[] = [];\n\tconst seen = new Set<string>();\n\tfor (const element of arr) {\n\t\tif (seen.has(element)) {\n\t\t\tcontinue;\n\t\t}\n\t\tresult.push(element);\n\t\tseen.add(element);\n\t}\n\treturn result;\n}\n\n/**\n * Create a regular expression that can be used to search forward in a piece of text\n * for a group of bracket pairs. But this regex must be built in a way in which\n * it is aware of the other bracket pairs defined for the language.\n *\n * For example, if a language contains the following bracket pairs:\n *   ['begin', 'end']\n *   ['if', 'end if']\n * The two bracket pairs do not collide because no open or close brackets are equal.\n * So the function getRegexForBracketPair is called twice, once with\n * the ['begin'], ['end'] group consisting of one bracket pair, and once with\n * the ['if'], ['end if'] group consiting of the other bracket pair.\n *\n * But there could be a situation where an occurrence of 'end if' is mistaken\n * for an occurrence of 'end'.\n *\n * Therefore, for the bracket pair ['begin', 'end'], the regex will also\n * target 'end if'. The regex will be something like:\n *   /(\\bend if\\b)|(\\bend\\b)|(\\bif\\b)/\n *\n * The regex also searches for \"superstrings\" (other brackets that might be mistaken with the current bracket).\n *\n */\nfunction getRegexForBracketPair(open: string[], close: string[], brackets: InternalBracket[], currentIndex: number): RegExp {\n\t// search in all brackets for other brackets that are a superstring of these brackets\n\tlet pieces: string[] = [];\n\tpieces = pieces.concat(open);\n\tpieces = pieces.concat(close);\n\tfor (let i = 0, len = pieces.length; i < len; i++) {\n\t\tcollectSuperstrings(pieces[i], brackets, currentIndex, pieces);\n\t}\n\tpieces = unique(pieces);\n\tpieces.sort(lengthcmp);\n\tpieces.reverse();\n\treturn createBracketOrRegExp(pieces);\n}\n\n/**\n * Matching a regular expression in JS can only be done \"forwards\". So JS offers natively only\n * methods to find the first match of a regex in a string. But sometimes, it is useful to\n * find the last match of a regex in a string. For such a situation, a nice solution is to\n * simply reverse the string and then search for a reversed regex.\n *\n * This function also has the fine details of `getRegexForBracketPair`. For the same example\n * given above, the regex produced here would look like:\n *   /(\\bfi dne\\b)|(\\bdne\\b)|(\\bfi\\b)/\n */\nfunction getReversedRegexForBracketPair(open: string[], close: string[], brackets: InternalBracket[], currentIndex: number): RegExp {\n\t// search in all brackets for other brackets that are a superstring of these brackets\n\tlet pieces: string[] = [];\n\tpieces = pieces.concat(open);\n\tpieces = pieces.concat(close);\n\tfor (let i = 0, len = pieces.length; i < len; i++) {\n\t\tcollectSuperstrings(pieces[i], brackets, currentIndex, pieces);\n\t}\n\tpieces = unique(pieces);\n\tpieces.sort(lengthcmp);\n\tpieces.reverse();\n\treturn createBracketOrRegExp(pieces.map(toReversedString));\n}\n\n/**\n * Creates a regular expression that targets all bracket pairs.\n *\n * e.g. for the bracket pairs:\n *  ['{','}']\n *  ['begin,'end']\n *  ['for','end']\n * the regex would look like:\n *  /(\\{)|(\\})|(\\bbegin\\b)|(\\bend\\b)|(\\bfor\\b)/\n */\nfunction getRegexForBrackets(brackets: RichEditBracket[]): RegExp {\n\tlet pieces: string[] = [];\n\tfor (const bracket of brackets) {\n\t\tfor (const open of bracket.open) {\n\t\t\tpieces.push(open);\n\t\t}\n\t\tfor (const close of bracket.close) {\n\t\t\tpieces.push(close);\n\t\t}\n\t}\n\tpieces = unique(pieces);\n\treturn createBracketOrRegExp(pieces);\n}\n\n/**\n * Matching a regular expression in JS can only be done \"forwards\". So JS offers natively only\n * methods to find the first match of a regex in a string. But sometimes, it is useful to\n * find the last match of a regex in a string. For such a situation, a nice solution is to\n * simply reverse the string and then search for a reversed regex.\n *\n * e.g. for the bracket pairs:\n *  ['{','}']\n *  ['begin,'end']\n *  ['for','end']\n * the regex would look like:\n *  /(\\{)|(\\})|(\\bnigeb\\b)|(\\bdne\\b)|(\\brof\\b)/\n */\nfunction getReversedRegexForBrackets(brackets: RichEditBracket[]): RegExp {\n\tlet pieces: string[] = [];\n\tfor (const bracket of brackets) {\n\t\tfor (const open of bracket.open) {\n\t\t\tpieces.push(open);\n\t\t}\n\t\tfor (const close of bracket.close) {\n\t\t\tpieces.push(close);\n\t\t}\n\t}\n\tpieces = unique(pieces);\n\treturn createBracketOrRegExp(pieces.map(toReversedString));\n}\n\nfunction prepareBracketForRegExp(str: string): string {\n\t// This bracket pair uses letters like e.g. \"begin\" - \"end\"\n\tconst insertWordBoundaries = (/^[\\w ]+$/.test(str));\n\tstr = strings.escapeRegExpCharacters(str);\n\treturn (insertWordBoundaries ? `\\\\b${str}\\\\b` : str);\n}\n\nfunction createBracketOrRegExp(pieces: string[]): RegExp {\n\tconst regexStr = `(${pieces.map(prepareBracketForRegExp).join(')|(')})`;\n\treturn strings.createRegExp(regexStr, true);\n}\n\nconst toReversedString = (function () {\n\n\tfunction reverse(str: string): string {\n\t\t// create a Uint16Array and then use a TextDecoder to create a string\n\t\tconst arr = new Uint16Array(str.length);\n\t\tlet offset = 0;\n\t\tfor (let i = str.length - 1; i >= 0; i--) {\n\t\t\tarr[offset++] = str.charCodeAt(i);\n\t\t}\n\t\treturn stringBuilder.getPlatformTextDecoder().decode(arr);\n\t}\n\n\tlet lastInput: string | null = null;\n\tlet lastOutput: string | null = null;\n\treturn function toReversedString(str: string): string {\n\t\tif (lastInput !== str) {\n\t\t\tlastInput = str;\n\t\t\tlastOutput = reverse(lastInput);\n\t\t}\n\t\treturn lastOutput!;\n\t};\n})();\n\nexport class BracketsUtils {\n\n\tprivate static _findPrevBracketInText(reversedBracketRegex: RegExp, lineNumber: number, reversedText: string, offset: number): Range | null {\n\t\tconst m = reversedText.match(reversedBracketRegex);\n\n\t\tif (!m) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst matchOffset = reversedText.length - (m.index || 0);\n\t\tconst matchLength = m[0].length;\n\t\tconst absoluteMatchOffset = offset + matchOffset;\n\n\t\treturn new Range(lineNumber, absoluteMatchOffset - matchLength + 1, lineNumber, absoluteMatchOffset + 1);\n\t}\n\n\tpublic static findPrevBracketInRange(reversedBracketRegex: RegExp, lineNumber: number, lineText: string, startOffset: number, endOffset: number): Range | null {\n\t\t// Because JS does not support backwards regex search, we search forwards in a reversed string with a reversed regex ;)\n\t\tconst reversedLineText = toReversedString(lineText);\n\t\tconst reversedSubstr = reversedLineText.substring(lineText.length - endOffset, lineText.length - startOffset);\n\t\treturn this._findPrevBracketInText(reversedBracketRegex, lineNumber, reversedSubstr, startOffset);\n\t}\n\n\tpublic static findNextBracketInText(bracketRegex: RegExp, lineNumber: number, text: string, offset: number): Range | null {\n\t\tconst m = text.match(bracketRegex);\n\n\t\tif (!m) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst matchOffset = m.index || 0;\n\t\tconst matchLength = m[0].length;\n\t\tif (matchLength === 0) {\n\t\t\treturn null;\n\t\t}\n\t\tconst absoluteMatchOffset = offset + matchOffset;\n\n\t\treturn new Range(lineNumber, absoluteMatchOffset + 1, lineNumber, absoluteMatchOffset + 1 + matchLength);\n\t}\n\n\tpublic static findNextBracketInRange(bracketRegex: RegExp, lineNumber: number, lineText: string, startOffset: number, endOffset: number): Range | null {\n\t\tconst substr = lineText.substring(startOffset, endOffset);\n\t\treturn this.findNextBracketInText(bracketRegex, lineNumber, substr, startOffset);\n\t}\n}\n"]}