{"version":3,"sources":["file:///workspace/appflow/src/vs/editor/common/diff/defaultLinesDiffComputer/linesSliceCharSequence.ts"],"names":[],"mappings":"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","file":"linesSliceCharSequence.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { findLastIdxMonotonous, findLastMonotonous, findFirstMonotonous } from 'vs/base/common/arraysFind';\nimport { CharCode } from 'vs/base/common/charCode';\nimport { OffsetRange } from 'vs/editor/common/core/offsetRange';\nimport { Position } from 'vs/editor/common/core/position';\nimport { Range } from 'vs/editor/common/core/range';\nimport { ISequence } from 'vs/editor/common/diff/defaultLinesDiffComputer/algorithms/diffAlgorithm';\nimport { isSpace } from 'vs/editor/common/diff/defaultLinesDiffComputer/utils';\n\nexport class LinesSliceCharSequence implements ISequence {\n\tprivate readonly elements: number[] = [];\n\tprivate readonly firstCharOffsetByLine: number[] = [];\n\tpublic readonly lineRange: OffsetRange;\n\t// To account for trimming\n\tprivate readonly additionalOffsetByLine: number[] = [];\n\n\tconstructor(public readonly lines: string[], lineRange: OffsetRange, public readonly considerWhitespaceChanges: boolean) {\n\t\t// This slice has to have lineRange.length many \\n! (otherwise diffing against an empty slice will be problematic)\n\t\t// (Unless it covers the entire document, in that case the other slice also has to cover the entire document ands it's okay)\n\n\t\t// If the slice covers the end, but does not start at the beginning, we include just the \\n of the previous line.\n\t\tlet trimFirstLineFully = false;\n\t\tif (lineRange.start > 0 && lineRange.endExclusive >= lines.length) {\n\t\t\tlineRange = new OffsetRange(lineRange.start - 1, lineRange.endExclusive);\n\t\t\ttrimFirstLineFully = true;\n\t\t}\n\n\t\tthis.lineRange = lineRange;\n\n\t\tthis.firstCharOffsetByLine[0] = 0;\n\t\tfor (let i = this.lineRange.start; i < this.lineRange.endExclusive; i++) {\n\t\t\tlet line = lines[i];\n\t\t\tlet offset = 0;\n\t\t\tif (trimFirstLineFully) {\n\t\t\t\toffset = line.length;\n\t\t\t\tline = '';\n\t\t\t\ttrimFirstLineFully = false;\n\t\t\t} else if (!considerWhitespaceChanges) {\n\t\t\t\tconst trimmedStartLine = line.trimStart();\n\t\t\t\toffset = line.length - trimmedStartLine.length;\n\t\t\t\tline = trimmedStartLine.trimEnd();\n\t\t\t}\n\n\t\t\tthis.additionalOffsetByLine.push(offset);\n\n\t\t\tfor (let i = 0; i < line.length; i++) {\n\t\t\t\tthis.elements.push(line.charCodeAt(i));\n\t\t\t}\n\n\t\t\t// Don't add an \\n that does not exist in the document.\n\t\t\tif (i < lines.length - 1) {\n\t\t\t\tthis.elements.push('\\n'.charCodeAt(0));\n\t\t\t\tthis.firstCharOffsetByLine[i - this.lineRange.start + 1] = this.elements.length;\n\t\t\t}\n\t\t}\n\t\t// To account for the last line\n\t\tthis.additionalOffsetByLine.push(0);\n\t}\n\n\ttoString() {\n\t\treturn `Slice: \"${this.text}\"`;\n\t}\n\n\tget text(): string {\n\t\treturn this.getText(new OffsetRange(0, this.length));\n\t}\n\n\tgetText(range: OffsetRange): string {\n\t\treturn this.elements.slice(range.start, range.endExclusive).map(e => String.fromCharCode(e)).join('');\n\t}\n\n\tgetElement(offset: number): number {\n\t\treturn this.elements[offset];\n\t}\n\n\tget length(): number {\n\t\treturn this.elements.length;\n\t}\n\n\tpublic getBoundaryScore(length: number): number {\n\t\t//   a   b   c   ,           d   e   f\n\t\t// 11  0   0   12  15  6   13  0   0   11\n\n\t\tconst prevCategory = getCategory(length > 0 ? this.elements[length - 1] : -1);\n\t\tconst nextCategory = getCategory(length < this.elements.length ? this.elements[length] : -1);\n\n\t\tif (prevCategory === CharBoundaryCategory.LineBreakCR && nextCategory === CharBoundaryCategory.LineBreakLF) {\n\t\t\t// don't break between \\r and \\n\n\t\t\treturn 0;\n\t\t}\n\n\t\tlet score = 0;\n\t\tif (prevCategory !== nextCategory) {\n\t\t\tscore += 10;\n\t\t\tif (prevCategory === CharBoundaryCategory.WordLower && nextCategory === CharBoundaryCategory.WordUpper) {\n\t\t\t\tscore += 1;\n\t\t\t}\n\t\t}\n\n\t\tscore += getCategoryBoundaryScore(prevCategory);\n\t\tscore += getCategoryBoundaryScore(nextCategory);\n\n\t\treturn score;\n\t}\n\n\tpublic translateOffset(offset: number): Position {\n\t\t// find smallest i, so that lineBreakOffsets[i] <= offset using binary search\n\t\tif (this.lineRange.isEmpty) {\n\t\t\treturn new Position(this.lineRange.start + 1, 1);\n\t\t}\n\n\t\tconst i = findLastIdxMonotonous(this.firstCharOffsetByLine, (value) => value <= offset);\n\t\treturn new Position(this.lineRange.start + i + 1, offset - this.firstCharOffsetByLine[i] + this.additionalOffsetByLine[i] + 1);\n\t}\n\n\tpublic translateRange(range: OffsetRange): Range {\n\t\treturn Range.fromPositions(this.translateOffset(range.start), this.translateOffset(range.endExclusive));\n\t}\n\n\t/**\n\t * Finds the word that contains the character at the given offset\n\t */\n\tpublic findWordContaining(offset: number): OffsetRange | undefined {\n\t\tif (offset < 0 || offset >= this.elements.length) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (!isWordChar(this.elements[offset])) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// find start\n\t\tlet start = offset;\n\t\twhile (start > 0 && isWordChar(this.elements[start - 1])) {\n\t\t\tstart--;\n\t\t}\n\n\t\t// find end\n\t\tlet end = offset;\n\t\twhile (end < this.elements.length && isWordChar(this.elements[end])) {\n\t\t\tend++;\n\t\t}\n\n\t\treturn new OffsetRange(start, end);\n\t}\n\n\tpublic countLinesIn(range: OffsetRange): number {\n\t\treturn this.translateOffset(range.endExclusive).lineNumber - this.translateOffset(range.start).lineNumber;\n\t}\n\n\tpublic isStronglyEqual(offset1: number, offset2: number): boolean {\n\t\treturn this.elements[offset1] === this.elements[offset2];\n\t}\n\n\tpublic extendToFullLines(range: OffsetRange): OffsetRange {\n\t\tconst start = findLastMonotonous(this.firstCharOffsetByLine, x => x <= range.start) ?? 0;\n\t\tconst end = findFirstMonotonous(this.firstCharOffsetByLine, x => range.endExclusive <= x) ?? this.elements.length;\n\t\treturn new OffsetRange(start, end);\n\t}\n}\n\nfunction isWordChar(charCode: number): boolean {\n\treturn charCode >= CharCode.a && charCode <= CharCode.z\n\t\t|| charCode >= CharCode.A && charCode <= CharCode.Z\n\t\t|| charCode >= CharCode.Digit0 && charCode <= CharCode.Digit9;\n}\n\nconst enum CharBoundaryCategory {\n\tWordLower,\n\tWordUpper,\n\tWordNumber,\n\tEnd,\n\tOther,\n\tSpace,\n\tLineBreakCR,\n\tLineBreakLF,\n}\n\nconst score: Record<CharBoundaryCategory, number> = {\n\t[CharBoundaryCategory.WordLower]: 0,\n\t[CharBoundaryCategory.WordUpper]: 0,\n\t[CharBoundaryCategory.WordNumber]: 0,\n\t[CharBoundaryCategory.End]: 10,\n\t[CharBoundaryCategory.Other]: 2,\n\t[CharBoundaryCategory.Space]: 3,\n\t[CharBoundaryCategory.LineBreakCR]: 10,\n\t[CharBoundaryCategory.LineBreakLF]: 10,\n};\n\nfunction getCategoryBoundaryScore(category: CharBoundaryCategory): number {\n\treturn score[category];\n}\n\nfunction getCategory(charCode: number): CharBoundaryCategory {\n\tif (charCode === CharCode.LineFeed) {\n\t\treturn CharBoundaryCategory.LineBreakLF;\n\t} else if (charCode === CharCode.CarriageReturn) {\n\t\treturn CharBoundaryCategory.LineBreakCR;\n\t} else if (isSpace(charCode)) {\n\t\treturn CharBoundaryCategory.Space;\n\t} else if (charCode >= CharCode.a && charCode <= CharCode.z) {\n\t\treturn CharBoundaryCategory.WordLower;\n\t} else if (charCode >= CharCode.A && charCode <= CharCode.Z) {\n\t\treturn CharBoundaryCategory.WordUpper;\n\t} else if (charCode >= CharCode.Digit0 && charCode <= CharCode.Digit9) {\n\t\treturn CharBoundaryCategory.WordNumber;\n\t} else if (charCode === -1) {\n\t\treturn CharBoundaryCategory.End;\n\t} else {\n\t\treturn CharBoundaryCategory.Other;\n\t}\n}\n\n"]}