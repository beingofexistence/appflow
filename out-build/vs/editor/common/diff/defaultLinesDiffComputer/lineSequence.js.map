{"version":3,"sources":["file:///workspace/appflow/src/vs/editor/common/diff/defaultLinesDiffComputer/lineSequence.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;IAMhG,MAAa,GAAG;QACf,YACkB,CAAqB,EACrB,CAAe;YADf,MAAC,GAAD,CAAC,CAAoB;YACrB,MAAC,GAAD,CAAC,CAAc;QAC7B,CAAC;QAEL,UAAU,CAAC,MAAc;YACxB,OAAO,IAAI,CAAC,CAAC,CAAW,MAAM,CAAC,CAAC;QACjC,CAAC;QAED,IAAI,MAAM;YACT,OAAO,IAAI,CAAC,CAAC,CAAW,MAAM,CAAC;QAChC,CAAC;QAED,gBAAgB,CAAC,MAAc;YAC9B,MAAM,iBAAiB,GAAG,MAAM,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC,CAAK,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;YACpF,MAAM,gBAAgB,GAAG,MAAM,KAAK,IAAI,CAAC,CAAC,CAAK,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC,CAAK,MAAM,CAAC,CAAC,CAAC;YAC/F,OAAO,IAAI,GAAG,CAAC,iBAAiB,GAAG,gBAAgB,CAAC,CAAC;QACtD,CAAC;QAED,OAAO,CAAC,KAAU;YACjB,OAAO,IAAI,CAAC,CAAC,CAAK,KAAK,CAAC,KAAK,CAAC,KAAK,EAAE,KAAK,CAAC,YAAY,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QACrE,CAAC;QAED,eAAe,CAAC,OAAe,EAAE,OAAe;YAC/C,OAAO,IAAI,CAAC,CAAC,CAAK,OAAO,CAAC,KAAK,IAAI,CAAC,CAAC,CAAK,OAAO,CAAC,CAAC;QACpD,CAAC;KACD;IA3BD,kBA2BC;IAED,SAAS,cAAc,CAAC,GAAW;QAClC,IAAI,CAAC,GAAG,CAAC,CAAC;QACV,OAAO,CAAC,GAAG,GAAG,CAAC,MAAM,IAAI,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC,CAAC,4BAAmB,IAAI,GAAG,CAAC,UAAU,CAAC,CAAC,CAAC,yBAAiB,CAAC,EAAE;YACtG,CAAC,EAAE,CAAC;SACJ;QACD,OAAO,CAAC,CAAC;IACV,CAAC","file":"lineSequence.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from 'vs/base/common/charCode';\nimport { OffsetRange } from 'vs/editor/common/core/offsetRange';\nimport { ISequence } from 'vs/editor/common/diff/defaultLinesDiffComputer/algorithms/diffAlgorithm';\n\nexport class LineSequence implements ISequence {\n\tconstructor(\n\t\tprivate readonly trimmedHash: number[],\n\t\tprivate readonly lines: string[]\n\t) { }\n\n\tgetElement(offset: number): number {\n\t\treturn this.trimmedHash[offset];\n\t}\n\n\tget length(): number {\n\t\treturn this.trimmedHash.length;\n\t}\n\n\tgetBoundaryScore(length: number): number {\n\t\tconst indentationBefore = length === 0 ? 0 : getIndentation(this.lines[length - 1]);\n\t\tconst indentationAfter = length === this.lines.length ? 0 : getIndentation(this.lines[length]);\n\t\treturn 1000 - (indentationBefore + indentationAfter);\n\t}\n\n\tgetText(range: OffsetRange): string {\n\t\treturn this.lines.slice(range.start, range.endExclusive).join('\\n');\n\t}\n\n\tisStronglyEqual(offset1: number, offset2: number): boolean {\n\t\treturn this.lines[offset1] === this.lines[offset2];\n\t}\n}\n\nfunction getIndentation(str: string): number {\n\tlet i = 0;\n\twhile (i < str.length && (str.charCodeAt(i) === CharCode.Space || str.charCodeAt(i) === CharCode.Tab)) {\n\t\ti++;\n\t}\n\treturn i;\n}\n"]}