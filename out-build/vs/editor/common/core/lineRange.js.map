{"version":3,"sources":["file:///workspace/appflow/src/vs/editor/common/core/lineRange.ts"],"names":[],"mappings":"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","file":"lineRange.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { BugIndicatingError } from 'vs/base/common/errors';\nimport { OffsetRange } from 'vs/editor/common/core/offsetRange';\nimport { Range } from 'vs/editor/common/core/range';\nimport { findFirstIdxMonotonousOrArrLen, findLastIdxMonotonous, findLastMonotonous } from 'vs/base/common/arraysFind';\n\n/**\n * A range of lines (1-based).\n */\nexport class LineRange {\n\tpublic static fromRange(range: Range): LineRange {\n\t\treturn new LineRange(range.startLineNumber, range.endLineNumber);\n\t}\n\n\tpublic static subtract(a: LineRange, b: LineRange | undefined): LineRange[] {\n\t\tif (!b) {\n\t\t\treturn [a];\n\t\t}\n\t\tif (a.startLineNumber < b.startLineNumber && b.endLineNumberExclusive < a.endLineNumberExclusive) {\n\t\t\treturn [\n\t\t\t\tnew LineRange(a.startLineNumber, b.startLineNumber),\n\t\t\t\tnew LineRange(b.endLineNumberExclusive, a.endLineNumberExclusive)\n\t\t\t];\n\t\t} else if (b.startLineNumber <= a.startLineNumber && a.endLineNumberExclusive <= b.endLineNumberExclusive) {\n\t\t\treturn [];\n\t\t} else if (b.endLineNumberExclusive < a.endLineNumberExclusive) {\n\t\t\treturn [new LineRange(Math.max(b.endLineNumberExclusive, a.startLineNumber), a.endLineNumberExclusive)];\n\t\t} else {\n\t\t\treturn [new LineRange(a.startLineNumber, Math.min(b.startLineNumber, a.endLineNumberExclusive))];\n\t\t}\n\t}\n\n\t/**\n\t * @param lineRanges An array of sorted line ranges.\n\t */\n\tpublic static joinMany(lineRanges: readonly (readonly LineRange[])[]): readonly LineRange[] {\n\t\tif (lineRanges.length === 0) {\n\t\t\treturn [];\n\t\t}\n\t\tlet result = new LineRangeSet(lineRanges[0].slice());\n\t\tfor (let i = 1; i < lineRanges.length; i++) {\n\t\t\tresult = result.getUnion(new LineRangeSet(lineRanges[i].slice()));\n\t\t}\n\t\treturn result.ranges;\n\t}\n\n\tpublic static ofLength(startLineNumber: number, length: number): LineRange {\n\t\treturn new LineRange(startLineNumber, startLineNumber + length);\n\t}\n\n\t/**\n\t * @internal\n\t */\n\tpublic static deserialize(lineRange: ISerializedLineRange): LineRange {\n\t\treturn new LineRange(lineRange[0], lineRange[1]);\n\t}\n\n\t/**\n\t * The start line number.\n\t */\n\tpublic readonly startLineNumber: number;\n\n\t/**\n\t * The end line number (exclusive).\n\t */\n\tpublic readonly endLineNumberExclusive: number;\n\n\tconstructor(\n\t\tstartLineNumber: number,\n\t\tendLineNumberExclusive: number,\n\t) {\n\t\tif (startLineNumber > endLineNumberExclusive) {\n\t\t\tthrow new BugIndicatingError(`startLineNumber ${startLineNumber} cannot be after endLineNumberExclusive ${endLineNumberExclusive}`);\n\t\t}\n\t\tthis.startLineNumber = startLineNumber;\n\t\tthis.endLineNumberExclusive = endLineNumberExclusive;\n\t}\n\n\t/**\n\t * Indicates if this line range contains the given line number.\n\t */\n\tpublic contains(lineNumber: number): boolean {\n\t\treturn this.startLineNumber <= lineNumber && lineNumber < this.endLineNumberExclusive;\n\t}\n\n\t/**\n\t * Indicates if this line range is empty.\n\t */\n\tget isEmpty(): boolean {\n\t\treturn this.startLineNumber === this.endLineNumberExclusive;\n\t}\n\n\t/**\n\t * Moves this line range by the given offset of line numbers.\n\t */\n\tpublic delta(offset: number): LineRange {\n\t\treturn new LineRange(this.startLineNumber + offset, this.endLineNumberExclusive + offset);\n\t}\n\n\tpublic deltaLength(offset: number): LineRange {\n\t\treturn new LineRange(this.startLineNumber, this.endLineNumberExclusive + offset);\n\t}\n\n\t/**\n\t * The number of lines this line range spans.\n\t */\n\tpublic get length(): number {\n\t\treturn this.endLineNumberExclusive - this.startLineNumber;\n\t}\n\n\t/**\n\t * Creates a line range that combines this and the given line range.\n\t */\n\tpublic join(other: LineRange): LineRange {\n\t\treturn new LineRange(\n\t\t\tMath.min(this.startLineNumber, other.startLineNumber),\n\t\t\tMath.max(this.endLineNumberExclusive, other.endLineNumberExclusive)\n\t\t);\n\t}\n\n\tpublic toString(): string {\n\t\treturn `[${this.startLineNumber},${this.endLineNumberExclusive})`;\n\t}\n\n\t/**\n\t * The resulting range is empty if the ranges do not intersect, but touch.\n\t * If the ranges don't even touch, the result is undefined.\n\t */\n\tpublic intersect(other: LineRange): LineRange | undefined {\n\t\tconst startLineNumber = Math.max(this.startLineNumber, other.startLineNumber);\n\t\tconst endLineNumberExclusive = Math.min(this.endLineNumberExclusive, other.endLineNumberExclusive);\n\t\tif (startLineNumber <= endLineNumberExclusive) {\n\t\t\treturn new LineRange(startLineNumber, endLineNumberExclusive);\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tpublic intersectsStrict(other: LineRange): boolean {\n\t\treturn this.startLineNumber < other.endLineNumberExclusive && other.startLineNumber < this.endLineNumberExclusive;\n\t}\n\n\tpublic overlapOrTouch(other: LineRange): boolean {\n\t\treturn this.startLineNumber <= other.endLineNumberExclusive && other.startLineNumber <= this.endLineNumberExclusive;\n\t}\n\n\tpublic equals(b: LineRange): boolean {\n\t\treturn this.startLineNumber === b.startLineNumber && this.endLineNumberExclusive === b.endLineNumberExclusive;\n\t}\n\n\tpublic toInclusiveRange(): Range | null {\n\t\tif (this.isEmpty) {\n\t\t\treturn null;\n\t\t}\n\t\treturn new Range(this.startLineNumber, 1, this.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER);\n\t}\n\n\tpublic toExclusiveRange(): Range {\n\t\treturn new Range(this.startLineNumber, 1, this.endLineNumberExclusive, 1);\n\t}\n\n\tpublic mapToLineArray<T>(f: (lineNumber: number) => T): T[] {\n\t\tconst result: T[] = [];\n\t\tfor (let lineNumber = this.startLineNumber; lineNumber < this.endLineNumberExclusive; lineNumber++) {\n\t\t\tresult.push(f(lineNumber));\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic forEach(f: (lineNumber: number) => void): void {\n\t\tfor (let lineNumber = this.startLineNumber; lineNumber < this.endLineNumberExclusive; lineNumber++) {\n\t\t\tf(lineNumber);\n\t\t}\n\t}\n\n\t/**\n\t * @internal\n\t */\n\tpublic serialize(): ISerializedLineRange {\n\t\treturn [this.startLineNumber, this.endLineNumberExclusive];\n\t}\n\n\tpublic includes(lineNumber: number): boolean {\n\t\treturn this.startLineNumber <= lineNumber && lineNumber < this.endLineNumberExclusive;\n\t}\n\n\t/**\n\t * Converts this 1-based line range to a 0-based offset range (subtracts 1!).\n\t * @internal\n\t */\n\tpublic toOffsetRange(): OffsetRange {\n\t\treturn new OffsetRange(this.startLineNumber - 1, this.endLineNumberExclusive - 1);\n\t}\n}\n\nexport type ISerializedLineRange = [startLineNumber: number, endLineNumberExclusive: number];\n\n\nexport class LineRangeSet {\n\tconstructor(\n\t\t/**\n\t\t * Sorted by start line number.\n\t\t * No two line ranges are touching or intersecting.\n\t\t */\n\t\tprivate readonly _normalizedRanges: LineRange[] = []\n\t) {\n\t}\n\n\tget ranges(): readonly LineRange[] {\n\t\treturn this._normalizedRanges;\n\t}\n\n\taddRange(range: LineRange): void {\n\t\tif (range.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Idea: Find joinRange such that:\n\t\t// replaceRange = _normalizedRanges.replaceRange(joinRange, range.joinAll(joinRange.map(idx => this._normalizedRanges[idx])))\n\n\t\t// idx of first element that touches range or that is after range\n\t\tconst joinRangeStartIdx = findFirstIdxMonotonousOrArrLen(this._normalizedRanges, r => r.endLineNumberExclusive >= range.startLineNumber);\n\t\t// idx of element after { last element that touches range or that is before range }\n\t\tconst joinRangeEndIdxExclusive = findLastIdxMonotonous(this._normalizedRanges, r => r.startLineNumber <= range.endLineNumberExclusive) + 1;\n\n\t\tif (joinRangeStartIdx === joinRangeEndIdxExclusive) {\n\t\t\t// If there is no element that touches range, then joinRangeStartIdx === joinRangeEndIdxExclusive and that value is the index of the element after range\n\t\t\tthis._normalizedRanges.splice(joinRangeStartIdx, 0, range);\n\t\t} else if (joinRangeStartIdx === joinRangeEndIdxExclusive - 1) {\n\t\t\t// Else, there is an element that touches range and in this case it is both the first and last element. Thus we can replace it\n\t\t\tconst joinRange = this._normalizedRanges[joinRangeStartIdx];\n\t\t\tthis._normalizedRanges[joinRangeStartIdx] = joinRange.join(range);\n\t\t} else {\n\t\t\t// First and last element are different - we need to replace the entire range\n\t\t\tconst joinRange = this._normalizedRanges[joinRangeStartIdx].join(this._normalizedRanges[joinRangeEndIdxExclusive - 1]).join(range);\n\t\t\tthis._normalizedRanges.splice(joinRangeStartIdx, joinRangeEndIdxExclusive - joinRangeStartIdx, joinRange);\n\t\t}\n\t}\n\n\tcontains(lineNumber: number): boolean {\n\t\tconst rangeThatStartsBeforeEnd = findLastMonotonous(this._normalizedRanges, r => r.startLineNumber <= lineNumber);\n\t\treturn !!rangeThatStartsBeforeEnd && rangeThatStartsBeforeEnd.endLineNumberExclusive > lineNumber;\n\t}\n\n\tintersects(range: LineRange): boolean {\n\t\tconst rangeThatStartsBeforeEnd = findLastMonotonous(this._normalizedRanges, r => r.startLineNumber < range.endLineNumberExclusive);\n\t\treturn !!rangeThatStartsBeforeEnd && rangeThatStartsBeforeEnd.endLineNumberExclusive > range.startLineNumber;\n\t}\n\n\tgetUnion(other: LineRangeSet): LineRangeSet {\n\t\tif (this._normalizedRanges.length === 0) {\n\t\t\treturn other;\n\t\t}\n\t\tif (other._normalizedRanges.length === 0) {\n\t\t\treturn this;\n\t\t}\n\n\t\tconst result: LineRange[] = [];\n\t\tlet i1 = 0;\n\t\tlet i2 = 0;\n\t\tlet current: LineRange | null = null;\n\t\twhile (i1 < this._normalizedRanges.length || i2 < other._normalizedRanges.length) {\n\t\t\tlet next: LineRange | null = null;\n\t\t\tif (i1 < this._normalizedRanges.length && i2 < other._normalizedRanges.length) {\n\t\t\t\tconst lineRange1 = this._normalizedRanges[i1];\n\t\t\t\tconst lineRange2 = other._normalizedRanges[i2];\n\t\t\t\tif (lineRange1.startLineNumber < lineRange2.startLineNumber) {\n\t\t\t\t\tnext = lineRange1;\n\t\t\t\t\ti1++;\n\t\t\t\t} else {\n\t\t\t\t\tnext = lineRange2;\n\t\t\t\t\ti2++;\n\t\t\t\t}\n\t\t\t} else if (i1 < this._normalizedRanges.length) {\n\t\t\t\tnext = this._normalizedRanges[i1];\n\t\t\t\ti1++;\n\t\t\t} else {\n\t\t\t\tnext = other._normalizedRanges[i2];\n\t\t\t\ti2++;\n\t\t\t}\n\n\t\t\tif (current === null) {\n\t\t\t\tcurrent = next;\n\t\t\t} else {\n\t\t\t\tif (current.endLineNumberExclusive >= next.startLineNumber) {\n\t\t\t\t\t// merge\n\t\t\t\t\tcurrent = new LineRange(current.startLineNumber, Math.max(current.endLineNumberExclusive, next.endLineNumberExclusive));\n\t\t\t\t} else {\n\t\t\t\t\t// push\n\t\t\t\t\tresult.push(current);\n\t\t\t\t\tcurrent = next;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (current !== null) {\n\t\t\tresult.push(current);\n\t\t}\n\t\treturn new LineRangeSet(result);\n\t}\n\n\t/**\n\t * Subtracts all ranges in this set from `range` and returns the result.\n\t */\n\tsubtractFrom(range: LineRange): LineRangeSet {\n\t\t// idx of first element that touches range or that is after range\n\t\tconst joinRangeStartIdx = findFirstIdxMonotonousOrArrLen(this._normalizedRanges, r => r.endLineNumberExclusive >= range.startLineNumber);\n\t\t// idx of element after { last element that touches range or that is before range }\n\t\tconst joinRangeEndIdxExclusive = findLastIdxMonotonous(this._normalizedRanges, r => r.startLineNumber <= range.endLineNumberExclusive) + 1;\n\n\t\tif (joinRangeStartIdx === joinRangeEndIdxExclusive) {\n\t\t\treturn new LineRangeSet([range]);\n\t\t}\n\n\t\tconst result: LineRange[] = [];\n\t\tlet startLineNumber = range.startLineNumber;\n\t\tfor (let i = joinRangeStartIdx; i < joinRangeEndIdxExclusive; i++) {\n\t\t\tconst r = this._normalizedRanges[i];\n\t\t\tif (r.startLineNumber > startLineNumber) {\n\t\t\t\tresult.push(new LineRange(startLineNumber, r.startLineNumber));\n\t\t\t}\n\t\t\tstartLineNumber = r.endLineNumberExclusive;\n\t\t}\n\t\tif (startLineNumber < range.endLineNumberExclusive) {\n\t\t\tresult.push(new LineRange(startLineNumber, range.endLineNumberExclusive));\n\t\t}\n\n\t\treturn new LineRangeSet(result);\n\t}\n\n\ttoString() {\n\t\treturn this._normalizedRanges.map(r => r.toString()).join(', ');\n\t}\n\n\tgetIntersection(other: LineRangeSet): LineRangeSet {\n\t\tconst result: LineRange[] = [];\n\n\t\tlet i1 = 0;\n\t\tlet i2 = 0;\n\t\twhile (i1 < this._normalizedRanges.length && i2 < other._normalizedRanges.length) {\n\t\t\tconst r1 = this._normalizedRanges[i1];\n\t\t\tconst r2 = other._normalizedRanges[i2];\n\n\t\t\tconst i = r1.intersect(r2);\n\t\t\tif (i && !i.isEmpty) {\n\t\t\t\tresult.push(i);\n\t\t\t}\n\n\t\t\tif (r1.endLineNumberExclusive < r2.endLineNumberExclusive) {\n\t\t\t\ti1++;\n\t\t\t} else {\n\t\t\t\ti2++;\n\t\t\t}\n\t\t}\n\n\t\treturn new LineRangeSet(result);\n\t}\n\n\tgetWithDelta(value: number): LineRangeSet {\n\t\treturn new LineRangeSet(this._normalizedRanges.map(r => r.delta(value)));\n\t}\n}\n"]}