{"version":3,"sources":["file:///workspace/appflow/src/vs/editor/common/core/wordHelper.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;IAMnF,QAAA,GAAG,GAAqB,mCAAmC,CAAC;IAoBzE;;;;;;OAMG;IACH,SAAS,gBAAgB,CAAC,eAAuB,EAAE;QAClD,IAAI,MAAM,GAAG,wBAAwB,CAAC;QACtC,KAAK,MAAM,GAAG,IAAI,WAAG,EAAoB;YACxC,IAAI,YAAY,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE;gBACnC,SAAS;aACT;YACD,MAAM,IAAI,IAAI,GAAG,GAAG,CAAC;SACrB;QACD,MAAM,IAAI,QAAQ,CAAC;QACnB,OAAO,IAAI,MAAM,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC;IAChC,CAAC;IAED,8FAA8F;IACjF,QAAA,GAAG,GAAmB,gBAAgB,EAAE,CAAC;IAEtD,SAAgB,GAAG,CAAuB,cAA8B;QACvE,IAAI,MAAM,GAAW,WAAG,CAAiB;QAEzC,IAAI,cAAc,IAAI,CAAC,cAAc,YAAY,MAAM,CAAC,EAAE;YACzD,IAAI,CAAC,cAAc,CAAC,MAAM,EAAE;gBAC3B,IAAI,KAAK,GAAG,GAAG,CAAC;gBAChB,IAAI,cAAc,CAAC,UAAU,EAAE;oBAC9B,KAAK,IAAI,GAAG,CAAC;iBACb;gBACD,IAAI,cAAc,CAAC,SAAS,EAAE;oBAC7B,KAAK,IAAI,GAAG,CAAC;iBACb;gBACD,IAAI,cAAc,CAAC,OAAO,EAAE;oBAC3B,KAAK,IAAI,GAAG,CAAC;iBACb;gBACD,MAAM,GAAG,IAAI,MAAM,CAAC,cAAc,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC;aAClD;iBAAM;gBACN,MAAM,GAAG,cAAc,CAAC;aACxB;SACD;QAED,MAAM,CAAC,SAAS,GAAG,CAAC,CAAC;QAErB,OAAO,MAAM,CAAC;IACf,CAAC;IAxBD,kBAwBC;IAUD,MAAM,cAAc,GAAG,IAAI,gBAAG,EAA+B,CAAC;IAC9D,cAAc,CAAC,OAAO,CAAC;QACtB,MAAM,EAAE,IAAI;QACZ,UAAU,EAAE,EAAE;QACd,UAAU,EAAE,GAAG;KACf,CAAC,CAAC;IAEH,SAAgB,GAAG,CAA2B,KAA2B;QACxE,MAAM,EAAE,GAAG,cAAc,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;QACzC,OAAO,IAAA,eAAG,EAAU,EAAE,CAAC,CAAC;IACzB,CAAC;IAHD,kBAGC;IAED,SAAgB,GAAG,CAAW,MAAc,EAAE,cAAsB,EAAE,IAAY,EAAE,UAAkB,EAAE,MAA6B;QAEpI,IAAI,CAAC,MAAM,EAAE;YACZ,MAAM,GAAG,mBAAQ,CAAC,KAAK,CAAC,cAAc,CAAE,CAAC;SACzC;QAED,IAAI,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC,MAAM,EAAE;YAChC,8CAA8C;YAC9C,kDAAkD;YAClD,IAAI,KAAK,GAAG,MAAM,GAAG,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC;YACvC,IAAI,KAAK,GAAG,CAAC,EAAE;gBACd,KAAK,GAAG,CAAC,CAAC;aACV;iBAAM;gBACN,UAAU,IAAI,KAAK,CAAC;aACpB;YACD,IAAI,GAAG,IAAI,CAAC,SAAS,CAAC,KAAK,EAAE,MAAM,GAAG,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;YACzD,OAAO,GAAG,CAAW,MAAM,EAAE,cAAc,EAAE,IAAI,EAAE,UAAU,EAAE,MAAM,CAAC,CAAC;SACvE;QAED,MAAM,EAAE,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;QACtB,MAAM,GAAG,GAAG,MAAM,GAAG,CAAC,GAAG,UAAU,CAAC;QAEpC,IAAI,cAAc,GAAG,CAAC,CAAC,CAAC;QACxB,IAAI,KAAK,GAA2B,IAAI,CAAC;QAEzC,KAAK,IAAI,CAAC,GAAG,CAAC,GAAI,CAAC,EAAE,EAAE;YACtB,oBAAoB;YACpB,IAAI,IAAI,CAAC,GAAG,EAAE,GAAG,EAAE,IAAI,MAAM,CAAC,UAAU,EAAE;gBACzC,MAAM;aACN;YAED,gFAAgF;YAChF,uEAAuE;YACvE,MAAM,UAAU,GAAG,GAAG,GAAG,MAAM,CAAC,UAAU,GAAG,CAAC,CAAC;YAC/C,cAAc,CAAC,SAAS,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,UAAU,CAAC,CAAC;YACnD,MAAM,SAAS,GAAG,gCAAgC,CAAC,cAAc,EAAE,IAAI,EAAE,GAAG,EAAE,cAAc,CAAC,CAAC;YAE9F,IAAI,CAAC,SAAS,IAAI,KAAK,EAAE;gBACxB,0BAA0B;gBAC1B,MAAM;aACN;YAED,KAAK,GAAG,SAAS,CAAC;YAElB,0BAA0B;YAC1B,IAAI,UAAU,IAAI,CAAC,EAAE;gBACpB,MAAM;aACN;YACD,cAAc,GAAG,UAAU,CAAC;SAC5B;QAED,IAAI,KAAK,EAAE;YACV,MAAM,MAAM,GAAG;gBACd,IAAI,EAAE,KAAK,CAAC,CAAC,CAAC;gBACd,WAAW,EAAE,UAAU,GAAG,CAAC,GAAG,KAAK,CAAC,KAAM;gBAC1C,SAAS,EAAE,UAAU,GAAG,CAAC,GAAG,KAAK,CAAC,KAAM,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,MAAM;aAC1D,CAAC;YACF,cAAc,CAAC,SAAS,GAAG,CAAC,CAAC;YAC7B,OAAO,MAAM,CAAC;SACd;QAED,OAAO,IAAI,CAAC;IACb,CAAC;IA9DD,kBA8DC;IAED,SAAS,gCAAgC,CAAC,cAAsB,EAAE,IAAY,EAAE,GAAW,EAAE,OAAe;QAC3G,IAAI,KAA6B,CAAC;QAClC,OAAO,KAAK,GAAG,cAAc,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE;YACzC,MAAM,UAAU,GAAG,KAAK,CAAC,KAAK,IAAI,CAAC,CAAC;YACpC,IAAI,UAAU,IAAI,GAAG,IAAI,cAAc,CAAC,SAAS,IAAI,GAAG,EAAE;gBACzD,OAAO,KAAK,CAAC;aACb;iBAAM,IAAI,OAAO,GAAG,CAAC,IAAI,UAAU,GAAG,OAAO,EAAE;gBAC/C,OAAO,IAAI,CAAC;aACZ;SACD;QACD,OAAO,IAAI,CAAC;IACb,CAAC","file":"wordHelper.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Iterable } from 'vs/base/common/iterator';\nimport { toDisposable } from 'vs/base/common/lifecycle';\nimport { LinkedList } from 'vs/base/common/linkedList';\n\nexport const USUAL_WORD_SEPARATORS = '`~!@#$%^&*()-=+[{]}\\\\|;:\\'\",.<>/?';\n\n/**\n * Word inside a model.\n */\nexport interface IWordAtPosition {\n\t/**\n\t * The word.\n\t */\n\treadonly word: string;\n\t/**\n\t * The column where the word starts.\n\t */\n\treadonly startColumn: number;\n\t/**\n\t * The column where the word ends.\n\t */\n\treadonly endColumn: number;\n}\n\n/**\n * Create a word definition regular expression based on default word separators.\n * Optionally provide allowed separators that should be included in words.\n *\n * The default would look like this:\n * /(-?\\d*\\.\\d\\w*)|([^\\`\\~\\!\\@\\#\\$\\%\\^\\&\\*\\(\\)\\-\\=\\+\\[\\{\\]\\}\\\\\\|\\;\\:\\'\\\"\\,\\.\\<\\>\\/\\?\\s]+)/g\n */\nfunction createWordRegExp(allowInWords: string = ''): RegExp {\n\tlet source = '(-?\\\\d*\\\\.\\\\d\\\\w*)|([^';\n\tfor (const sep of USUAL_WORD_SEPARATORS) {\n\t\tif (allowInWords.indexOf(sep) >= 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tsource += '\\\\' + sep;\n\t}\n\tsource += '\\\\s]+)';\n\treturn new RegExp(source, 'g');\n}\n\n// catches numbers (including floating numbers) in the first group, and alphanum in the second\nexport const DEFAULT_WORD_REGEXP = createWordRegExp();\n\nexport function ensureValidWordDefinition(wordDefinition?: RegExp | null): RegExp {\n\tlet result: RegExp = DEFAULT_WORD_REGEXP;\n\n\tif (wordDefinition && (wordDefinition instanceof RegExp)) {\n\t\tif (!wordDefinition.global) {\n\t\t\tlet flags = 'g';\n\t\t\tif (wordDefinition.ignoreCase) {\n\t\t\t\tflags += 'i';\n\t\t\t}\n\t\t\tif (wordDefinition.multiline) {\n\t\t\t\tflags += 'm';\n\t\t\t}\n\t\t\tif (wordDefinition.unicode) {\n\t\t\t\tflags += 'u';\n\t\t\t}\n\t\t\tresult = new RegExp(wordDefinition.source, flags);\n\t\t} else {\n\t\t\tresult = wordDefinition;\n\t\t}\n\t}\n\n\tresult.lastIndex = 0;\n\n\treturn result;\n}\n\n\nexport interface IGetWordAtTextConfig {\n\tmaxLen: number;\n\twindowSize: number;\n\ttimeBudget: number;\n}\n\n\nconst _defaultConfig = new LinkedList<IGetWordAtTextConfig>();\n_defaultConfig.unshift({\n\tmaxLen: 1000,\n\twindowSize: 15,\n\ttimeBudget: 150\n});\n\nexport function setDefaultGetWordAtTextConfig(value: IGetWordAtTextConfig) {\n\tconst rm = _defaultConfig.unshift(value);\n\treturn toDisposable(rm);\n}\n\nexport function getWordAtText(column: number, wordDefinition: RegExp, text: string, textOffset: number, config?: IGetWordAtTextConfig): IWordAtPosition | null {\n\n\tif (!config) {\n\t\tconfig = Iterable.first(_defaultConfig)!;\n\t}\n\n\tif (text.length > config.maxLen) {\n\t\t// don't throw strings that long at the regexp\n\t\t// but use a sub-string in which a word must occur\n\t\tlet start = column - config.maxLen / 2;\n\t\tif (start < 0) {\n\t\t\tstart = 0;\n\t\t} else {\n\t\t\ttextOffset += start;\n\t\t}\n\t\ttext = text.substring(start, column + config.maxLen / 2);\n\t\treturn getWordAtText(column, wordDefinition, text, textOffset, config);\n\t}\n\n\tconst t1 = Date.now();\n\tconst pos = column - 1 - textOffset;\n\n\tlet prevRegexIndex = -1;\n\tlet match: RegExpExecArray | null = null;\n\n\tfor (let i = 1; ; i++) {\n\t\t// check time budget\n\t\tif (Date.now() - t1 >= config.timeBudget) {\n\t\t\tbreak;\n\t\t}\n\n\t\t// reset the index at which the regexp should start matching, also know where it\n\t\t// should stop so that subsequent search don't repeat previous searches\n\t\tconst regexIndex = pos - config.windowSize * i;\n\t\twordDefinition.lastIndex = Math.max(0, regexIndex);\n\t\tconst thisMatch = _findRegexMatchEnclosingPosition(wordDefinition, text, pos, prevRegexIndex);\n\n\t\tif (!thisMatch && match) {\n\t\t\t// stop: we have something\n\t\t\tbreak;\n\t\t}\n\n\t\tmatch = thisMatch;\n\n\t\t// stop: searched at start\n\t\tif (regexIndex <= 0) {\n\t\t\tbreak;\n\t\t}\n\t\tprevRegexIndex = regexIndex;\n\t}\n\n\tif (match) {\n\t\tconst result = {\n\t\t\tword: match[0],\n\t\t\tstartColumn: textOffset + 1 + match.index!,\n\t\t\tendColumn: textOffset + 1 + match.index! + match[0].length\n\t\t};\n\t\twordDefinition.lastIndex = 0;\n\t\treturn result;\n\t}\n\n\treturn null;\n}\n\nfunction _findRegexMatchEnclosingPosition(wordDefinition: RegExp, text: string, pos: number, stopPos: number): RegExpExecArray | null {\n\tlet match: RegExpExecArray | null;\n\twhile (match = wordDefinition.exec(text)) {\n\t\tconst matchIndex = match.index || 0;\n\t\tif (matchIndex <= pos && wordDefinition.lastIndex >= pos) {\n\t\t\treturn match;\n\t\t} else if (stopPos > 0 && matchIndex > stopPos) {\n\t\t\treturn null;\n\t\t}\n\t}\n\treturn null;\n}\n"]}