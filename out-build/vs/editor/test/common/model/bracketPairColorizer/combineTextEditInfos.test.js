/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(["require", "exports", "assert", "vs/base/test/common/utils", "vs/editor/common/core/range", "vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/beforeEditPositionMapper", "vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/combineTextEditInfos", "vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/length", "vs/editor/test/common/testTextModel"], function (require, exports, assert, utils_1, range_1, beforeEditPositionMapper_1, combineTextEditInfos_1, length_1, testTextModel_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    suite('combineTextEditInfos', () => {
        (0, utils_1.$bT)();
        for (let seed = 0; seed < 50; seed++) {
            test('test' + seed, () => {
                runTest(seed);
            });
        }
    });
    function runTest(seed) {
        const rng = new MersenneTwister(seed);
        const str = 'abcde\nfghij\nklmno\npqrst\n';
        const textModelS0 = (0, testTextModel_1.$O0b)(str);
        const edits1 = getRandomEditInfos(textModelS0, rng.nextIntRange(1, 4), rng);
        const textModelS1 = (0, testTextModel_1.$O0b)(textModelS0.getValue());
        textModelS1.applyEdits(edits1.map(e => toEdit(e)));
        const edits2 = getRandomEditInfos(textModelS1, rng.nextIntRange(1, 4), rng);
        const textModelS2 = (0, testTextModel_1.$O0b)(textModelS1.getValue());
        textModelS2.applyEdits(edits2.map(e => toEdit(e)));
        const combinedEdits = (0, combineTextEditInfos_1.$OA)(edits1, edits2);
        for (const edit of combinedEdits) {
            const range = range_1.$ks.fromPositions((0, length_1.$Ct)(edit.startOffset), (0, length_1.$Ct)((0, length_1.$vt)(edit.startOffset, edit.newLength)));
            const value = textModelS2.getValueInRange(range);
            if (!value.match(/^(L|C|\n)*$/)) {
                throw new Error('Invalid edit: ' + value);
            }
            textModelS2.applyEdits([{
                    range,
                    text: textModelS0.getValueInRange(range_1.$ks.fromPositions((0, length_1.$Ct)(edit.startOffset), (0, length_1.$Ct)(edit.endOffset))),
                }]);
        }
        assert.deepStrictEqual(textModelS2.getValue(), textModelS0.getValue());
        textModelS0.dispose();
        textModelS1.dispose();
        textModelS2.dispose();
    }
    function getRandomEditInfos(textModel, count, rng) {
        const edits = [];
        let i = 0;
        for (let j = 0; j < count; j++) {
            edits.push(getRandomEdit(textModel, i, rng));
            i = textModel.getOffsetAt((0, length_1.$Ct)(edits[j].endOffset));
        }
        return edits;
    }
    function getRandomEdit(textModel, rangeOffsetStart, rng) {
        const textModelLength = textModel.getValueLength();
        const offsetStart = rng.nextIntRange(rangeOffsetStart, textModelLength);
        const offsetEnd = rng.nextIntRange(offsetStart, textModelLength);
        const lineCount = rng.nextIntRange(0, 3);
        const columnCount = rng.nextIntRange(0, 5);
        return new beforeEditPositionMapper_1.$IA((0, length_1.$Dt)(textModel.getPositionAt(offsetStart)), (0, length_1.$Dt)(textModel.getPositionAt(offsetEnd)), (0, length_1.$rt)(lineCount, columnCount));
    }
    function toEdit(editInfo) {
        const l = (0, length_1.$st)(editInfo.newLength);
        let text = '';
        for (let i = 0; i < l.lineCount; i++) {
            text += 'LLL\n';
        }
        for (let i = 0; i < l.columnCount; i++) {
            text += 'C';
        }
        return {
            range: range_1.$ks.fromPositions((0, length_1.$Ct)(editInfo.startOffset), (0, length_1.$Ct)(editInfo.endOffset)),
            text
        };
    }
    // Generated by copilot
    class MersenneTwister {
        constructor(seed) {
            this.a = new Array(624);
            this.b = 0;
            this.a[0] = seed >>> 0;
            for (let i = 1; i < 624; i++) {
                const s = this.a[i - 1] ^ (this.a[i - 1] >>> 30);
                this.a[i] = (((((s & 0xffff0000) >>> 16) * 0x6c078965) << 16) + (s & 0x0000ffff) * 0x6c078965 + i) >>> 0;
            }
        }
        nextInt() {
            if (this.b === 0) {
                this.c();
            }
            let y = this.a[this.b];
            y = y ^ (y >>> 11);
            y = y ^ ((y << 7) & 0x9d2c5680);
            y = y ^ ((y << 15) & 0xefc60000);
            y = y ^ (y >>> 18);
            this.b = (this.b + 1) % 624;
            return y >>> 0;
        }
        nextIntRange(start, endExclusive) {
            const range = endExclusive - start;
            return Math.floor(this.nextInt() / (0x100000000 / range)) + start;
        }
        c() {
            for (let i = 0; i < 624; i++) {
                const y = (this.a[i] & 0x80000000) + (this.a[(i + 1) % 624] & 0x7fffffff);
                this.a[i] = this.a[(i + 397) % 624] ^ (y >>> 1);
                if ((y % 2) !== 0) {
                    this.a[i] = this.a[i] ^ 0x9908b0df;
                }
            }
        }
    }
});
//# sourceMappingURL=combineTextEditInfos.test.js.map