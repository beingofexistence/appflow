{"version":3,"sources":["file:///workspace/appflow/src/vs/code/electron-main/auth.ts"],"names":[],"mappings":"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","file":"auth.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { app, AuthenticationResponseDetails, AuthInfo, Event as ElectronEvent, WebContents } from 'electron';\nimport { CancellationToken } from 'vs/base/common/cancellation';\nimport { Event } from 'vs/base/common/event';\nimport { hash } from 'vs/base/common/hash';\nimport { Disposable } from 'vs/base/common/lifecycle';\nimport { generateUuid } from 'vs/base/common/uuid';\nimport { IEncryptionMainService } from 'vs/platform/encryption/common/encryptionService';\nimport { ILogService } from 'vs/platform/log/common/log';\nimport { StorageScope, StorageTarget } from 'vs/platform/storage/common/storage';\nimport { IApplicationStorageMainService } from 'vs/platform/storage/electron-main/storageMainService';\nimport { IWindowsMainService } from 'vs/platform/windows/electron-main/windows';\n\ninterface ElectronAuthenticationResponseDetails extends AuthenticationResponseDetails {\n\tfirstAuthAttempt?: boolean; // https://github.com/electron/electron/blob/84a42a050e7d45225e69df5bd2d2bf9f1037ea41/shell/browser/login_handler.cc#L70\n}\n\ntype LoginEvent = {\n\tevent: ElectronEvent;\n\tauthInfo: AuthInfo;\n\treq: ElectronAuthenticationResponseDetails;\n\n\tcallback: (username?: string, password?: string) => void;\n};\n\ntype Credentials = {\n\tusername: string;\n\tpassword: string;\n};\n\nenum ProxyAuthState {\n\n\t/**\n\t * Initial state: we will try to use stored credentials\n\t * first to reply to the auth challenge.\n\t */\n\tInitial = 1,\n\n\t/**\n\t * We used stored credentials and are still challenged,\n\t * so we will show a login dialog next.\n\t */\n\tStoredCredentialsUsed,\n\n\t/**\n\t * Finally, if we showed a login dialog already, we will\n\t * not show any more login dialogs until restart to reduce\n\t * the UI noise.\n\t */\n\tLoginDialogShown\n}\n\nexport class ProxyAuthHandler extends Disposable {\n\n\tprivate readonly PROXY_CREDENTIALS_SERVICE_KEY = 'proxy-credentials://';\n\n\tprivate pendingProxyResolve: Promise<Credentials | undefined> | undefined = undefined;\n\n\tprivate state = ProxyAuthState.Initial;\n\n\tprivate sessionCredentials: Credentials | undefined = undefined;\n\n\tconstructor(\n\t\t@ILogService private readonly logService: ILogService,\n\t\t@IWindowsMainService private readonly windowsMainService: IWindowsMainService,\n\t\t@IEncryptionMainService private readonly encryptionMainService: IEncryptionMainService,\n\t\t@IApplicationStorageMainService private readonly applicationStorageMainService: IApplicationStorageMainService\n\t) {\n\t\tsuper();\n\n\t\tthis.registerListeners();\n\t}\n\n\tprivate registerListeners(): void {\n\t\tconst onLogin = Event.fromNodeEventEmitter<LoginEvent>(app, 'login', (event: ElectronEvent, webContents: WebContents, req: ElectronAuthenticationResponseDetails, authInfo: AuthInfo, callback) => ({ event, webContents, req, authInfo, callback }));\n\t\tthis._register(onLogin(this.onLogin, this));\n\t}\n\n\tprivate async onLogin({ event, authInfo, req, callback }: LoginEvent): Promise<void> {\n\t\tif (!authInfo.isProxy) {\n\t\t\treturn; // only for proxy\n\t\t}\n\n\t\tif (!this.pendingProxyResolve && this.state === ProxyAuthState.LoginDialogShown && req.firstAuthAttempt) {\n\t\t\tthis.logService.trace('auth#onLogin (proxy) - exit - proxy dialog already shown');\n\n\t\t\treturn; // only one dialog per session at max (except when firstAuthAttempt: false which indicates a login problem)\n\t\t}\n\n\t\t// Signal we handle this event on our own, otherwise\n\t\t// Electron will ignore our provided credentials.\n\t\tevent.preventDefault();\n\n\t\tlet credentials: Credentials | undefined = undefined;\n\t\tif (!this.pendingProxyResolve) {\n\t\t\tthis.logService.trace('auth#onLogin (proxy) - no pending proxy handling found, starting new');\n\n\t\t\tthis.pendingProxyResolve = this.resolveProxyCredentials(authInfo);\n\t\t\ttry {\n\t\t\t\tcredentials = await this.pendingProxyResolve;\n\t\t\t} finally {\n\t\t\t\tthis.pendingProxyResolve = undefined;\n\t\t\t}\n\t\t} else {\n\t\t\tthis.logService.trace('auth#onLogin (proxy) - pending proxy handling found');\n\n\t\t\tcredentials = await this.pendingProxyResolve;\n\t\t}\n\n\t\t// According to Electron docs, it is fine to call back without\n\t\t// username or password to signal that the authentication was handled\n\t\t// by us, even though without having credentials received:\n\t\t//\n\t\t// > If `callback` is called without a username or password, the authentication\n\t\t// > request will be cancelled and the authentication error will be returned to the\n\t\t// > page.\n\t\tcallback(credentials?.username, credentials?.password);\n\t}\n\n\tprivate async resolveProxyCredentials(authInfo: AuthInfo): Promise<Credentials | undefined> {\n\t\tthis.logService.trace('auth#resolveProxyCredentials (proxy) - enter');\n\n\t\ttry {\n\t\t\tconst credentials = await this.doResolveProxyCredentials(authInfo);\n\t\t\tif (credentials) {\n\t\t\t\tthis.logService.trace('auth#resolveProxyCredentials (proxy) - got credentials');\n\n\t\t\t\treturn credentials;\n\t\t\t} else {\n\t\t\t\tthis.logService.trace('auth#resolveProxyCredentials (proxy) - did not get credentials');\n\t\t\t}\n\t\t} finally {\n\t\t\tthis.logService.trace('auth#resolveProxyCredentials (proxy) - exit');\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tprivate async doResolveProxyCredentials(authInfo: AuthInfo): Promise<Credentials | undefined> {\n\t\tthis.logService.trace('auth#doResolveProxyCredentials - enter', authInfo);\n\n\t\t// Compute a hash over the authentication info to be used\n\t\t// with the credentials store to return the right credentials\n\t\t// given the properties of the auth request\n\t\t// (see https://github.com/microsoft/vscode/issues/109497)\n\t\tconst authInfoHash = String(hash({ scheme: authInfo.scheme, host: authInfo.host, port: authInfo.port }));\n\n\t\tlet storedUsername: string | undefined;\n\t\tlet storedPassword: string | undefined;\n\t\ttry {\n\t\t\t// Try to find stored credentials for the given auth info\n\t\t\tconst encryptedValue = this.applicationStorageMainService.get(this.PROXY_CREDENTIALS_SERVICE_KEY + authInfoHash, StorageScope.APPLICATION);\n\t\t\tif (encryptedValue) {\n\t\t\t\tconst credentials: Credentials = JSON.parse(await this.encryptionMainService.decrypt(encryptedValue));\n\t\t\t\tstoredUsername = credentials.username;\n\t\t\t\tstoredPassword = credentials.password;\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthis.logService.error(error); // handle errors by asking user for login via dialog\n\t\t}\n\n\t\t// Reply with stored credentials unless we used them already.\n\t\t// In that case we need to show a login dialog again because\n\t\t// they seem invalid.\n\t\tif (this.state !== ProxyAuthState.StoredCredentialsUsed && typeof storedUsername === 'string' && typeof storedPassword === 'string') {\n\t\t\tthis.logService.trace('auth#doResolveProxyCredentials (proxy) - exit - found stored credentials to use');\n\t\t\tthis.state = ProxyAuthState.StoredCredentialsUsed;\n\n\t\t\treturn { username: storedUsername, password: storedPassword };\n\t\t}\n\n\t\t// Find suitable window to show dialog: prefer to show it in the\n\t\t// active window because any other network request will wait on\n\t\t// the credentials and we want the user to present the dialog.\n\t\tconst window = this.windowsMainService.getFocusedWindow() || this.windowsMainService.getLastActiveWindow();\n\t\tif (!window) {\n\t\t\tthis.logService.trace('auth#doResolveProxyCredentials (proxy) - exit - no opened window found to show dialog in');\n\n\t\t\treturn undefined; // unexpected\n\t\t}\n\n\t\tthis.logService.trace(`auth#doResolveProxyCredentials (proxy) - asking window ${window.id} to handle proxy login`);\n\n\t\t// Open proxy dialog\n\t\tconst payload = {\n\t\t\tauthInfo,\n\t\t\tusername: this.sessionCredentials?.username ?? storedUsername, // prefer to show already used username (if any) over stored\n\t\t\tpassword: this.sessionCredentials?.password ?? storedPassword, // prefer to show already used password (if any) over stored\n\t\t\treplyChannel: `vscode:proxyAuthResponse:${generateUuid()}`\n\t\t};\n\t\twindow.sendWhenReady('vscode:openProxyAuthenticationDialog', CancellationToken.None, payload);\n\t\tthis.state = ProxyAuthState.LoginDialogShown;\n\n\t\t// Handle reply\n\t\tconst loginDialogCredentials = await new Promise<Credentials | undefined>(resolve => {\n\t\t\tconst proxyAuthResponseHandler = async (event: ElectronEvent, channel: string, reply: Credentials & { remember: boolean } | undefined /* canceled */) => {\n\t\t\t\tif (channel === payload.replyChannel) {\n\t\t\t\t\tthis.logService.trace(`auth#doResolveProxyCredentials - exit - received credentials from window ${window.id}`);\n\t\t\t\t\twindow.win?.webContents.off('ipc-message', proxyAuthResponseHandler);\n\n\t\t\t\t\t// We got credentials from the window\n\t\t\t\t\tif (reply) {\n\t\t\t\t\t\tconst credentials: Credentials = { username: reply.username, password: reply.password };\n\n\t\t\t\t\t\t// Update stored credentials based on `remember` flag\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tif (reply.remember) {\n\t\t\t\t\t\t\t\tconst encryptedSerializedCredentials = await this.encryptionMainService.encrypt(JSON.stringify(credentials));\n\t\t\t\t\t\t\t\tthis.applicationStorageMainService.store(\n\t\t\t\t\t\t\t\t\tthis.PROXY_CREDENTIALS_SERVICE_KEY + authInfoHash,\n\t\t\t\t\t\t\t\t\tencryptedSerializedCredentials,\n\t\t\t\t\t\t\t\t\tStorageScope.APPLICATION,\n\t\t\t\t\t\t\t\t\t// Always store in machine scope because we do not want these values to be synced\n\t\t\t\t\t\t\t\t\tStorageTarget.MACHINE\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.applicationStorageMainService.remove(this.PROXY_CREDENTIALS_SERVICE_KEY + authInfoHash, StorageScope.APPLICATION);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\tthis.logService.error(error); // handle gracefully\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tresolve({ username: credentials.username, password: credentials.password });\n\t\t\t\t\t}\n\n\t\t\t\t\t// We did not get any credentials from the window (e.g. cancelled)\n\t\t\t\t\telse {\n\t\t\t\t\t\tresolve(undefined);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\twindow.win?.webContents.on('ipc-message', proxyAuthResponseHandler);\n\t\t});\n\n\t\t// Remember credentials for the session in case\n\t\t// the credentials are wrong and we show the dialog\n\t\t// again\n\t\tthis.sessionCredentials = loginDialogCredentials;\n\n\t\treturn loginDialogCredentials;\n\t}\n}\n"]}