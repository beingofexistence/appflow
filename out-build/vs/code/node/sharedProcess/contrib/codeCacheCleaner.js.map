{"version":3,"sources":["file:///workspace/appflow/src/vs/code/node/sharedProcess/contrib/codeCacheCleaner.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;;;;;;;;;;IAUzF,IAAM,IAAI,GAAV,MAAM,IAAiB,SAAQ,eAAG;QAMxC,YACC,oBAAwC,EACvB,CAAoC,EACxC,CAAgC;YAE7C,KAAK,EAAE,CAAC;YAH0B,MAAC,GAAD,CAAC,CAAkB;YACvB,MAAC,GAAD,CAAC,CAAc;YAP7B,MAAC,GAAa,IAAI,CAAC,CAAC,CAAc,OAAO,KAAK,QAAQ;gBACtE,CAAC,CAAC,IAAI,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC,CAAG,4BAA4B;gBACxD,CAAC,CAAC,IAAI,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC,CAAC,4BAA4B;YAS5D,0EAA0E;YAC1E,6EAA6E;YAC7E,iCAAiC;YACjC,IAAI,oBAAoB,EAAE;gBACzB,MAAM,SAAS,GAAG,IAAI,CAAC,CAAC,CAAS,IAAI,WAAG,CAAc,GAAG,EAAE;oBAC1D,IAAI,CAAC,CAAC,CAAiB,oBAAoB,CAAC,CAAC;gBAC9C,CAAC,EAAE,EAAE,GAAG,IAAI,CAAC,eAAe,CAAC,CAAC,CAAC;gBAC/B,SAAS,CAAC,QAAQ,EAAE,CAAC;aACrB;QACF,CAAC;QAEO,KAAK,CAAC,CAAC,CAAiB,oBAA4B;YAC3D,IAAI,CAAC,CAAC,CAAU,KAAK,CAAC,oEAAoE,CAAC,CAAC;YAE5F,IAAI;gBACH,MAAM,GAAG,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;gBAEvB,oDAAoD;gBACpD,gDAAgD;gBAChD,MAAM,iBAAiB,GAAG,IAAA,UAAG,EAAK,oBAAoB,CAAC,CAAC;gBACxD,MAAM,gBAAgB,GAAG,IAAA,UAAG,EAAM,oBAAoB,CAAC,CAAC;gBAExD,MAAM,UAAU,GAAG,MAAM,cAAQ,CAAC,OAAO,CAAC,iBAAiB,CAAC,CAAC;gBAC7D,MAAM,OAAO,CAAC,GAAG,CAAC,UAAU,CAAC,GAAG,CAAC,KAAK,EAAC,SAAS,EAAC,EAAE;oBAClD,IAAI,SAAS,KAAK,gBAAgB,EAAE;wBACnC,OAAO,CAAC,+BAA+B;qBACvC;oBAED,oCAAoC;oBACpC,MAAM,kBAAkB,GAAG,IAAA,UAAG,EAAE,iBAAiB,EAAE,SAAS,CAAC,CAAC;oBAC9D,MAAM,kBAAkB,GAAG,MAAM,cAAQ,CAAC,IAAI,CAAC,kBAAkB,CAAC,CAAC;oBACnE,IAAI,kBAAkB,CAAC,WAAW,EAAE,IAAI,CAAC,GAAG,GAAG,kBAAkB,CAAC,KAAK,CAAC,OAAO,EAAE,CAAC,GAAG,IAAI,CAAC,CAAC,EAAY;wBACtG,IAAI,CAAC,CAAC,CAAU,KAAK,CAAC,oDAAoD,SAAS,GAAG,CAAC,CAAC;wBAExF,OAAO,cAAQ,CAAC,EAAE,CAAC,kBAAkB,CAAC,CAAC;qBACvC;gBACF,CAAC,CAAC,CAAC,CAAC;aACJ;YAAC,OAAO,KAAK,EAAE;gBACf,IAAA,WAAE,EAAgB,KAAK,CAAC,CAAC;aACzB;QACF,CAAC;KACD,CAAA;IAtDY,oBAAI;mBAAJ,IAAI;QAQd,WAAA,oBAAG,CAAA;QACH,WAAA,SAAG,CAAA;OATO,IAAI,CAsDhB","file":"codeCacheCleaner.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { RunOnceScheduler } from 'vs/base/common/async';\nimport { onUnexpectedError } from 'vs/base/common/errors';\nimport { Disposable } from 'vs/base/common/lifecycle';\nimport { basename, dirname, join } from 'vs/base/common/path';\nimport { Promises } from 'vs/base/node/pfs';\nimport { ILogService } from 'vs/platform/log/common/log';\nimport { IProductService } from 'vs/platform/product/common/productService';\n\nexport class CodeCacheCleaner extends Disposable {\n\n\tprivate readonly _DataMaxAge = this.productService.quality !== 'stable'\n\t\t? 1000 * 60 * 60 * 24 * 7 \t\t// roughly 1 week (insiders)\n\t\t: 1000 * 60 * 60 * 24 * 30 * 3; // roughly 3 months (stable)\n\n\tconstructor(\n\t\tcurrentCodeCachePath: string | undefined,\n\t\t@IProductService private readonly productService: IProductService,\n\t\t@ILogService private readonly logService: ILogService\n\t) {\n\t\tsuper();\n\n\t\t// Cached data is stored as user data and we run a cleanup task every time\n\t\t// the editor starts. The strategy is to delete all files that are older than\n\t\t// 3 months (1 week respectively)\n\t\tif (currentCodeCachePath) {\n\t\t\tconst scheduler = this._register(new RunOnceScheduler(() => {\n\t\t\t\tthis.cleanUpCodeCaches(currentCodeCachePath);\n\t\t\t}, 30 * 1000 /* after 30s */));\n\t\t\tscheduler.schedule();\n\t\t}\n\t}\n\n\tprivate async cleanUpCodeCaches(currentCodeCachePath: string): Promise<void> {\n\t\tthis.logService.trace('[code cache cleanup]: Starting to clean up old code cache folders.');\n\n\t\ttry {\n\t\t\tconst now = Date.now();\n\n\t\t\t// The folder which contains folders of cached data.\n\t\t\t// Each of these folders is partioned per commit\n\t\t\tconst codeCacheRootPath = dirname(currentCodeCachePath);\n\t\t\tconst currentCodeCache = basename(currentCodeCachePath);\n\n\t\t\tconst codeCaches = await Promises.readdir(codeCacheRootPath);\n\t\t\tawait Promise.all(codeCaches.map(async codeCache => {\n\t\t\t\tif (codeCache === currentCodeCache) {\n\t\t\t\t\treturn; // not the current cache folder\n\t\t\t\t}\n\n\t\t\t\t// Delete cache folder if old enough\n\t\t\t\tconst codeCacheEntryPath = join(codeCacheRootPath, codeCache);\n\t\t\t\tconst codeCacheEntryStat = await Promises.stat(codeCacheEntryPath);\n\t\t\t\tif (codeCacheEntryStat.isDirectory() && (now - codeCacheEntryStat.mtime.getTime()) > this._DataMaxAge) {\n\t\t\t\t\tthis.logService.trace(`[code cache cleanup]: Removing code cache folder ${codeCache}.`);\n\n\t\t\t\t\treturn Promises.rm(codeCacheEntryPath);\n\t\t\t\t}\n\t\t\t}));\n\t\t} catch (error) {\n\t\t\tonUnexpectedError(error);\n\t\t}\n\t}\n}\n"]}