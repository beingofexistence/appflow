{"version":3,"sources":["file:///workspace/appflow/src/vs/server/node/serverConnectionToken.ts"],"names":[],"mappings":"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","file":"serverConnectionToken.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as cookie from 'cookie';\nimport * as fs from 'fs';\nimport * as http from 'http';\nimport * as url from 'url';\nimport * as path from 'vs/base/common/path';\nimport { generateUuid } from 'vs/base/common/uuid';\nimport { connectionTokenCookieName, connectionTokenQueryName } from 'vs/base/common/network';\nimport { ServerParsedArgs } from 'vs/server/node/serverEnvironmentService';\nimport { Promises } from 'vs/base/node/pfs';\n\nconst connectionTokenRegex = /^[0-9A-Za-z_-]+$/;\n\nexport const enum ServerConnectionTokenType {\n\tNone,\n\tOptional,// TODO: Remove this soon\n\tMandatory\n}\n\nexport class NoneServerConnectionToken {\n\tpublic readonly type = ServerConnectionTokenType.None;\n\n\tpublic validate(connectionToken: any): boolean {\n\t\treturn true;\n\t}\n}\n\nexport class MandatoryServerConnectionToken {\n\tpublic readonly type = ServerConnectionTokenType.Mandatory;\n\n\tconstructor(public readonly value: string) {\n\t}\n\n\tpublic validate(connectionToken: any): boolean {\n\t\treturn (connectionToken === this.value);\n\t}\n}\n\nexport type ServerConnectionToken = NoneServerConnectionToken | MandatoryServerConnectionToken;\n\nexport class ServerConnectionTokenParseError {\n\tconstructor(\n\t\tpublic readonly message: string\n\t) { }\n}\n\nexport async function parseServerConnectionToken(args: ServerParsedArgs, defaultValue: () => Promise<string>): Promise<ServerConnectionToken | ServerConnectionTokenParseError> {\n\tconst withoutConnectionToken = args['without-connection-token'];\n\tconst connectionToken = args['connection-token'];\n\tconst connectionTokenFile = args['connection-token-file'];\n\n\tif (withoutConnectionToken) {\n\t\tif (typeof connectionToken !== 'undefined' || typeof connectionTokenFile !== 'undefined') {\n\t\t\treturn new ServerConnectionTokenParseError(`Please do not use the argument '--connection-token' or '--connection-token-file' at the same time as '--without-connection-token'.`);\n\t\t}\n\t\treturn new NoneServerConnectionToken();\n\t}\n\n\tif (typeof connectionTokenFile !== 'undefined') {\n\t\tif (typeof connectionToken !== 'undefined') {\n\t\t\treturn new ServerConnectionTokenParseError(`Please do not use the argument '--connection-token' at the same time as '--connection-token-file'.`);\n\t\t}\n\n\t\tlet rawConnectionToken: string;\n\t\ttry {\n\t\t\trawConnectionToken = fs.readFileSync(connectionTokenFile).toString().replace(/\\r?\\n$/, '');\n\t\t} catch (e) {\n\t\t\treturn new ServerConnectionTokenParseError(`Unable to read the connection token file at '${connectionTokenFile}'.`);\n\t\t}\n\n\t\tif (!connectionTokenRegex.test(rawConnectionToken)) {\n\t\t\treturn new ServerConnectionTokenParseError(`The connection token defined in '${connectionTokenFile} does not adhere to the characters 0-9, a-z, A-Z, _, or -.`);\n\t\t}\n\n\t\treturn new MandatoryServerConnectionToken(rawConnectionToken);\n\t}\n\n\tif (typeof connectionToken !== 'undefined') {\n\t\tif (!connectionTokenRegex.test(connectionToken)) {\n\t\t\treturn new ServerConnectionTokenParseError(`The connection token '${connectionToken} does not adhere to the characters 0-9, a-z, A-Z or -.`);\n\t\t}\n\n\t\treturn new MandatoryServerConnectionToken(connectionToken);\n\t}\n\n\treturn new MandatoryServerConnectionToken(await defaultValue());\n}\n\nexport async function determineServerConnectionToken(args: ServerParsedArgs): Promise<ServerConnectionToken | ServerConnectionTokenParseError> {\n\tconst readOrGenerateConnectionToken = async () => {\n\t\tif (!args['user-data-dir']) {\n\t\t\t// No place to store it!\n\t\t\treturn generateUuid();\n\t\t}\n\t\tconst storageLocation = path.join(args['user-data-dir'], 'token');\n\n\t\t// First try to find a connection token\n\t\ttry {\n\t\t\tconst fileContents = await Promises.readFile(storageLocation);\n\t\t\tconst connectionToken = fileContents.toString().replace(/\\r?\\n$/, '');\n\t\t\tif (connectionTokenRegex.test(connectionToken)) {\n\t\t\t\treturn connectionToken;\n\t\t\t}\n\t\t} catch (err) { }\n\n\t\t// No connection token found, generate one\n\t\tconst connectionToken = generateUuid();\n\n\t\ttry {\n\t\t\t// Try to store it\n\t\t\tawait Promises.writeFile(storageLocation, connectionToken, { mode: 0o600 });\n\t\t} catch (err) { }\n\n\t\treturn connectionToken;\n\t};\n\treturn parseServerConnectionToken(args, readOrGenerateConnectionToken);\n}\n\nexport function requestHasValidConnectionToken(connectionToken: ServerConnectionToken, req: http.IncomingMessage, parsedUrl: url.UrlWithParsedQuery) {\n\t// First check if there is a valid query parameter\n\tif (connectionToken.validate(parsedUrl.query[connectionTokenQueryName])) {\n\t\treturn true;\n\t}\n\n\t// Otherwise, check if there is a valid cookie\n\tconst cookies = cookie.parse(req.headers.cookie || '');\n\treturn connectionToken.validate(cookies[connectionTokenCookieName]);\n}\n"]}