{"version":3,"sources":["file:///workspace/appflow/src/vs/server/node/remoteExtensionManagement.ts"],"names":[],"mappings":"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","file":"remoteExtensionManagement.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { PersistentProtocol, ProtocolConstants, ISocket } from 'vs/base/parts/ipc/common/ipc.net';\nimport { ILogService } from 'vs/platform/log/common/log';\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { VSBuffer } from 'vs/base/common/buffer';\nimport { ProcessTimeRunOnceScheduler } from 'vs/base/common/async';\n\nfunction printTime(ms: number): string {\n\tlet h = 0;\n\tlet m = 0;\n\tlet s = 0;\n\tif (ms >= 1000) {\n\t\ts = Math.floor(ms / 1000);\n\t\tms -= s * 1000;\n\t}\n\tif (s >= 60) {\n\t\tm = Math.floor(s / 60);\n\t\ts -= m * 60;\n\t}\n\tif (m >= 60) {\n\t\th = Math.floor(m / 60);\n\t\tm -= h * 60;\n\t}\n\tconst _h = h ? `${h}h` : ``;\n\tconst _m = m ? `${m}m` : ``;\n\tconst _s = s ? `${s}s` : ``;\n\tconst _ms = ms ? `${ms}ms` : ``;\n\treturn `${_h}${_m}${_s}${_ms}`;\n}\n\nexport class ManagementConnection {\n\n\tprivate _onClose = new Emitter<void>();\n\tpublic readonly onClose: Event<void> = this._onClose.event;\n\n\tprivate readonly _reconnectionGraceTime: number;\n\tprivate readonly _reconnectionShortGraceTime: number;\n\tprivate _remoteAddress: string;\n\n\tpublic readonly protocol: PersistentProtocol;\n\tprivate _disposed: boolean;\n\tprivate _disconnectRunner1: ProcessTimeRunOnceScheduler;\n\tprivate _disconnectRunner2: ProcessTimeRunOnceScheduler;\n\n\tconstructor(\n\t\tprivate readonly _logService: ILogService,\n\t\tprivate readonly _reconnectionToken: string,\n\t\tremoteAddress: string,\n\t\tprotocol: PersistentProtocol\n\t) {\n\t\tthis._reconnectionGraceTime = ProtocolConstants.ReconnectionGraceTime;\n\t\tthis._reconnectionShortGraceTime = ProtocolConstants.ReconnectionShortGraceTime;\n\t\tthis._remoteAddress = remoteAddress;\n\n\t\tthis.protocol = protocol;\n\t\tthis._disposed = false;\n\t\tthis._disconnectRunner1 = new ProcessTimeRunOnceScheduler(() => {\n\t\t\tthis._log(`The reconnection grace time of ${printTime(this._reconnectionGraceTime)} has expired, so the connection will be disposed.`);\n\t\t\tthis._cleanResources();\n\t\t}, this._reconnectionGraceTime);\n\t\tthis._disconnectRunner2 = new ProcessTimeRunOnceScheduler(() => {\n\t\t\tthis._log(`The reconnection short grace time of ${printTime(this._reconnectionShortGraceTime)} has expired, so the connection will be disposed.`);\n\t\t\tthis._cleanResources();\n\t\t}, this._reconnectionShortGraceTime);\n\n\t\tthis.protocol.onDidDispose(() => {\n\t\t\tthis._log(`The client has disconnected gracefully, so the connection will be disposed.`);\n\t\t\tthis._cleanResources();\n\t\t});\n\t\tthis.protocol.onSocketClose(() => {\n\t\t\tthis._log(`The client has disconnected, will wait for reconnection ${printTime(this._reconnectionGraceTime)} before disposing...`);\n\t\t\t// The socket has closed, let's give the renderer a certain amount of time to reconnect\n\t\t\tthis._disconnectRunner1.schedule();\n\t\t});\n\n\t\tthis._log(`New connection established.`);\n\t}\n\n\tprivate _log(_str: string): void {\n\t\tthis._logService.info(`[${this._remoteAddress}][${this._reconnectionToken.substr(0, 8)}][ManagementConnection] ${_str}`);\n\t}\n\n\tpublic shortenReconnectionGraceTimeIfNecessary(): void {\n\t\tif (this._disconnectRunner2.isScheduled()) {\n\t\t\t// we are disconnected and already running the short reconnection timer\n\t\t\treturn;\n\t\t}\n\t\tif (this._disconnectRunner1.isScheduled()) {\n\t\t\tthis._log(`Another client has connected, will shorten the wait for reconnection ${printTime(this._reconnectionShortGraceTime)} before disposing...`);\n\t\t\t// we are disconnected and running the long reconnection timer\n\t\t\tthis._disconnectRunner2.schedule();\n\t\t}\n\t}\n\n\tprivate _cleanResources(): void {\n\t\tif (this._disposed) {\n\t\t\t// already called\n\t\t\treturn;\n\t\t}\n\t\tthis._disposed = true;\n\t\tthis._disconnectRunner1.dispose();\n\t\tthis._disconnectRunner2.dispose();\n\t\tconst socket = this.protocol.getSocket();\n\t\tthis.protocol.sendDisconnect();\n\t\tthis.protocol.dispose();\n\t\tsocket.end();\n\t\tthis._onClose.fire(undefined);\n\t}\n\n\tpublic acceptReconnection(remoteAddress: string, socket: ISocket, initialDataChunk: VSBuffer): void {\n\t\tthis._remoteAddress = remoteAddress;\n\t\tthis._log(`The client has reconnected.`);\n\t\tthis._disconnectRunner1.cancel();\n\t\tthis._disconnectRunner2.cancel();\n\t\tthis.protocol.beginAcceptReconnection(socket, initialDataChunk);\n\t\tthis.protocol.endAcceptReconnection();\n\t}\n}\n"]}