{"version":3,"sources":["file:///workspace/appflow/src/vs/workbench/api/node/extHostStoragePaths.ts"],"names":[],"mappings":"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","file":"extHostStoragePaths.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as fs from 'fs';\nimport * as path from 'vs/base/common/path';\nimport { URI } from 'vs/base/common/uri';\nimport { ExtensionStoragePaths as CommonExtensionStoragePaths } from 'vs/workbench/api/common/extHostStoragePaths';\nimport { Disposable } from 'vs/base/common/lifecycle';\nimport { Schemas } from 'vs/base/common/network';\nimport { IntervalTimer, timeout } from 'vs/base/common/async';\nimport { ILogService } from 'vs/platform/log/common/log';\nimport { Promises } from 'vs/base/node/pfs';\n\nexport class ExtensionStoragePaths extends CommonExtensionStoragePaths {\n\n\tprivate _workspaceStorageLock: Lock | null = null;\n\n\tprotected override async _getWorkspaceStorageURI(storageName: string): Promise<URI> {\n\t\tconst workspaceStorageURI = await super._getWorkspaceStorageURI(storageName);\n\t\tif (workspaceStorageURI.scheme !== Schemas.file) {\n\t\t\treturn workspaceStorageURI;\n\t\t}\n\n\t\tif (this._environment.skipWorkspaceStorageLock) {\n\t\t\tthis._logService.info(`Skipping acquiring lock for ${workspaceStorageURI.fsPath}.`);\n\t\t\treturn workspaceStorageURI;\n\t\t}\n\n\t\tconst workspaceStorageBase = workspaceStorageURI.fsPath;\n\t\tlet attempt = 0;\n\t\tdo {\n\t\t\tlet workspaceStoragePath: string;\n\t\t\tif (attempt === 0) {\n\t\t\t\tworkspaceStoragePath = workspaceStorageBase;\n\t\t\t} else {\n\t\t\t\tworkspaceStoragePath = (\n\t\t\t\t\t/[/\\\\]$/.test(workspaceStorageBase)\n\t\t\t\t\t\t? `${workspaceStorageBase.substr(0, workspaceStorageBase.length - 1)}-${attempt}`\n\t\t\t\t\t\t: `${workspaceStorageBase}-${attempt}`\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tawait mkdir(workspaceStoragePath);\n\n\t\t\tconst lockfile = path.join(workspaceStoragePath, 'vscode.lock');\n\t\t\tconst lock = await tryAcquireLock(this._logService, lockfile, false);\n\t\t\tif (lock) {\n\t\t\t\tthis._workspaceStorageLock = lock;\n\t\t\t\tprocess.on('exit', () => {\n\t\t\t\t\tlock.dispose();\n\t\t\t\t});\n\t\t\t\treturn URI.file(workspaceStoragePath);\n\t\t\t}\n\n\t\t\tattempt++;\n\t\t} while (attempt < 10);\n\n\t\t// just give up\n\t\treturn workspaceStorageURI;\n\t}\n\n\toverride onWillDeactivateAll(): void {\n\t\t// the lock will be released soon\n\t\tthis._workspaceStorageLock?.setWillRelease(6000);\n\t}\n}\n\nasync function mkdir(dir: string): Promise<void> {\n\ttry {\n\t\tawait Promises.stat(dir);\n\t\treturn;\n\t} catch {\n\t\t// doesn't exist, that's OK\n\t}\n\n\ttry {\n\t\tawait Promises.mkdir(dir, { recursive: true });\n\t} catch {\n\t}\n}\n\nconst MTIME_UPDATE_TIME = 1000; // 1s\nconst STALE_LOCK_TIME = 10 * 60 * 1000; // 10 minutes\n\nclass Lock extends Disposable {\n\n\tprivate readonly _timer: IntervalTimer;\n\n\tconstructor(\n\t\tprivate readonly logService: ILogService,\n\t\tprivate readonly filename: string\n\t) {\n\t\tsuper();\n\n\t\tthis._timer = this._register(new IntervalTimer());\n\t\tthis._timer.cancelAndSet(async () => {\n\t\t\tconst contents = await readLockfileContents(logService, filename);\n\t\t\tif (!contents || contents.pid !== process.pid) {\n\t\t\t\t// we don't hold the lock anymore ...\n\t\t\t\tlogService.info(`Lock '${filename}': The lock was lost unexpectedly.`);\n\t\t\t\tthis._timer.cancel();\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tawait Promises.utimes(filename, new Date(), new Date());\n\t\t\t} catch (err) {\n\t\t\t\tlogService.error(err);\n\t\t\t\tlogService.info(`Lock '${filename}': Could not update mtime.`);\n\t\t\t}\n\t\t}, MTIME_UPDATE_TIME);\n\t}\n\n\tpublic override dispose(): void {\n\t\tsuper.dispose();\n\t\ttry { fs.unlinkSync(this.filename); } catch (err) { }\n\t}\n\n\tpublic async setWillRelease(timeUntilReleaseMs: number): Promise<void> {\n\t\tthis.logService.info(`Lock '${this.filename}': Marking the lockfile as scheduled to be released in ${timeUntilReleaseMs} ms.`);\n\t\ttry {\n\t\t\tconst contents: ILockfileContents = {\n\t\t\t\tpid: process.pid,\n\t\t\t\twillReleaseAt: Date.now() + timeUntilReleaseMs\n\t\t\t};\n\t\t\tawait Promises.writeFile(this.filename, JSON.stringify(contents), { flag: 'w' });\n\t\t} catch (err) {\n\t\t\tthis.logService.error(err);\n\t\t}\n\t}\n}\n\n/**\n * Attempt to acquire a lock on a directory.\n * This does not use the real `flock`, but uses a file.\n * @returns a disposable if the lock could be acquired or null if it could not.\n */\nasync function tryAcquireLock(logService: ILogService, filename: string, isSecondAttempt: boolean): Promise<Lock | null> {\n\ttry {\n\t\tconst contents: ILockfileContents = {\n\t\t\tpid: process.pid,\n\t\t\twillReleaseAt: 0\n\t\t};\n\t\tawait Promises.writeFile(filename, JSON.stringify(contents), { flag: 'wx' });\n\t} catch (err) {\n\t\tlogService.error(err);\n\t}\n\n\t// let's see if we got the lock\n\tconst contents = await readLockfileContents(logService, filename);\n\tif (!contents || contents.pid !== process.pid) {\n\t\t// we didn't get the lock\n\t\tif (isSecondAttempt) {\n\t\t\tlogService.info(`Lock '${filename}': Could not acquire lock, giving up.`);\n\t\t\treturn null;\n\t\t}\n\t\tlogService.info(`Lock '${filename}': Could not acquire lock, checking if the file is stale.`);\n\t\treturn checkStaleAndTryAcquireLock(logService, filename);\n\t}\n\n\t// we got the lock\n\tlogService.info(`Lock '${filename}': Lock acquired.`);\n\treturn new Lock(logService, filename);\n}\n\ninterface ILockfileContents {\n\tpid: number;\n\twillReleaseAt: number | undefined;\n}\n\n/**\n * @returns 0 if the pid cannot be read\n */\nasync function readLockfileContents(logService: ILogService, filename: string): Promise<ILockfileContents | null> {\n\tlet contents: Buffer;\n\ttry {\n\t\tcontents = await Promises.readFile(filename);\n\t} catch (err) {\n\t\t// cannot read the file\n\t\tlogService.error(err);\n\t\treturn null;\n\t}\n\n\ttry {\n\t\treturn JSON.parse(String(contents));\n\t} catch (err) {\n\t\t// cannot parse the file\n\t\tlogService.error(err);\n\t\treturn null;\n\t}\n}\n\n/**\n * @returns 0 if the mtime cannot be read\n */\nasync function readmtime(logService: ILogService, filename: string): Promise<number> {\n\tlet stats: fs.Stats;\n\ttry {\n\t\tstats = await Promises.stat(filename);\n\t} catch (err) {\n\t\t// cannot read the file stats to check if it is stale or not\n\t\tlogService.error(err);\n\t\treturn 0;\n\t}\n\treturn stats.mtime.getTime();\n}\n\nfunction processExists(pid: number): boolean {\n\ttry {\n\t\tprocess.kill(pid, 0); // throws an exception if the process doesn't exist anymore.\n\t\treturn true;\n\t} catch (e) {\n\t\treturn false;\n\t}\n}\n\nasync function checkStaleAndTryAcquireLock(logService: ILogService, filename: string): Promise<Lock | null> {\n\tconst contents = await readLockfileContents(logService, filename);\n\tif (!contents) {\n\t\tlogService.info(`Lock '${filename}': Could not read pid of lock holder.`);\n\t\treturn tryDeleteAndAcquireLock(logService, filename);\n\t}\n\n\tif (contents.willReleaseAt) {\n\t\tlet timeUntilRelease = contents.willReleaseAt - Date.now();\n\t\tif (timeUntilRelease < 5000) {\n\t\t\tif (timeUntilRelease > 0) {\n\t\t\t\tlogService.info(`Lock '${filename}': The lockfile is scheduled to be released in ${timeUntilRelease} ms.`);\n\t\t\t} else {\n\t\t\t\tlogService.info(`Lock '${filename}': The lockfile is scheduled to have been released.`);\n\t\t\t}\n\n\t\t\twhile (timeUntilRelease > 0) {\n\t\t\t\tawait timeout(Math.min(100, timeUntilRelease));\n\t\t\t\tconst mtime = await readmtime(logService, filename);\n\t\t\t\tif (mtime === 0) {\n\t\t\t\t\t// looks like the lock was released\n\t\t\t\t\treturn tryDeleteAndAcquireLock(logService, filename);\n\t\t\t\t}\n\t\t\t\ttimeUntilRelease = contents.willReleaseAt - Date.now();\n\t\t\t}\n\n\t\t\treturn tryDeleteAndAcquireLock(logService, filename);\n\t\t}\n\t}\n\n\tif (!processExists(contents.pid)) {\n\t\tlogService.info(`Lock '${filename}': The pid ${contents.pid} appears to be gone.`);\n\t\treturn tryDeleteAndAcquireLock(logService, filename);\n\t}\n\n\tconst mtime1 = await readmtime(logService, filename);\n\tconst elapsed1 = Date.now() - mtime1;\n\tif (elapsed1 <= STALE_LOCK_TIME) {\n\t\t// the lock does not look stale\n\t\tlogService.info(`Lock '${filename}': The lock does not look stale, elapsed: ${elapsed1} ms, giving up.`);\n\t\treturn null;\n\t}\n\n\t// the lock holder updates the mtime every 1s.\n\t// let's give it a chance to update the mtime\n\t// in case of a wake from sleep or something similar\n\tlogService.info(`Lock '${filename}': The lock looks stale, waiting for 2s.`);\n\tawait timeout(2000);\n\n\tconst mtime2 = await readmtime(logService, filename);\n\tconst elapsed2 = Date.now() - mtime2;\n\tif (elapsed2 <= STALE_LOCK_TIME) {\n\t\t// the lock does not look stale\n\t\tlogService.info(`Lock '${filename}': The lock does not look stale, elapsed: ${elapsed2} ms, giving up.`);\n\t\treturn null;\n\t}\n\n\t// the lock looks stale\n\tlogService.info(`Lock '${filename}': The lock looks stale even after waiting for 2s.`);\n\treturn tryDeleteAndAcquireLock(logService, filename);\n}\n\nasync function tryDeleteAndAcquireLock(logService: ILogService, filename: string): Promise<Lock | null> {\n\tlogService.info(`Lock '${filename}': Deleting a stale lock.`);\n\ttry {\n\t\tawait Promises.unlink(filename);\n\t} catch (err) {\n\t\t// cannot delete the file\n\t\t// maybe the file is already deleted\n\t}\n\treturn tryAcquireLock(logService, filename, true);\n}\n"]}