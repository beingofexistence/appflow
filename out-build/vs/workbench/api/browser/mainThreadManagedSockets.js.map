{"version":3,"sources":["file:///workspace/appflow/src/vs/workbench/api/browser/mainThreadManagedSockets.ts"],"names":[],"mappings":"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","file":"mainThreadManagedSockets.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { VSBuffer } from 'vs/base/common/buffer';\nimport { Emitter } from 'vs/base/common/event';\nimport { Disposable, IDisposable } from 'vs/base/common/lifecycle';\nimport { ISocket, SocketCloseEventType } from 'vs/base/parts/ipc/common/ipc.net';\nimport { ManagedSocket, RemoteSocketHalf, connectManagedSocket } from 'vs/platform/remote/common/managedSocket';\nimport { ManagedRemoteConnection, RemoteConnectionType } from 'vs/platform/remote/common/remoteAuthorityResolver';\nimport { IRemoteSocketFactoryService, ISocketFactory } from 'vs/platform/remote/common/remoteSocketFactoryService';\nimport { ExtHostContext, ExtHostManagedSocketsShape, MainContext, MainThreadManagedSocketsShape } from 'vs/workbench/api/common/extHost.protocol';\nimport { IExtHostContext, extHostNamedCustomer } from 'vs/workbench/services/extensions/common/extHostCustomers';\n\n@extHostNamedCustomer(MainContext.MainThreadManagedSockets)\nexport class MainThreadManagedSockets extends Disposable implements MainThreadManagedSocketsShape {\n\n\tprivate readonly _proxy: ExtHostManagedSocketsShape;\n\tprivate readonly _registrations = new Map<number, IDisposable>();\n\tprivate readonly _remoteSockets = new Map<number, RemoteSocketHalf>();\n\n\tconstructor(\n\t\textHostContext: IExtHostContext,\n\t\t@IRemoteSocketFactoryService private readonly _remoteSocketFactoryService: IRemoteSocketFactoryService,\n\t) {\n\t\tsuper();\n\t\tthis._proxy = extHostContext.getProxy(ExtHostContext.ExtHostManagedSockets);\n\t}\n\n\tasync $registerSocketFactory(socketFactoryId: number): Promise<void> {\n\t\tconst that = this;\n\t\tconst socketFactory = new class implements ISocketFactory<RemoteConnectionType.Managed> {\n\n\t\t\tsupports(connectTo: ManagedRemoteConnection): boolean {\n\t\t\t\treturn (connectTo.id === socketFactoryId);\n\t\t\t}\n\n\t\t\tconnect(connectTo: ManagedRemoteConnection, path: string, query: string, debugLabel: string): Promise<ISocket> {\n\t\t\t\treturn new Promise<ISocket>((resolve, reject) => {\n\t\t\t\t\tif (connectTo.id !== socketFactoryId) {\n\t\t\t\t\t\treturn reject(new Error('Invalid connectTo'));\n\t\t\t\t\t}\n\n\t\t\t\t\tconst factoryId = connectTo.id;\n\t\t\t\t\tthat._proxy.$openRemoteSocket(factoryId).then(socketId => {\n\t\t\t\t\t\tconst half: RemoteSocketHalf = {\n\t\t\t\t\t\t\tonClose: new Emitter(),\n\t\t\t\t\t\t\tonData: new Emitter(),\n\t\t\t\t\t\t\tonEnd: new Emitter(),\n\t\t\t\t\t\t};\n\t\t\t\t\t\tthat._remoteSockets.set(socketId, half);\n\n\t\t\t\t\t\tMainThreadManagedSocket.connect(socketId, that._proxy, path, query, debugLabel, half)\n\t\t\t\t\t\t\t.then(\n\t\t\t\t\t\t\t\tsocket => {\n\t\t\t\t\t\t\t\t\tsocket.onDidDispose(() => that._remoteSockets.delete(socketId));\n\t\t\t\t\t\t\t\t\tresolve(socket);\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\terr => {\n\t\t\t\t\t\t\t\t\tthat._remoteSockets.delete(socketId);\n\t\t\t\t\t\t\t\t\treject(err);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t}).catch(reject);\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\t\tthis._registrations.set(socketFactoryId, this._remoteSocketFactoryService.register(RemoteConnectionType.Managed, socketFactory));\n\n\t}\n\n\tasync $unregisterSocketFactory(socketFactoryId: number): Promise<void> {\n\t\tthis._registrations.get(socketFactoryId)?.dispose();\n\t}\n\n\t$onDidManagedSocketHaveData(socketId: number, data: VSBuffer): void {\n\t\tthis._remoteSockets.get(socketId)?.onData.fire(data);\n\t}\n\n\t$onDidManagedSocketClose(socketId: number, error: string | undefined): void {\n\t\tthis._remoteSockets.get(socketId)?.onClose.fire({\n\t\t\ttype: SocketCloseEventType.NodeSocketCloseEvent,\n\t\t\terror: error ? new Error(error) : undefined,\n\t\t\thadError: !!error\n\t\t});\n\t\tthis._remoteSockets.delete(socketId);\n\t}\n\n\t$onDidManagedSocketEnd(socketId: number): void {\n\t\tthis._remoteSockets.get(socketId)?.onEnd.fire();\n\t}\n}\n\nexport class MainThreadManagedSocket extends ManagedSocket {\n\tpublic static connect(\n\t\tsocketId: number,\n\t\tproxy: ExtHostManagedSocketsShape,\n\t\tpath: string, query: string, debugLabel: string,\n\t\thalf: RemoteSocketHalf\n\t): Promise<MainThreadManagedSocket> {\n\t\tconst socket = new MainThreadManagedSocket(socketId, proxy, debugLabel, half);\n\t\treturn connectManagedSocket(socket, path, query, debugLabel, half);\n\t}\n\n\tprivate constructor(\n\t\tprivate readonly socketId: number,\n\t\tprivate readonly proxy: ExtHostManagedSocketsShape,\n\t\tdebugLabel: string,\n\t\thalf: RemoteSocketHalf,\n\t) {\n\t\tsuper(debugLabel, half);\n\t}\n\n\tpublic override write(buffer: VSBuffer): void {\n\t\tthis.proxy.$remoteSocketWrite(this.socketId, buffer);\n\t}\n\n\tprotected override  closeRemote(): void {\n\t\tthis.proxy.$remoteSocketEnd(this.socketId);\n\t}\n\n\tpublic override drain(): Promise<void> {\n\t\treturn this.proxy.$remoteSocketDrain(this.socketId);\n\t}\n}\n"]}