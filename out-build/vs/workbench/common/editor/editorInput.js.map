{"version":3,"sources":["file:///workspace/appflow/src/vs/workbench/common/editor/editorInput.ts"],"names":[],"mappings":"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","file":"editorInput.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Emitter } from 'vs/base/common/event';\nimport { URI } from 'vs/base/common/uri';\nimport { IEditorModel, IEditorOptions } from 'vs/platform/editor/common/editor';\nimport { firstOrDefault } from 'vs/base/common/arrays';\nimport { EditorInputCapabilities, Verbosity, GroupIdentifier, ISaveOptions, IRevertOptions, IMoveResult, IEditorDescriptor, IEditorPane, IUntypedEditorInput, EditorResourceAccessor, AbstractEditorInput, isEditorInput, IEditorIdentifier } from 'vs/workbench/common/editor';\nimport { isEqual } from 'vs/base/common/resources';\nimport { ConfirmResult } from 'vs/platform/dialogs/common/dialogs';\nimport { IMarkdownString } from 'vs/base/common/htmlContent';\n\nexport interface IEditorCloseHandler {\n\n\t/**\n\t * If `true`, will call into the `confirm` method to ask for confirmation\n\t * before closing the editor.\n\t */\n\tshowConfirm(): boolean;\n\n\t/**\n\t * Allows an editor to control what should happen when the editor\n\t * (or a list of editor of the same kind) is being closed.\n\t *\n\t * By default a file specific dialog will open if the editor is\n\t * dirty and not in the process of saving.\n\t *\n\t * If the editor is not dealing with files or another condition\n\t * should be used besides dirty state, this method should be\n\t * implemented to show a different dialog.\n\t *\n\t * @param editors All editors of the same kind that are being closed. Should be used\n\t * to show a combined dialog.\n\t */\n\tconfirm(editors: ReadonlyArray<IEditorIdentifier>): Promise<ConfirmResult>;\n}\n\n/**\n * Editor inputs are lightweight objects that can be passed to the workbench API to open inside the editor part.\n * Each editor input is mapped to an editor that is capable of opening it through the Platform facade.\n */\nexport abstract class EditorInput extends AbstractEditorInput {\n\n\tprotected readonly _onDidChangeDirty = this._register(new Emitter<void>());\n\tprotected readonly _onDidChangeLabel = this._register(new Emitter<void>());\n\tprotected readonly _onDidChangeCapabilities = this._register(new Emitter<void>());\n\n\tprivate readonly _onWillDispose = this._register(new Emitter<void>());\n\n\t/**\n\t * Triggered when this input changes its dirty state.\n\t */\n\treadonly onDidChangeDirty = this._onDidChangeDirty.event;\n\n\t/**\n\t * Triggered when this input changes its label\n\t */\n\treadonly onDidChangeLabel = this._onDidChangeLabel.event;\n\n\t/**\n\t * Triggered when this input changes its capabilities.\n\t */\n\treadonly onDidChangeCapabilities = this._onDidChangeCapabilities.event;\n\n\t/**\n\t * Triggered when this input is about to be disposed.\n\t */\n\treadonly onWillDispose = this._onWillDispose.event;\n\n\tprivate disposed: boolean = false;\n\n\t/**\n\t * Optional: subclasses can override to implement\n\t * custom confirmation on close behavior.\n\t */\n\treadonly closeHandler?: IEditorCloseHandler;\n\n\t/**\n\t * Unique type identifier for this input. Every editor input of the\n\t * same class should share the same type identifier. The type identifier\n\t * is used for example for serialising/deserialising editor inputs\n\t * via the serialisers of the `EditorInputFactoryRegistry`.\n\t */\n\tabstract get typeId(): string;\n\n\t/**\n\t * Returns the optional associated resource of this input.\n\t *\n\t * This resource should be unique for all editors of the same\n\t * kind and input and is often used to identify the editor input among\n\t * others.\n\t *\n\t * **Note:** DO NOT use this property for anything but identity\n\t * checks. DO NOT use this property to present as label to the user.\n\t * Please refer to `EditorResourceAccessor` documentation in that case.\n\t */\n\tabstract get resource(): URI | undefined;\n\n\t/**\n\t * Identifies the type of editor this input represents\n\t * This ID is registered with the {@link EditorResolverService} to allow\n\t * for resolving an untyped input to a typed one\n\t */\n\tget editorId(): string | undefined {\n\t\treturn undefined;\n\t}\n\n\t/**\n\t * The capabilities of the input.\n\t */\n\tget capabilities(): EditorInputCapabilities {\n\t\treturn EditorInputCapabilities.Readonly;\n\t}\n\n\t/**\n\t * Figure out if the input has the provided capability.\n\t */\n\thasCapability(capability: EditorInputCapabilities): boolean {\n\t\tif (capability === EditorInputCapabilities.None) {\n\t\t\treturn this.capabilities === EditorInputCapabilities.None;\n\t\t}\n\n\t\treturn (this.capabilities & capability) !== 0;\n\t}\n\n\tisReadonly(): boolean | IMarkdownString {\n\t\treturn this.hasCapability(EditorInputCapabilities.Readonly);\n\t}\n\n\t/**\n\t * Returns the display name of this input.\n\t */\n\tgetName(): string {\n\t\treturn `Editor ${this.typeId}`;\n\t}\n\n\t/**\n\t * Returns the display description of this input.\n\t */\n\tgetDescription(verbosity?: Verbosity): string | undefined {\n\t\treturn undefined;\n\t}\n\n\t/**\n\t * Returns the display title of this input.\n\t */\n\tgetTitle(verbosity?: Verbosity): string {\n\t\treturn this.getName();\n\t}\n\n\t/**\n\t * Returns the extra classes to apply to the label of this input.\n\t */\n\tgetLabelExtraClasses(): string[] {\n\t\treturn [];\n\t}\n\n\t/**\n\t * Returns the aria label to be read out by a screen reader.\n\t */\n\tgetAriaLabel(): string {\n\t\treturn this.getTitle(Verbosity.SHORT);\n\t}\n\n\t/**\n\t * Returns a descriptor suitable for telemetry events.\n\t *\n\t * Subclasses should extend if they can contribute.\n\t */\n\tgetTelemetryDescriptor(): { [key: string]: unknown } {\n\t\t/* __GDPR__FRAGMENT__\n\t\t\t\"EditorTelemetryDescriptor\" : {\n\t\t\t\t\"typeId\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" }\n\t\t\t}\n\t\t*/\n\t\treturn { typeId: this.typeId };\n\t}\n\n\t/**\n\t * Returns if this input is dirty or not.\n\t */\n\tisDirty(): boolean {\n\t\treturn false;\n\t}\n\n\t/**\n\t * Returns if the input has unsaved changes.\n\t */\n\tisModified(): boolean {\n\t\treturn this.isDirty();\n\t}\n\n\t/**\n\t * Returns if this input is currently being saved or soon to be\n\t * saved. Based on this assumption the editor may for example\n\t * decide to not signal the dirty state to the user assuming that\n\t * the save is scheduled to happen anyway.\n\t */\n\tisSaving(): boolean {\n\t\treturn false;\n\t}\n\n\t/**\n\t * Returns a type of `IEditorModel` that represents the resolved input.\n\t * Subclasses should override to provide a meaningful model or return\n\t * `null` if the editor does not require a model.\n\t *\n\t * The `options` parameter are passed down from the editor when the\n\t * input is resolved as part of it.\n\t */\n\tasync resolve(options?: IEditorOptions): Promise<IEditorModel | null> {\n\t\treturn null;\n\t}\n\n\t/**\n\t * Saves the editor. The provided groupId helps implementors\n\t * to e.g. preserve view state of the editor and re-open it\n\t * in the correct group after saving.\n\t *\n\t * @returns the resulting editor input (typically the same) of\n\t * this operation or `undefined` to indicate that the operation\n\t * failed or was canceled.\n\t */\n\tasync save(group: GroupIdentifier, options?: ISaveOptions): Promise<EditorInput | IUntypedEditorInput | undefined> {\n\t\treturn this;\n\t}\n\n\t/**\n\t * Saves the editor to a different location. The provided `group`\n\t * helps implementors to e.g. preserve view state of the editor\n\t * and re-open it in the correct group after saving.\n\t *\n\t * @returns the resulting editor input (typically a different one)\n\t * of this operation or `undefined` to indicate that the operation\n\t * failed or was canceled.\n\t */\n\tasync saveAs(group: GroupIdentifier, options?: ISaveOptions): Promise<EditorInput | IUntypedEditorInput | undefined> {\n\t\treturn this;\n\t}\n\n\t/**\n\t * Reverts this input from the provided group.\n\t */\n\tasync revert(group: GroupIdentifier, options?: IRevertOptions): Promise<void> { }\n\n\t/**\n\t * Called to determine how to handle a resource that is renamed that matches\n\t * the editors resource (or is a child of).\n\t *\n\t * Implementors are free to not implement this method to signal no intent\n\t * to participate. If an editor is returned though, it will replace the\n\t * current one with that editor and optional options.\n\t */\n\tasync rename(group: GroupIdentifier, target: URI): Promise<IMoveResult | undefined> {\n\t\treturn undefined;\n\t}\n\n\t/**\n\t * Returns a copy of the current editor input. Used when we can't just reuse the input\n\t */\n\tcopy(): EditorInput {\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns if the other object matches this input.\n\t */\n\tmatches(otherInput: EditorInput | IUntypedEditorInput): boolean {\n\n\t\t// Typed inputs: via  === check\n\t\tif (isEditorInput(otherInput)) {\n\t\t\treturn this === otherInput;\n\t\t}\n\n\t\t// Untyped inputs: go into properties\n\t\tconst otherInputEditorId = otherInput.options?.override;\n\n\t\t// If the overrides are both defined and don't match that means they're separate inputs\n\t\tif (this.editorId !== otherInputEditorId && otherInputEditorId !== undefined && this.editorId !== undefined) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn isEqual(this.resource, EditorResourceAccessor.getCanonicalUri(otherInput));\n\t}\n\n\t/**\n\t * If a editor was registered onto multiple editor panes, this method\n\t * will be asked to return the preferred one to use.\n\t *\n\t * @param editorPanes a list of editor pane descriptors that are candidates\n\t * for the editor to open in.\n\t */\n\tprefersEditorPane<T extends IEditorDescriptor<IEditorPane>>(editorPanes: T[]): T | undefined {\n\t\treturn firstOrDefault(editorPanes);\n\t}\n\n\t/**\n\t * Returns a representation of this typed editor input as untyped\n\t * resource editor input that e.g. can be used to serialize the\n\t * editor input into a form that it can be restored.\n\t *\n\t * May return `undefined` if an untyped representation is not supported.\n\t *\n\t * @param options additional configuration for the expected return type.\n\t * When `preserveViewState` is provided, implementations should try to\n\t * preserve as much view state as possible from the typed input based on\n\t * the group the editor is opened.\n\t */\n\ttoUntyped(options?: { preserveViewState: GroupIdentifier }): IUntypedEditorInput | undefined {\n\t\treturn undefined;\n\t}\n\n\t/**\n\t * Returns if this editor is disposed.\n\t */\n\tisDisposed(): boolean {\n\t\treturn this.disposed;\n\t}\n\n\toverride dispose(): void {\n\t\tif (!this.disposed) {\n\t\t\tthis.disposed = true;\n\t\t\tthis._onWillDispose.fire();\n\t\t}\n\n\t\tsuper.dispose();\n\t}\n}\n"]}