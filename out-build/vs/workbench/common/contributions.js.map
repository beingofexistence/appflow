{"version":3,"sources":["file:///workspace/appflow/src/vs/workbench/common/contributions.ts"],"names":[],"mappings":"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","file":"contributions.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IInstantiationService, IConstructorSignature, ServicesAccessor, BrandedService } from 'vs/platform/instantiation/common/instantiation';\nimport { ILifecycleService, LifecyclePhase } from 'vs/workbench/services/lifecycle/common/lifecycle';\nimport { Registry } from 'vs/platform/registry/common/platform';\nimport { runWhenIdle, IdleDeadline, DeferredPromise } from 'vs/base/common/async';\nimport { mark } from 'vs/base/common/performance';\nimport { ILogService } from 'vs/platform/log/common/log';\nimport { IEnvironmentService } from 'vs/platform/environment/common/environment';\n\n/**\n * A workbench contribution that will be loaded when the workbench starts and disposed when the workbench shuts down.\n */\nexport interface IWorkbenchContribution {\n\t// Marker Interface\n}\n\nexport namespace Extensions {\n\texport const Workbench = 'workbench.contributions.kind';\n}\n\ntype IWorkbenchContributionSignature<Service extends BrandedService[]> = new (...services: Service) => IWorkbenchContribution;\n\nexport interface IWorkbenchContributionsRegistry {\n\n\t/**\n\t * Registers a workbench contribution to the platform that will\n\t * be loaded when the workbench starts and disposed when the\n\t * workbench shuts down.\n\t *\n\t * The parameter `phase` controls when the contribution is instantiated.\n\t * Phases `Starting` and `Ready` are synchronous, all other phases are\n\t * delayed until the workbench is idle. Contributions are guaranteed to\n\t * be created in the order of their phases, even when delayed to idle.\n\t *\n\t * @param phase the lifecycle phase when to instantiate the contribution.\n\t */\n\tregisterWorkbenchContribution<Services extends BrandedService[]>(contribution: IWorkbenchContributionSignature<Services>, phase: LifecyclePhase): void;\n\n\t/**\n\t * Starts the registry by providing the required services.\n\t */\n\tstart(accessor: ServicesAccessor): void;\n}\n\nclass WorkbenchContributionsRegistry implements IWorkbenchContributionsRegistry {\n\n\tprivate instantiationService: IInstantiationService | undefined;\n\tprivate lifecycleService: ILifecycleService | undefined;\n\tprivate logService: ILogService | undefined;\n\tprivate environmentService: IEnvironmentService | undefined;\n\n\tprivate readonly contributions = new Map<LifecyclePhase, IConstructorSignature<IWorkbenchContribution>[]>();\n\tprivate readonly pendingRestoredContributions = new DeferredPromise<void>();\n\n\tregisterWorkbenchContribution(contribution: IConstructorSignature<IWorkbenchContribution>, phase: LifecyclePhase = LifecyclePhase.Starting): void {\n\n\t\t// Instantiate directly if we are already matching the provided phase\n\t\tif (this.instantiationService && this.lifecycleService && this.logService && this.environmentService && this.lifecycleService.phase >= phase) {\n\t\t\tthis.safeCreateContribution(this.instantiationService, this.logService, this.environmentService, contribution, phase);\n\t\t}\n\n\t\t// Otherwise keep contributions by lifecycle phase\n\t\telse {\n\t\t\tlet contributions = this.contributions.get(phase);\n\t\t\tif (!contributions) {\n\t\t\t\tcontributions = [];\n\t\t\t\tthis.contributions.set(phase, contributions);\n\t\t\t}\n\n\t\t\tcontributions.push(contribution);\n\t\t}\n\t}\n\n\tstart(accessor: ServicesAccessor): void {\n\t\tconst instantiationService = this.instantiationService = accessor.get(IInstantiationService);\n\t\tconst lifecycleService = this.lifecycleService = accessor.get(ILifecycleService);\n\t\tconst logService = this.logService = accessor.get(ILogService);\n\t\tconst environmentService = this.environmentService = accessor.get(IEnvironmentService);\n\n\t\tfor (const phase of [LifecyclePhase.Starting, LifecyclePhase.Ready, LifecyclePhase.Restored, LifecyclePhase.Eventually]) {\n\t\t\tthis.instantiateByPhase(instantiationService, lifecycleService, logService, environmentService, phase);\n\t\t}\n\t}\n\n\tprivate instantiateByPhase(instantiationService: IInstantiationService, lifecycleService: ILifecycleService, logService: ILogService, environmentService: IEnvironmentService, phase: LifecyclePhase): void {\n\n\t\t// Instantiate contributions directly when phase is already reached\n\t\tif (lifecycleService.phase >= phase) {\n\t\t\tthis.doInstantiateByPhase(instantiationService, logService, environmentService, phase);\n\t\t}\n\n\t\t// Otherwise wait for phase to be reached\n\t\telse {\n\t\t\tlifecycleService.when(phase).then(() => this.doInstantiateByPhase(instantiationService, logService, environmentService, phase));\n\t\t}\n\t}\n\n\tprivate async doInstantiateByPhase(instantiationService: IInstantiationService, logService: ILogService, environmentService: IEnvironmentService, phase: LifecyclePhase): Promise<void> {\n\t\tconst contributions = this.contributions.get(phase);\n\t\tif (contributions) {\n\t\t\tthis.contributions.delete(phase);\n\n\t\t\tswitch (phase) {\n\t\t\t\tcase LifecyclePhase.Starting:\n\t\t\t\tcase LifecyclePhase.Ready: {\n\n\t\t\t\t\t// instantiate everything synchronously and blocking\n\t\t\t\t\t// measure the time it takes as perf marks for diagnosis\n\n\t\t\t\t\tmark(`code/willCreateWorkbenchContributions/${phase}`);\n\n\t\t\t\t\tfor (const contribution of contributions) {\n\t\t\t\t\t\tthis.safeCreateContribution(instantiationService, logService, environmentService, contribution, phase);\n\t\t\t\t\t}\n\n\t\t\t\t\tmark(`code/didCreateWorkbenchContributions/${phase}`);\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcase LifecyclePhase.Restored:\n\t\t\t\tcase LifecyclePhase.Eventually: {\n\n\t\t\t\t\t// for the Restored/Eventually-phase we instantiate contributions\n\t\t\t\t\t// only when idle. this might take a few idle-busy-cycles but will\n\t\t\t\t\t// finish within the timeouts\n\t\t\t\t\t// given that, we must ensure to await the contributions from the\n\t\t\t\t\t// Restored-phase before we instantiate the Eventually-phase\n\n\t\t\t\t\tif (phase === LifecyclePhase.Eventually) {\n\t\t\t\t\t\tawait this.pendingRestoredContributions.p;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.doInstantiateWhenIdle(contributions, instantiationService, logService, environmentService, phase);\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate doInstantiateWhenIdle(contributions: IConstructorSignature<IWorkbenchContribution>[], instantiationService: IInstantiationService, logService: ILogService, environmentService: IEnvironmentService, phase: LifecyclePhase): void {\n\t\tmark(`code/willCreateWorkbenchContributions/${phase}`);\n\n\t\tlet i = 0;\n\t\tconst forcedTimeout = phase === LifecyclePhase.Eventually ? 3000 : 500;\n\n\t\tconst instantiateSome = (idle: IdleDeadline) => {\n\t\t\twhile (i < contributions.length) {\n\t\t\t\tconst contribution = contributions[i++];\n\t\t\t\tthis.safeCreateContribution(instantiationService, logService, environmentService, contribution, phase);\n\t\t\t\tif (idle.timeRemaining() < 1) {\n\t\t\t\t\t// time is up -> reschedule\n\t\t\t\t\trunWhenIdle(instantiateSome, forcedTimeout);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (i === contributions.length) {\n\t\t\t\tmark(`code/didCreateWorkbenchContributions/${phase}`);\n\n\t\t\t\tif (phase === LifecyclePhase.Restored) {\n\t\t\t\t\tthis.pendingRestoredContributions.complete();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\trunWhenIdle(instantiateSome, forcedTimeout);\n\t}\n\n\tprivate safeCreateContribution(instantiationService: IInstantiationService, logService: ILogService, environmentService: IEnvironmentService, contribution: IConstructorSignature<IWorkbenchContribution>, phase: LifecyclePhase): void {\n\t\tconst now: number | undefined = phase < LifecyclePhase.Restored ? Date.now() : undefined;\n\n\t\ttry {\n\t\t\tinstantiationService.createInstance(contribution);\n\t\t} catch (error) {\n\t\t\tlogService.error(`Unable to create workbench contribution ${contribution.name}.`, error);\n\t\t}\n\n\t\tif (typeof now === 'number' && !environmentService.isBuilt /* only log out of sources where we have good ctor names */) {\n\t\t\tconst time = Date.now() - now;\n\t\t\tif (time > 20) {\n\t\t\t\tlogService.warn(`Workbench contribution ${contribution.name} blocked restore phase by ${time}ms.`);\n\t\t\t}\n\t\t}\n\t}\n}\n\nRegistry.add(Extensions.Workbench, new WorkbenchContributionsRegistry());\n"]}