{"version":3,"sources":["vs/workbench/browser/editor.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;IA0ChG;;;OAGG;IACH,MAAa,GAAG;QAEf,MAAM,CAAC,MAAM,CACZ,IAAgD,EAChD,MAAc,EACd,IAAY;YAEZ,OAAO,IAAI,GAAG,CAAkB,IAAyC,EAAE,MAAM,EAAE,IAAI,CAAC,CAAC;QAC1F,CAAC;QAED,YACkB,CAAuC,EAC/C,MAAc,EACd,IAAY;YAFJ,MAAC,GAAD,CAAC,CAAsC;YAC/C,WAAM,GAAN,MAAM,CAAQ;YACd,SAAI,GAAJ,IAAI,CAAQ;QAClB,CAAC;QAEL,WAAW,CAAC,oBAAyB;YACpC,OAAO,oBAAoB,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC,CAAI,CAAC;QACvD,CAAC;QAED,SAAS,CAAC,UAAe;YACxB,OAAO,UAAU,CAAC,KAAK,EAAE,KAAK,IAAI,CAAC,MAAM,CAAC;QAC3C,CAAC;KACD;IAvBD,kBAuBC;IAED,MAAa,GAAG;QAAhB;YAEkB,MAAC,GAAyB,IAAI,GAAG,EAAgE,CAAC;YA4EnH,YAAY;QACb,CAAC;QA3EA,kBAAkB,CAAC,oBAAyB,EAAmB,iBAAyD;YACvH,IAAI,CAAC,CAAC,CAAuB,GAAG,CAAC,oBAAoB,EAAE,iBAAiB,CAAC,CAAC;YAE1E,OAAO,IAAA,eAAG,EAAU,GAAG,EAAE;gBACxB,IAAI,CAAC,CAAC,CAAuB,MAAM,CAAC,oBAAoB,CAAC,CAAC;YAC3D,CAAC,CAAC,CAAC;QACJ,CAAC;QAED,aAAa,CAAC,MAAW;YACxB,MAAM,WAAW,GAAG,IAAI,CAAC,CAAC,CAAyB,MAAM,CAAC,CAAC;YAE3D,IAAI,WAAW,CAAC,MAAM,KAAK,CAAC,EAAE;gBAC7B,OAAO,SAAS,CAAC;aACjB;YAED,IAAI,WAAW,CAAC,MAAM,KAAK,CAAC,EAAE;gBAC7B,OAAO,WAAW,CAAC,CAAC,CAAC,CAAC;aACtB;YAED,OAAO,MAAM,CAAC,iBAAiB,CAAC,WAAW,CAAC,CAAC;QAC9C,CAAC;QAEO,CAAC,CAAyB,MAAW,EAAU,YAAsB;YAC5E,MAAM,6BAA6B,GAA2B,EAAE,CAAC;YAEjE,KAAK,MAAM,UAAU,IAAI,IAAI,CAAC,CAAC,CAAuB,IAAI,EAAE,EAAE;gBAC7D,MAAM,iBAAiB,GAAG,IAAI,CAAC,CAAC,CAAuB,GAAG,CAAC,UAAU,CAAC,IAAI,EAAE,CAAC;gBAC7E,KAAK,MAAM,gBAAgB,IAAI,iBAAiB,EAAE;oBACjD,MAAM,WAAW,GAAG,gBAAgB,CAAC,IAAI,CAAC;oBAE1C,6DAA6D;oBAC7D,IAAI,CAAC,YAAY,IAAI,MAAM,CAAC,WAAW,KAAK,WAAW,EAAE;wBACxD,6BAA6B,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;wBAC/C,MAAM;qBACN;oBAED,0BAA0B;yBACrB,IAAI,YAAY,IAAI,MAAM,YAAY,WAAW,EAAE;wBACvD,6BAA6B,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;wBAC/C,MAAM;qBACN;iBACD;aACD;YAED,gFAAgF;YAChF,IAAI,CAAC,YAAY,IAAI,6BAA6B,CAAC,MAAM,KAAK,CAAC,EAAE;gBAChE,OAAO,IAAI,CAAC,CAAC,CAAyB,MAAM,EAAE,IAAI,CAAC,CAAC;aACpD;YAED,OAAO,6BAA6B,CAAC;QACtC,CAAC;QAED,6BAA6B;QAE7B,mBAAmB,CAAC,MAAc;YACjC,OAAO,mBAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAuB,IAAI,EAAE,EAAE,MAAM,CAAC,EAAE,CAAC,MAAM,CAAC,MAAM,KAAK,MAAM,CAAC,CAAC;QAC/F,CAAC;QAED,cAAc;YACb,OAAO,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAuB,IAAI,EAAE,CAAC,CAAC;QACxD,CAAC;QAED,UAAU;YACT,MAAM,aAAa,GAAkC,EAAE,CAAC;YACxD,KAAK,MAAM,UAAU,IAAI,IAAI,CAAC,CAAC,CAAuB,IAAI,EAAE,EAAE;gBAC7D,MAAM,iBAAiB,GAAG,IAAI,CAAC,CAAC,CAAuB,GAAG,CAAC,UAAU,CAAC,CAAC;gBACvE,IAAI,iBAAiB,EAAE;oBACtB,aAAa,CAAC,IAAI,CAAC,GAAG,iBAAiB,CAAC,GAAG,CAAC,gBAAgB,CAAC,EAAE,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC,CAAC;iBACxF;aACD;YAED,OAAO,aAAa,CAAC;QACtB,CAAC;KAGD;IA/ED,kBA+EC;IAED,cAAG,CAAM,GAAG,CAAC,YAAG,CAAc,UAAU,EAAE,IAAI,GAAG,EAAiB,CAAC,CAAC;IAEpE,YAAY;IAEZ,8BAA8B;IAE9B,SAAgB,GAAG,CAAc,QAA0B,EAAE,SAAgB;QAC5E,MAAM,aAAa,GAAG,QAAQ,CAAC,GAAG,CAAC,mBAAG,CAAY,CAAC;QACnD,MAAM,kBAAkB,GAAG,QAAQ,CAAC,GAAG,CAAC,iBAAG,CAAiB,CAAC;QAC7D,MAAM,kBAAkB,GAAG,QAAQ,CAAC,GAAG,CAAC,wBAAG,CAAiB,CAAC;QAE7D,OAAO,IAAI,OAAO,CAAC,OAAO,CAAC,EAAE;YAC5B,IAAI,kBAAkB,GAAG,CAAC,GAAG,SAAS,CAAC,CAAC;YAExC,iDAAiD;YACjD,MAAM,QAAQ,GAAG,aAAa,CAAC,gBAAgB,CAAC,KAAK,EAAC,KAAK,EAAC,EAAE;gBAC7D,IAAI,KAAK,CAAC,OAAO,KAAK,2BAAkB,CAAC,IAAI,EAAE;oBAC9C,OAAO,CAAC,iEAAiE;iBACzE;gBAED,IAAI,eAAe,GAAG,YAAG,CAAoB,cAAc,CAAC,KAAK,CAAC,MAAM,EAAE,EAAE,iBAAiB,EAAE,yBAAgB,CAAC,OAAO,EAAE,CAAC,CAAC;gBAC3H,IAAI,iBAAiB,GAAG,YAAG,CAAoB,cAAc,CAAC,KAAK,CAAC,MAAM,EAAE,EAAE,iBAAiB,EAAE,yBAAgB,CAAC,SAAS,EAAE,CAAC,CAAC;gBAE/H,wEAAwE;gBACxE,oEAAoE;gBACpE,iEAAiE;gBACjE,0DAA0D;gBAC1D,IAAI,KAAK,CAAC,OAAO,KAAK,2BAAkB,CAAC,OAAO,EAAE;oBACjD,MAAM,kBAAkB,GAAG,YAAG,CAAoB,cAAc,CAAC,aAAa,CAAC,YAAY,EAAE,EAAE,iBAAiB,EAAE,yBAAgB,CAAC,OAAO,EAAE,CAAC,CAAC;oBAC9I,MAAM,oBAAoB,GAAG,YAAG,CAAoB,cAAc,CAAC,aAAa,CAAC,YAAY,EAAE,EAAE,iBAAiB,EAAE,yBAAgB,CAAC,SAAS,EAAE,CAAC,CAAC;oBAElJ,IAAI,kBAAkB,CAAC,MAAM,CAAC,OAAO,CAAC,eAAe,EAAE,kBAAkB,CAAC,EAAE;wBAC3E,eAAe,GAAG,SAAS,CAAC;qBAC5B;oBAED,IAAI,kBAAkB,CAAC,MAAM,CAAC,OAAO,CAAC,iBAAiB,EAAE,oBAAoB,CAAC,EAAE;wBAC/E,iBAAiB,GAAG,SAAS,CAAC;qBAC9B;iBACD;gBAED,8DAA8D;gBAC9D,yCAAyC;gBACzC,kBAAkB,GAAG,kBAAkB,CAAC,MAAM,CAAC,QAAQ,CAAC,EAAE;oBAEzD,kEAAkE;oBAClE,IAAI,kBAAkB,CAAC,MAAM,CAAC,OAAO,CAAC,QAAQ,EAAE,eAAe,CAAC,IAAI,kBAAkB,CAAC,MAAM,CAAC,OAAO,CAAC,QAAQ,EAAE,iBAAiB,CAAC,EAAE;wBACnI,OAAO,KAAK,CAAC;qBACb;oBAED,sDAAsD;oBACtD,wDAAwD;oBACxD,qDAAqD;oBACrD,oDAAoD;oBACpD,6BAA6B;oBAC7B,0DAA0D;oBAC1D,IAAI,KAAK,CAAC,OAAO,KAAK,2BAAkB,CAAC,OAAO,EAAE;wBACjD,IACC,CAAC,eAAe,EAAE,MAAM,KAAK,iBAAO,CAAC,QAAQ,IAAI,kBAAkB,CAAC,MAAM,CAAC,OAAO,CAAC,QAAQ,EAAE,eAAe,CAAC,IAAI,CAAC,EAAE,MAAM,EAAE,QAAQ,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC;4BAChJ,CAAC,iBAAiB,EAAE,MAAM,KAAK,iBAAO,CAAC,QAAQ,IAAI,kBAAkB,CAAC,MAAM,CAAC,OAAO,CAAC,QAAQ,EAAE,iBAAiB,CAAC,IAAI,CAAC,EAAE,MAAM,EAAE,QAAQ,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC,EACnJ;4BACD,OAAO,KAAK,CAAC;yBACb;qBACD;oBAED,uDAAuD;oBACvD,OAAO,IAAI,CAAC;gBACb,CAAC,CAAC,CAAC;gBAEH,oDAAoD;gBACpD,IAAI,kBAAkB,CAAC,MAAM,KAAK,CAAC,EAAE;oBAEpC,wEAAwE;oBACxE,gFAAgF;oBAChF,6EAA6E;oBAC7E,yBAAyB;oBACzB,MAAM,cAAc,GAAG,SAAS,CAAC,MAAM,CAAC,QAAQ,CAAC,EAAE,CAAC,kBAAkB,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC,CAAC;oBAC1F,IAAI,cAAc,CAAC,MAAM,GAAG,CAAC,EAAE;wBAC9B,MAAM,gBAAQ,CAAC,OAAO,CAAC,cAAc,CAAC,GAAG,CAAC,KAAK,EAAC,QAAQ,EAAC,EAAE,CAAC,MAAM,IAAI,OAAO,CAAO,OAAO,CAAC,EAAE;4BAC7F,IAAI,CAAC,kBAAkB,CAAC,OAAO,CAAC,QAAQ,CAAC,EAAE;gCAC1C,OAAO,OAAO,EAAE,CAAC,CAAC,wCAAwC;6BAC1D;4BAED,mDAAmD;4BACnD,MAAM,QAAQ,GAAG,kBAAkB,CAAC,gBAAgB,CAAC,WAAW,CAAC,EAAE;gCAClE,IAAI,CAAC,WAAW,CAAC,OAAO,EAAE,IAAI,kBAAkB,CAAC,MAAM,CAAC,OAAO,CAAC,QAAQ,EAAE,WAAW,CAAC,QAAQ,CAAC,EAAE;oCAChG,QAAQ,CAAC,OAAO,EAAE,CAAC;oCAEnB,OAAO,OAAO,EAAE,CAAC;iCACjB;4BACF,CAAC,CAAC,CAAC;wBACJ,CAAC,CAAC,CAAC,CAAC,CAAC;qBACL;oBAED,QAAQ,CAAC,OAAO,EAAE,CAAC;oBAEnB,OAAO,OAAO,EAAE,CAAC;iBACjB;YACF,CAAC,CAAC,CAAC;QACJ,CAAC,CAAC,CAAC;IACJ,CAAC;IA7FD,kBA6FC;IAED,YAAY;IAEZ,cAAc;IAEd,SAAgB,GAAG,CAAoB,KAAU,EAAU,KAAyB,EAAE,KAA+B,EAAE,UAA8B;QACpJ,IAAI,SAAS,GAAG,KAAK,CAAC,YAAY,EAAE,CAAC;QACrC,IAAI,KAAK,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE;YACpC,SAAS,GAAG,IAAA,cAAQ,EAAC,CAAS,EAAE,IAAc,EAAE,SAAS,CAAC,CAAC;SAC3D;QAED,IAAI,KAAK,EAAE,QAAQ,CAAC,KAAK,IAAI,KAAK,CAAC,EAAE;YACpC,SAAS,GAAG,IAAA,cAAQ,EAAC,CAAQ,EAAE,IAAa,EAAE,SAAS,CAAC,CAAC;SACzD;QAED,8CAA8C;QAC9C,kDAAkD;QAClD,sBAAsB;QACtB,IAAI,KAAK,IAAI,OAAO,UAAU,KAAK,QAAQ,IAAI,UAAU,GAAG,CAAC,EAAE;YAC9D,SAAS,GAAG,GAAG,SAAS,KAAK,KAAK,CAAC,SAAS,EAAE,CAAC;SAC/C;QAED,OAAO,SAAS,CAAC;IAClB,CAAC;IAlBD,kBAkBC;;AAED,YAAY","file":"editor.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { localize } from 'vs/nls';\nimport { EditorResourceAccessor, EditorExtensions, SideBySideEditor, IEditorDescriptor as ICommonEditorDescriptor, EditorCloseContext } from 'vs/workbench/common/editor';\nimport { EditorInput } from 'vs/workbench/common/editor/editorInput';\nimport { SyncDescriptor } from 'vs/platform/instantiation/common/descriptors';\nimport { Registry } from 'vs/platform/registry/common/platform';\nimport { EditorPane } from 'vs/workbench/browser/parts/editor/editorPane';\nimport { IConstructorSignature, IInstantiationService, BrandedService, ServicesAccessor } from 'vs/platform/instantiation/common/instantiation';\nimport { IDisposable, toDisposable } from 'vs/base/common/lifecycle';\nimport { Promises } from 'vs/base/common/async';\nimport { IEditorService } from 'vs/workbench/services/editor/common/editorService';\nimport { IUriIdentityService } from 'vs/platform/uriIdentity/common/uriIdentity';\nimport { IWorkingCopyService } from 'vs/workbench/services/workingCopy/common/workingCopyService';\nimport { URI } from 'vs/base/common/uri';\nimport { Schemas } from 'vs/base/common/network';\nimport { IEditorGroup } from 'vs/workbench/services/editor/common/editorGroupsService';\nimport { Iterable } from 'vs/base/common/iterator';\n\n//#region Editor Pane Registry\n\nexport interface IEditorPaneDescriptor extends ICommonEditorDescriptor<EditorPane> { }\n\nexport interface IEditorPaneRegistry {\n\n\t/**\n\t * Registers an editor pane to the platform for the given editor type. The second parameter also supports an\n\t * array of input classes to be passed in. If the more than one editor is registered for the same editor\n\t * input, the input itself will be asked which editor it prefers if this method is provided. Otherwise\n\t * the first editor in the list will be returned.\n\t *\n\t * @param editorDescriptors A set of constructor functions that return an instance of `EditorInput` for which the\n\t * registered editor should be used for.\n\t */\n\tregisterEditorPane(editorPaneDescriptor: IEditorPaneDescriptor, editorDescriptors: readonly SyncDescriptor<EditorInput>[]): IDisposable;\n\n\t/**\n\t * Returns the editor pane descriptor for the given editor or `undefined` if none.\n\t */\n\tgetEditorPane(editor: EditorInput): IEditorPaneDescriptor | undefined;\n}\n\n/**\n * A lightweight descriptor of an editor pane. The descriptor is deferred so that heavy editor\n * panes can load lazily in the workbench.\n */\nexport class EditorPaneDescriptor implements IEditorPaneDescriptor {\n\n\tstatic create<Services extends BrandedService[]>(\n\t\tctor: { new(...services: Services): EditorPane },\n\t\ttypeId: string,\n\t\tname: string\n\t): EditorPaneDescriptor {\n\t\treturn new EditorPaneDescriptor(ctor as IConstructorSignature<EditorPane>, typeId, name);\n\t}\n\n\tprivate constructor(\n\t\tprivate readonly ctor: IConstructorSignature<EditorPane>,\n\t\treadonly typeId: string,\n\t\treadonly name: string\n\t) { }\n\n\tinstantiate(instantiationService: IInstantiationService): EditorPane {\n\t\treturn instantiationService.createInstance(this.ctor);\n\t}\n\n\tdescribes(editorPane: EditorPane): boolean {\n\t\treturn editorPane.getId() === this.typeId;\n\t}\n}\n\nexport class EditorPaneRegistry implements IEditorPaneRegistry {\n\n\tprivate readonly mapEditorPanesToEditors = new Map<EditorPaneDescriptor, readonly SyncDescriptor<EditorInput>[]>();\n\n\tregisterEditorPane(editorPaneDescriptor: EditorPaneDescriptor, editorDescriptors: readonly SyncDescriptor<EditorInput>[]): IDisposable {\n\t\tthis.mapEditorPanesToEditors.set(editorPaneDescriptor, editorDescriptors);\n\n\t\treturn toDisposable(() => {\n\t\t\tthis.mapEditorPanesToEditors.delete(editorPaneDescriptor);\n\t\t});\n\t}\n\n\tgetEditorPane(editor: EditorInput): EditorPaneDescriptor | undefined {\n\t\tconst descriptors = this.findEditorPaneDescriptors(editor);\n\n\t\tif (descriptors.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (descriptors.length === 1) {\n\t\t\treturn descriptors[0];\n\t\t}\n\n\t\treturn editor.prefersEditorPane(descriptors);\n\t}\n\n\tprivate findEditorPaneDescriptors(editor: EditorInput, byInstanceOf?: boolean): EditorPaneDescriptor[] {\n\t\tconst matchingEditorPaneDescriptors: EditorPaneDescriptor[] = [];\n\n\t\tfor (const editorPane of this.mapEditorPanesToEditors.keys()) {\n\t\t\tconst editorDescriptors = this.mapEditorPanesToEditors.get(editorPane) || [];\n\t\t\tfor (const editorDescriptor of editorDescriptors) {\n\t\t\t\tconst editorClass = editorDescriptor.ctor;\n\n\t\t\t\t// Direct check on constructor type (ignores prototype chain)\n\t\t\t\tif (!byInstanceOf && editor.constructor === editorClass) {\n\t\t\t\t\tmatchingEditorPaneDescriptors.push(editorPane);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// Normal instanceof check\n\t\t\t\telse if (byInstanceOf && editor instanceof editorClass) {\n\t\t\t\t\tmatchingEditorPaneDescriptors.push(editorPane);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If no descriptors found, continue search using instanceof and prototype chain\n\t\tif (!byInstanceOf && matchingEditorPaneDescriptors.length === 0) {\n\t\t\treturn this.findEditorPaneDescriptors(editor, true);\n\t\t}\n\n\t\treturn matchingEditorPaneDescriptors;\n\t}\n\n\t//#region Used for tests only\n\n\tgetEditorPaneByType(typeId: string): EditorPaneDescriptor | undefined {\n\t\treturn Iterable.find(this.mapEditorPanesToEditors.keys(), editor => editor.typeId === typeId);\n\t}\n\n\tgetEditorPanes(): readonly EditorPaneDescriptor[] {\n\t\treturn Array.from(this.mapEditorPanesToEditors.keys());\n\t}\n\n\tgetEditors(): SyncDescriptor<EditorInput>[] {\n\t\tconst editorClasses: SyncDescriptor<EditorInput>[] = [];\n\t\tfor (const editorPane of this.mapEditorPanesToEditors.keys()) {\n\t\t\tconst editorDescriptors = this.mapEditorPanesToEditors.get(editorPane);\n\t\t\tif (editorDescriptors) {\n\t\t\t\teditorClasses.push(...editorDescriptors.map(editorDescriptor => editorDescriptor.ctor));\n\t\t\t}\n\t\t}\n\n\t\treturn editorClasses;\n\t}\n\n\t//#endregion\n}\n\nRegistry.add(EditorExtensions.EditorPane, new EditorPaneRegistry());\n\n//#endregion\n\n//#region Editor Close Tracker\n\nexport function whenEditorClosed(accessor: ServicesAccessor, resources: URI[]): Promise<void> {\n\tconst editorService = accessor.get(IEditorService);\n\tconst uriIdentityService = accessor.get(IUriIdentityService);\n\tconst workingCopyService = accessor.get(IWorkingCopyService);\n\n\treturn new Promise(resolve => {\n\t\tlet remainingResources = [...resources];\n\n\t\t// Observe any editor closing from this moment on\n\t\tconst listener = editorService.onDidCloseEditor(async event => {\n\t\t\tif (event.context === EditorCloseContext.MOVE) {\n\t\t\t\treturn; // ignore move events where the editor will open in another group\n\t\t\t}\n\n\t\t\tlet primaryResource = EditorResourceAccessor.getOriginalUri(event.editor, { supportSideBySide: SideBySideEditor.PRIMARY });\n\t\t\tlet secondaryResource = EditorResourceAccessor.getOriginalUri(event.editor, { supportSideBySide: SideBySideEditor.SECONDARY });\n\n\t\t\t// Specially handle an editor getting replaced: if the new active editor\n\t\t\t// matches any of the resources from the closed editor, ignore those\n\t\t\t// resources because they were actually not closed, but replaced.\n\t\t\t// (see https://github.com/microsoft/vscode/issues/134299)\n\t\t\tif (event.context === EditorCloseContext.REPLACE) {\n\t\t\t\tconst newPrimaryResource = EditorResourceAccessor.getOriginalUri(editorService.activeEditor, { supportSideBySide: SideBySideEditor.PRIMARY });\n\t\t\t\tconst newSecondaryResource = EditorResourceAccessor.getOriginalUri(editorService.activeEditor, { supportSideBySide: SideBySideEditor.SECONDARY });\n\n\t\t\t\tif (uriIdentityService.extUri.isEqual(primaryResource, newPrimaryResource)) {\n\t\t\t\t\tprimaryResource = undefined;\n\t\t\t\t}\n\n\t\t\t\tif (uriIdentityService.extUri.isEqual(secondaryResource, newSecondaryResource)) {\n\t\t\t\t\tsecondaryResource = undefined;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove from resources to wait for being closed based on the\n\t\t\t// resources from editors that got closed\n\t\t\tremainingResources = remainingResources.filter(resource => {\n\n\t\t\t\t// Closing editor matches resource directly: remove from remaining\n\t\t\t\tif (uriIdentityService.extUri.isEqual(resource, primaryResource) || uriIdentityService.extUri.isEqual(resource, secondaryResource)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// Closing editor is untitled with associated resource\n\t\t\t\t// that matches resource directly: remove from remaining\n\t\t\t\t// but only if the editor was not replaced, otherwise\n\t\t\t\t// saving an untitled with associated resource would\n\t\t\t\t// release the `--wait` call.\n\t\t\t\t// (see https://github.com/microsoft/vscode/issues/141237)\n\t\t\t\tif (event.context !== EditorCloseContext.REPLACE) {\n\t\t\t\t\tif (\n\t\t\t\t\t\t(primaryResource?.scheme === Schemas.untitled && uriIdentityService.extUri.isEqual(resource, primaryResource.with({ scheme: resource.scheme }))) ||\n\t\t\t\t\t\t(secondaryResource?.scheme === Schemas.untitled && uriIdentityService.extUri.isEqual(resource, secondaryResource.with({ scheme: resource.scheme })))\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Editor is not yet closed, so keep it in waiting mode\n\t\t\t\treturn true;\n\t\t\t});\n\n\t\t\t// All resources to wait for being closed are closed\n\t\t\tif (remainingResources.length === 0) {\n\n\t\t\t\t// If auto save is configured with the default delay (1s) it is possible\n\t\t\t\t// to close the editor while the save still continues in the background. As such\n\t\t\t\t// we have to also check if the editors to track for are dirty and if so wait\n\t\t\t\t// for them to get saved.\n\t\t\t\tconst dirtyResources = resources.filter(resource => workingCopyService.isDirty(resource));\n\t\t\t\tif (dirtyResources.length > 0) {\n\t\t\t\t\tawait Promises.settled(dirtyResources.map(async resource => await new Promise<void>(resolve => {\n\t\t\t\t\t\tif (!workingCopyService.isDirty(resource)) {\n\t\t\t\t\t\t\treturn resolve(); // return early if resource is not dirty\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Otherwise resolve promise when resource is saved\n\t\t\t\t\t\tconst listener = workingCopyService.onDidChangeDirty(workingCopy => {\n\t\t\t\t\t\t\tif (!workingCopy.isDirty() && uriIdentityService.extUri.isEqual(resource, workingCopy.resource)) {\n\t\t\t\t\t\t\t\tlistener.dispose();\n\n\t\t\t\t\t\t\t\treturn resolve();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t})));\n\t\t\t\t}\n\n\t\t\t\tlistener.dispose();\n\n\t\t\t\treturn resolve();\n\t\t\t}\n\t\t});\n\t});\n}\n\n//#endregion\n\n//#region ARIA\n\nexport function computeEditorAriaLabel(input: EditorInput, index: number | undefined, group: IEditorGroup | undefined, groupCount: number | undefined): string {\n\tlet ariaLabel = input.getAriaLabel();\n\tif (group && !group.isPinned(input)) {\n\t\tariaLabel = localize('preview', \"{0}, preview\", ariaLabel);\n\t}\n\n\tif (group?.isSticky(index ?? input)) {\n\t\tariaLabel = localize('pinned', \"{0}, pinned\", ariaLabel);\n\t}\n\n\t// Apply group information to help identify in\n\t// which group we are (only if more than one group\n\t// is actually opened)\n\tif (group && typeof groupCount === 'number' && groupCount > 1) {\n\t\tariaLabel = `${ariaLabel}, ${group.ariaLabel}`;\n\t}\n\n\treturn ariaLabel;\n}\n\n//#endregion\n"]}