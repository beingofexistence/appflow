{"version":3,"sources":["vs/workbench/contrib/debug/common/debug.ts"],"names":[],"mappings":"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","file":"debug.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IAction } from 'vs/base/common/actions';\nimport { VSBuffer } from 'vs/base/common/buffer';\nimport { CancellationToken } from 'vs/base/common/cancellation';\nimport { Color } from 'vs/base/common/color';\nimport { Event } from 'vs/base/common/event';\nimport { IJSONSchemaSnippet } from 'vs/base/common/jsonSchema';\nimport { IDisposable } from 'vs/base/common/lifecycle';\nimport severity from 'vs/base/common/severity';\nimport { URI as uri } from 'vs/base/common/uri';\nimport { IPosition, Position } from 'vs/editor/common/core/position';\nimport { IRange } from 'vs/editor/common/core/range';\nimport * as editorCommon from 'vs/editor/common/editorCommon';\nimport { ITextModel as EditorIModel } from 'vs/editor/common/model';\nimport * as nls from 'vs/nls';\nimport { ConfigurationTarget } from 'vs/platform/configuration/common/configuration';\nimport { RawContextKey } from 'vs/platform/contextkey/common/contextkey';\nimport { createDecorator } from 'vs/platform/instantiation/common/instantiation';\nimport { ITelemetryEndpoint } from 'vs/platform/telemetry/common/telemetry';\nimport { IWorkspaceFolder } from 'vs/platform/workspace/common/workspace';\nimport { IEditorPane } from 'vs/workbench/common/editor';\nimport { DebugCompoundRoot } from 'vs/workbench/contrib/debug/common/debugCompoundRoot';\nimport { Source } from 'vs/workbench/contrib/debug/common/debugSource';\nimport { ITaskIdentifier } from 'vs/workbench/contrib/tasks/common/tasks';\nimport { IEditorService } from 'vs/workbench/services/editor/common/editorService';\n\nexport const VIEWLET_ID = 'workbench.view.debug';\n\nexport const VARIABLES_VIEW_ID = 'workbench.debug.variablesView';\nexport const WATCH_VIEW_ID = 'workbench.debug.watchExpressionsView';\nexport const CALLSTACK_VIEW_ID = 'workbench.debug.callStackView';\nexport const LOADED_SCRIPTS_VIEW_ID = 'workbench.debug.loadedScriptsView';\nexport const BREAKPOINTS_VIEW_ID = 'workbench.debug.breakPointsView';\nexport const DISASSEMBLY_VIEW_ID = 'workbench.debug.disassemblyView';\nexport const DEBUG_PANEL_ID = 'workbench.panel.repl';\nexport const REPL_VIEW_ID = 'workbench.panel.repl.view';\nexport const CONTEXT_DEBUG_TYPE = new RawContextKey<string>('debugType', undefined, { type: 'string', description: nls.localize('debugType', \"Debug type of the active debug session. For example 'python'.\") });\nexport const CONTEXT_DEBUG_CONFIGURATION_TYPE = new RawContextKey<string>('debugConfigurationType', undefined, { type: 'string', description: nls.localize('debugConfigurationType', \"Debug type of the selected launch configuration. For example 'python'.\") });\nexport const CONTEXT_DEBUG_STATE = new RawContextKey<string>('debugState', 'inactive', { type: 'string', description: nls.localize('debugState', \"State that the focused debug session is in. One of the following: 'inactive', 'initializing', 'stopped' or 'running'.\") });\nexport const CONTEXT_DEBUG_UX_KEY = 'debugUx';\nexport const CONTEXT_DEBUG_UX = new RawContextKey<string>(CONTEXT_DEBUG_UX_KEY, 'default', { type: 'string', description: nls.localize('debugUX', \"Debug UX state. When there are no debug configurations it is 'simple', otherwise 'default'. Used to decide when to show welcome views in the debug viewlet.\") });\nexport const CONTEXT_HAS_DEBUGGED = new RawContextKey<boolean>('hasDebugged', false, { type: 'boolean', description: nls.localize('hasDebugged', \"True when a debug session has been started at least once, false otherwise.\") });\nexport const CONTEXT_IN_DEBUG_MODE = new RawContextKey<boolean>('inDebugMode', false, { type: 'boolean', description: nls.localize('inDebugMode', \"True when debugging, false otherwise.\") });\nexport const CONTEXT_IN_DEBUG_REPL = new RawContextKey<boolean>('inDebugRepl', false, { type: 'boolean', description: nls.localize('inDebugRepl', \"True when focus is in the debug console, false otherwise.\") });\nexport const CONTEXT_BREAKPOINT_WIDGET_VISIBLE = new RawContextKey<boolean>('breakpointWidgetVisible', false, { type: 'boolean', description: nls.localize('breakpointWidgetVisibile', \"True when breakpoint editor zone widget is visible, false otherwise.\") });\nexport const CONTEXT_IN_BREAKPOINT_WIDGET = new RawContextKey<boolean>('inBreakpointWidget', false, { type: 'boolean', description: nls.localize('inBreakpointWidget', \"True when focus is in the breakpoint editor zone widget, false otherwise.\") });\nexport const CONTEXT_BREAKPOINTS_FOCUSED = new RawContextKey<boolean>('breakpointsFocused', true, { type: 'boolean', description: nls.localize('breakpointsFocused', \"True when the BREAKPOINTS view is focused, false otherwise.\") });\nexport const CONTEXT_WATCH_EXPRESSIONS_FOCUSED = new RawContextKey<boolean>('watchExpressionsFocused', true, { type: 'boolean', description: nls.localize('watchExpressionsFocused', \"True when the WATCH view is focused, false otherwsie.\") });\nexport const CONTEXT_WATCH_EXPRESSIONS_EXIST = new RawContextKey<boolean>('watchExpressionsExist', false, { type: 'boolean', description: nls.localize('watchExpressionsExist', \"True when at least one watch expression exists, false otherwise.\") });\nexport const CONTEXT_VARIABLES_FOCUSED = new RawContextKey<boolean>('variablesFocused', true, { type: 'boolean', description: nls.localize('variablesFocused', \"True when the VARIABLES views is focused, false otherwsie\") });\nexport const CONTEXT_EXPRESSION_SELECTED = new RawContextKey<boolean>('expressionSelected', false, { type: 'boolean', description: nls.localize('expressionSelected', \"True when an expression input box is open in either the WATCH or the VARIABLES view, false otherwise.\") });\nexport const CONTEXT_BREAKPOINT_INPUT_FOCUSED = new RawContextKey<boolean>('breakpointInputFocused', false, { type: 'boolean', description: nls.localize('breakpointInputFocused', \"True when the input box has focus in the BREAKPOINTS view.\") });\nexport const CONTEXT_CALLSTACK_ITEM_TYPE = new RawContextKey<string>('callStackItemType', undefined, { type: 'string', description: nls.localize('callStackItemType', \"Represents the item type of the focused element in the CALL STACK view. For example: 'session', 'thread', 'stackFrame'\") });\nexport const CONTEXT_CALLSTACK_SESSION_IS_ATTACH = new RawContextKey<boolean>('callStackSessionIsAttach', false, { type: 'boolean', description: nls.localize('callStackSessionIsAttach', \"True when the session in the CALL STACK view is attach, false otherwise. Used internally for inline menus in the CALL STACK view.\") });\nexport const CONTEXT_CALLSTACK_ITEM_STOPPED = new RawContextKey<boolean>('callStackItemStopped', false, { type: 'boolean', description: nls.localize('callStackItemStopped', \"True when the focused item in the CALL STACK is stopped. Used internaly for inline menus in the CALL STACK view.\") });\nexport const CONTEXT_CALLSTACK_SESSION_HAS_ONE_THREAD = new RawContextKey<boolean>('callStackSessionHasOneThread', false, { type: 'boolean', description: nls.localize('callStackSessionHasOneThread', \"True when the focused session in the CALL STACK view has exactly one thread. Used internally for inline menus in the CALL STACK view.\") });\nexport const CONTEXT_WATCH_ITEM_TYPE = new RawContextKey<string>('watchItemType', undefined, { type: 'string', description: nls.localize('watchItemType', \"Represents the item type of the focused element in the WATCH view. For example: 'expression', 'variable'\") });\nexport const CONTEXT_CAN_VIEW_MEMORY = new RawContextKey<boolean>('canViewMemory', undefined, { type: 'boolean', description: nls.localize('canViewMemory', \"Indicates whether the item in the view has an associated memory refrence.\") });\nexport const CONTEXT_BREAKPOINT_ITEM_TYPE = new RawContextKey<string>('breakpointItemType', undefined, { type: 'string', description: nls.localize('breakpointItemType', \"Represents the item type of the focused element in the BREAKPOINTS view. For example: 'breakpoint', 'exceptionBreakppint', 'functionBreakpoint', 'dataBreakpoint'\") });\nexport const CONTEXT_BREAKPOINT_SUPPORTS_CONDITION = new RawContextKey<boolean>('breakpointSupportsCondition', false, { type: 'boolean', description: nls.localize('breakpointSupportsCondition', \"True when the focused breakpoint supports conditions.\") });\nexport const CONTEXT_LOADED_SCRIPTS_SUPPORTED = new RawContextKey<boolean>('loadedScriptsSupported', false, { type: 'boolean', description: nls.localize('loadedScriptsSupported', \"True when the focused sessions supports the LOADED SCRIPTS view\") });\nexport const CONTEXT_LOADED_SCRIPTS_ITEM_TYPE = new RawContextKey<string>('loadedScriptsItemType', undefined, { type: 'string', description: nls.localize('loadedScriptsItemType', \"Represents the item type of the focused element in the LOADED SCRIPTS view.\") });\nexport const CONTEXT_FOCUSED_SESSION_IS_ATTACH = new RawContextKey<boolean>('focusedSessionIsAttach', false, { type: 'boolean', description: nls.localize('focusedSessionIsAttach', \"True when the focused session is 'attach'.\") });\nexport const CONTEXT_STEP_BACK_SUPPORTED = new RawContextKey<boolean>('stepBackSupported', false, { type: 'boolean', description: nls.localize('stepBackSupported', \"True when the focused session supports 'stepBack' requests.\") });\nexport const CONTEXT_RESTART_FRAME_SUPPORTED = new RawContextKey<boolean>('restartFrameSupported', false, { type: 'boolean', description: nls.localize('restartFrameSupported', \"True when the focused session supports 'restartFrame' requests.\") });\nexport const CONTEXT_STACK_FRAME_SUPPORTS_RESTART = new RawContextKey<boolean>('stackFrameSupportsRestart', false, { type: 'boolean', description: nls.localize('stackFrameSupportsRestart', \"True when the focused stack frame suppots 'restartFrame'.\") });\nexport const CONTEXT_JUMP_TO_CURSOR_SUPPORTED = new RawContextKey<boolean>('jumpToCursorSupported', false, { type: 'boolean', description: nls.localize('jumpToCursorSupported', \"True when the focused session supports 'jumpToCursor' request.\") });\nexport const CONTEXT_STEP_INTO_TARGETS_SUPPORTED = new RawContextKey<boolean>('stepIntoTargetsSupported', false, { type: 'boolean', description: nls.localize('stepIntoTargetsSupported', \"True when the focused session supports 'stepIntoTargets' request.\") });\nexport const CONTEXT_BREAKPOINTS_EXIST = new RawContextKey<boolean>('breakpointsExist', false, { type: 'boolean', description: nls.localize('breakpointsExist', \"True when at least one breakpoint exists.\") });\nexport const CONTEXT_DEBUGGERS_AVAILABLE = new RawContextKey<boolean>('debuggersAvailable', false, { type: 'boolean', description: nls.localize('debuggersAvailable', \"True when there is at least one debug extensions active.\") });\nexport const CONTEXT_DEBUG_EXTENSION_AVAILABLE = new RawContextKey<boolean>('debugExtensionAvailable', true, { type: 'boolean', description: nls.localize('debugExtensionsAvailable', \"True when there is at least one debug extension installed and enabled.\") });\nexport const CONTEXT_DEBUG_PROTOCOL_VARIABLE_MENU_CONTEXT = new RawContextKey<string>('debugProtocolVariableMenuContext', undefined, { type: 'string', description: nls.localize('debugProtocolVariableMenuContext', \"Represents the context the debug adapter sets on the focused variable in the VARIABLES view.\") });\nexport const CONTEXT_SET_VARIABLE_SUPPORTED = new RawContextKey<boolean>('debugSetVariableSupported', false, { type: 'boolean', description: nls.localize('debugSetVariableSupported', \"True when the focused session supports 'setVariable' request.\") });\nexport const CONTEXT_SET_EXPRESSION_SUPPORTED = new RawContextKey<boolean>('debugSetExpressionSupported', false, { type: 'boolean', description: nls.localize('debugSetExpressionSupported', \"True when the focused session supports 'setExpression' request.\") });\nexport const CONTEXT_BREAK_WHEN_VALUE_CHANGES_SUPPORTED = new RawContextKey<boolean>('breakWhenValueChangesSupported', false, { type: 'boolean', description: nls.localize('breakWhenValueChangesSupported', \"True when the focused session supports to break when value changes.\") });\nexport const CONTEXT_BREAK_WHEN_VALUE_IS_ACCESSED_SUPPORTED = new RawContextKey<boolean>('breakWhenValueIsAccessedSupported', false, { type: 'boolean', description: nls.localize('breakWhenValueIsAccessedSupported', \"True when the focused breakpoint supports to break when value is accessed.\") });\nexport const CONTEXT_BREAK_WHEN_VALUE_IS_READ_SUPPORTED = new RawContextKey<boolean>('breakWhenValueIsReadSupported', false, { type: 'boolean', description: nls.localize('breakWhenValueIsReadSupported', \"True when the focused breakpoint supports to break when value is read.\") });\nexport const CONTEXT_TERMINATE_DEBUGGEE_SUPPORTED = new RawContextKey<boolean>('terminateDebuggeeSupported', false, { type: 'boolean', description: nls.localize('terminateDebuggeeSupported', \"True when the focused session supports the terminate debuggee capability.\") });\nexport const CONTEXT_SUSPEND_DEBUGGEE_SUPPORTED = new RawContextKey<boolean>('suspendDebuggeeSupported', false, { type: 'boolean', description: nls.localize('suspendDebuggeeSupported', \"True when the focused session supports the suspend debuggee capability.\") });\nexport const CONTEXT_VARIABLE_EVALUATE_NAME_PRESENT = new RawContextKey<boolean>('variableEvaluateNamePresent', false, { type: 'boolean', description: nls.localize('variableEvaluateNamePresent', \"True when the focused variable has an 'evalauteName' field set.\") });\nexport const CONTEXT_VARIABLE_IS_READONLY = new RawContextKey<boolean>('variableIsReadonly', false, { type: 'boolean', description: nls.localize('variableIsReadonly', \"True when the focused variable is read-only.\") });\nexport const CONTEXT_EXCEPTION_WIDGET_VISIBLE = new RawContextKey<boolean>('exceptionWidgetVisible', false, { type: 'boolean', description: nls.localize('exceptionWidgetVisible', \"True when the exception widget is visible.\") });\nexport const CONTEXT_MULTI_SESSION_REPL = new RawContextKey<boolean>('multiSessionRepl', false, { type: 'boolean', description: nls.localize('multiSessionRepl', \"True when there is more than 1 debug console.\") });\nexport const CONTEXT_MULTI_SESSION_DEBUG = new RawContextKey<boolean>('multiSessionDebug', false, { type: 'boolean', description: nls.localize('multiSessionDebug', \"True when there is more than 1 active debug session.\") });\nexport const CONTEXT_DISASSEMBLE_REQUEST_SUPPORTED = new RawContextKey<boolean>('disassembleRequestSupported', false, { type: 'boolean', description: nls.localize('disassembleRequestSupported', \"True when the focused sessions supports disassemble request.\") });\nexport const CONTEXT_DISASSEMBLY_VIEW_FOCUS = new RawContextKey<boolean>('disassemblyViewFocus', false, { type: 'boolean', description: nls.localize('disassemblyViewFocus', \"True when the Disassembly View is focused.\") });\nexport const CONTEXT_LANGUAGE_SUPPORTS_DISASSEMBLE_REQUEST = new RawContextKey<boolean>('languageSupportsDisassembleRequest', false, { type: 'boolean', description: nls.localize('languageSupportsDisassembleRequest', \"True when the language in the current editor supports disassemble request.\") });\nexport const CONTEXT_FOCUSED_STACK_FRAME_HAS_INSTRUCTION_POINTER_REFERENCE = new RawContextKey<boolean>('focusedStackFrameHasInstructionReference', false, { type: 'boolean', description: nls.localize('focusedStackFrameHasInstructionReference', \"True when the focused stack frame has instruction pointer reference.\") });\n\nexport const debuggerDisabledMessage = (debugType: string) => nls.localize('debuggerDisabled', \"Configured debug type '{0}' is installed but not supported in this environment.\", debugType);\n\nexport const EDITOR_CONTRIBUTION_ID = 'editor.contrib.debug';\nexport const BREAKPOINT_EDITOR_CONTRIBUTION_ID = 'editor.contrib.breakpoint';\nexport const DEBUG_SCHEME = 'debug';\nexport const INTERNAL_CONSOLE_OPTIONS_SCHEMA = {\n\tenum: ['neverOpen', 'openOnSessionStart', 'openOnFirstSessionStart'],\n\tdefault: 'openOnFirstSessionStart',\n\tdescription: nls.localize('internalConsoleOptions', \"Controls when the internal Debug Console should open.\")\n};\n\n// raw\n\nexport interface IRawModelUpdate {\n\tsessionId: string;\n\tthreads: DebugProtocol.Thread[];\n\tstoppedDetails?: IRawStoppedDetails;\n}\n\nexport interface IRawStoppedDetails {\n\treason?: string;\n\tdescription?: string;\n\tthreadId?: number;\n\ttext?: string;\n\ttotalFrames?: number;\n\tallThreadsStopped?: boolean;\n\tframesErrorMessage?: string;\n\thitBreakpointIds?: number[];\n}\n\n// model\n\nexport interface ITreeElement {\n\tgetId(): string;\n}\n\nexport interface IReplElement extends ITreeElement {\n\ttoString(includeSource?: boolean): string;\n\treadonly sourceData?: IReplElementSource;\n}\n\nexport interface INestingReplElement extends IReplElement {\n\treadonly hasChildren: boolean;\n\tgetChildren(): Promise<IReplElement[]> | IReplElement[];\n}\n\nexport interface IReplElementSource {\n\treadonly source: Source;\n\treadonly lineNumber: number;\n\treadonly column: number;\n}\n\nexport interface IExpressionContainer extends ITreeElement {\n\treadonly hasChildren: boolean;\n\tevaluateLazy(): Promise<void>;\n\tgetChildren(): Promise<IExpression[]>;\n\treadonly reference?: number;\n\treadonly memoryReference?: string;\n\treadonly value: string;\n\treadonly type?: string;\n\tvalueChanged?: boolean;\n\treadonly presentationHint?: DebugProtocol.VariablePresentationHint | undefined;\n}\n\nexport interface IExpression extends IExpressionContainer {\n\tname: string;\n}\n\nexport interface IDebugger {\n\treadonly type: string;\n\tcreateDebugAdapter(session: IDebugSession): Promise<IDebugAdapter>;\n\trunInTerminal(args: DebugProtocol.RunInTerminalRequestArguments, sessionId: string): Promise<number | undefined>;\n\tstartDebugging(args: IConfig, parentSessionId: string): Promise<boolean>;\n\tgetCustomTelemetryEndpoint(): ITelemetryEndpoint | undefined;\n\tgetInitialConfigurationContent(initialConfigs?: IConfig[]): Promise<string>;\n}\n\nexport interface IDebuggerMetadata {\n\tlabel: string;\n\ttype: string;\n\tstrings?: { [key in DebuggerString]: string };\n\tinterestedInLanguage(languageId: string): boolean;\n}\n\nexport const enum State {\n\tInactive,\n\tInitializing,\n\tStopped,\n\tRunning\n}\n\nexport function getStateLabel(state: State): string {\n\tswitch (state) {\n\t\tcase State.Initializing: return 'initializing';\n\t\tcase State.Stopped: return 'stopped';\n\t\tcase State.Running: return 'running';\n\t\tdefault: return 'inactive';\n\t}\n}\n\nexport interface AdapterEndEvent {\n\terror?: Error;\n\tsessionLengthInSeconds: number;\n\temittedStopped: boolean;\n}\n\nexport interface LoadedSourceEvent {\n\treason: 'new' | 'changed' | 'removed';\n\tsource: Source;\n}\n\nexport type IDebugSessionReplMode = 'separate' | 'mergeWithParent';\n\nexport interface IDebugSessionOptions {\n\tnoDebug?: boolean;\n\tparentSession?: IDebugSession;\n\tlifecycleManagedByParent?: boolean;\n\trepl?: IDebugSessionReplMode;\n\tcompoundRoot?: DebugCompoundRoot;\n\tcompact?: boolean;\n\tstartedByUser?: boolean;\n\tsaveBeforeRestart?: boolean;\n\tsuppressDebugToolbar?: boolean;\n\tsuppressDebugStatusbar?: boolean;\n\tsuppressDebugView?: boolean;\n}\n\nexport interface IDataBreakpointInfoResponse {\n\tdataId: string | null;\n\tdescription: string;\n\tcanPersist?: boolean;\n\taccessTypes?: DebugProtocol.DataBreakpointAccessType[];\n}\n\nexport interface IMemoryInvalidationEvent {\n\tfromOffset: number;\n\ttoOffset: number;\n}\n\nexport const enum MemoryRangeType {\n\tValid,\n\tUnreadable,\n\tError,\n}\n\nexport interface IMemoryRange {\n\ttype: MemoryRangeType;\n\toffset: number;\n\tlength: number;\n}\n\nexport interface IValidMemoryRange extends IMemoryRange {\n\ttype: MemoryRangeType.Valid;\n\toffset: number;\n\tlength: number;\n\tdata: VSBuffer;\n}\n\nexport interface IUnreadableMemoryRange extends IMemoryRange {\n\ttype: MemoryRangeType.Unreadable;\n}\n\nexport interface IErrorMemoryRange extends IMemoryRange {\n\ttype: MemoryRangeType.Error;\n\terror: string;\n}\n\n/**\n * Union type of memory that can be returned from read(). Since a read request\n * could encompass multiple previously-read ranges, multiple of these types\n * are possible to return.\n */\nexport type MemoryRange = IValidMemoryRange | IUnreadableMemoryRange | IErrorMemoryRange;\n\nexport const DEBUG_MEMORY_SCHEME = 'vscode-debug-memory';\n\n/**\n * An IMemoryRegion corresponds to a contiguous range of memory referred to\n * by a DAP `memoryReference`.\n */\nexport interface IMemoryRegion extends IDisposable {\n\t/**\n\t * Event that fires when memory changes. Can be a result of memory events or\n\t * `write` requests.\n\t */\n\treadonly onDidInvalidate: Event<IMemoryInvalidationEvent>;\n\n\t/**\n\t * Whether writes are supported on this memory region.\n\t */\n\treadonly writable: boolean;\n\n\t/**\n\t * Requests memory ranges from the debug adapter. It returns a list of memory\n\t * ranges that overlap (but may exceed!) the given offset. Use the `offset`\n\t * and `length` of each range for display.\n\t */\n\tread(fromOffset: number, toOffset: number): Promise<MemoryRange[]>;\n\n\t/**\n\t * Writes memory to the debug adapter at the given offset.\n\t */\n\twrite(offset: number, data: VSBuffer): Promise<number>;\n}\n\n/** Data that can be inserted in {@link IDebugSession.appendToRepl} */\nexport interface INewReplElementData {\n\t/**\n\t * Output string to display\n\t */\n\toutput: string;\n\n\t/**\n\t * Expression data to display. Will result in the item being expandable in\n\t * the REPL. Its value will be used if {@link output} is not provided.\n\t */\n\texpression?: IExpression;\n\n\t/**\n\t * Output severity.\n\t */\n\tsev: severity;\n\n\t/**\n\t * Originating location.\n\t */\n\tsource?: IReplElementSource;\n}\n\n\nexport interface IDebugSession extends ITreeElement {\n\n\treadonly configuration: IConfig;\n\treadonly unresolvedConfiguration: IConfig | undefined;\n\treadonly state: State;\n\treadonly root: IWorkspaceFolder | undefined;\n\treadonly parentSession: IDebugSession | undefined;\n\treadonly subId: string | undefined;\n\treadonly compact: boolean;\n\treadonly compoundRoot: DebugCompoundRoot | undefined;\n\treadonly saveBeforeRestart: boolean;\n\treadonly name: string;\n\treadonly autoExpandLazyVariables: boolean;\n\treadonly suppressDebugToolbar: boolean;\n\treadonly suppressDebugStatusbar: boolean;\n\treadonly suppressDebugView: boolean;\n\treadonly lifecycleManagedByParent: boolean;\n\n\tsetSubId(subId: string | undefined): void;\n\n\tgetMemory(memoryReference: string): IMemoryRegion;\n\n\tsetName(name: string): void;\n\treadonly onDidChangeName: Event<string>;\n\tgetLabel(): string;\n\n\tgetSourceForUri(modelUri: uri): Source | undefined;\n\tgetSource(raw?: DebugProtocol.Source): Source;\n\n\tsetConfiguration(configuration: { resolved: IConfig; unresolved: IConfig | undefined }): void;\n\trawUpdate(data: IRawModelUpdate): void;\n\n\tgetThread(threadId: number): IThread | undefined;\n\tgetAllThreads(): IThread[];\n\tclearThreads(removeThreads: boolean, reference?: number): void;\n\tgetStoppedDetails(): IRawStoppedDetails | undefined;\n\n\tgetReplElements(): IReplElement[];\n\thasSeparateRepl(): boolean;\n\tremoveReplExpressions(): void;\n\taddReplExpression(stackFrame: IStackFrame | undefined, name: string): Promise<void>;\n\tappendToRepl(data: INewReplElementData): void;\n\n\t// session events\n\treadonly onDidEndAdapter: Event<AdapterEndEvent | undefined>;\n\treadonly onDidChangeState: Event<void>;\n\treadonly onDidChangeReplElements: Event<void>;\n\n\t// DA capabilities\n\treadonly capabilities: DebugProtocol.Capabilities;\n\n\t// DAP events\n\n\treadonly onDidLoadedSource: Event<LoadedSourceEvent>;\n\treadonly onDidCustomEvent: Event<DebugProtocol.Event>;\n\treadonly onDidProgressStart: Event<DebugProtocol.ProgressStartEvent>;\n\treadonly onDidProgressUpdate: Event<DebugProtocol.ProgressUpdateEvent>;\n\treadonly onDidProgressEnd: Event<DebugProtocol.ProgressEndEvent>;\n\treadonly onDidInvalidateMemory: Event<DebugProtocol.MemoryEvent>;\n\n\t// DAP request\n\n\tinitialize(dbgr: IDebugger): Promise<void>;\n\tlaunchOrAttach(config: IConfig): Promise<void>;\n\trestart(): Promise<void>;\n\tterminate(restart?: boolean /* false */): Promise<void>;\n\tdisconnect(restart?: boolean /* false */, suspend?: boolean): Promise<void>;\n\n\tsendBreakpoints(modelUri: uri, bpts: IBreakpoint[], sourceModified: boolean): Promise<void>;\n\tsendFunctionBreakpoints(fbps: IFunctionBreakpoint[]): Promise<void>;\n\tdataBreakpointInfo(name: string, variablesReference?: number): Promise<IDataBreakpointInfoResponse | undefined>;\n\tsendDataBreakpoints(dbps: IDataBreakpoint[]): Promise<void>;\n\tsendInstructionBreakpoints(dbps: IInstructionBreakpoint[]): Promise<void>;\n\tsendExceptionBreakpoints(exbpts: IExceptionBreakpoint[]): Promise<void>;\n\tbreakpointsLocations(uri: uri, lineNumber: number): Promise<IPosition[]>;\n\tgetDebugProtocolBreakpoint(breakpointId: string): DebugProtocol.Breakpoint | undefined;\n\n\tstackTrace(threadId: number, startFrame: number, levels: number, token: CancellationToken): Promise<DebugProtocol.StackTraceResponse | undefined>;\n\texceptionInfo(threadId: number): Promise<IExceptionInfo | undefined>;\n\tscopes(frameId: number, threadId: number): Promise<DebugProtocol.ScopesResponse | undefined>;\n\tvariables(variablesReference: number, threadId: number | undefined, filter: 'indexed' | 'named' | undefined, start: number | undefined, count: number | undefined): Promise<DebugProtocol.VariablesResponse | undefined>;\n\tevaluate(expression: string, frameId?: number, context?: string): Promise<DebugProtocol.EvaluateResponse | undefined>;\n\tcustomRequest(request: string, args: any): Promise<DebugProtocol.Response | undefined>;\n\tcancel(progressId: string): Promise<DebugProtocol.CancelResponse | undefined>;\n\tdisassemble(memoryReference: string, offset: number, instructionOffset: number, instructionCount: number): Promise<DebugProtocol.DisassembledInstruction[] | undefined>;\n\treadMemory(memoryReference: string, offset: number, count: number): Promise<DebugProtocol.ReadMemoryResponse | undefined>;\n\twriteMemory(memoryReference: string, offset: number, data: string, allowPartial?: boolean): Promise<DebugProtocol.WriteMemoryResponse | undefined>;\n\n\trestartFrame(frameId: number, threadId: number): Promise<void>;\n\tnext(threadId: number, granularity?: DebugProtocol.SteppingGranularity): Promise<void>;\n\tstepIn(threadId: number, targetId?: number, granularity?: DebugProtocol.SteppingGranularity): Promise<void>;\n\tstepInTargets(frameId: number): Promise<DebugProtocol.StepInTarget[] | undefined>;\n\tstepOut(threadId: number, granularity?: DebugProtocol.SteppingGranularity): Promise<void>;\n\tstepBack(threadId: number, granularity?: DebugProtocol.SteppingGranularity): Promise<void>;\n\tcontinue(threadId: number): Promise<void>;\n\treverseContinue(threadId: number): Promise<void>;\n\tpause(threadId: number): Promise<void>;\n\tterminateThreads(threadIds: number[]): Promise<void>;\n\n\tcompletions(frameId: number | undefined, threadId: number, text: string, position: Position, overwriteBefore: number, token: CancellationToken): Promise<DebugProtocol.CompletionsResponse | undefined>;\n\tsetVariable(variablesReference: number | undefined, name: string, value: string): Promise<DebugProtocol.SetVariableResponse | undefined>;\n\tsetExpression(frameId: number, expression: string, value: string): Promise<DebugProtocol.SetExpressionResponse | undefined>;\n\tloadSource(resource: uri): Promise<DebugProtocol.SourceResponse | undefined>;\n\tgetLoadedSources(): Promise<Source[]>;\n\n\tgotoTargets(source: DebugProtocol.Source, line: number, column?: number): Promise<DebugProtocol.GotoTargetsResponse | undefined>;\n\tgoto(threadId: number, targetId: number): Promise<DebugProtocol.GotoResponse | undefined>;\n}\n\nexport interface IThread extends ITreeElement {\n\n\t/**\n\t * Process the thread belongs to\n\t */\n\treadonly session: IDebugSession;\n\n\t/**\n\t * Id of the thread generated by the debug adapter backend.\n\t */\n\treadonly threadId: number;\n\n\t/**\n\t * Name of the thread.\n\t */\n\treadonly name: string;\n\n\t/**\n\t * Information about the current thread stop event. Undefined if thread is not stopped.\n\t */\n\treadonly stoppedDetails: IRawStoppedDetails | undefined;\n\n\t/**\n\t * Information about the exception if an 'exception' stopped event raised and DA supports the 'exceptionInfo' request, otherwise undefined.\n\t */\n\treadonly exceptionInfo: Promise<IExceptionInfo | undefined>;\n\n\treadonly stateLabel: string;\n\n\t/**\n\t * Gets the callstack if it has already been received from the debug\n\t * adapter.\n\t */\n\tgetCallStack(): ReadonlyArray<IStackFrame>;\n\n\n\t/**\n\t * Gets the top stack frame that is not hidden if the callstack has already been received from the debug adapter\n\t */\n\tgetTopStackFrame(): IStackFrame | undefined;\n\n\t/**\n\t * Invalidates the callstack cache\n\t */\n\tclearCallStack(): void;\n\n\t/**\n\t * Indicates whether this thread is stopped. The callstack for stopped\n\t * threads can be retrieved from the debug adapter.\n\t */\n\treadonly stopped: boolean;\n\n\tnext(granularity?: DebugProtocol.SteppingGranularity): Promise<any>;\n\tstepIn(granularity?: DebugProtocol.SteppingGranularity): Promise<any>;\n\tstepOut(granularity?: DebugProtocol.SteppingGranularity): Promise<any>;\n\tstepBack(granularity?: DebugProtocol.SteppingGranularity): Promise<any>;\n\tcontinue(): Promise<any>;\n\tpause(): Promise<any>;\n\tterminate(): Promise<any>;\n\treverseContinue(): Promise<any>;\n}\n\nexport interface IScope extends IExpressionContainer {\n\treadonly name: string;\n\treadonly expensive: boolean;\n\treadonly range?: IRange;\n\treadonly hasChildren: boolean;\n}\n\nexport interface IStackFrame extends ITreeElement {\n\treadonly thread: IThread;\n\treadonly name: string;\n\treadonly presentationHint: string | undefined;\n\treadonly frameId: number;\n\treadonly range: IRange;\n\treadonly source: Source;\n\treadonly canRestart: boolean;\n\treadonly instructionPointerReference?: string;\n\tgetScopes(): Promise<IScope[]>;\n\tgetMostSpecificScopes(range: IRange): Promise<ReadonlyArray<IScope>>;\n\tforgetScopes(): void;\n\trestart(): Promise<any>;\n\ttoString(): string;\n\topenInEditor(editorService: IEditorService, preserveFocus?: boolean, sideBySide?: boolean, pinned?: boolean): Promise<IEditorPane | undefined>;\n\tequals(other: IStackFrame): boolean;\n}\n\nexport interface IEnablement extends ITreeElement {\n\treadonly enabled: boolean;\n}\n\nexport interface IBreakpointData {\n\treadonly id?: string;\n\treadonly lineNumber: number;\n\treadonly column?: number;\n\treadonly enabled?: boolean;\n\treadonly condition?: string;\n\treadonly logMessage?: string;\n\treadonly hitCondition?: string;\n}\n\nexport interface IBreakpointUpdateData {\n\treadonly condition?: string;\n\treadonly hitCondition?: string;\n\treadonly logMessage?: string;\n\treadonly lineNumber?: number;\n\treadonly column?: number;\n}\n\nexport interface IBaseBreakpoint extends IEnablement {\n\treadonly condition?: string;\n\treadonly hitCondition?: string;\n\treadonly logMessage?: string;\n\treadonly verified: boolean;\n\treadonly supported: boolean;\n\treadonly message?: string;\n\treadonly sessionsThatVerified: string[];\n\tgetIdFromAdapter(sessionId: string): number | undefined;\n}\n\nexport interface IBreakpoint extends IBaseBreakpoint {\n\t/** URI where the breakpoint was first set by the user. */\n\treadonly originalUri: uri;\n\t/** URI where the breakpoint is currently shown; may be moved by debugger */\n\treadonly uri: uri;\n\treadonly lineNumber: number;\n\treadonly endLineNumber?: number;\n\treadonly column?: number;\n\treadonly endColumn?: number;\n\treadonly adapterData: any;\n\treadonly sessionAgnosticData: { lineNumber: number; column: number | undefined };\n}\n\nexport interface IFunctionBreakpoint extends IBaseBreakpoint {\n\treadonly name: string;\n}\n\nexport interface IExceptionBreakpoint extends IBaseBreakpoint {\n\treadonly filter: string;\n\treadonly label: string;\n\treadonly description: string | undefined;\n}\n\nexport interface IDataBreakpoint extends IBaseBreakpoint {\n\treadonly description: string;\n\treadonly dataId: string;\n\treadonly canPersist: boolean;\n\treadonly accessType: DebugProtocol.DataBreakpointAccessType;\n}\n\nexport interface IInstructionBreakpoint extends IBaseBreakpoint {\n\treadonly instructionReference: string;\n\treadonly offset?: number;\n\t/** Original instruction memory address; display purposes only */\n\treadonly address: bigint;\n\ttoJSON(): DebugProtocol.InstructionBreakpoint;\n}\n\nexport interface IExceptionInfo {\n\treadonly id?: string;\n\treadonly description?: string;\n\treadonly breakMode: string | null;\n\treadonly details?: DebugProtocol.ExceptionDetails;\n}\n\n// model interfaces\n\nexport interface IViewModel extends ITreeElement {\n\t/**\n\t * Returns the focused debug session or undefined if no session is stopped.\n\t */\n\treadonly focusedSession: IDebugSession | undefined;\n\n\t/**\n\t * Returns the focused thread or undefined if no thread is stopped.\n\t */\n\treadonly focusedThread: IThread | undefined;\n\n\t/**\n\t * Returns the focused stack frame or undefined if there are no stack frames.\n\t */\n\treadonly focusedStackFrame: IStackFrame | undefined;\n\n\tgetSelectedExpression(): { expression: IExpression; settingWatch: boolean } | undefined;\n\tsetSelectedExpression(expression: IExpression | undefined, settingWatch: boolean): void;\n\tupdateViews(): void;\n\n\tisMultiSessionView(): boolean;\n\n\tonDidFocusSession: Event<IDebugSession | undefined>;\n\tonDidFocusThread: Event<{ thread: IThread | undefined; explicit: boolean; session: IDebugSession | undefined }>;\n\tonDidFocusStackFrame: Event<{ stackFrame: IStackFrame | undefined; explicit: boolean; session: IDebugSession | undefined }>;\n\tonDidSelectExpression: Event<{ expression: IExpression; settingWatch: boolean } | undefined>;\n\tonDidEvaluateLazyExpression: Event<IExpressionContainer>;\n\tonWillUpdateViews: Event<void>;\n\n\tevaluateLazyExpression(expression: IExpressionContainer): void;\n}\n\nexport interface IEvaluate {\n\tevaluate(session: IDebugSession, stackFrame: IStackFrame, context: string): Promise<void>;\n}\n\nexport interface IDebugModel extends ITreeElement {\n\tgetSession(sessionId: string | undefined, includeInactive?: boolean): IDebugSession | undefined;\n\tgetSessions(includeInactive?: boolean): IDebugSession[];\n\tgetBreakpoints(filter?: { uri?: uri; originalUri?: uri; lineNumber?: number; column?: number; enabledOnly?: boolean }): ReadonlyArray<IBreakpoint>;\n\tareBreakpointsActivated(): boolean;\n\tgetFunctionBreakpoints(): ReadonlyArray<IFunctionBreakpoint>;\n\tgetDataBreakpoints(): ReadonlyArray<IDataBreakpoint>;\n\n\t/**\n\t * Returns list of all exception breakpoints.\n\t */\n\tgetExceptionBreakpoints(): ReadonlyArray<IExceptionBreakpoint>;\n\n\t/**\n\t * Returns list of exception breakpoints for the given session\n\t * @param sessionId Session id. If falsy, returns the breakpoints from the last set fallback session.\n\t */\n\tgetExceptionBreakpointsForSession(sessionId?: string): ReadonlyArray<IExceptionBreakpoint>;\n\n\tgetInstructionBreakpoints(): ReadonlyArray<IInstructionBreakpoint>;\n\tgetWatchExpressions(): ReadonlyArray<IExpression & IEvaluate>;\n\n\tonDidChangeBreakpoints: Event<IBreakpointsChangeEvent | undefined>;\n\tonDidChangeCallStack: Event<void>;\n\tonDidChangeWatchExpressions: Event<IExpression | undefined>;\n\n\tfetchCallstack(thread: IThread, levels?: number): Promise<void>;\n}\n\n/**\n * An event describing a change to the set of [breakpoints](#debug.Breakpoint).\n */\nexport interface IBreakpointsChangeEvent {\n\tadded?: Array<IBreakpoint | IFunctionBreakpoint | IDataBreakpoint | IInstructionBreakpoint>;\n\tremoved?: Array<IBreakpoint | IFunctionBreakpoint | IDataBreakpoint | IInstructionBreakpoint>;\n\tchanged?: Array<IBreakpoint | IFunctionBreakpoint | IDataBreakpoint | IInstructionBreakpoint>;\n\tsessionOnly: boolean;\n}\n\n// Debug configuration interfaces\n\nexport interface IDebugConfiguration {\n\tallowBreakpointsEverywhere: boolean;\n\topenDebug: 'neverOpen' | 'openOnSessionStart' | 'openOnFirstSessionStart' | 'openOnDebugBreak';\n\topenExplorerOnEnd: boolean;\n\tinlineValues: boolean | 'auto' | 'on' | 'off'; // boolean for back-compat\n\ttoolBarLocation: 'floating' | 'docked' | 'commandCenter' | 'hidden';\n\tshowInStatusBar: 'never' | 'always' | 'onFirstSessionStart';\n\tinternalConsoleOptions: 'neverOpen' | 'openOnSessionStart' | 'openOnFirstSessionStart';\n\textensionHostDebugAdapter: boolean;\n\tenableAllHovers: boolean;\n\tshowSubSessionsInToolBar: boolean;\n\tconsole: {\n\t\tfontSize: number;\n\t\tfontFamily: string;\n\t\tlineHeight: number;\n\t\twordWrap: boolean;\n\t\tcloseOnEnd: boolean;\n\t\tcollapseIdenticalLines: boolean;\n\t\thistorySuggestions: boolean;\n\t\tacceptSuggestionOnEnter: 'off' | 'on';\n\t};\n\tfocusWindowOnBreak: boolean;\n\tfocusEditorOnBreak: boolean;\n\tonTaskErrors: 'debugAnyway' | 'showErrors' | 'prompt' | 'abort';\n\tshowBreakpointsInOverviewRuler: boolean;\n\tshowInlineBreakpointCandidates: boolean;\n\tconfirmOnExit: 'always' | 'never';\n\tdisassemblyView: {\n\t\tshowSourceCode: boolean;\n\t};\n\tautoExpandLazyVariables: boolean;\n\tenableStatusBarColor: boolean;\n}\n\nexport interface IGlobalConfig {\n\tversion: string;\n\tcompounds: ICompound[];\n\tconfigurations: IConfig[];\n}\n\ninterface IEnvConfig {\n\tinternalConsoleOptions?: 'neverOpen' | 'openOnSessionStart' | 'openOnFirstSessionStart';\n\tpreRestartTask?: string | ITaskIdentifier;\n\tpostRestartTask?: string | ITaskIdentifier;\n\tpreLaunchTask?: string | ITaskIdentifier;\n\tpostDebugTask?: string | ITaskIdentifier;\n\tdebugServer?: number;\n\tnoDebug?: boolean;\n\tsuppressMultipleSessionWarning?: boolean;\n}\n\nexport interface IConfigPresentation {\n\thidden?: boolean;\n\tgroup?: string;\n\torder?: number;\n}\n\nexport interface IConfig extends IEnvConfig {\n\n\t// fundamental attributes\n\ttype: string;\n\trequest: string;\n\tname: string;\n\tpresentation?: IConfigPresentation;\n\t// platform specifics\n\twindows?: IEnvConfig;\n\tosx?: IEnvConfig;\n\tlinux?: IEnvConfig;\n\n\t// internals\n\t__configurationTarget?: ConfigurationTarget;\n\t__sessionId?: string;\n\t__restart?: any;\n\t__autoAttach?: boolean;\n\tport?: number; // TODO\n}\n\nexport interface ICompound {\n\tname: string;\n\tstopAll?: boolean;\n\tpreLaunchTask?: string | ITaskIdentifier;\n\tconfigurations: (string | { name: string; folder: string })[];\n\tpresentation?: IConfigPresentation;\n}\n\nexport interface IDebugAdapter extends IDisposable {\n\treadonly onError: Event<Error>;\n\treadonly onExit: Event<number | null>;\n\tonRequest(callback: (request: DebugProtocol.Request) => void): void;\n\tonEvent(callback: (event: DebugProtocol.Event) => void): void;\n\tstartSession(): Promise<void>;\n\tsendMessage(message: DebugProtocol.ProtocolMessage): void;\n\tsendResponse(response: DebugProtocol.Response): void;\n\tsendRequest(command: string, args: any, clb: (result: DebugProtocol.Response) => void, timeout?: number): number;\n\tstopSession(): Promise<void>;\n}\n\nexport interface IDebugAdapterFactory extends ITerminalLauncher {\n\tcreateDebugAdapter(session: IDebugSession): IDebugAdapter;\n\tsubstituteVariables(folder: IWorkspaceFolder | undefined, config: IConfig): Promise<IConfig>;\n}\n\nexport interface IDebugAdapterExecutableOptions {\n\tcwd?: string;\n\tenv?: { [key: string]: string };\n}\n\nexport interface IDebugAdapterExecutable {\n\treadonly type: 'executable';\n\treadonly command: string;\n\treadonly args: string[];\n\treadonly options?: IDebugAdapterExecutableOptions;\n}\n\nexport interface IDebugAdapterServer {\n\treadonly type: 'server';\n\treadonly port: number;\n\treadonly host?: string;\n}\n\nexport interface IDebugAdapterNamedPipeServer {\n\treadonly type: 'pipeServer';\n\treadonly path: string;\n}\n\nexport interface IDebugAdapterInlineImpl extends IDisposable {\n\treadonly onDidSendMessage: Event<DebugProtocol.Message>;\n\thandleMessage(message: DebugProtocol.Message): void;\n}\n\nexport interface IDebugAdapterImpl {\n\treadonly type: 'implementation';\n\treadonly implementation: IDebugAdapterInlineImpl;\n}\n\nexport type IAdapterDescriptor = IDebugAdapterExecutable | IDebugAdapterServer | IDebugAdapterNamedPipeServer | IDebugAdapterImpl;\n\nexport interface IPlatformSpecificAdapterContribution {\n\tprogram?: string;\n\targs?: string[];\n\truntime?: string;\n\truntimeArgs?: string[];\n}\n\nexport interface IDebuggerContribution extends IPlatformSpecificAdapterContribution {\n\ttype: string;\n\tlabel?: string;\n\twin?: IPlatformSpecificAdapterContribution;\n\twinx86?: IPlatformSpecificAdapterContribution;\n\twindows?: IPlatformSpecificAdapterContribution;\n\tosx?: IPlatformSpecificAdapterContribution;\n\tlinux?: IPlatformSpecificAdapterContribution;\n\n\t// internal\n\taiKey?: string;\n\n\t// supported languages\n\tlanguages?: string[];\n\n\t// debug configuration support\n\tconfigurationAttributes?: any;\n\tinitialConfigurations?: any[];\n\tconfigurationSnippets?: IJSONSchemaSnippet[];\n\tvariables?: { [key: string]: string };\n\twhen?: string;\n\thiddenWhen?: string;\n\tdeprecated?: string;\n\tstrings?: { [key in DebuggerString]: string };\n}\n\nexport interface IBreakpointContribution {\n\tlanguage: string;\n\twhen?: string;\n}\n\nexport enum DebugConfigurationProviderTriggerKind {\n\t/**\n\t *\t`DebugConfigurationProvider.provideDebugConfigurations` is called to provide the initial debug configurations for a newly created launch.json.\n\t */\n\tInitial = 1,\n\t/**\n\t * `DebugConfigurationProvider.provideDebugConfigurations` is called to provide dynamically generated debug configurations when the user asks for them through the UI (e.g. via the \"Select and Start Debugging\" command).\n\t */\n\tDynamic = 2\n}\n\nexport interface IDebugConfigurationProvider {\n\treadonly type: string;\n\treadonly triggerKind: DebugConfigurationProviderTriggerKind;\n\tresolveDebugConfiguration?(folderUri: uri | undefined, debugConfiguration: IConfig, token: CancellationToken): Promise<IConfig | null | undefined>;\n\tresolveDebugConfigurationWithSubstitutedVariables?(folderUri: uri | undefined, debugConfiguration: IConfig, token: CancellationToken): Promise<IConfig | null | undefined>;\n\tprovideDebugConfigurations?(folderUri: uri | undefined, token: CancellationToken): Promise<IConfig[]>;\n}\n\nexport interface IDebugAdapterDescriptorFactory {\n\treadonly type: string;\n\tcreateDebugAdapterDescriptor(session: IDebugSession): Promise<IAdapterDescriptor>;\n}\n\ninterface ITerminalLauncher {\n\trunInTerminal(args: DebugProtocol.RunInTerminalRequestArguments, sessionId: string): Promise<number | undefined>;\n}\n\nexport interface IConfigurationManager {\n\n\t/**\n\t * Returns an object containing the selected launch configuration and the selected configuration name. Both these fields can be null (no folder workspace).\n\t */\n\treadonly selectedConfiguration: {\n\t\tlaunch: ILaunch | undefined;\n\t\t// Potentially activates extensions\n\t\tgetConfig: () => Promise<IConfig | undefined>;\n\t\tname: string | undefined;\n\t\t// Type is used when matching dynamic configurations to their corresponding provider\n\t\ttype: string | undefined;\n\t};\n\n\tselectConfiguration(launch: ILaunch | undefined, name?: string, config?: IConfig, dynamicConfigOptions?: { type?: string }): Promise<void>;\n\n\tgetLaunches(): ReadonlyArray<ILaunch>;\n\tgetLaunch(workspaceUri: uri | undefined): ILaunch | undefined;\n\tgetAllConfigurations(): { launch: ILaunch; name: string; presentation?: IConfigPresentation }[];\n\tremoveRecentDynamicConfigurations(name: string, type: string): void;\n\tgetRecentDynamicConfigurations(): { name: string; type: string }[];\n\n\t/**\n\t * Allows to register on change of selected debug configuration.\n\t */\n\tonDidSelectConfiguration: Event<void>;\n\n\thasDebugConfigurationProvider(debugType: string): boolean;\n\tgetDynamicProviders(): Promise<{ label: string; type: string; pick: () => Promise<{ launch: ILaunch; config: IConfig } | undefined> }[]>;\n\n\tregisterDebugConfigurationProvider(debugConfigurationProvider: IDebugConfigurationProvider): IDisposable;\n\tunregisterDebugConfigurationProvider(debugConfigurationProvider: IDebugConfigurationProvider): void;\n\n\tresolveConfigurationByProviders(folderUri: uri | undefined, type: string | undefined, debugConfiguration: any, token: CancellationToken): Promise<any>;\n}\n\nexport enum DebuggerString {\n\tUnverifiedBreakpoints = 'unverifiedBreakpoints'\n}\n\nexport interface IAdapterManager {\n\n\tonDidRegisterDebugger: Event<void>;\n\n\thasEnabledDebuggers(): boolean;\n\tgetDebugAdapterDescriptor(session: IDebugSession): Promise<IAdapterDescriptor | undefined>;\n\tgetDebuggerLabel(type: string): string | undefined;\n\tsomeDebuggerInterestedInLanguage(language: string): boolean;\n\tgetDebugger(type: string): IDebuggerMetadata | undefined;\n\n\tactivateDebuggers(activationEvent: string, debugType?: string): Promise<void>;\n\tregisterDebugAdapterFactory(debugTypes: string[], debugAdapterFactory: IDebugAdapterFactory): IDisposable;\n\tcreateDebugAdapter(session: IDebugSession): IDebugAdapter | undefined;\n\tregisterDebugAdapterDescriptorFactory(debugAdapterDescriptorFactory: IDebugAdapterDescriptorFactory): IDisposable;\n\tunregisterDebugAdapterDescriptorFactory(debugAdapterDescriptorFactory: IDebugAdapterDescriptorFactory): void;\n\n\tsubstituteVariables(debugType: string, folder: IWorkspaceFolder | undefined, config: IConfig): Promise<IConfig>;\n\trunInTerminal(debugType: string, args: DebugProtocol.RunInTerminalRequestArguments, sessionId: string): Promise<number | undefined>;\n\tgetEnabledDebugger(type: string): (IDebugger & IDebuggerMetadata) | undefined;\n\tguessDebugger(gettingConfigurations: boolean): Promise<(IDebugger & IDebuggerMetadata) | undefined>;\n\n\tget onDidDebuggersExtPointRead(): Event<void>;\n}\n\nexport interface ILaunch {\n\n\t/**\n\t * Resource pointing to the launch.json this object is wrapping.\n\t */\n\treadonly uri: uri;\n\n\t/**\n\t * Name of the launch.\n\t */\n\treadonly name: string;\n\n\t/**\n\t * Workspace of the launch. Can be undefined.\n\t */\n\treadonly workspace: IWorkspaceFolder | undefined;\n\n\t/**\n\t * Should this launch be shown in the debug dropdown.\n\t */\n\treadonly hidden: boolean;\n\n\t/**\n\t * Returns a configuration with the specified name.\n\t * Returns undefined if there is no configuration with the specified name.\n\t */\n\tgetConfiguration(name: string): IConfig | undefined;\n\n\t/**\n\t * Returns a compound with the specified name.\n\t * Returns undefined if there is no compound with the specified name.\n\t */\n\tgetCompound(name: string): ICompound | undefined;\n\n\t/**\n\t * Returns the names of all configurations and compounds.\n\t * Ignores configurations which are invalid.\n\t */\n\tgetConfigurationNames(ignoreCompoundsAndPresentation?: boolean): string[];\n\n\t/**\n\t * Opens the launch.json file. Creates if it does not exist.\n\t */\n\topenConfigFile(options: { preserveFocus: boolean; type?: string; suppressInitialConfigs?: boolean }, token?: CancellationToken): Promise<{ editor: IEditorPane | null; created: boolean }>;\n}\n\n// Debug service interfaces\n\nexport const IDebugService = createDecorator<IDebugService>('debugService');\n\nexport interface IDebugService {\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Gets the current debug state.\n\t */\n\treadonly state: State;\n\n\treadonly initializingOptions?: IDebugSessionOptions | undefined;\n\n\t/**\n\t * Allows to register on debug state changes.\n\t */\n\tonDidChangeState: Event<State>;\n\n\t/**\n\t * Allows to register on new session events.\n\t */\n\tonDidNewSession: Event<IDebugSession>;\n\n\t/**\n\t * Allows to register on sessions about to be created (not yet fully initialised)\n\t */\n\tonWillNewSession: Event<IDebugSession>;\n\n\t/**\n\t * Allows to register on end session events.\n\t */\n\tonDidEndSession: Event<IDebugSession>;\n\n\t/**\n\t * Gets the configuration manager.\n\t */\n\tgetConfigurationManager(): IConfigurationManager;\n\n\t/**\n\t * Gets the adapter manager.\n\t */\n\tgetAdapterManager(): IAdapterManager;\n\n\t/**\n\t * Sets the focused stack frame and evaluates all expressions against the newly focused stack frame,\n\t */\n\tfocusStackFrame(focusedStackFrame: IStackFrame | undefined, thread?: IThread, session?: IDebugSession, options?: { explicit?: boolean; preserveFocus?: boolean; sideBySide?: boolean; pinned?: boolean }): Promise<void>;\n\n\t/**\n\t * Returns true if breakpoints can be set for a given editor model. Depends on mode.\n\t */\n\tcanSetBreakpointsIn(model: EditorIModel): boolean;\n\n\t/**\n\t * Adds new breakpoints to the model for the file specified with the uri. Notifies debug adapter of breakpoint changes.\n\t */\n\taddBreakpoints(uri: uri, rawBreakpoints: IBreakpointData[], ariaAnnounce?: boolean): Promise<IBreakpoint[]>;\n\n\t/**\n\t * Updates the breakpoints.\n\t */\n\tupdateBreakpoints(originalUri: uri, data: Map<string, IBreakpointUpdateData>, sendOnResourceSaved: boolean): Promise<void>;\n\n\t/**\n\t * Enables or disables all breakpoints. If breakpoint is passed only enables or disables the passed breakpoint.\n\t * Notifies debug adapter of breakpoint changes.\n\t */\n\tenableOrDisableBreakpoints(enable: boolean, breakpoint?: IEnablement): Promise<void>;\n\n\t/**\n\t * Sets the global activated property for all breakpoints.\n\t * Notifies debug adapter of breakpoint changes.\n\t */\n\tsetBreakpointsActivated(activated: boolean): Promise<void>;\n\n\t/**\n\t * Removes all breakpoints. If id is passed only removes the breakpoint associated with that id.\n\t * Notifies debug adapter of breakpoint changes.\n\t */\n\tremoveBreakpoints(id?: string): Promise<any>;\n\n\t/**\n\t * Adds a new function breakpoint for the given name.\n\t */\n\taddFunctionBreakpoint(name?: string, id?: string): void;\n\n\t/**\n\t * Updates an already existing function breakpoint.\n\t * Notifies debug adapter of breakpoint changes.\n\t */\n\tupdateFunctionBreakpoint(id: string, update: { name?: string; hitCondition?: string; condition?: string }): Promise<void>;\n\n\t/**\n\t * Removes all function breakpoints. If id is passed only removes the function breakpoint with the passed id.\n\t * Notifies debug adapter of breakpoint changes.\n\t */\n\tremoveFunctionBreakpoints(id?: string): Promise<void>;\n\n\t/**\n\t * Adds a new data breakpoint.\n\t */\n\taddDataBreakpoint(label: string, dataId: string, canPersist: boolean, accessTypes: DebugProtocol.DataBreakpointAccessType[] | undefined, accessType: DebugProtocol.DataBreakpointAccessType): Promise<void>;\n\n\t/**\n\t * Removes all data breakpoints. If id is passed only removes the data breakpoint with the passed id.\n\t * Notifies debug adapter of breakpoint changes.\n\t */\n\tremoveDataBreakpoints(id?: string): Promise<void>;\n\n\t/**\n\t * Adds a new instruction breakpoint.\n\t */\n\taddInstructionBreakpoint(instructionReference: string, offset: number, address: bigint, condition?: string, hitCondition?: string): Promise<void>;\n\n\t/**\n\t * Removes all instruction breakpoints. If address is passed only removes the instruction breakpoint with the passed address.\n\t * The address should be the address string supplied by the debugger from the \"Disassemble\" request.\n\t * Notifies debug adapter of breakpoint changes.\n\t */\n\tremoveInstructionBreakpoints(instructionReference?: string, offset?: number): Promise<void>;\n\n\tsetExceptionBreakpointCondition(breakpoint: IExceptionBreakpoint, condition: string | undefined): Promise<void>;\n\n\tsetExceptionBreakpointsForSession(session: IDebugSession, data: DebugProtocol.ExceptionBreakpointsFilter[]): void;\n\n\t/**\n\t * Sends all breakpoints to the passed session.\n\t * If session is not passed, sends all breakpoints to each session.\n\t */\n\tsendAllBreakpoints(session?: IDebugSession): Promise<any>;\n\n\t/**\n\t * Adds a new watch expression and evaluates it against the debug adapter.\n\t */\n\taddWatchExpression(name?: string): void;\n\n\t/**\n\t * Renames a watch expression and evaluates it against the debug adapter.\n\t */\n\trenameWatchExpression(id: string, newName: string): void;\n\n\t/**\n\t * Moves a watch expression to a new possition. Used for reordering watch expressions.\n\t */\n\tmoveWatchExpression(id: string, position: number): void;\n\n\t/**\n\t * Removes all watch expressions. If id is passed only removes the watch expression with the passed id.\n\t */\n\tremoveWatchExpressions(id?: string): void;\n\n\t/**\n\t * Starts debugging. If the configOrName is not passed uses the selected configuration in the debug dropdown.\n\t * Also saves all files, manages if compounds are present in the configuration\n\t * and resolveds configurations via DebugConfigurationProviders.\n\t *\n\t * Returns true if the start debugging was successful. For compound launches, all configurations have to start successfully for it to return success.\n\t * On errors the startDebugging will throw an error, however some error and cancelations are handled and in that case will simply return false.\n\t */\n\tstartDebugging(launch: ILaunch | undefined, configOrName?: IConfig | string, options?: IDebugSessionOptions, saveBeforeStart?: boolean): Promise<boolean>;\n\n\t/**\n\t * Restarts a session or creates a new one if there is no active session.\n\t */\n\trestartSession(session: IDebugSession, restartData?: any): Promise<any>;\n\n\t/**\n\t * Stops the session. If no session is specified then all sessions are stopped.\n\t */\n\tstopSession(session: IDebugSession | undefined, disconnect?: boolean, suspend?: boolean): Promise<any>;\n\n\t/**\n\t * Makes unavailable all sources with the passed uri. Source will appear as grayed out in callstack view.\n\t */\n\tsourceIsNotAvailable(uri: uri): void;\n\n\t/**\n\t * Gets the current debug model.\n\t */\n\tgetModel(): IDebugModel;\n\n\t/**\n\t * Gets the current view model.\n\t */\n\tgetViewModel(): IViewModel;\n\n\t/**\n\t * Resumes execution and pauses until the given position is reached.\n\t */\n\trunTo(uri: uri, lineNumber: number, column?: number): Promise<void>;\n}\n\n// Editor interfaces\nexport const enum BreakpointWidgetContext {\n\tCONDITION = 0,\n\tHIT_COUNT = 1,\n\tLOG_MESSAGE = 2\n}\n\nexport interface IDebugEditorContribution extends editorCommon.IEditorContribution {\n\tshowHover(range: Position, focus: boolean): Promise<void>;\n\taddLaunchConfiguration(): Promise<any>;\n\tcloseExceptionWidget(): void;\n}\n\nexport interface IBreakpointEditorContribution extends editorCommon.IEditorContribution {\n\tshowBreakpointWidget(lineNumber: number, column: number | undefined, context?: BreakpointWidgetContext): void;\n\tcloseBreakpointWidget(): void;\n\tgetContextMenuActionsAtPosition(lineNumber: number, model: EditorIModel): IAction[];\n}\n\nexport interface IReplConfiguration {\n\treadonly fontSize: number;\n\treadonly fontFamily: string;\n\treadonly lineHeight: number;\n\treadonly cssLineHeight: string;\n\treadonly backgroundColor: Color | undefined;\n\treadonly fontSizeForTwistie: number;\n}\n\nexport interface IReplOptions {\n\treadonly replConfiguration: IReplConfiguration;\n}\n"]}