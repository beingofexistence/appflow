{"version":3,"sources":["vs/workbench/contrib/tasks/common/taskService.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;IAgBnF,QAAA,IAAI,GAA8B,IAAI,gBAAG,CAAoB,0BAA0B,EAAE,KAAK,EAAE,GAAG,CAAC,QAAQ,CAAC,CAAgC,EAAE,IAAsH,CAAC,CAAC,CAAC;IACxQ,QAAA,IAAI,GAA6B,IAAI,gBAAG,CAAoB,yBAAyB,EAAE,KAAK,EAAE,GAAG,CAAC,QAAQ,CAAC,CAA+B,EAAE,IAAqH,CAAC,CAAC,CAAC;IACpQ,QAAA,IAAI,GAAqB,IAAI,gBAAG,CAAoB,wBAAwB,EAAE,KAAK,EAAE,GAAG,CAAC,QAAQ,CAAC,CAA8B,EAAE,IAAoD,CAAC,CAAC,CAAC;IACzL,QAAA,IAAI,GAA+B,IAAI,gBAAG,CAAoB,2BAA2B,EAAE,KAAK,EAAE,GAAG,CAAC,QAAQ,CAAC,CAAiC,EAAE,IAAuH,CAAC,CAAC,CAAC;IAC5Q,QAAA,IAAI,GAAmB,IAAI,gBAAG,CAAoB,sBAAsB,EAAE,KAAK,EAAE,GAAG,CAAC,QAAQ,CAAC,CAA4B,EAAE,IAAgD,CAAC,CAAC,CAAC;IAC/K,QAAA,IAAI,GAA4B,gBAAG,CAAY,EAAE,CAAC,gBAAG,CAAY,GAAG,CAAC,YAAI,EAA4B,YAAI,CAA6B,EAAE,YAAI,CAA4B,CAAC;IAEzK,QAAA,IAAI,GAAW,IAAA,mBAAG,EAA2B,aAAa,CAAC,CAAC","file":"taskService.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as nls from 'vs/nls';\nimport { Action } from 'vs/base/common/actions';\nimport { Event } from 'vs/base/common/event';\nimport { createDecorator } from 'vs/platform/instantiation/common/instantiation';\nimport { IDisposable } from 'vs/base/common/lifecycle';\n\nimport { IWorkspaceFolder, IWorkspace } from 'vs/platform/workspace/common/workspace';\nimport { Task, ContributedTask, CustomTask, ITaskSet, TaskSorter, ITaskEvent, ITaskIdentifier, ConfiguringTask, TaskRunSource } from 'vs/workbench/contrib/tasks/common/tasks';\nimport { ITaskSummary, ITaskTerminateResponse, ITaskSystemInfo } from 'vs/workbench/contrib/tasks/common/taskSystem';\nimport { IStringDictionary } from 'vs/base/common/collections';\nimport { RawContextKey, ContextKeyExpr } from 'vs/platform/contextkey/common/contextkey';\n\nexport { ITaskSummary, Task, ITaskTerminateResponse as TaskTerminateResponse };\n\nexport const CustomExecutionSupportedContext = new RawContextKey<boolean>('customExecutionSupported', false, nls.localize('tasks.customExecutionSupported', \"Whether CustomExecution tasks are supported. Consider using in the when clause of a \\'taskDefinition\\' contribution.\"));\nexport const ShellExecutionSupportedContext = new RawContextKey<boolean>('shellExecutionSupported', false, nls.localize('tasks.shellExecutionSupported', \"Whether ShellExecution tasks are supported. Consider using in the when clause of a \\'taskDefinition\\' contribution.\"));\nexport const TaskCommandsRegistered = new RawContextKey<boolean>('taskCommandsRegistered', false, nls.localize('tasks.taskCommandsRegistered', \"Whether the task commands have been registered yet\"));\nexport const ProcessExecutionSupportedContext = new RawContextKey<boolean>('processExecutionSupported', false, nls.localize('tasks.processExecutionSupported', \"Whether ProcessExecution tasks are supported. Consider using in the when clause of a \\'taskDefinition\\' contribution.\"));\nexport const ServerlessWebContext = new RawContextKey<boolean>('serverlessWebContext', false, nls.localize('tasks.serverlessWebContext', \"True when in the web with no remote authority.\"));\nexport const TaskExecutionSupportedContext = ContextKeyExpr.or(ContextKeyExpr.and(ShellExecutionSupportedContext, ProcessExecutionSupportedContext), CustomExecutionSupportedContext);\n\nexport const ITaskService = createDecorator<ITaskService>('taskService');\n\nexport interface ITaskProvider {\n\tprovideTasks(validTypes: IStringDictionary<boolean>): Promise<ITaskSet>;\n\tresolveTask(task: ConfiguringTask): Promise<ContributedTask | undefined>;\n}\n\nexport interface IProblemMatcherRunOptions {\n\tattachProblemMatcher?: boolean;\n}\n\nexport interface ICustomizationProperties {\n\tgroup?: string | { kind?: string; isDefault?: boolean };\n\tproblemMatcher?: string | string[];\n\tisBackground?: boolean;\n\tcolor?: string;\n\ticon?: string;\n}\n\nexport interface ITaskFilter {\n\tversion?: string;\n\ttype?: string;\n\ttask?: string;\n}\n\ninterface IWorkspaceTaskResult {\n\tset: ITaskSet | undefined;\n\tconfigurations: {\n\t\tbyIdentifier: IStringDictionary<ConfiguringTask>;\n\t} | undefined;\n\thasErrors: boolean;\n}\n\nexport interface IWorkspaceFolderTaskResult extends IWorkspaceTaskResult {\n\tworkspaceFolder: IWorkspaceFolder;\n}\n\nexport interface ITaskService {\n\treadonly _serviceBrand: undefined;\n\tonDidStateChange: Event<ITaskEvent>;\n\tisReconnected: boolean;\n\tonDidReconnectToTasks: Event<void>;\n\tsupportsMultipleTaskExecutions: boolean;\n\n\tconfigureAction(): Action;\n\trun(task: Task | undefined, options?: IProblemMatcherRunOptions): Promise<ITaskSummary | undefined>;\n\tinTerminal(): boolean;\n\tgetActiveTasks(): Promise<Task[]>;\n\tgetBusyTasks(): Promise<Task[]>;\n\tterminate(task: Task): Promise<ITaskTerminateResponse>;\n\ttasks(filter?: ITaskFilter): Promise<Task[]>;\n\ttaskTypes(): string[];\n\tgetWorkspaceTasks(runSource?: TaskRunSource): Promise<Map<string, IWorkspaceFolderTaskResult>>;\n\tgetSavedTasks(type: 'persistent' | 'historical'): Promise<(Task | ConfiguringTask)[]>;\n\tremoveRecentlyUsedTask(taskRecentlyUsedKey: string): void;\n\t/**\n\t * @param alias The task's name, label or defined identifier.\n\t */\n\tgetTask(workspaceFolder: IWorkspace | IWorkspaceFolder | string, alias: string | ITaskIdentifier, compareId?: boolean): Promise<Task | undefined>;\n\ttryResolveTask(configuringTask: ConfiguringTask): Promise<Task | undefined>;\n\tcreateSorter(): TaskSorter;\n\n\tgetTaskDescription(task: Task | ConfiguringTask): string | undefined;\n\tcustomize(task: ContributedTask | CustomTask | ConfiguringTask, properties?: {}, openConfig?: boolean): Promise<void>;\n\topenConfig(task: CustomTask | ConfiguringTask | undefined): Promise<boolean>;\n\n\tregisterTaskProvider(taskProvider: ITaskProvider, type: string): IDisposable;\n\n\tregisterTaskSystem(scheme: string, taskSystemInfo: ITaskSystemInfo): void;\n\tonDidChangeTaskSystemInfo: Event<void>;\n\treadonly hasTaskSystemInfo: boolean;\n\tregisterSupportedExecutions(custom?: boolean, shell?: boolean, process?: boolean): void;\n\n\textensionCallbackTaskComplete(task: Task, result: number | undefined): Promise<void>;\n}\n"]}