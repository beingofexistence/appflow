{"version":3,"sources":["vs/workbench/contrib/notebook/browser/viewModel/notebookOutlineEntryFactory.ts"],"names":[],"mappings":"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","file":"notebookOutlineEntryFactory.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { renderMarkdownAsPlaintext } from 'vs/base/browser/markdownRenderer';\nimport { CancellationToken } from 'vs/base/common/cancellation';\nimport { IOutlineModelService, OutlineModelService } from 'vs/editor/contrib/documentSymbols/browser/outlineModel';\nimport { localize } from 'vs/nls';\nimport { ICellViewModel } from 'vs/workbench/contrib/notebook/browser/notebookBrowser';\nimport { getMarkdownHeadersInCell } from 'vs/workbench/contrib/notebook/browser/viewModel/foldingModel';\nimport { OutlineEntry } from './OutlineEntry';\nimport { CellKind } from 'vs/workbench/contrib/notebook/common/notebookCommon';\nimport { INotebookExecutionStateService } from 'vs/workbench/contrib/notebook/common/notebookExecutionStateService';\nimport { Range } from 'vs/editor/common/core/range';\nimport { ITextModel } from 'vs/editor/common/model';\nimport { SymbolKind } from 'vs/editor/common/languages';\n\ntype entryDesc = {\n\tname: string;\n\tposition: Range;\n\tlevel: number;\n\tkind: SymbolKind;\n};\n\nexport class NotebookOutlineEntryFactory {\n\n\tprivate cellOutlineEntryCache: Record<string, entryDesc[]> = {};\n\n\tconstructor(\n\t\tprivate readonly executionStateService: INotebookExecutionStateService\n\t) { }\n\n\tpublic getOutlineEntries(cell: ICellViewModel, index: number): OutlineEntry[] {\n\t\tconst entries: OutlineEntry[] = [];\n\n\t\tconst isMarkdown = cell.cellKind === CellKind.Markup;\n\n\t\t// cap the amount of characters that we look at and use the following logic\n\t\t// - for MD prefer headings (each header is an entry)\n\t\t// - otherwise use the first none-empty line of the cell (MD or code)\n\t\tlet content = getCellFirstNonEmptyLine(cell);\n\t\tlet hasHeader = false;\n\n\t\tif (isMarkdown) {\n\t\t\tconst fullContent = cell.getText().substring(0, 10000);\n\t\t\tfor (const { depth, text } of getMarkdownHeadersInCell(fullContent)) {\n\t\t\t\thasHeader = true;\n\t\t\t\tentries.push(new OutlineEntry(index++, depth, cell, text, false, false));\n\t\t\t}\n\n\t\t\tif (!hasHeader) {\n\t\t\t\t// no markdown syntax headers, try to find html tags\n\t\t\t\tconst match = fullContent.match(/<h([1-6]).*>(.*)<\\/h\\1>/i);\n\t\t\t\tif (match) {\n\t\t\t\t\thasHeader = true;\n\t\t\t\t\tconst level = parseInt(match[1]);\n\t\t\t\t\tconst text = match[2].trim();\n\t\t\t\t\tentries.push(new OutlineEntry(index++, level, cell, text, false, false));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!hasHeader) {\n\t\t\t\tcontent = renderMarkdownAsPlaintext({ value: content });\n\t\t\t}\n\t\t}\n\n\t\tif (!hasHeader) {\n\t\t\tif (!isMarkdown && cell.model.textModel) {\n\t\t\t\tconst cachedEntries = this.cellOutlineEntryCache[cell.model.textModel.id];\n\n\t\t\t\t// Gathering symbols from the model is an async operation, but this provider is syncronous.\n\t\t\t\t// So symbols need to be precached before this function is called to get the full list.\n\t\t\t\tif (cachedEntries) {\n\t\t\t\t\tcachedEntries.forEach((cached) => {\n\t\t\t\t\t\tentries.push(new OutlineEntry(index++, cached.level, cell, cached.name, false, false, cached.position, cached.kind));\n\t\t\t\t\t});\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst exeState = !isMarkdown && this.executionStateService.getCellExecution(cell.uri);\n\t\t\tif (entries.length === 0) {\n\t\t\t\tlet preview = content.trim();\n\t\t\t\tif (preview.length === 0) {\n\t\t\t\t\t// empty or just whitespace\n\t\t\t\t\tpreview = localize('empty', \"empty cell\");\n\t\t\t\t}\n\n\t\t\t\tentries.push(new OutlineEntry(index++, 7, cell, preview, !!exeState, exeState ? exeState.isPaused : false));\n\t\t\t}\n\t\t}\n\n\t\treturn entries;\n\t}\n\n\tpublic async cacheSymbols(textModel: ITextModel, outlineModelService: IOutlineModelService, cancelToken: CancellationToken) {\n\t\tconst outlineModel = await outlineModelService.getOrCreate(textModel, cancelToken);\n\t\tconst entries = createOutlineEntries(outlineModel.getTopLevelSymbols(), 7);\n\t\tthis.cellOutlineEntryCache[textModel.id] = entries;\n\t}\n}\n\ntype outlineModel = Awaited<ReturnType<OutlineModelService['getOrCreate']>>;\ntype documentSymbol = ReturnType<outlineModel['getTopLevelSymbols']>[number];\n\nfunction createOutlineEntries(symbols: documentSymbol[], level: number): entryDesc[] {\n\tconst entries: entryDesc[] = [];\n\tsymbols.forEach(symbol => {\n\t\tconst position = new Range(symbol.selectionRange.startLineNumber,\n\t\t\tsymbol.selectionRange.startColumn,\n\t\t\tsymbol.selectionRange.startLineNumber,\n\t\t\tsymbol.selectionRange.startColumn);\n\t\tentries.push({ name: symbol.name, position, level, kind: symbol.kind });\n\t\tif (symbol.children) {\n\t\t\tentries.push(...createOutlineEntries(symbol.children, level + 1));\n\t\t}\n\t});\n\treturn entries;\n}\n\nfunction getCellFirstNonEmptyLine(cell: ICellViewModel) {\n\tconst textBuffer = cell.textBuffer;\n\tfor (let i = 0; i < textBuffer.getLineCount(); i++) {\n\t\tconst firstNonWhitespace = textBuffer.getLineFirstNonWhitespaceColumn(i + 1);\n\t\tconst lineLength = textBuffer.getLineLength(i + 1);\n\t\tif (firstNonWhitespace < lineLength) {\n\t\t\treturn textBuffer.getLineContent(i + 1);\n\t\t}\n\t}\n\n\treturn cell.getText().substring(0, 100);\n}\n"]}