{"version":3,"sources":["file:///workspace/appflow/src/vs/workbench/contrib/notebook/common/notebookEditorModelResolverService.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;IAQnF,QAAA,IAAI,GAAkC,IAAA,mBAAG,EAAkD,+BAA+B,CAAC,CAAC","file":"notebookEditorModelResolverService.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { createDecorator } from 'vs/platform/instantiation/common/instantiation';\nimport { URI } from 'vs/base/common/uri';\nimport { IResolvedNotebookEditorModel } from 'vs/workbench/contrib/notebook/common/notebookCommon';\nimport { IReference } from 'vs/base/common/lifecycle';\nimport { Event, IWaitUntil } from 'vs/base/common/event';\n\nexport const INotebookEditorModelResolverService = createDecorator<INotebookEditorModelResolverService>('INotebookModelResolverService');\n\n/**\n * A notebook file can only be opened ONCE per notebook type.\n * This event fires when a file is already open as type A\n * and there is request to open it as type B. Listeners must\n * do cleanup (close editor, release references) or the request fails\n */\nexport interface INotebookConflictEvent extends IWaitUntil {\n\tresource: URI;\n\tviewType: string;\n}\n\nexport interface IUntitledNotebookResource {\n\t/**\n\t * Depending on the value of `untitledResource` will\n\t * resolve a untitled notebook that:\n\t * - gets a unique name if `undefined` (e.g. `Untitled-1')\n\t * - uses the resource directly if the scheme is `untitled:`\n\t * - converts any other resource scheme to `untitled:` and will\n\t *   assume an associated file path\n\t *\n\t * Untitled notebook editors with associated path behave slightly\n\t * different from other untitled editors:\n\t * - they are dirty right when opening\n\t * - they will not ask for a file path when saving but use the associated path\n\t */\n\tuntitledResource: URI | undefined;\n}\n\nexport interface INotebookEditorModelResolverService {\n\treadonly _serviceBrand: undefined;\n\n\treadonly onDidSaveNotebook: Event<URI>;\n\treadonly onDidChangeDirty: Event<IResolvedNotebookEditorModel>;\n\n\treadonly onWillFailWithConflict: Event<INotebookConflictEvent>;\n\n\tisDirty(resource: URI): boolean;\n\n\tresolve(resource: URI, viewType?: string): Promise<IReference<IResolvedNotebookEditorModel>>;\n\tresolve(resource: IUntitledNotebookResource, viewType: string): Promise<IReference<IResolvedNotebookEditorModel>>;\n}\n"]}