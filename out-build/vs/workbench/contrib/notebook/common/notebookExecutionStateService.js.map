{"version":3,"sources":["file:///workspace/appflow/src/vs/workbench/contrib/notebook/common/notebookExecutionStateService.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;IAuBhG,IAAY,qBAGX;IAHD,WAAY,qBAAqB;QAChC,iEAAI,CAAA;QACJ,yEAAQ,CAAA;IACT,CAAC,EAHW,qBAAqB,qCAArB,qBAAqB,QAGhC;IA0BY,QAAA,GAAG,GAA8B,IAAA,mBAAG,EAA6C,gCAAgC,CAAC,CAAC","file":"notebookExecutionStateService.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event } from 'vs/base/common/event';\nimport { IDisposable } from 'vs/base/common/lifecycle';\nimport { URI } from 'vs/base/common/uri';\nimport { createDecorator } from 'vs/platform/instantiation/common/instantiation';\nimport { NotebookCellExecutionState, NotebookExecutionState } from 'vs/workbench/contrib/notebook/common/notebookCommon';\nimport { CellExecutionUpdateType, ICellExecuteOutputEdit, ICellExecuteOutputItemEdit } from 'vs/workbench/contrib/notebook/common/notebookExecutionService';\n\nexport type ICellExecuteUpdate = ICellExecuteOutputEdit | ICellExecuteOutputItemEdit | ICellExecutionStateUpdate;\n\nexport interface ICellExecutionStateUpdate {\n\teditType: CellExecutionUpdateType.ExecutionState;\n\texecutionOrder?: number;\n\trunStartTime?: number;\n\tdidPause?: boolean;\n\tisPaused?: boolean;\n}\n\nexport interface ICellExecutionComplete {\n\trunEndTime?: number;\n\tlastRunSuccess?: boolean;\n}\nexport enum NotebookExecutionType {\n\tcell,\n\tnotebook\n}\nexport interface ICellExecutionStateChangedEvent {\n\ttype: NotebookExecutionType.cell;\n\tnotebook: URI;\n\tcellHandle: number;\n\tchanged?: INotebookCellExecution; // undefined -> execution was completed\n\taffectsCell(cell: URI): boolean;\n\taffectsNotebook(notebook: URI): boolean;\n}\nexport interface IExecutionStateChangedEvent {\n\ttype: NotebookExecutionType.notebook;\n\tnotebook: URI;\n\tchanged?: INotebookExecution; // undefined -> execution was completed\n\taffectsNotebook(notebook: URI): boolean;\n}\nexport interface INotebookFailStateChangedEvent {\n\tvisible: boolean;\n\tnotebook: URI;\n}\n\nexport interface IFailedCellInfo {\n\tcellHandle: number;\n\tdisposable: IDisposable;\n\tvisible: boolean;\n}\n\nexport const INotebookExecutionStateService = createDecorator<INotebookExecutionStateService>('INotebookExecutionStateService');\n\nexport interface INotebookExecutionStateService {\n\t_serviceBrand: undefined;\n\n\tonDidChangeExecution: Event<ICellExecutionStateChangedEvent | IExecutionStateChangedEvent>;\n\tonDidChangeLastRunFailState: Event<INotebookFailStateChangedEvent>;\n\n\tforceCancelNotebookExecutions(notebookUri: URI): void;\n\tgetCellExecutionsForNotebook(notebook: URI): INotebookCellExecution[];\n\tgetCellExecutionsByHandleForNotebook(notebook: URI): Map<number, INotebookCellExecution> | undefined;\n\tgetCellExecution(cellUri: URI): INotebookCellExecution | undefined;\n\tcreateCellExecution(notebook: URI, cellHandle: number): INotebookCellExecution;\n\tgetExecution(notebook: URI): INotebookExecution | undefined;\n\tcreateExecution(notebook: URI): INotebookExecution;\n\tgetLastFailedCellForNotebook(notebook: URI): number | undefined;\n}\n\nexport interface INotebookCellExecution {\n\treadonly notebook: URI;\n\treadonly cellHandle: number;\n\treadonly state: NotebookCellExecutionState;\n\treadonly didPause: boolean;\n\treadonly isPaused: boolean;\n\n\tconfirm(): void;\n\tupdate(updates: ICellExecuteUpdate[]): void;\n\tcomplete(complete: ICellExecutionComplete): void;\n}\nexport interface INotebookExecution {\n\treadonly notebook: URI;\n\treadonly state: NotebookExecutionState;\n\n\tconfirm(): void;\n\tbegin(): void;\n\tcomplete(): void;\n}\n"]}