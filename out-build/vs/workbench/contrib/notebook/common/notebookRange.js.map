{"version":3,"sources":["file:///workspace/appflow/src/vs/workbench/contrib/notebook/common/notebookRange.ts"],"names":[],"mappings":"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","file":"notebookRange.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * [start, end]\n */\nexport interface ICellRange {\n\t/**\n\t * zero based index\n\t */\n\tstart: number;\n\n\t/**\n\t * zero based index\n\t */\n\tend: number;\n}\n\n\nexport function isICellRange(candidate: any): candidate is ICellRange {\n\tif (!candidate || typeof candidate !== 'object') {\n\t\treturn false;\n\t}\n\treturn typeof (<ICellRange>candidate).start === 'number'\n\t\t&& typeof (<ICellRange>candidate).end === 'number';\n}\n\nexport function cellIndexesToRanges(indexes: number[]) {\n\tindexes.sort((a, b) => a - b);\n\tconst first = indexes.shift();\n\n\tif (first === undefined) {\n\t\treturn [];\n\t}\n\n\treturn indexes.reduce(function (ranges, num) {\n\t\tif (num <= ranges[0][1]) {\n\t\t\tranges[0][1] = num + 1;\n\t\t} else {\n\t\t\tranges.unshift([num, num + 1]);\n\t\t}\n\t\treturn ranges;\n\t}, [[first, first + 1]]).reverse().map(val => ({ start: val[0], end: val[1] }));\n}\n\nexport function cellRangesToIndexes(ranges: ICellRange[]) {\n\tconst indexes = ranges.reduce((a, b) => {\n\t\tfor (let i = b.start; i < b.end; i++) {\n\t\t\ta.push(i);\n\t\t}\n\n\t\treturn a;\n\t}, [] as number[]);\n\n\treturn indexes;\n}\n\nexport function reduceCellRanges(ranges: ICellRange[]): ICellRange[] {\n\tconst sorted = ranges.sort((a, b) => a.start - b.start);\n\tconst first = sorted[0];\n\n\tif (!first) {\n\t\treturn [];\n\t}\n\n\treturn sorted.reduce((prev: ICellRange[], curr) => {\n\t\tconst last = prev[prev.length - 1];\n\t\tif (last.end >= curr.start) {\n\t\t\tlast.end = Math.max(last.end, curr.end);\n\t\t} else {\n\t\t\tprev.push(curr);\n\t\t}\n\t\treturn prev;\n\t}, [first] as ICellRange[]);\n}\n\nexport function cellRangesEqual(a: ICellRange[], b: ICellRange[]) {\n\ta = reduceCellRanges(a);\n\tb = reduceCellRanges(b);\n\tif (a.length !== b.length) {\n\t\treturn false;\n\t}\n\n\tfor (let i = 0; i < a.length; i++) {\n\t\tif (a[i].start !== b[i].start || a[i].end !== b[i].end) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/**\n * todo@rebornix test and sort\n * @param range\n * @param other\n * @returns\n */\n\nexport function cellRangeContains(range: ICellRange, other: ICellRange): boolean {\n\treturn other.start >= range.start && other.end <= range.end;\n}\n"]}