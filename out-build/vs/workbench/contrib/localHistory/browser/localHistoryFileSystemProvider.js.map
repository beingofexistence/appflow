{"version":3,"sources":["file:///workspace/appflow/src/vs/workbench/contrib/localHistory/browser/localHistoryFileSystemProvider.ts"],"names":[],"mappings":"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","file":"localHistoryFileSystemProvider.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event } from 'vs/base/common/event';\nimport { Disposable, IDisposable } from 'vs/base/common/lifecycle';\nimport { URI } from 'vs/base/common/uri';\nimport { IFileDeleteOptions, IFileOverwriteOptions, FileSystemProviderCapabilities, FileType, IFileWriteOptions, hasReadWriteCapability, IFileService, IFileSystemProvider, IFileSystemProviderWithFileReadWriteCapability, IStat, IWatchOptions } from 'vs/platform/files/common/files';\nimport { isEqual } from 'vs/base/common/resources';\nimport { VSBuffer } from 'vs/base/common/buffer';\n\ninterface ILocalHistoryResource {\n\n\t/**\n\t * The location of the local history entry to read from.\n\t */\n\treadonly location: URI;\n\n\t/**\n\t * The associated resource the local history entry is about.\n\t */\n\treadonly associatedResource: URI;\n}\n\ninterface ISerializedLocalHistoryResource {\n\treadonly location: string;\n\treadonly associatedResource: string;\n}\n\n/**\n * A wrapper around a standard file system provider\n * that is entirely readonly.\n */\nexport class LocalHistoryFileSystemProvider implements IFileSystemProvider, IFileSystemProviderWithFileReadWriteCapability {\n\n\tstatic readonly SCHEMA = 'vscode-local-history';\n\n\tstatic toLocalHistoryFileSystem(resource: ILocalHistoryResource): URI {\n\t\tconst serializedLocalHistoryResource: ISerializedLocalHistoryResource = {\n\t\t\tlocation: resource.location.toString(true),\n\t\t\tassociatedResource: resource.associatedResource.toString(true)\n\t\t};\n\n\t\t// Try to preserve the associated resource as much as possible\n\t\t// and only keep the `query` part dynamic. This enables other\n\t\t// components (e.g. other timeline providers) to continue\n\t\t// providing timeline entries even when our resource is active.\n\t\treturn resource.associatedResource.with({\n\t\t\tscheme: LocalHistoryFileSystemProvider.SCHEMA,\n\t\t\tquery: JSON.stringify(serializedLocalHistoryResource)\n\t\t});\n\t}\n\n\tstatic fromLocalHistoryFileSystem(resource: URI): ILocalHistoryResource {\n\t\tconst serializedLocalHistoryResource: ISerializedLocalHistoryResource = JSON.parse(resource.query);\n\n\t\treturn {\n\t\t\tlocation: URI.parse(serializedLocalHistoryResource.location),\n\t\t\tassociatedResource: URI.parse(serializedLocalHistoryResource.associatedResource)\n\t\t};\n\t}\n\n\tprivate static readonly EMPTY_RESOURCE = URI.from({ scheme: LocalHistoryFileSystemProvider.SCHEMA, path: '/empty' });\n\n\tstatic readonly EMPTY: ILocalHistoryResource = {\n\t\tlocation: LocalHistoryFileSystemProvider.EMPTY_RESOURCE,\n\t\tassociatedResource: LocalHistoryFileSystemProvider.EMPTY_RESOURCE\n\t};\n\n\tget capabilities() {\n\t\treturn FileSystemProviderCapabilities.FileReadWrite | FileSystemProviderCapabilities.Readonly;\n\t}\n\n\tconstructor(private readonly fileService: IFileService) { }\n\n\tprivate readonly mapSchemeToProvider = new Map<string, Promise<IFileSystemProvider>>();\n\n\tprivate async withProvider(resource: URI): Promise<IFileSystemProvider> {\n\t\tconst scheme = resource.scheme;\n\n\t\tlet providerPromise = this.mapSchemeToProvider.get(scheme);\n\t\tif (!providerPromise) {\n\n\t\t\t// Resolve early when provider already exists\n\t\t\tconst provider = this.fileService.getProvider(scheme);\n\t\t\tif (provider) {\n\t\t\t\tproviderPromise = Promise.resolve(provider);\n\t\t\t}\n\n\t\t\t// Otherwise wait for registration\n\t\t\telse {\n\t\t\t\tproviderPromise = new Promise<IFileSystemProvider>(resolve => {\n\t\t\t\t\tconst disposable = this.fileService.onDidChangeFileSystemProviderRegistrations(e => {\n\t\t\t\t\t\tif (e.added && e.provider && e.scheme === scheme) {\n\t\t\t\t\t\t\tdisposable.dispose();\n\n\t\t\t\t\t\t\tresolve(e.provider);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tthis.mapSchemeToProvider.set(scheme, providerPromise);\n\t\t}\n\n\t\treturn providerPromise;\n\t}\n\n\t//#region Supported File Operations\n\n\tasync stat(resource: URI): Promise<IStat> {\n\t\tconst location = LocalHistoryFileSystemProvider.fromLocalHistoryFileSystem(resource).location;\n\n\t\t// Special case: empty resource\n\t\tif (isEqual(LocalHistoryFileSystemProvider.EMPTY_RESOURCE, location)) {\n\t\t\treturn { type: FileType.File, ctime: 0, mtime: 0, size: 0 };\n\t\t}\n\n\t\t// Otherwise delegate to provider\n\t\treturn (await this.withProvider(location)).stat(location);\n\t}\n\n\tasync readFile(resource: URI): Promise<Uint8Array> {\n\t\tconst location = LocalHistoryFileSystemProvider.fromLocalHistoryFileSystem(resource).location;\n\n\t\t// Special case: empty resource\n\t\tif (isEqual(LocalHistoryFileSystemProvider.EMPTY_RESOURCE, location)) {\n\t\t\treturn VSBuffer.fromString('').buffer;\n\t\t}\n\n\t\t// Otherwise delegate to provider\n\t\tconst provider = await this.withProvider(location);\n\t\tif (hasReadWriteCapability(provider)) {\n\t\t\treturn provider.readFile(location);\n\t\t}\n\n\t\tthrow new Error('Unsupported');\n\t}\n\n\t//#endregion\n\n\t//#region Unsupported File Operations\n\n\treadonly onDidChangeCapabilities = Event.None;\n\treadonly onDidChangeFile = Event.None;\n\n\tasync writeFile(resource: URI, content: Uint8Array, opts: IFileWriteOptions): Promise<void> { }\n\n\tasync mkdir(resource: URI): Promise<void> { }\n\tasync readdir(resource: URI): Promise<[string, FileType][]> { return []; }\n\n\tasync rename(from: URI, to: URI, opts: IFileOverwriteOptions): Promise<void> { }\n\tasync delete(resource: URI, opts: IFileDeleteOptions): Promise<void> { }\n\n\twatch(resource: URI, opts: IWatchOptions): IDisposable { return Disposable.None; }\n\n\t//#endregion\n}\n"]}