{"version":3,"sources":["file:///workspace/appflow/src/vs/workbench/contrib/testing/common/testService.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;IAgBnF,QAAA,IAAI,GAAW,IAAA,mBAAG,EAA2B,aAAa,CAAC,CAAC;IA8DlE,MAAM,IAAI,GAAoB,CAAC,UAAqC,EAAE,EAAE,CAC9E,CAAC,mBAAQ,CAAC,IAAI,CAAC,UAAU,CAAC,SAAS,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,QAAQ,CAAC,IAAI,GAAG,CAAC,CAAC,CAAC;IADnD,QAAA,IAAI,QAC+C;IAEzD,MAAM,IAAI,GAAoB,CAAC,UAAqC,EAAE,EAAgB,EAAK,EAAE;QACnG,IAAI,OAAO,EAAE,KAAK,QAAQ,EAAE;YAC3B,EAAE,GAAG,YAAG,CAAI,UAAU,CAAC,EAAE,CAAC,CAAC;SAC3B;QAED,IAAI,EAAE,CAAC,MAAM,EAAE;YACd,OAAO,EAAE,UAAU,EAAE,EAAE,CAAC,QAAQ,EAAE,EAAE,CAAC;SACrC;QAED,MAAM,OAAO,GAAqB,EAAE,IAAI,uCAA8B,EAAE,KAAK,EAAE,EAAE,EAAE,CAAC;QACpF,KAAK,MAAM,CAAC,IAAI,EAAE,CAAC,WAAW,EAAE,EAAE;YACjC,IAAI,CAAC,CAAC,CAAC,MAAM,EAAE;gBACd,MAAM,IAAI,GAAG,UAAU,CAAC,WAAW,CAAC,CAAC,CAAC,QAAQ,EAAE,CAAC,CAAC;gBAClD,IAAI,IAAI,EAAE;oBACT,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;iBACzB;aACD;SACD;QAED,OAAO,OAAO,CAAC;IAChB,CAAC,CAAC;IApBW,QAAA,IAAI,QAoBf;IAEF;;;;OAIG;IACI,MAAM,IAAI,GAAmB,KAAK,EAAE,UAAqC,EAAE,EAAU,EAAE,EAAE,GAAG,gCAAiB,CAAC,IAAI,EAAE,EAAE;QAC5H,MAAM,MAAM,GAAG,CAAC,GAAG,YAAG,CAAI,UAAU,CAAC,EAAE,CAAC,CAAC,WAAW,EAAE,CAAC,CAAC;QAExD,IAAI,aAAa,GAAG,CAAC,CAAC;QACtB,KAAK,IAAI,CAAC,GAAG,MAAM,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,EAAE,CAAC,uBAAuB,IAAI,CAAC,IAAI,aAAa,GAAG;YACnF,MAAM,EAAE,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC,QAAQ,EAAE,CAAC;YAChC,MAAM,QAAQ,GAAG,UAAU,CAAC,WAAW,CAAC,EAAE,CAAC,CAAC;YAC5C,IAAI,CAAC,QAAQ,EAAE;gBACd,CAAC,EAAE,CAAC;gBACJ,SAAS;aACT;YAED,IAAI,CAAC,KAAK,MAAM,CAAC,MAAM,GAAG,CAAC,EAAE;gBAC5B,OAAO,QAAQ,CAAC;aAChB;YAED,uDAAuD;YACvD,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,QAAQ,EAAE,CAAC,EAAE;gBACrD,MAAM,UAAU,CAAC,MAAM,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;aAC/B;YAED,aAAa,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,oDAAoD;YAC3E,CAAC,GAAG,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC;SACtB;QACD,OAAO,SAAS,CAAC;IAClB,CAAC,CAAC;IAzBW,QAAA,IAAI,QAyBf;IAEF;;OAEG;IACH,MAAM,mBAAmB,GAAG,CAAC,WAAiB,EAAU,IAAmC,EAAE,EAAE;QAC9F,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE;YACpB,OAAO;SACP;QAED,OAAO,IAAI,OAAO,CAAO,OAAO,CAAC,EAAE;YAClC,MAAM,CAAC,GAAG,WAAW,CAAC,gBAAgB,CAAC,GAAG,EAAE;gBAC3C,IAAI,WAAW,CAAC,UAAU,CAAC,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,IAAI,CAAC,IAAI,KAAK,IAAI,EAAE;oBAC5E,OAAO,EAAE,CAAC,CAAC,6BAA6B;oBACxC,CAAC,CAAC,OAAO,EAAE,CAAC;iBACZ;YACF,CAAC,CAAC,CAAC;QACJ,CAAC,CAAC,CAAC;IACJ,CAAC,CAAC;IAEF;;;OAGG;IACI,MAAM,IAAI,GAAU,KAAK,SAAS,CAAC,EAAE,WAAiB,EAAU,KAAU,EAAkB,GAAQ,EAAE,WAAW,GAAG,IAAI;QAC9H,KAAK,MAAM,IAAI,IAAI,WAAW,CAAC,UAAU,CAAC,GAAG,EAAE;YAC9C,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,EAAE;gBACnB,SAAS;aACT;YAED,IAAI,KAAK,CAAC,MAAM,CAAC,OAAO,CAAC,GAAG,EAAE,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE;gBAC7C,MAAM,IAAI,CAAC;aACX;YAED,IAAI,KAAK,CAAC,MAAM,CAAC,eAAe,CAAC,GAAG,EAAE,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE;gBACrD,IAAI,IAAI,CAAC,MAAM,2CAAmC,EAAE;oBACnD,MAAM,WAAW,CAAC,UAAU,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;iBACxD;gBACD,IAAI,WAAW,EAAE;oBAChB,MAAM,mBAAmB,CAAC,WAAW,EAAE,IAAI,CAAC,CAAC;iBAC7C;aACD;SACD;IACF,CAAC,CAAC;IAnBW,QAAA,IAAI,QAmBf","file":"testService.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken } from 'vs/base/common/cancellation';\nimport { Event } from 'vs/base/common/event';\nimport { Iterable } from 'vs/base/common/iterator';\nimport { IDisposable } from 'vs/base/common/lifecycle';\nimport { MarshalledId } from 'vs/base/common/marshallingIds';\nimport { URI } from 'vs/base/common/uri';\nimport { createDecorator } from 'vs/platform/instantiation/common/instantiation';\nimport { IUriIdentityService } from 'vs/platform/uriIdentity/common/uriIdentity';\nimport { IObservableValue, MutableObservableValue } from 'vs/workbench/contrib/testing/common/observableValue';\nimport { AbstractIncrementalTestCollection, ICallProfileRunHandler, IncrementalTestCollectionItem, InternalTestItem, ITestItemContext, ResolvedTestRunRequest, IStartControllerTests, IStartControllerTestsResult, TestItemExpandState, TestRunProfileBitset, TestsDiff } from 'vs/workbench/contrib/testing/common/testTypes';\nimport { TestExclusions } from 'vs/workbench/contrib/testing/common/testExclusions';\nimport { TestId } from 'vs/workbench/contrib/testing/common/testId';\nimport { ITestResult } from 'vs/workbench/contrib/testing/common/testResult';\n\nexport const ITestService = createDecorator<ITestService>('testService');\n\nexport interface IMainThreadTestController {\n\treadonly id: string;\n\treadonly label: IObservableValue<string>;\n\treadonly canRefresh: IObservableValue<boolean>;\n\tsyncTests(token: CancellationToken): Promise<void>;\n\trefreshTests(token: CancellationToken): Promise<void>;\n\tconfigureRunProfile(profileId: number): void;\n\texpandTest(id: string, levels: number): Promise<void>;\n\tstartContinuousRun(request: ICallProfileRunHandler[], token: CancellationToken): Promise<IStartControllerTestsResult[]>;\n\trunTests(request: IStartControllerTests[], token: CancellationToken): Promise<IStartControllerTestsResult[]>;\n}\n\nexport interface IMainThreadTestCollection extends AbstractIncrementalTestCollection<IncrementalTestCollectionItem> {\n\tonBusyProvidersChange: Event<number>;\n\n\t/**\n\t * Number of providers working to discover tests.\n\t */\n\tbusyProviders: number;\n\n\t/**\n\t * Root item IDs.\n\t */\n\trootIds: Iterable<string>;\n\n\t/**\n\t * Root items, correspond to registered controllers.\n\t */\n\trootItems: Iterable<IncrementalTestCollectionItem>;\n\n\t/**\n\t * Iterates over every test in the collection, in strictly descending\n\t * order of depth.\n\t */\n\tall: Iterable<IncrementalTestCollectionItem>;\n\n\t/**\n\t * Gets a node in the collection by ID.\n\t */\n\tgetNodeById(id: string): IncrementalTestCollectionItem | undefined;\n\n\t/**\n\t * Gets all tests that have the given URL. Tests returned from this\n\t * method are *not* in any particular order.\n\t */\n\tgetNodeByUrl(uri: URI): Iterable<IncrementalTestCollectionItem>;\n\n\t/**\n\t * Requests that children be revealed for the given test. \"Levels\" may\n\t * be infinite.\n\t */\n\texpand(testId: string, levels: number): Promise<void>;\n\n\t/**\n\t * Gets a diff that adds all items currently in the tree to a new collection,\n\t * allowing it to fully hydrate.\n\t */\n\tgetReviverDiff(): TestsDiff;\n}\n\nexport const testCollectionIsEmpty = (collection: IMainThreadTestCollection) =>\n\t!Iterable.some(collection.rootItems, r => r.children.size > 0);\n\nexport const getContextForTestItem = (collection: IMainThreadTestCollection, id: string | TestId) => {\n\tif (typeof id === 'string') {\n\t\tid = TestId.fromString(id);\n\t}\n\n\tif (id.isRoot) {\n\t\treturn { controller: id.toString() };\n\t}\n\n\tconst context: ITestItemContext = { $mid: MarshalledId.TestItemContext, tests: [] };\n\tfor (const i of id.idsFromRoot()) {\n\t\tif (!i.isRoot) {\n\t\t\tconst test = collection.getNodeById(i.toString());\n\t\t\tif (test) {\n\t\t\t\tcontext.tests.push(test);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn context;\n};\n\n/**\n * Ensures the test with the given ID exists in the collection, if possible.\n * If cancellation is requested, or the test cannot be found, it will return\n * undefined.\n */\nexport const expandAndGetTestById = async (collection: IMainThreadTestCollection, id: string, ct = CancellationToken.None) => {\n\tconst idPath = [...TestId.fromString(id).idsFromRoot()];\n\n\tlet expandToLevel = 0;\n\tfor (let i = idPath.length - 1; !ct.isCancellationRequested && i >= expandToLevel;) {\n\t\tconst id = idPath[i].toString();\n\t\tconst existing = collection.getNodeById(id);\n\t\tif (!existing) {\n\t\t\ti--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (i === idPath.length - 1) {\n\t\t\treturn existing;\n\t\t}\n\n\t\t// expand children only if it looks like it's necessary\n\t\tif (!existing.children.has(idPath[i + 1].toString())) {\n\t\t\tawait collection.expand(id, 0);\n\t\t}\n\n\t\texpandToLevel = i + 1; // avoid an infinite loop if the test does not exist\n\t\ti = idPath.length - 1;\n\t}\n\treturn undefined;\n};\n\n/**\n * Waits for the test to no longer be in the \"busy\" state.\n */\nconst waitForTestToBeIdle = (testService: ITestService, test: IncrementalTestCollectionItem) => {\n\tif (!test.item.busy) {\n\t\treturn;\n\t}\n\n\treturn new Promise<void>(resolve => {\n\t\tconst l = testService.onDidProcessDiff(() => {\n\t\t\tif (testService.collection.getNodeById(test.item.extId)?.item.busy !== true) {\n\t\t\t\tresolve(); // removed, or no longer busy\n\t\t\t\tl.dispose();\n\t\t\t}\n\t\t});\n\t});\n};\n\n/**\n * Iterator that expands to and iterates through tests in the file. Iterates\n * in strictly descending order.\n */\nexport const testsInFile = async function* (testService: ITestService, ident: IUriIdentityService, uri: URI, waitForIdle = true): AsyncIterable<IncrementalTestCollectionItem> {\n\tfor (const test of testService.collection.all) {\n\t\tif (!test.item.uri) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ident.extUri.isEqual(uri, test.item.uri)) {\n\t\t\tyield test;\n\t\t}\n\n\t\tif (ident.extUri.isEqualOrParent(uri, test.item.uri)) {\n\t\t\tif (test.expand === TestItemExpandState.Expandable) {\n\t\t\t\tawait testService.collection.expand(test.item.extId, 1);\n\t\t\t}\n\t\t\tif (waitForIdle) {\n\t\t\t\tawait waitForTestToBeIdle(testService, test);\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * An instance of the RootProvider should be registered for each extension\n * host.\n */\nexport interface ITestRootProvider {\n\t// todo: nothing, yet\n}\n\n/**\n * A run request that expresses the intent of the request and allows the\n * test service to resolve the specifics of the group.\n */\nexport interface AmbiguousRunTestsRequest {\n\t/** Group to run */\n\tgroup: TestRunProfileBitset;\n\t/** Tests to run. Allowed to be from different controllers */\n\ttests: readonly InternalTestItem[];\n\t/** Tests to exclude. If not given, the current UI excluded tests are used */\n\texclude?: InternalTestItem[];\n\t/** Whether this was triggered from an auto run. */\n\tcontinuous?: boolean;\n}\n\nexport interface ITestService {\n\treadonly _serviceBrand: undefined;\n\t/**\n\t * Fires when the user requests to cancel a test run -- or all runs, if no\n\t * runId is given.\n\t */\n\treadonly onDidCancelTestRun: Event<{ runId: string | undefined }>;\n\n\t/**\n\t * Event that fires when the excluded tests change.\n\t */\n\treadonly excluded: TestExclusions;\n\n\t/**\n\t * Test collection instance.\n\t */\n\treadonly collection: IMainThreadTestCollection;\n\n\t/**\n\t * Event that fires immediately before a diff is processed.\n\t */\n\treadonly onWillProcessDiff: Event<TestsDiff>;\n\n\t/**\n\t * Event that fires after a diff is processed.\n\t */\n\treadonly onDidProcessDiff: Event<TestsDiff>;\n\n\t/**\n\t * Whether inline editor decorations should be visible.\n\t */\n\treadonly showInlineOutput: MutableObservableValue<boolean>;\n\n\t/**\n\t * Registers an interface that runs tests for the given provider ID.\n\t */\n\tregisterTestController(providerId: string, controller: IMainThreadTestController): IDisposable;\n\n\t/**\n\t * Gets a registered test controller by ID.\n\t */\n\tgetTestController(controllerId: string): IMainThreadTestController | undefined;\n\n\t/**\n\t * Refreshes tests for the controller, or all controllers if no ID is given.\n\t */\n\trefreshTests(controllerId?: string): Promise<void>;\n\n\t/**\n\t * Cancels any ongoing test refreshes.\n\t */\n\tcancelRefreshTests(): void;\n\n\t/**\n\t * Requests that tests be executed continuously, until the token is cancelled.\n\t */\n\tstartContinuousRun(req: ResolvedTestRunRequest, token: CancellationToken): Promise<void>;\n\n\t/**\n\t * Requests that tests be executed.\n\t */\n\trunTests(req: AmbiguousRunTestsRequest, token?: CancellationToken): Promise<ITestResult>;\n\n\t/**\n\t * Requests that tests be executed.\n\t */\n\trunResolvedTests(req: ResolvedTestRunRequest, token?: CancellationToken): Promise<ITestResult>;\n\n\t/**\n\t * Ensures the test diff from the remote ext host is flushed and waits for\n\t * any \"busy\" tests to become idle before resolving.\n\t */\n\tsyncTests(): Promise<void>;\n\n\t/**\n\t * Cancels an ongoing test run by its ID, or all runs if no ID is given.\n\t */\n\tcancelTestRun(runId?: string): void;\n\n\t/**\n\t * Publishes a test diff for a controller.\n\t */\n\tpublishDiff(controllerId: string, diff: TestsDiff): void;\n}\n"]}