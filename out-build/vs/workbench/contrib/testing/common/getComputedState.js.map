{"version":3,"sources":["file:///workspace/appflow/src/vs/workbench/contrib/testing/common/getComputedState.ts"],"names":[],"mappings":"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","file":"getComputedState.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Iterable } from 'vs/base/common/iterator';\nimport { TestResultState } from 'vs/workbench/contrib/testing/common/testTypes';\nimport { makeEmptyCounts, maxPriority, statePriority } from 'vs/workbench/contrib/testing/common/testingStates';\n\n/**\n * Accessor for nodes in get and refresh computed state.\n */\nexport interface IComputedStateAccessor<T> {\n\tgetOwnState(item: T): TestResultState | undefined;\n\tgetCurrentComputedState(item: T): TestResultState;\n\tsetComputedState(item: T, state: TestResultState): void;\n\tgetChildren(item: T): Iterable<T>;\n\tgetParents(item: T): Iterable<T>;\n}\n\nexport interface IComputedStateAndDurationAccessor<T> extends IComputedStateAccessor<T> {\n\tgetOwnDuration(item: T): number | undefined;\n\tgetCurrentComputedDuration(item: T): number | undefined;\n\tsetComputedDuration(item: T, duration: number | undefined): void;\n}\n\nconst isDurationAccessor = <T>(accessor: IComputedStateAccessor<T>): accessor is IComputedStateAndDurationAccessor<T> => 'getOwnDuration' in accessor;\n\n/**\n * Gets the computed state for the node.\n * @param force whether to refresh the computed state for this node, even\n * if it was previously set.\n */\n\nconst getComputedState = <T extends object>(accessor: IComputedStateAccessor<T>, node: T, force = false) => {\n\tlet computed = accessor.getCurrentComputedState(node);\n\tif (computed === undefined || force) {\n\t\tcomputed = accessor.getOwnState(node) ?? TestResultState.Unset;\n\n\t\tlet childrenCount = 0;\n\t\tconst stateMap = makeEmptyCounts();\n\n\t\tfor (const child of accessor.getChildren(node)) {\n\t\t\tconst childComputed = getComputedState(accessor, child);\n\t\t\tchildrenCount++;\n\t\t\tstateMap[childComputed]++;\n\n\t\t\t// If all children are skipped, make the current state skipped too if unset (#131537)\n\t\t\tcomputed = childComputed === TestResultState.Skipped && computed === TestResultState.Unset\n\t\t\t\t? TestResultState.Skipped : maxPriority(computed, childComputed);\n\t\t}\n\n\t\tif (childrenCount > LARGE_NODE_THRESHOLD) {\n\t\t\tlargeNodeChildrenStates.set(node, stateMap);\n\t\t}\n\n\t\taccessor.setComputedState(node, computed);\n\t}\n\n\treturn computed;\n};\n\nconst getComputedDuration = <T>(accessor: IComputedStateAndDurationAccessor<T>, node: T, force = false): number | undefined => {\n\tlet computed = accessor.getCurrentComputedDuration(node);\n\tif (computed === undefined || force) {\n\t\tconst own = accessor.getOwnDuration(node);\n\t\tif (own !== undefined) {\n\t\t\tcomputed = own;\n\t\t} else {\n\t\t\tcomputed = undefined;\n\t\t\tfor (const child of accessor.getChildren(node)) {\n\t\t\t\tconst d = getComputedDuration(accessor, child);\n\t\t\t\tif (d !== undefined) {\n\t\t\t\t\tcomputed = (computed || 0) + d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\taccessor.setComputedDuration(node, computed);\n\t}\n\n\treturn computed;\n};\n\nconst LARGE_NODE_THRESHOLD = 64;\n\n/**\n * Map of how many nodes have in each state. This is used to optimize state\n * computation in large nodes with children above the `LARGE_NODE_THRESHOLD`.\n */\nconst largeNodeChildrenStates = new WeakMap<object, { [K in TestResultState]: number }>();\n\n/**\n * Refreshes the computed state for the node and its parents. Any changes\n * elements cause `addUpdated` to be called.\n */\nexport const refreshComputedState = <T extends object>(\n\taccessor: IComputedStateAccessor<T>,\n\tnode: T,\n\texplicitNewComputedState?: TestResultState,\n\trefreshDuration = true,\n) => {\n\tconst oldState = accessor.getCurrentComputedState(node);\n\tconst oldPriority = statePriority[oldState];\n\tconst newState = explicitNewComputedState ?? getComputedState(accessor, node, true);\n\tconst newPriority = statePriority[newState];\n\tconst toUpdate = new Set<T>();\n\n\tif (newPriority !== oldPriority) {\n\t\taccessor.setComputedState(node, newState);\n\t\ttoUpdate.add(node);\n\n\t\tlet moveFromState = oldState;\n\t\tlet moveToState = newState;\n\n\t\tfor (const parent of accessor.getParents(node)) {\n\t\t\tconst lnm = largeNodeChildrenStates.get(parent);\n\t\t\tif (lnm) {\n\t\t\t\tlnm[moveFromState]--;\n\t\t\t\tlnm[moveToState]++;\n\t\t\t}\n\n\t\t\tconst prev = accessor.getCurrentComputedState(parent);\n\t\t\tif (newPriority > oldPriority) {\n\t\t\t\t// Update all parents to ensure they're at least this priority.\n\t\t\t\tif (prev !== undefined && statePriority[prev] >= newPriority) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (lnm && lnm[moveToState] > 1) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// moveToState remains the same, the new higher priority node state\n\t\t\t\taccessor.setComputedState(parent, newState);\n\t\t\t\ttoUpdate.add(parent);\n\t\t\t} else /* newProirity < oldPriority */ {\n\t\t\t\t// Update all parts whose statese might have been based on this one\n\t\t\t\tif (prev === undefined || statePriority[prev] > oldPriority) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (lnm && lnm[moveFromState] > 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tmoveToState = getComputedState(accessor, parent, true);\n\t\t\t\taccessor.setComputedState(parent, moveToState);\n\t\t\t\ttoUpdate.add(parent);\n\t\t\t}\n\n\t\t\tmoveFromState = prev;\n\t\t}\n\t}\n\n\tif (isDurationAccessor(accessor) && refreshDuration) {\n\t\tfor (const parent of Iterable.concat(Iterable.single(node), accessor.getParents(node))) {\n\t\t\tconst oldDuration = accessor.getCurrentComputedDuration(parent);\n\t\t\tconst newDuration = getComputedDuration(accessor, parent, true);\n\t\t\tif (oldDuration === newDuration) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\taccessor.setComputedDuration(parent, newDuration);\n\t\t\ttoUpdate.add(parent);\n\t\t}\n\t}\n\n\treturn toUpdate;\n};\n"]}