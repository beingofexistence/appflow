{"version":3,"sources":["file:///workspace/appflow/src/vs/workbench/contrib/testing/common/testingContinuousRunService.ts"],"names":[],"mappings":"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","file":"testingContinuousRunService.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationTokenSource } from 'vs/base/common/cancellation';\nimport { Disposable, toDisposable } from 'vs/base/common/lifecycle';\nimport { IContextKey, IContextKeyService } from 'vs/platform/contextkey/common/contextkey';\nimport { createDecorator } from 'vs/platform/instantiation/common/instantiation';\nimport { IStorageService, StorageScope, StorageTarget } from 'vs/platform/storage/common/storage';\nimport { StoredValue } from 'vs/workbench/contrib/testing/common/storedValue';\nimport { TestingContextKeys } from 'vs/workbench/contrib/testing/common/testingContextKeys';\nimport { ITestService } from 'vs/workbench/contrib/testing/common/testService';\nimport { TestService } from 'vs/workbench/contrib/testing/common/testServiceImpl';\nimport { ITestRunProfile } from 'vs/workbench/contrib/testing/common/testTypes';\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { TestId } from 'vs/workbench/contrib/testing/common/testId';\nimport { WellDefinedPrefixTree } from 'vs/base/common/prefixTree';\n\nexport const ITestingContinuousRunService = createDecorator<ITestingContinuousRunService>('testingContinuousRunService');\n\nexport interface ITestingContinuousRunService {\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Gets a list of the last test profiles that were continuously run in the workspace.\n\t */\n\treadonly lastRunProfileIds: ReadonlySet<number>;\n\n\t/**\n\t * Fired when a test is added or removed from continous run, or when\n\t * enablement is changed globally.\n\t */\n\tonDidChange: Event<string | undefined>;\n\n\t/**\n\t * Gets whether continous run is specifically enabled for the given test ID.\n\t */\n\tisSpecificallyEnabledFor(testId: string): boolean;\n\n\t/**\n\t * Gets whether continous run is specifically enabled for\n\t * the given test ID, or any of its parents.\n\t */\n\tisEnabledForAParentOf(testId: string): boolean;\n\n\t/**\n\t * Gets whether continous run is specifically enabled for\n\t * the given test ID, or any of its parents.\n\t */\n\tisEnabledForAChildOf(testId: string): boolean;\n\n\t/**\n\t * Gets whether it's enabled at all.\n\t */\n\tisEnabled(): boolean;\n\n\t/**\n\t * Starts a continuous auto run with a specific profile or set of profiles.\n\t * Globally if no test is given, for a specific test otherwise.\n\t */\n\tstart(profile: ITestRunProfile[], testId?: string): void;\n\n\t/**\n\t * Stops any continuous run\n\t * Globally if no test is given, for a specific test otherwise.\n\t */\n\tstop(testId?: string): void;\n}\n\nexport class TestingContinuousRunService extends Disposable implements ITestingContinuousRunService {\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate readonly changeEmitter = new Emitter<string | undefined>();\n\tprivate globallyRunning?: CancellationTokenSource;\n\tprivate readonly running = new WellDefinedPrefixTree<CancellationTokenSource>();\n\tprivate readonly lastRun: StoredValue<Set<number>>;\n\tprivate readonly isGloballyOn: IContextKey<boolean>;\n\n\tpublic readonly onDidChange = this.changeEmitter.event;\n\n\tpublic get lastRunProfileIds() {\n\t\treturn this.lastRun.get(new Set());\n\t}\n\n\tconstructor(\n\t\t@ITestService private readonly testService: TestService,\n\t\t@IStorageService storageService: IStorageService,\n\t\t@IContextKeyService contextKeyService: IContextKeyService,\n\t) {\n\t\tsuper();\n\t\tthis.isGloballyOn = TestingContextKeys.isContinuousModeOn.bindTo(contextKeyService);\n\t\tthis.lastRun = this._register(new StoredValue<Set<number>>({\n\t\t\tkey: 'lastContinuousRunProfileIds',\n\t\t\tscope: StorageScope.WORKSPACE,\n\t\t\ttarget: StorageTarget.MACHINE,\n\t\t\tserialization: {\n\t\t\t\tdeserialize: v => new Set(JSON.parse(v)),\n\t\t\t\tserialize: v => JSON.stringify([...v])\n\t\t\t},\n\t\t}, storageService));\n\n\t\tthis._register(toDisposable(() => {\n\t\t\tthis.globallyRunning?.dispose();\n\t\t\tfor (const cts of this.running.values()) {\n\t\t\t\tcts.dispose();\n\t\t\t}\n\t\t}));\n\t}\n\n\t/** @inheritdoc */\n\tpublic isSpecificallyEnabledFor(testId: string): boolean {\n\t\treturn this.running.size > 0 && this.running.hasKey(TestId.fromString(testId).path);\n\t}\n\n\t/** @inheritdoc */\n\tpublic isEnabledForAParentOf(testId: string): boolean {\n\t\tif (this.globallyRunning) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn this.running.size > 0 && this.running.hasKeyOrParent(TestId.fromString(testId).path);\n\t}\n\n\t/** @inheritdoc */\n\tpublic isEnabledForAChildOf(testId: string): boolean {\n\t\treturn this.running.size > 0 && this.running.hasKeyOrChildren(TestId.fromString(testId).path);\n\t}\n\n\t/** @inheritdoc */\n\tpublic isEnabled(): boolean {\n\t\treturn !!this.globallyRunning || this.running.size > 0;\n\t}\n\n\t/** @inheritdoc */\n\tpublic start(profile: ITestRunProfile[], testId?: string): void {\n\t\tconst cts = new CancellationTokenSource();\n\n\t\tif (testId === undefined) {\n\t\t\tthis.isGloballyOn.set(true);\n\t\t}\n\n\t\tif (!testId) {\n\t\t\tthis.globallyRunning?.dispose(true);\n\t\t\tthis.globallyRunning = cts;\n\t\t} else {\n\t\t\tthis.running.mutate(TestId.fromString(testId).path, c => {\n\t\t\t\tc?.dispose(true);\n\t\t\t\treturn cts;\n\t\t\t});\n\t\t}\n\n\t\tthis.lastRun.store(new Set(profile.map(p => p.profileId)));\n\n\t\tthis.testService.startContinuousRun({\n\t\t\tcontinuous: true,\n\t\t\ttargets: profile.map(p => ({\n\t\t\t\ttestIds: [testId ?? p.controllerId],\n\t\t\t\tcontrollerId: p.controllerId,\n\t\t\t\tprofileGroup: p.group,\n\t\t\t\tprofileId: p.profileId\n\t\t\t})),\n\t\t}, cts.token);\n\n\t\tthis.changeEmitter.fire(testId);\n\t}\n\n\t/** @inheritdoc */\n\tpublic stop(testId?: string): void {\n\t\tif (!testId) {\n\t\t\tthis.globallyRunning?.dispose(true);\n\t\t\tthis.globallyRunning = undefined;\n\t\t} else {\n\t\t\tthis.running.delete(TestId.fromString(testId).path)?.dispose(true);\n\t\t}\n\n\t\tif (testId === undefined) {\n\t\t\tthis.isGloballyOn.set(false);\n\t\t}\n\n\t\tthis.changeEmitter.fire(testId);\n\t}\n}\n"]}