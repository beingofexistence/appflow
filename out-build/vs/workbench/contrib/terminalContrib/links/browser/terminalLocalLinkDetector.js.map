{"version":3,"sources":["file:///workspace/appflow/src/vs/workbench/contrib/terminalContrib/links/browser/terminalLocalLinkDetector.ts"],"names":[],"mappings":"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","file":"terminalLocalLinkDetector.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { OS } from 'vs/base/common/platform';\nimport { URI } from 'vs/base/common/uri';\nimport { IUriIdentityService } from 'vs/platform/uriIdentity/common/uriIdentity';\nimport { IWorkspaceContextService } from 'vs/platform/workspace/common/workspace';\nimport { ITerminalLinkDetector, ITerminalLinkResolver, ITerminalSimpleLink, ResolvedLink, TerminalBuiltinLinkType } from 'vs/workbench/contrib/terminalContrib/links/browser/links';\nimport { convertLinkRangeToBuffer, getXtermLineContent, getXtermRangesByAttr, osPathModule, updateLinkWithRelativeCwd } from 'vs/workbench/contrib/terminalContrib/links/browser/terminalLinkHelpers';\nimport { ITerminalCapabilityStore, TerminalCapability } from 'vs/platform/terminal/common/capabilities/capabilities';\nimport type { IBufferLine, IBufferRange, Terminal } from 'xterm';\nimport { ITerminalProcessManager } from 'vs/workbench/contrib/terminal/common/terminal';\nimport { detectLinks } from 'vs/workbench/contrib/terminalContrib/links/browser/terminalLinkParsing';\nimport { ITerminalBackend, ITerminalLogService } from 'vs/platform/terminal/common/terminal';\n\nconst enum Constants {\n\t/**\n\t * The max line length to try extract word links from.\n\t */\n\tMaxLineLength = 2000,\n\n\t/**\n\t * The maximum number of links in a line to resolve against the file system. This limit is put\n\t * in place to avoid sending excessive data when remote connections are in place.\n\t */\n\tMaxResolvedLinksInLine = 10,\n\n\t/**\n\t * The maximum length of a link to resolve against the file system. This limit is put in place\n\t * to avoid sending excessive data when remote connections are in place.\n\t */\n\tMaxResolvedLinkLength = 1024,\n}\n\nconst fallbackMatchers: RegExp[] = [\n\t// Python style error: File \"<path>\", line <line>\n\t/^ *File (?<link>\"(?<path>.+)\"(, line (?<line>\\d+))?)/,\n\t// Some C++ compile error formats:\n\t// C:\\foo\\bar baz(339) : error ...\n\t// C:\\foo\\bar baz(339,12) : error ...\n\t// C:\\foo\\bar baz(339, 12) : error ...\n\t// C:\\foo\\bar baz(339): error ...       [#178584, Visual Studio CL/NVIDIA CUDA compiler]\n\t// C:\\foo\\bar baz(339,12): ...\n\t// C:\\foo\\bar baz(339, 12): ...\n\t/^(?<link>(?<path>.+)\\((?<line>\\d+)(?:, ?(?<col>\\d+))?\\)) ?:/,\n\t// C:\\foo/bar baz:339 : error ...\n\t// C:\\foo/bar baz:339:12 : error ...\n\t// C:\\foo/bar baz:339: error ...\n\t// C:\\foo/bar baz:339:12: error ...     [#178584, Clang]\n\t/^(?<link>(?<path>.+):(?<line>\\d+)(?::(?<col>\\d+))?) ?:/,\n\t// Cmd prompt\n\t/^(?<link>(?<path>.+))>/,\n\t// The whole line is the path\n\t/^ *(?<link>(?<path>.+))/\n];\n\nexport class TerminalLocalLinkDetector implements ITerminalLinkDetector {\n\tstatic id = 'local';\n\n\t// This was chosen as a reasonable maximum line length given the tradeoff between performance\n\t// and how likely it is to encounter such a large line length. Some useful reference points:\n\t// - Window old max length: 260 ($MAX_PATH)\n\t// - Linux max length: 4096 ($PATH_MAX)\n\treadonly maxLinkLength = 500;\n\n\tconstructor(\n\t\treadonly xterm: Terminal,\n\t\tprivate readonly _capabilities: ITerminalCapabilityStore,\n\t\tprivate readonly _processManager: Pick<ITerminalProcessManager, 'initialCwd' | 'os' | 'remoteAuthority' | 'userHome'> & { backend?: Pick<ITerminalBackend, 'getWslPath'> },\n\t\tprivate readonly _linkResolver: ITerminalLinkResolver,\n\t\t@ITerminalLogService private readonly _logService: ITerminalLogService,\n\t\t@IUriIdentityService private readonly _uriIdentityService: IUriIdentityService,\n\t\t@IWorkspaceContextService private readonly _workspaceContextService: IWorkspaceContextService\n\t) {\n\t}\n\n\tasync detect(lines: IBufferLine[], startLine: number, endLine: number): Promise<ITerminalSimpleLink[]> {\n\t\tconst links: ITerminalSimpleLink[] = [];\n\n\t\t// Get the text representation of the wrapped line\n\t\tconst text = getXtermLineContent(this.xterm.buffer.active, startLine, endLine, this.xterm.cols);\n\t\tif (text === '' || text.length > Constants.MaxLineLength) {\n\t\t\treturn [];\n\t\t}\n\n\t\tlet stringIndex = -1;\n\t\tlet resolvedLinkCount = 0;\n\n\t\tconst os = this._processManager.os || OS;\n\t\tconst parsedLinks = detectLinks(text, os);\n\t\tthis._logService.trace('terminalLocalLinkDetector#detect text', text);\n\t\tthis._logService.trace('terminalLocalLinkDetector#detect parsedLinks', parsedLinks);\n\t\tfor (const parsedLink of parsedLinks) {\n\n\t\t\t// Don't try resolve any links of excessive length\n\t\t\tif (parsedLink.path.text.length > Constants.MaxResolvedLinkLength) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Convert the link text's string index into a wrapped buffer range\n\t\t\tconst bufferRange = convertLinkRangeToBuffer(lines, this.xterm.cols, {\n\t\t\t\tstartColumn: (parsedLink.prefix?.index ?? parsedLink.path.index) + 1,\n\t\t\t\tstartLineNumber: 1,\n\t\t\t\tendColumn: parsedLink.path.index + parsedLink.path.text.length + (parsedLink.suffix?.suffix.text.length ?? 0) + 1,\n\t\t\t\tendLineNumber: 1\n\t\t\t}, startLine);\n\n\t\t\t// Get a single link candidate if the cwd of the line is known\n\t\t\tconst linkCandidates: string[] = [];\n\t\t\tconst osPath = osPathModule(os);\n\t\t\tif (osPath.isAbsolute(parsedLink.path.text) || parsedLink.path.text.startsWith('~')) {\n\t\t\t\tlinkCandidates.push(parsedLink.path.text);\n\t\t\t} else {\n\t\t\t\tif (this._capabilities.has(TerminalCapability.CommandDetection)) {\n\t\t\t\t\tconst absolutePath = updateLinkWithRelativeCwd(this._capabilities, bufferRange.start.y, parsedLink.path.text, osPath, this._logService);\n\t\t\t\t\t// Only add a single exact link candidate if the cwd is available, this may cause\n\t\t\t\t\t// the link to not be resolved but that should only occur when the actual file does\n\t\t\t\t\t// not exist. Doing otherwise could cause unexpected results where handling via the\n\t\t\t\t\t// word link detector is preferable.\n\t\t\t\t\tif (absolutePath) {\n\t\t\t\t\t\tlinkCandidates.push(...absolutePath);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Fallback to resolving against the initial cwd, removing any relative directory prefixes\n\t\t\t\tif (linkCandidates.length === 0) {\n\t\t\t\t\tlinkCandidates.push(parsedLink.path.text);\n\t\t\t\t\tif (parsedLink.path.text.match(/^(\\.\\.[\\/\\\\])+/)) {\n\t\t\t\t\t\tlinkCandidates.push(parsedLink.path.text.replace(/^(\\.\\.[\\/\\\\])+/, ''));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If any candidates end with special characters that are likely to not be part of the\n\t\t\t// link, add a candidate excluding them.\n\t\t\tconst specialEndCharRegex = /[\\[\\]\"'\\.]$/;\n\t\t\tconst trimRangeMap: Map<string, number> = new Map();\n\t\t\tconst specialEndLinkCandidates: string[] = [];\n\t\t\tfor (const candidate of linkCandidates) {\n\t\t\t\tlet previous = candidate;\n\t\t\t\tlet removed = previous.replace(specialEndCharRegex, '');\n\t\t\t\tlet trimRange = 0;\n\t\t\t\twhile (removed !== previous) {\n\t\t\t\t\t// Only trim the link if there is no suffix, otherwise the underline would be incorrect\n\t\t\t\t\tif (!parsedLink.suffix) {\n\t\t\t\t\t\ttrimRange++;\n\t\t\t\t\t}\n\t\t\t\t\tspecialEndLinkCandidates.push(removed);\n\t\t\t\t\ttrimRangeMap.set(removed, trimRange);\n\t\t\t\t\tprevious = removed;\n\t\t\t\t\tremoved = removed.replace(specialEndCharRegex, '');\n\t\t\t\t}\n\t\t\t}\n\t\t\tlinkCandidates.push(...specialEndLinkCandidates);\n\t\t\tthis._logService.trace('terminalLocalLinkDetector#detect linkCandidates', linkCandidates);\n\n\t\t\t// Validate the path and convert to the outgoing type\n\t\t\tconst simpleLink = await this._validateAndGetLink(undefined, bufferRange, linkCandidates, trimRangeMap);\n\t\t\tif (simpleLink) {\n\t\t\t\tsimpleLink.parsedLink = parsedLink;\n\t\t\t\tsimpleLink.text = text.substring(\n\t\t\t\t\tparsedLink.prefix?.index ?? parsedLink.path.index,\n\t\t\t\t\tparsedLink.suffix ? parsedLink.suffix.suffix.index + parsedLink.suffix.suffix.text.length : parsedLink.path.index + parsedLink.path.text.length\n\t\t\t\t);\n\t\t\t\tthis._logService.trace('terminalLocalLinkDetector#detect verified link', simpleLink);\n\t\t\t\tlinks.push(simpleLink);\n\t\t\t}\n\n\t\t\t// Stop early if too many links exist in the line\n\t\t\tif (++resolvedLinkCount >= Constants.MaxResolvedLinksInLine) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Match against the fallback matchers which are mainly designed to catch paths with spaces\n\t\t// that aren't possible using the regular mechanism.\n\t\tif (links.length === 0) {\n\t\t\tfor (const matcher of fallbackMatchers) {\n\t\t\t\tconst match = text.match(matcher);\n\t\t\t\tconst group = match?.groups;\n\t\t\t\tif (!group) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst link = group?.link;\n\t\t\t\tconst path = group?.path;\n\t\t\t\tconst line = group?.line;\n\t\t\t\tconst col = group?.col;\n\t\t\t\tif (!link || !path) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Don't try resolve any links of excessive length\n\t\t\t\tif (link.length > Constants.MaxResolvedLinkLength) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Convert the link text's string index into a wrapped buffer range\n\t\t\t\tstringIndex = text.indexOf(link);\n\t\t\t\tconst bufferRange = convertLinkRangeToBuffer(lines, this.xterm.cols, {\n\t\t\t\t\tstartColumn: stringIndex + 1,\n\t\t\t\t\tstartLineNumber: 1,\n\t\t\t\t\tendColumn: stringIndex + link.length + 1,\n\t\t\t\t\tendLineNumber: 1\n\t\t\t\t}, startLine);\n\n\t\t\t\t// Validate and add link\n\t\t\t\tconst suffix = line ? `:${line}${col ? `:${col}` : ''}` : '';\n\t\t\t\tconst simpleLink = await this._validateAndGetLink(`${path}${suffix}`, bufferRange, [path]);\n\t\t\t\tif (simpleLink) {\n\t\t\t\t\tlinks.push(simpleLink);\n\t\t\t\t}\n\n\t\t\t\t// Only match a single fallback matcher\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Sometimes links are styled specially in the terminal like underlined or bolded, try split\n\t\t// the line by attributes and test whether it matches a path\n\t\tif (links.length === 0) {\n\t\t\tconst rangeCandidates = getXtermRangesByAttr(this.xterm.buffer.active, startLine, endLine, this.xterm.cols);\n\t\t\tfor (const rangeCandidate of rangeCandidates) {\n\t\t\t\tlet text = '';\n\t\t\t\tfor (let y = rangeCandidate.start.y; y <= rangeCandidate.end.y; y++) {\n\t\t\t\t\tconst line = this.xterm.buffer.active.getLine(y);\n\t\t\t\t\tif (!line) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tconst lineStartX = y === rangeCandidate.start.y ? rangeCandidate.start.x : 0;\n\t\t\t\t\tconst lineEndX = y === rangeCandidate.end.y ? rangeCandidate.end.x : this.xterm.cols - 1;\n\t\t\t\t\ttext += line.translateToString(false, lineStartX, lineEndX);\n\t\t\t\t}\n\n\t\t\t\t// HACK: Adjust to 1-based for link API\n\t\t\t\trangeCandidate.start.x++;\n\t\t\t\trangeCandidate.start.y++;\n\t\t\t\trangeCandidate.end.y++;\n\n\t\t\t\t// Validate and add link\n\t\t\t\tconst simpleLink = await this._validateAndGetLink(text, rangeCandidate, [text]);\n\t\t\t\tif (simpleLink) {\n\t\t\t\t\tlinks.push(simpleLink);\n\t\t\t\t}\n\n\t\t\t\t// Stop early if too many links exist in the line\n\t\t\t\tif (++resolvedLinkCount >= Constants.MaxResolvedLinksInLine) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn links;\n\t}\n\n\tprivate _isDirectoryInsideWorkspace(uri: URI) {\n\t\tconst folders = this._workspaceContextService.getWorkspace().folders;\n\t\tfor (let i = 0; i < folders.length; i++) {\n\t\t\tif (this._uriIdentityService.extUri.isEqualOrParent(uri, folders[i].uri)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate async _validateLinkCandidates(linkCandidates: string[]): Promise<ResolvedLink | undefined> {\n\t\tfor (const link of linkCandidates) {\n\t\t\tconst result = await this._linkResolver.resolveLink(this._processManager, link);\n\t\t\tif (result) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t}\n\n\t/**\n\t * Validates a set of link candidates and returns a link if validated.\n\t * @param linkText The link text, this should be undefined to use the link stat value\n\t * @param trimRangeMap A map of link candidates to the amount of buffer range they need trimmed.\n\t */\n\tprivate async _validateAndGetLink(linkText: string | undefined, bufferRange: IBufferRange, linkCandidates: string[], trimRangeMap?: Map<string, number>): Promise<ITerminalSimpleLink | undefined> {\n\t\tconst linkStat = await this._validateLinkCandidates(linkCandidates);\n\t\tif (linkStat) {\n\t\t\tlet type: TerminalBuiltinLinkType;\n\t\t\tif (linkStat.isDirectory) {\n\t\t\t\tif (this._isDirectoryInsideWorkspace(linkStat.uri)) {\n\t\t\t\t\ttype = TerminalBuiltinLinkType.LocalFolderInWorkspace;\n\t\t\t\t} else {\n\t\t\t\t\ttype = TerminalBuiltinLinkType.LocalFolderOutsideWorkspace;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttype = TerminalBuiltinLinkType.LocalFile;\n\t\t\t}\n\n\t\t\t// Offset the buffer range if the link range was trimmed\n\t\t\tconst trimRange = trimRangeMap?.get(linkStat.link);\n\t\t\tif (trimRange) {\n\t\t\t\tbufferRange.end.x -= trimRange;\n\t\t\t\tif (bufferRange.end.x < 0) {\n\t\t\t\t\tbufferRange.end.y--;\n\t\t\t\t\tbufferRange.end.x += this.xterm.cols;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\ttext: linkText ?? linkStat.link,\n\t\t\t\turi: linkStat.uri,\n\t\t\t\tbufferRange: bufferRange,\n\t\t\t\ttype\n\t\t\t};\n\t\t}\n\t\treturn undefined;\n\t}\n}\n"]}