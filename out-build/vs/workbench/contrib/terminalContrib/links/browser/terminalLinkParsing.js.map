{"version":3,"sources":["file:///workspace/appflow/src/vs/workbench/contrib/terminalContrib/links/browser/terminalLinkParsing.ts"],"names":[],"mappings":"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","file":"terminalLinkParsing.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * This module is responsible for parsing possible links out of lines with only access to the line\n * text and the target operating system, ie. it does not do any validation that paths actually\n * exist.\n */\n\nimport { Lazy } from 'vs/base/common/lazy';\nimport { OperatingSystem } from 'vs/base/common/platform';\n\nexport interface IParsedLink {\n\tpath: ILinkPartialRange;\n\tprefix?: ILinkPartialRange;\n\tsuffix?: ILinkSuffix;\n}\n\nexport interface ILinkSuffix {\n\trow: number | undefined;\n\tcol: number | undefined;\n\trowEnd: number | undefined;\n\tcolEnd: number | undefined;\n\tsuffix: ILinkPartialRange;\n}\n\nexport interface ILinkPartialRange {\n\tindex: number;\n\ttext: string;\n}\n\n/**\n * A regex that extracts the link suffix which contains line and column information. The link suffix\n * must terminate at the end of line.\n */\nconst linkSuffixRegexEol = new Lazy<RegExp>(() => generateLinkSuffixRegex(true));\n/**\n * A regex that extracts the link suffix which contains line and column information.\n */\nconst linkSuffixRegex = new Lazy<RegExp>(() => generateLinkSuffixRegex(false));\n\nfunction generateLinkSuffixRegex(eolOnly: boolean) {\n\tlet ri = 0;\n\tlet ci = 0;\n\tlet rei = 0;\n\tlet cei = 0;\n\tfunction r(): string {\n\t\treturn `(?<row${ri++}>\\\\d+)`;\n\t}\n\tfunction c(): string {\n\t\treturn `(?<col${ci++}>\\\\d+)`;\n\t}\n\tfunction re(): string {\n\t\treturn `(?<rowEnd${rei++}>\\\\d+)`;\n\t}\n\tfunction ce(): string {\n\t\treturn `(?<colEnd${cei++}>\\\\d+)`;\n\t}\n\n\tconst eolSuffix = eolOnly ? '$' : '';\n\n\t// The comments in the regex below use real strings/numbers for better readability, here's\n\t// the legend:\n\t// - Path    = foo\n\t// - Row     = 339\n\t// - Col     = 12\n\t// - RowEnd  = 341\n\t// - ColEnd  = 14\n\t//\n\t// These all support single quote ' in the place of \" and [] in the place of ()\n\tconst lineAndColumnRegexClauses = [\n\t\t// foo:339\n\t\t// foo:339:12\n\t\t// foo:339.12\n\t\t// foo 339\n\t\t// foo 339:12                             [#140780]\n\t\t// foo 339.12\n\t\t// \"foo\",339\n\t\t// \"foo\",339:12\n\t\t// \"foo\",339.12\n\t\t// \"foo\",339.12-14\n\t\t// \"foo\",339.12-341.14\n\t\t`(?::| |['\"],)${r()}([:.]${c()}(?:-(?:${re()}\\.)?${ce()})?)?` + eolSuffix,\n\t\t// The quotes below are optional          [#171652]\n\t\t// \"foo\", line 339                        [#40468]\n\t\t// \"foo\", line 339, col 12\n\t\t// \"foo\", line 339, column 12\n\t\t// \"foo\":line 339\n\t\t// \"foo\":line 339, col 12\n\t\t// \"foo\":line 339, column 12\n\t\t// \"foo\": line 339\n\t\t// \"foo\": line 339, col 12\n\t\t// \"foo\": line 339, column 12\n\t\t// \"foo\" on line 339\n\t\t// \"foo\" on line 339, col 12\n\t\t// \"foo\" on line 339, column 12\n\t\t// \"foo\" line 339 column 12\n\t\t// \"foo\", line 339, character 12          [#171880]\n\t\t// \"foo\", line 339, characters 12-14      [#171880]\n\t\t// \"foo\", lines 339-341                   [#171880]\n\t\t// \"foo\", lines 339-341, characters 12-14 [#178287]\n\t\t`['\"]?(?:,? |: ?| on )lines? ${r()}(?:-${re()})?(?:,? (?:col(?:umn)?|characters?) ${c()}(?:-${ce()})?)?` + eolSuffix,\n\t\t// foo(339)\n\t\t// foo(339,12)\n\t\t// foo(339, 12)\n\t\t// foo (339)\n\t\t//   ...\n\t\t// foo: (339)\n\t\t//   ...\n\t\t`:? ?[\\\\[\\\\(]${r()}(?:, ?${c()})?[\\\\]\\\\)]` + eolSuffix,\n\t];\n\n\tconst suffixClause = lineAndColumnRegexClauses\n\t\t// Join all clauses together\n\t\t.join('|')\n\t\t// Convert spaces to allow the non-breaking space char (ascii 160)\n\t\t.replace(/ /g, `[${'\\u00A0'} ]`);\n\n\treturn new RegExp(`(${suffixClause})`, eolOnly ? undefined : 'g');\n}\n\n/**\n * Removes the optional link suffix which contains line and column information.\n * @param link The link to use.\n */\nexport function removeLinkSuffix(link: string): string {\n\tconst suffix = getLinkSuffix(link)?.suffix;\n\tif (!suffix) {\n\t\treturn link;\n\t}\n\treturn link.substring(0, suffix.index);\n}\n\n/**\n * Removes any query string from the link.\n * @param link The link to use.\n */\nexport function removeLinkQueryString(link: string): string {\n\t// Skip ? in UNC paths\n\tconst start = link.startsWith('\\\\\\\\?\\\\') ? 4 : 0;\n\tconst index = link.indexOf('?', start);\n\tif (index === -1) {\n\t\treturn link;\n\t}\n\treturn link.substring(0, index);\n}\n\nexport function detectLinkSuffixes(line: string): ILinkSuffix[] {\n\t// Find all suffixes on the line. Since the regex global flag is used, lastIndex will be updated\n\t// in place such that there are no overlapping matches.\n\tlet match: RegExpExecArray | null;\n\tconst results: ILinkSuffix[] = [];\n\tlinkSuffixRegex.value.lastIndex = 0;\n\twhile ((match = linkSuffixRegex.value.exec(line)) !== null) {\n\t\tconst suffix = toLinkSuffix(match);\n\t\tif (suffix === null) {\n\t\t\tbreak;\n\t\t}\n\t\tresults.push(suffix);\n\t}\n\treturn results;\n}\n\n/**\n * Returns the optional link suffix which contains line and column information.\n * @param link The link to parse.\n */\nexport function getLinkSuffix(link: string): ILinkSuffix | null {\n\treturn toLinkSuffix(linkSuffixRegexEol.value.exec(link));\n}\n\nexport function toLinkSuffix(match: RegExpExecArray | null): ILinkSuffix | null {\n\tconst groups = match?.groups;\n\tif (!groups || match.length < 1) {\n\t\treturn null;\n\t}\n\treturn {\n\t\trow: parseIntOptional(groups.row0 || groups.row1 || groups.row2),\n\t\tcol: parseIntOptional(groups.col0 || groups.col1 || groups.col2),\n\t\trowEnd: parseIntOptional(groups.rowEnd0 || groups.rowEnd1 || groups.rowEnd2),\n\t\tcolEnd: parseIntOptional(groups.colEnd0 || groups.colEnd1 || groups.colEnd2),\n\t\tsuffix: { index: match.index, text: match[0] }\n\t};\n}\n\nfunction parseIntOptional(value: string | undefined): number | undefined {\n\tif (value === undefined) {\n\t\treturn value;\n\t}\n\treturn parseInt(value);\n}\n\n// This defines valid path characters for a link with a suffix, the first `[]` of the regex includes\n// characters the path is not allowed to _start_ with, the second `[]` includes characters not\n// allowed at all in the path. If the characters show up in both regexes the link will stop at that\n// character, otherwise it will stop at a space character.\nconst linkWithSuffixPathCharacters = /(?<path>[^\\s\\|<>\\[\\({][^\\s\\|<>]*)$/;\n\nexport function detectLinks(line: string, os: OperatingSystem) {\n\t// 1: Detect all links on line via suffixes first\n\tconst results = detectLinksViaSuffix(line);\n\n\t// 2: Detect all links without suffixes and merge non-conflicting ranges into the results\n\tconst noSuffixPaths = detectPathsNoSuffix(line, os);\n\tbinaryInsertList(results, noSuffixPaths);\n\n\treturn results;\n}\n\nfunction binaryInsertList(list: IParsedLink[], newItems: IParsedLink[]) {\n\tif (list.length === 0) {\n\t\tlist.push(...newItems);\n\t}\n\tfor (const item of newItems) {\n\t\tbinaryInsert(list, item, 0, list.length);\n\t}\n}\n\nfunction binaryInsert(list: IParsedLink[], newItem: IParsedLink, low: number, high: number) {\n\tif (list.length === 0) {\n\t\tlist.push(newItem);\n\t\treturn;\n\t}\n\tif (low > high) {\n\t\treturn;\n\t}\n\t// Find the index where the newItem would be inserted\n\tconst mid = Math.floor((low + high) / 2);\n\tif (\n\t\tmid >= list.length ||\n\t\t(newItem.path.index < list[mid].path.index && (mid === 0 || newItem.path.index > list[mid - 1].path.index))\n\t) {\n\t\t// Check if it conflicts with an existing link before adding\n\t\tif (\n\t\t\tmid >= list.length ||\n\t\t\t(newItem.path.index + newItem.path.text.length < list[mid].path.index && (mid === 0 || newItem.path.index > list[mid - 1].path.index + list[mid - 1].path.text.length))\n\t\t) {\n\t\t\tlist.splice(mid, 0, newItem);\n\t\t}\n\t\treturn;\n\t}\n\tif (newItem.path.index > list[mid].path.index) {\n\t\tbinaryInsert(list, newItem, mid + 1, high);\n\t} else {\n\t\tbinaryInsert(list, newItem, low, mid - 1);\n\t}\n}\n\nfunction detectLinksViaSuffix(line: string): IParsedLink[] {\n\tconst results: IParsedLink[] = [];\n\n\t// 1: Detect link suffixes on the line\n\tconst suffixes = detectLinkSuffixes(line);\n\tfor (const suffix of suffixes) {\n\t\tconst beforeSuffix = line.substring(0, suffix.suffix.index);\n\t\tconst possiblePathMatch = beforeSuffix.match(linkWithSuffixPathCharacters);\n\t\tif (possiblePathMatch && possiblePathMatch.index !== undefined && possiblePathMatch.groups?.path) {\n\t\t\tlet linkStartIndex = possiblePathMatch.index;\n\t\t\tlet path = possiblePathMatch.groups.path;\n\t\t\t// Extract a path prefix if it exists (not part of the path, but part of the underlined\n\t\t\t// section)\n\t\t\tlet prefix: ILinkPartialRange | undefined = undefined;\n\t\t\tconst prefixMatch = path.match(/^(?<prefix>['\"]+)/);\n\t\t\tif (prefixMatch?.groups?.prefix) {\n\t\t\t\tprefix = {\n\t\t\t\t\tindex: linkStartIndex,\n\t\t\t\t\ttext: prefixMatch.groups.prefix\n\t\t\t\t};\n\t\t\t\tpath = path.substring(prefix.text.length);\n\n\t\t\t\t// If there are multiple characters in the prefix, trim the prefix if the _first_\n\t\t\t\t// suffix character is the same as the last prefix character. For example, for the\n\t\t\t\t// text `echo \"'foo' on line 1\"`:\n\t\t\t\t//\n\t\t\t\t// - Prefix='\n\t\t\t\t// - Path=foo\n\t\t\t\t// - Suffix=' on line 1\n\t\t\t\t//\n\t\t\t\t// If this fails on a multi-character prefix, just keep the original.\n\t\t\t\tif (prefixMatch.groups.prefix.length > 1) {\n\t\t\t\t\tif (suffix.suffix.text[0].match(/['\"]/) && prefixMatch.groups.prefix[prefixMatch.groups.prefix.length - 1] === suffix.suffix.text[0]) {\n\t\t\t\t\t\tconst trimPrefixAmount = prefixMatch.groups.prefix.length - 1;\n\t\t\t\t\t\tprefix.index += trimPrefixAmount;\n\t\t\t\t\t\tprefix.text = prefixMatch.groups.prefix[prefixMatch.groups.prefix.length - 1];\n\t\t\t\t\t\tlinkStartIndex += trimPrefixAmount;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tresults.push({\n\t\t\t\tpath: {\n\t\t\t\t\tindex: linkStartIndex + (prefix?.text.length || 0),\n\t\t\t\t\ttext: path\n\t\t\t\t},\n\t\t\t\tprefix,\n\t\t\t\tsuffix\n\t\t\t});\n\t\t}\n\t}\n\n\treturn results;\n}\n\nenum RegexPathConstants {\n\tPathPrefix = '(?:\\\\.\\\\.?|\\\\~)',\n\tPathSeparatorClause = '\\\\/',\n\t// '\":; are allowed in paths but they are often separators so ignore them\n\t// Also disallow \\\\ to prevent a catastropic backtracking case #24795\n\tExcludedPathCharactersClause = '[^\\\\0<>\\\\?\\\\s!`&*()\\'\":;\\\\\\\\]',\n\tExcludedStartPathCharactersClause = '[^\\\\0<>\\\\s!`&*()\\\\[\\\\]\\'\":;\\\\\\\\]',\n\n\tWinOtherPathPrefix = '\\\\.\\\\.?|\\\\~',\n\tWinPathSeparatorClause = '(?:\\\\\\\\|\\\\/)',\n\tWinExcludedPathCharactersClause = '[^\\\\0<>\\\\?\\\\|\\\\/\\\\s!`&*()\\'\":;]',\n\tWinExcludedStartPathCharactersClause = '[^\\\\0<>\\\\?\\\\|\\\\/\\\\s!`&*()\\\\[\\\\]\\'\":;]',\n}\n\n/**\n * A regex that matches non-Windows paths, such as `/foo`, `~/foo`, `./foo`, `../foo` and\n * `foo/bar`.\n */\nconst unixLocalLinkClause = '(?:(?:' + RegexPathConstants.PathPrefix + '|(?:' + RegexPathConstants.ExcludedStartPathCharactersClause + RegexPathConstants.ExcludedPathCharactersClause + '*))?(?:' + RegexPathConstants.PathSeparatorClause + '(?:' + RegexPathConstants.ExcludedPathCharactersClause + ')+)+)';\n\n/**\n * A regex clause that matches the start of an absolute path on Windows, such as: `C:`, `c:` and\n * `\\\\?\\C` (UNC path).\n */\nexport const winDrivePrefix = '(?:\\\\\\\\\\\\\\\\\\\\?\\\\\\\\)?[a-zA-Z]:';\n\n/**\n * A regex that matches Windows paths, such as `\\\\?\\c:\\foo`, `c:\\foo`, `~\\foo`, `.\\foo`, `..\\foo`\n * and `foo\\bar`.\n */\nconst winLocalLinkClause = '(?:(?:' + `(?:${winDrivePrefix}|${RegexPathConstants.WinOtherPathPrefix})` + '|(?:' + RegexPathConstants.WinExcludedStartPathCharactersClause + RegexPathConstants.WinExcludedPathCharactersClause + '*))?(?:' + RegexPathConstants.WinPathSeparatorClause + '(?:' + RegexPathConstants.WinExcludedPathCharactersClause + ')+)+)';\n\nfunction detectPathsNoSuffix(line: string, os: OperatingSystem): IParsedLink[] {\n\tconst results: IParsedLink[] = [];\n\n\tconst regex = new RegExp(os === OperatingSystem.Windows ? winLocalLinkClause : unixLocalLinkClause, 'g');\n\tlet match;\n\twhile ((match = regex.exec(line)) !== null) {\n\t\tlet text = match[0];\n\t\tlet index = match.index;\n\t\tif (!text) {\n\t\t\t// Something matched but does not comply with the given match index, since this would\n\t\t\t// most likely a bug the regex itself we simply do nothing here\n\t\t\tbreak;\n\t\t}\n\n\t\t// Adjust the link range to exclude a/ and b/ if it looks like a git diff\n\t\tif (\n\t\t\t// --- a/foo/bar\n\t\t\t// +++ b/foo/bar\n\t\t\t((line.startsWith('--- a/') || line.startsWith('+++ b/')) && index === 4) ||\n\t\t\t// diff --git a/foo/bar b/foo/bar\n\t\t\t(line.startsWith('diff --git') && (text.startsWith('a/') || text.startsWith('b/')))\n\t\t) {\n\t\t\ttext = text.substring(2);\n\t\t\tindex += 2;\n\t\t}\n\n\t\tresults.push({\n\t\t\tpath: {\n\t\t\t\tindex,\n\t\t\t\ttext\n\t\t\t},\n\t\t\tprefix: undefined,\n\t\t\tsuffix: undefined\n\t\t});\n\t}\n\n\treturn results;\n}\n"]}