{"version":3,"sources":["file:///workspace/appflow/src/vs/workbench/contrib/files/browser/files.ts"],"names":[],"mappings":"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","file":"files.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI } from 'vs/base/common/uri';\nimport { IListService } from 'vs/platform/list/browser/listService';\nimport { OpenEditor, ISortOrderConfiguration } from 'vs/workbench/contrib/files/common/files';\nimport { EditorResourceAccessor, SideBySideEditor, IEditorIdentifier } from 'vs/workbench/common/editor';\nimport { List } from 'vs/base/browser/ui/list/listWidget';\nimport { IEditorService } from 'vs/workbench/services/editor/common/editorService';\nimport { ExplorerItem } from 'vs/workbench/contrib/files/common/explorerModel';\nimport { coalesce } from 'vs/base/common/arrays';\nimport { AsyncDataTree } from 'vs/base/browser/ui/tree/asyncDataTree';\nimport { IEditorGroupsService } from 'vs/workbench/services/editor/common/editorGroupsService';\nimport { IEditableData } from 'vs/workbench/common/views';\nimport { createDecorator } from 'vs/platform/instantiation/common/instantiation';\nimport { ResourceFileEdit } from 'vs/editor/browser/services/bulkEditService';\nimport { ProgressLocation } from 'vs/platform/progress/common/progress';\n\nexport interface IExplorerService {\n\treadonly _serviceBrand: undefined;\n\treadonly roots: ExplorerItem[];\n\treadonly sortOrderConfiguration: ISortOrderConfiguration;\n\n\tgetContext(respectMultiSelection: boolean, ignoreNestedChildren?: boolean): ExplorerItem[];\n\thasViewFocus(): boolean;\n\tsetEditable(stat: ExplorerItem, data: IEditableData | null): Promise<void>;\n\tgetEditable(): { stat: ExplorerItem; data: IEditableData } | undefined;\n\tgetEditableData(stat: ExplorerItem): IEditableData | undefined;\n\t// If undefined is passed checks if any element is currently being edited.\n\tisEditable(stat: ExplorerItem | undefined): boolean;\n\tfindClosest(resource: URI): ExplorerItem | null;\n\tfindClosestRoot(resource: URI): ExplorerItem | null;\n\trefresh(): Promise<void>;\n\tsetToCopy(stats: ExplorerItem[], cut: boolean): Promise<void>;\n\tisCut(stat: ExplorerItem): boolean;\n\tapplyBulkEdit(edit: ResourceFileEdit[], options: { undoLabel: string; progressLabel: string; confirmBeforeUndo?: boolean; progressLocation?: ProgressLocation.Explorer | ProgressLocation.Window }): Promise<void>;\n\n\t/**\n\t * Selects and reveal the file element provided by the given resource if its found in the explorer.\n\t * Will try to resolve the path in case the explorer is not yet expanded to the file yet.\n\t */\n\tselect(resource: URI, reveal?: boolean | string): Promise<void>;\n\n\tregisterView(contextAndRefreshProvider: IExplorerView): void;\n}\n\nexport const IExplorerService = createDecorator<IExplorerService>('explorerService');\n\nexport interface IExplorerView {\n\tgetContext(respectMultiSelection: boolean): ExplorerItem[];\n\trefresh(recursive: boolean, item?: ExplorerItem): Promise<void>;\n\tselectResource(resource: URI | undefined, reveal?: boolean | string): Promise<void>;\n\tsetTreeInput(): Promise<void>;\n\titemsCopied(tats: ExplorerItem[], cut: boolean, previousCut: ExplorerItem[] | undefined): void;\n\tsetEditable(stat: ExplorerItem, isEditing: boolean): Promise<void>;\n\tisItemVisible(item: ExplorerItem): boolean;\n\tisItemCollapsed(item: ExplorerItem): boolean;\n\thasFocus(): boolean;\n}\n\nfunction getFocus(listService: IListService): unknown | undefined {\n\tconst list = listService.lastFocusedList;\n\tif (list?.getHTMLElement() === document.activeElement) {\n\t\tlet focus: unknown;\n\t\tif (list instanceof List) {\n\t\t\tconst focused = list.getFocusedElements();\n\t\t\tif (focused.length) {\n\t\t\t\tfocus = focused[0];\n\t\t\t}\n\t\t} else if (list instanceof AsyncDataTree) {\n\t\t\tconst focused = list.getFocus();\n\t\t\tif (focused.length) {\n\t\t\t\tfocus = focused[0];\n\t\t\t}\n\t\t}\n\n\t\treturn focus;\n\t}\n\n\treturn undefined;\n}\n\n// Commands can get executed from a command palette, from a context menu or from some list using a keybinding\n// To cover all these cases we need to properly compute the resource on which the command is being executed\nexport function getResourceForCommand(resource: URI | object | undefined, listService: IListService, editorService: IEditorService): URI | undefined {\n\tif (URI.isUri(resource)) {\n\t\treturn resource;\n\t}\n\n\tconst focus = getFocus(listService);\n\tif (focus instanceof ExplorerItem) {\n\t\treturn focus.resource;\n\t} else if (focus instanceof OpenEditor) {\n\t\treturn focus.getResource();\n\t}\n\n\treturn EditorResourceAccessor.getOriginalUri(editorService.activeEditor, { supportSideBySide: SideBySideEditor.PRIMARY });\n}\n\nexport function getMultiSelectedResources(resource: URI | object | undefined, listService: IListService, editorService: IEditorService, explorerService: IExplorerService): Array<URI> {\n\tconst list = listService.lastFocusedList;\n\tif (list?.getHTMLElement() === document.activeElement) {\n\t\t// Explorer\n\t\tif (list instanceof AsyncDataTree && list.getFocus().every(item => item instanceof ExplorerItem)) {\n\t\t\t// Explorer\n\t\t\tconst context = explorerService.getContext(true, true);\n\t\t\tif (context.length) {\n\t\t\t\treturn context.map(c => c.resource);\n\t\t\t}\n\t\t}\n\n\t\t// Open editors view\n\t\tif (list instanceof List) {\n\t\t\tconst selection = coalesce(list.getSelectedElements().filter(s => s instanceof OpenEditor).map((oe: OpenEditor) => oe.getResource()));\n\t\t\tconst focusedElements = list.getFocusedElements();\n\t\t\tconst focus = focusedElements.length ? focusedElements[0] : undefined;\n\t\t\tlet mainUriStr: string | undefined = undefined;\n\t\t\tif (URI.isUri(resource)) {\n\t\t\t\tmainUriStr = resource.toString();\n\t\t\t} else if (focus instanceof OpenEditor) {\n\t\t\t\tconst focusedResource = focus.getResource();\n\t\t\t\tmainUriStr = focusedResource ? focusedResource.toString() : undefined;\n\t\t\t}\n\t\t\t// We only respect the selection if it contains the main element.\n\t\t\tif (selection.some(s => s.toString() === mainUriStr)) {\n\t\t\t\treturn selection;\n\t\t\t}\n\t\t}\n\t}\n\n\tconst result = getResourceForCommand(resource, listService, editorService);\n\treturn !!result ? [result] : [];\n}\n\nexport function getOpenEditorsViewMultiSelection(listService: IListService, editorGroupService: IEditorGroupsService): Array<IEditorIdentifier> | undefined {\n\tconst list = listService.lastFocusedList;\n\tif (list?.getHTMLElement() === document.activeElement) {\n\t\t// Open editors view\n\t\tif (list instanceof List) {\n\t\t\tconst selection = coalesce(list.getSelectedElements().filter(s => s instanceof OpenEditor));\n\t\t\tconst focusedElements = list.getFocusedElements();\n\t\t\tconst focus = focusedElements.length ? focusedElements[0] : undefined;\n\t\t\tlet mainEditor: IEditorIdentifier | undefined = undefined;\n\t\t\tif (focus instanceof OpenEditor) {\n\t\t\t\tmainEditor = focus;\n\t\t\t}\n\t\t\t// We only respect the selection if it contains the main element.\n\t\t\tif (selection.some(s => s === mainEditor)) {\n\t\t\t\treturn selection;\n\t\t\t}\n\t\t\treturn mainEditor ? [mainEditor] : undefined;\n\t\t}\n\t}\n\n\treturn undefined;\n}\n"]}