{"version":3,"sources":["file:///workspace/appflow/src/vs/workbench/services/remote/common/remoteAgentService.ts"],"names":[],"mappings":"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","file":"remoteAgentService.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { createDecorator } from 'vs/platform/instantiation/common/instantiation';\nimport { RemoteAgentConnectionContext, IRemoteAgentEnvironment } from 'vs/platform/remote/common/remoteAgentEnvironment';\nimport { IChannel, IServerChannel } from 'vs/base/parts/ipc/common/ipc';\nimport { IDiagnosticInfoOptions, IDiagnosticInfo } from 'vs/platform/diagnostics/common/diagnostics';\nimport { Event } from 'vs/base/common/event';\nimport { PersistentConnectionEvent } from 'vs/platform/remote/common/remoteAgentConnection';\nimport { ITelemetryData, TelemetryLevel } from 'vs/platform/telemetry/common/telemetry';\nimport { timeout } from 'vs/base/common/async';\n\nexport const IRemoteAgentService = createDecorator<IRemoteAgentService>('remoteAgentService');\n\nexport interface IRemoteAgentService {\n\treadonly _serviceBrand: undefined;\n\n\tgetConnection(): IRemoteAgentConnection | null;\n\t/**\n\t * Get the remote environment. In case of an error, returns `null`.\n\t */\n\tgetEnvironment(): Promise<IRemoteAgentEnvironment | null>;\n\t/**\n\t * Get the remote environment. Can return an error.\n\t */\n\tgetRawEnvironment(): Promise<IRemoteAgentEnvironment | null>;\n\t/**\n\t * Get exit information for a remote extension host.\n\t */\n\tgetExtensionHostExitInfo(reconnectionToken: string): Promise<IExtensionHostExitInfo | null>;\n\n\t/**\n\t * Gets the round trip time from the remote extension host. Note that this\n\t * may be delayed if the extension host is busy.\n\t */\n\tgetRoundTripTime(): Promise<number | undefined>;\n\n\tgetDiagnosticInfo(options: IDiagnosticInfoOptions): Promise<IDiagnosticInfo | undefined>;\n\tupdateTelemetryLevel(telemetryLevel: TelemetryLevel): Promise<void>;\n\tlogTelemetry(eventName: string, data?: ITelemetryData): Promise<void>;\n\tflushTelemetry(): Promise<void>;\n}\n\nexport interface IExtensionHostExitInfo {\n\tcode: number;\n\tsignal: string;\n}\n\nexport interface IRemoteAgentConnection {\n\treadonly remoteAuthority: string;\n\n\treadonly onReconnecting: Event<void>;\n\treadonly onDidStateChange: Event<PersistentConnectionEvent>;\n\n\tdispose(): void;\n\tgetChannel<T extends IChannel>(channelName: string): T;\n\twithChannel<T extends IChannel, R>(channelName: string, callback: (channel: T) => Promise<R>): Promise<R>;\n\tregisterChannel<T extends IServerChannel<RemoteAgentConnectionContext>>(channelName: string, channel: T): void;\n\tgetInitialConnectionTimeMs(): Promise<number>;\n}\n\nexport interface IRemoteConnectionLatencyMeasurement {\n\n\treadonly initial: number | undefined;\n\treadonly current: number;\n\treadonly average: number;\n\n\treadonly high: boolean;\n}\n\nexport const remoteConnectionLatencyMeasurer = new class {\n\n\treadonly maxSampleCount = 5;\n\treadonly sampleDelay = 2000;\n\n\treadonly initial: number[] = [];\n\treadonly maxInitialCount = 3;\n\n\treadonly average: number[] = [];\n\treadonly maxAverageCount = 100;\n\n\treadonly highLatencyMultiple = 2;\n\treadonly highLatencyMinThreshold = 500;\n\treadonly highLatencyMaxThreshold = 1500;\n\n\tlastMeasurement: IRemoteConnectionLatencyMeasurement | undefined = undefined;\n\tget latency() { return this.lastMeasurement; }\n\n\tasync measure(remoteAgentService: IRemoteAgentService): Promise<IRemoteConnectionLatencyMeasurement | undefined> {\n\t\tlet currentLatency = Infinity;\n\n\t\t// Measure up to samples count\n\t\tfor (let i = 0; i < this.maxSampleCount; i++) {\n\t\t\tconst rtt = await remoteAgentService.getRoundTripTime();\n\t\t\tif (rtt === undefined) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tcurrentLatency = Math.min(currentLatency, rtt / 2 /* we want just one way, not round trip time */);\n\t\t\tawait timeout(this.sampleDelay);\n\t\t}\n\n\t\t// Keep track of average latency\n\t\tthis.average.push(currentLatency);\n\t\tif (this.average.length > this.maxAverageCount) {\n\t\t\tthis.average.shift();\n\t\t}\n\n\t\t// Keep track of initial latency\n\t\tlet initialLatency: number | undefined = undefined;\n\t\tif (this.initial.length < this.maxInitialCount) {\n\t\t\tthis.initial.push(currentLatency);\n\t\t} else {\n\t\t\tinitialLatency = this.initial.reduce((sum, value) => sum + value, 0) / this.initial.length;\n\t\t}\n\n\t\t// Remember as last measurement\n\t\tthis.lastMeasurement = {\n\t\t\tinitial: initialLatency,\n\t\t\tcurrent: currentLatency,\n\t\t\taverage: this.average.reduce((sum, value) => sum + value, 0) / this.average.length,\n\t\t\thigh: (() => {\n\n\t\t\t\t// based on the initial, average and current latency, try to decide\n\t\t\t\t// if the connection has high latency\n\t\t\t\t// Some rules:\n\t\t\t\t// - we require the initial latency to be computed\n\t\t\t\t// - we only consider latency above highLatencyMinThreshold as potentially high\n\t\t\t\t// - we require the current latency to be above the average latency by a factor of highLatencyMultiple\n\t\t\t\t// - but not if the latency is actually above highLatencyMaxThreshold\n\n\t\t\t\tif (typeof initialLatency === 'undefined') {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tif (currentLatency > this.highLatencyMaxThreshold) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tif (currentLatency > this.highLatencyMinThreshold && currentLatency > initialLatency * this.highLatencyMultiple) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\t\t\t})()\n\t\t};\n\n\t\treturn this.lastMeasurement;\n\t}\n};\n"]}