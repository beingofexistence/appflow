{"version":3,"sources":["file:///workspace/appflow/src/vs/workbench/services/remote/common/remoteExplorerService.ts"],"names":[],"mappings":"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","file":"remoteExplorerService.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event, Emitter } from 'vs/base/common/event';\nimport { IInstantiationService, createDecorator } from 'vs/platform/instantiation/common/instantiation';\nimport { InstantiationType, registerSingleton } from 'vs/platform/instantiation/common/extensions';\nimport { IStorageService, StorageScope, StorageTarget } from 'vs/platform/storage/common/storage';\nimport { ITunnelService, RemoteTunnel, TunnelProtocol } from 'vs/platform/tunnel/common/tunnel';\nimport { IDisposable } from 'vs/base/common/lifecycle';\nimport { IEditableData } from 'vs/workbench/common/views';\nimport { TunnelInformation, TunnelPrivacy } from 'vs/platform/remote/common/remoteAuthorityResolver';\nimport { URI } from 'vs/base/common/uri';\nimport { Attributes, CandidatePort, TunnelCloseReason, TunnelModel, TunnelProperties, TunnelSource } from 'vs/workbench/services/remote/common/tunnelModel';\n\nexport const IRemoteExplorerService = createDecorator<IRemoteExplorerService>('remoteExplorerService');\nexport const REMOTE_EXPLORER_TYPE_KEY: string = 'remote.explorerType';\nexport const TUNNEL_VIEW_ID = '~remote.forwardedPorts';\nexport const TUNNEL_VIEW_CONTAINER_ID = '~remote.forwardedPortsContainer';\nexport const PORT_AUTO_FORWARD_SETTING = 'remote.autoForwardPorts';\nexport const PORT_AUTO_SOURCE_SETTING = 'remote.autoForwardPortsSource';\nexport const PORT_AUTO_SOURCE_SETTING_PROCESS = 'process';\nexport const PORT_AUTO_SOURCE_SETTING_OUTPUT = 'output';\nexport const PORT_AUTO_SOURCE_SETTING_HYBRID = 'hybrid';\n\nexport enum TunnelType {\n\tCandidate = 'Candidate',\n\tDetected = 'Detected',\n\tForwarded = 'Forwarded',\n\tAdd = 'Add'\n}\n\nexport interface ITunnelItem {\n\ttunnelType: TunnelType;\n\tremoteHost: string;\n\tremotePort: number;\n\tlocalAddress?: string;\n\tprotocol: TunnelProtocol;\n\tlocalUri?: URI;\n\tlocalPort?: number;\n\tname?: string;\n\tcloseable?: boolean;\n\tsource: {\n\t\tsource: TunnelSource;\n\t\tdescription: string;\n\t};\n\tprivacy: TunnelPrivacy;\n\tprocessDescription?: string;\n\treadonly label: string;\n}\n\nexport enum TunnelEditId {\n\tNone = 0,\n\tNew = 1,\n\tLabel = 2,\n\tLocalPort = 3\n}\n\nexport interface IRemoteExplorerService {\n\treadonly _serviceBrand: undefined;\n\tonDidChangeTargetType: Event<string[]>;\n\ttargetType: string[];\n\treadonly tunnelModel: TunnelModel;\n\tonDidChangeEditable: Event<{ tunnel: ITunnelItem; editId: TunnelEditId } | undefined>;\n\tsetEditable(tunnelItem: ITunnelItem | undefined, editId: TunnelEditId, data: IEditableData | null): void;\n\tgetEditableData(tunnelItem: ITunnelItem | undefined, editId?: TunnelEditId): IEditableData | undefined;\n\tforward(tunnelProperties: TunnelProperties, attributes?: Attributes | null): Promise<RemoteTunnel | string | undefined>;\n\tclose(remote: { host: string; port: number }, reason: TunnelCloseReason): Promise<void>;\n\tsetTunnelInformation(tunnelInformation: TunnelInformation | undefined): void;\n\tsetCandidateFilter(filter: ((candidates: CandidatePort[]) => Promise<CandidatePort[]>) | undefined): IDisposable;\n\tonFoundNewCandidates(candidates: CandidatePort[]): void;\n\trestore(): Promise<void>;\n\tenablePortsFeatures(): void;\n\tonEnabledPortsFeatures: Event<void>;\n\tportsFeaturesEnabled: boolean;\n\treadonly namedProcesses: Map<number, string>;\n}\n\nclass RemoteExplorerService implements IRemoteExplorerService {\n\tpublic _serviceBrand: undefined;\n\tprivate _targetType: string[] = [];\n\tprivate readonly _onDidChangeTargetType: Emitter<string[]> = new Emitter<string[]>();\n\tpublic readonly onDidChangeTargetType: Event<string[]> = this._onDidChangeTargetType.event;\n\tprivate _tunnelModel: TunnelModel;\n\tprivate _editable: { tunnelItem: ITunnelItem | undefined; editId: TunnelEditId; data: IEditableData } | undefined;\n\tprivate readonly _onDidChangeEditable: Emitter<{ tunnel: ITunnelItem; editId: TunnelEditId } | undefined> = new Emitter();\n\tpublic readonly onDidChangeEditable: Event<{ tunnel: ITunnelItem; editId: TunnelEditId } | undefined> = this._onDidChangeEditable.event;\n\tprivate readonly _onEnabledPortsFeatures: Emitter<void> = new Emitter();\n\tpublic readonly onEnabledPortsFeatures: Event<void> = this._onEnabledPortsFeatures.event;\n\tprivate _portsFeaturesEnabled: boolean = false;\n\tpublic readonly namedProcesses = new Map<number, string>();\n\n\tconstructor(\n\t\t@IStorageService private readonly storageService: IStorageService,\n\t\t@ITunnelService private readonly tunnelService: ITunnelService,\n\t\t@IInstantiationService instantiationService: IInstantiationService,\n\t) {\n\t\tthis._tunnelModel = instantiationService.createInstance(TunnelModel);\n\t}\n\n\tset targetType(name: string[]) {\n\t\t// Can just compare the first element of the array since there are no target overlaps\n\t\tconst current: string = this._targetType.length > 0 ? this._targetType[0] : '';\n\t\tconst newName: string = name.length > 0 ? name[0] : '';\n\t\tif (current !== newName) {\n\t\t\tthis._targetType = name;\n\t\t\tthis.storageService.store(REMOTE_EXPLORER_TYPE_KEY, this._targetType.toString(), StorageScope.WORKSPACE, StorageTarget.MACHINE);\n\t\t\tthis.storageService.store(REMOTE_EXPLORER_TYPE_KEY, this._targetType.toString(), StorageScope.PROFILE, StorageTarget.USER);\n\t\t\tthis._onDidChangeTargetType.fire(this._targetType);\n\t\t}\n\t}\n\tget targetType(): string[] {\n\t\treturn this._targetType;\n\t}\n\n\tget tunnelModel(): TunnelModel {\n\t\treturn this._tunnelModel;\n\t}\n\n\tforward(tunnelProperties: TunnelProperties, attributes?: Attributes | null): Promise<RemoteTunnel | string | undefined> {\n\t\treturn this.tunnelModel.forward(tunnelProperties, attributes);\n\t}\n\n\tclose(remote: { host: string; port: number }, reason: TunnelCloseReason): Promise<void> {\n\t\treturn this.tunnelModel.close(remote.host, remote.port, reason);\n\t}\n\n\tsetTunnelInformation(tunnelInformation: TunnelInformation | undefined): void {\n\t\tif (tunnelInformation?.features) {\n\t\t\tthis.tunnelService.setTunnelFeatures(tunnelInformation.features);\n\t\t}\n\t\tthis.tunnelModel.addEnvironmentTunnels(tunnelInformation?.environmentTunnels);\n\t}\n\n\tsetEditable(tunnelItem: ITunnelItem | undefined, editId: TunnelEditId, data: IEditableData | null): void {\n\t\tif (!data) {\n\t\t\tthis._editable = undefined;\n\t\t} else {\n\t\t\tthis._editable = { tunnelItem, data, editId };\n\t\t}\n\t\tthis._onDidChangeEditable.fire(tunnelItem ? { tunnel: tunnelItem, editId } : undefined);\n\t}\n\n\tgetEditableData(tunnelItem: ITunnelItem | undefined, editId: TunnelEditId): IEditableData | undefined {\n\t\treturn (this._editable &&\n\t\t\t((!tunnelItem && (tunnelItem === this._editable.tunnelItem)) ||\n\t\t\t\t(tunnelItem && (this._editable.tunnelItem?.remotePort === tunnelItem.remotePort) && (this._editable.tunnelItem.remoteHost === tunnelItem.remoteHost)\n\t\t\t\t\t&& (this._editable.editId === editId)))) ?\n\t\t\tthis._editable.data : undefined;\n\t}\n\n\tsetCandidateFilter(filter: (candidates: CandidatePort[]) => Promise<CandidatePort[]>): IDisposable {\n\t\tif (!filter) {\n\t\t\treturn {\n\t\t\t\tdispose: () => { }\n\t\t\t};\n\t\t}\n\t\tthis.tunnelModel.setCandidateFilter(filter);\n\t\treturn {\n\t\t\tdispose: () => {\n\t\t\t\tthis.tunnelModel.setCandidateFilter(undefined);\n\t\t\t}\n\t\t};\n\t}\n\n\tonFoundNewCandidates(candidates: CandidatePort[]): void {\n\t\tthis.tunnelModel.setCandidates(candidates);\n\t}\n\n\trestore(): Promise<void> {\n\t\treturn this.tunnelModel.restoreForwarded();\n\t}\n\n\tenablePortsFeatures(): void {\n\t\tthis._portsFeaturesEnabled = true;\n\t\tthis._onEnabledPortsFeatures.fire();\n\t}\n\n\tget portsFeaturesEnabled(): boolean {\n\t\treturn this._portsFeaturesEnabled;\n\t}\n}\n\nregisterSingleton(IRemoteExplorerService, RemoteExplorerService, InstantiationType.Delayed);\n"]}