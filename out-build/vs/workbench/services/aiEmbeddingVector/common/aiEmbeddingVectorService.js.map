{"version":3,"sources":["file:///workspace/appflow/src/vs/workbench/services/aiEmbeddingVector/common/aiEmbeddingVectorService.ts"],"names":[],"mappings":"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","file":"aiEmbeddingVectorService.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { createDecorator } from 'vs/platform/instantiation/common/instantiation';\nimport { CancellationToken } from 'vs/base/common/cancellation';\nimport { CancelablePromise, createCancelablePromise, raceCancellablePromises, timeout } from 'vs/base/common/async';\nimport { IDisposable } from 'vs/base/common/lifecycle';\nimport { InstantiationType, registerSingleton } from 'vs/platform/instantiation/common/extensions';\nimport { StopWatch } from 'vs/base/common/stopwatch';\nimport { ILogService } from 'vs/platform/log/common/log';\n\nexport const IAiEmbeddingVectorService = createDecorator<IAiEmbeddingVectorService>('IAiEmbeddingVectorService');\n\nexport interface IAiEmbeddingVectorService {\n\treadonly _serviceBrand: undefined;\n\n\tisEnabled(): boolean;\n\tgetEmbeddingVector(str: string, token: CancellationToken): Promise<number[]>;\n\tgetEmbeddingVector(strings: string[], token: CancellationToken): Promise<number[][]>;\n\tregisterAiEmbeddingVectorProvider(model: string, provider: IAiEmbeddingVectorProvider): IDisposable;\n}\n\nexport interface IAiEmbeddingVectorProvider {\n\tprovideAiEmbeddingVector(strings: string[], token: CancellationToken): Promise<number[][]>;\n}\n\nexport class AiEmbeddingVectorService implements IAiEmbeddingVectorService {\n\treadonly _serviceBrand: undefined;\n\n\tstatic readonly DEFAULT_TIMEOUT = 1000 * 10; // 10 seconds\n\n\tprivate readonly _providers: IAiEmbeddingVectorProvider[] = [];\n\n\tconstructor(@ILogService private readonly logService: ILogService) { }\n\n\tisEnabled(): boolean {\n\t\treturn this._providers.length > 0;\n\t}\n\n\tregisterAiEmbeddingVectorProvider(model: string, provider: IAiEmbeddingVectorProvider): IDisposable {\n\t\tthis._providers.push(provider);\n\t\treturn {\n\t\t\tdispose: () => {\n\t\t\t\tconst index = this._providers.indexOf(provider);\n\t\t\t\tif (index >= 0) {\n\t\t\t\t\tthis._providers.splice(index, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\tgetEmbeddingVector(str: string, token: CancellationToken): Promise<number[]>;\n\tgetEmbeddingVector(strings: string[], token: CancellationToken): Promise<number[][]>;\n\tasync getEmbeddingVector(strings: string | string[], token: CancellationToken): Promise<number[] | number[][]> {\n\t\tif (this._providers.length === 0) {\n\t\t\tthrow new Error('No embedding vector providers registered');\n\t\t}\n\n\t\tconst stopwatch = StopWatch.create();\n\n\t\tconst cancellablePromises: Array<CancelablePromise<number[][]>> = [];\n\n\t\tconst timer = timeout(AiEmbeddingVectorService.DEFAULT_TIMEOUT);\n\t\tconst disposable = token.onCancellationRequested(() => {\n\t\t\tdisposable.dispose();\n\t\t\ttimer.cancel();\n\t\t});\n\n\t\tfor (const provider of this._providers) {\n\t\t\tcancellablePromises.push(createCancelablePromise(async t => {\n\t\t\t\ttry {\n\t\t\t\t\treturn await provider.provideAiEmbeddingVector(\n\t\t\t\t\t\tArray.isArray(strings) ? strings : [strings],\n\t\t\t\t\t\tt\n\t\t\t\t\t);\n\t\t\t\t} catch (e) {\n\t\t\t\t\t// logged in extension host\n\t\t\t\t}\n\t\t\t\t// Wait for the timer to finish to allow for another provider to resolve.\n\t\t\t\t// Alternatively, if something resolved, or we've timed out, this will throw\n\t\t\t\t// as expected.\n\t\t\t\tawait timer;\n\t\t\t\tthrow new Error('Embedding vector provider timed out');\n\t\t\t}));\n\t\t}\n\n\t\tcancellablePromises.push(createCancelablePromise(async (t) => {\n\t\t\tconst disposable = t.onCancellationRequested(() => {\n\t\t\t\ttimer.cancel();\n\t\t\t\tdisposable.dispose();\n\t\t\t});\n\t\t\tawait timer;\n\t\t\tthrow new Error('Embedding vector provider timed out');\n\t\t}));\n\n\t\ttry {\n\t\t\tconst result = await raceCancellablePromises(cancellablePromises);\n\n\t\t\t// If we have a single result, return it directly, otherwise return an array.\n\t\t\t// This aligns with the API overloads.\n\t\t\tif (result.length === 1) {\n\t\t\t\treturn result[0];\n\t\t\t}\n\t\t\treturn result;\n\t\t} finally {\n\t\t\tstopwatch.stop();\n\t\t\tthis.logService.trace(`[AiEmbeddingVectorService]: getEmbeddingVector took ${stopwatch.elapsed()}ms`);\n\t\t}\n\t}\n}\n\nregisterSingleton(IAiEmbeddingVectorService, AiEmbeddingVectorService, InstantiationType.Delayed);\n"]}