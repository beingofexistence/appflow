{"version":3,"sources":["file:///workspace/appflow/src/vs/workbench/services/workspaces/common/workspaceIdentityService.ts"],"names":[],"mappings":"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","file":"workspaceIdentityService.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { VSBuffer } from 'vs/base/common/buffer';\nimport { CancellationToken } from 'vs/base/common/cancellation';\nimport { isEqualOrParent, joinPath, relativePath } from 'vs/base/common/resources';\nimport { URI } from 'vs/base/common/uri';\nimport { InstantiationType, registerSingleton } from 'vs/platform/instantiation/common/extensions';\nimport { createDecorator } from 'vs/platform/instantiation/common/instantiation';\nimport { IWorkspaceStateFolder } from 'vs/platform/userDataSync/common/userDataSync';\nimport { EditSessionIdentityMatch, IEditSessionIdentityService } from 'vs/platform/workspace/common/editSessions';\nimport { IWorkspaceContextService, IWorkspaceFolder } from 'vs/platform/workspace/common/workspace';\n\nexport const IWorkspaceIdentityService = createDecorator<IWorkspaceIdentityService>('IWorkspaceIdentityService');\nexport interface IWorkspaceIdentityService {\n\t_serviceBrand: undefined;\n\tmatches(folders: IWorkspaceStateFolder[], cancellationToken: CancellationToken): Promise<((obj: any) => any) | false>;\n\tgetWorkspaceStateFolders(cancellationToken: CancellationToken): Promise<IWorkspaceStateFolder[]>;\n}\n\nexport class WorkspaceIdentityService implements IWorkspaceIdentityService {\n\tdeclare _serviceBrand: undefined;\n\n\tconstructor(\n\t\t@IWorkspaceContextService private readonly workspaceContextService: IWorkspaceContextService,\n\t\t@IEditSessionIdentityService private readonly editSessionIdentityService: IEditSessionIdentityService\n\t) { }\n\n\tasync getWorkspaceStateFolders(cancellationToken: CancellationToken): Promise<IWorkspaceStateFolder[]> {\n\t\tconst workspaceStateFolders: IWorkspaceStateFolder[] = [];\n\n\t\tfor (const workspaceFolder of this.workspaceContextService.getWorkspace().folders) {\n\t\t\tconst workspaceFolderIdentity = await this.editSessionIdentityService.getEditSessionIdentifier(workspaceFolder, cancellationToken);\n\t\t\tif (!workspaceFolderIdentity) { continue; }\n\t\t\tworkspaceStateFolders.push({ resourceUri: workspaceFolder.uri.toString(), workspaceFolderIdentity });\n\t\t}\n\n\t\treturn workspaceStateFolders;\n\t}\n\n\tasync matches(incomingWorkspaceFolders: IWorkspaceStateFolder[], cancellationToken: CancellationToken): Promise<((value: any) => any) | false> {\n\t\tconst incomingToCurrentWorkspaceFolderUris: { [key: string]: string } = {};\n\n\t\tconst incomingIdentitiesToIncomingWorkspaceFolders: { [key: string]: string } = {};\n\t\tfor (const workspaceFolder of incomingWorkspaceFolders) {\n\t\t\tincomingIdentitiesToIncomingWorkspaceFolders[workspaceFolder.workspaceFolderIdentity] = workspaceFolder.resourceUri;\n\t\t}\n\n\t\t// Precompute the identities of the current workspace folders\n\t\tconst currentWorkspaceFoldersToIdentities = new Map<IWorkspaceFolder, string>();\n\t\tfor (const workspaceFolder of this.workspaceContextService.getWorkspace().folders) {\n\t\t\tconst workspaceFolderIdentity = await this.editSessionIdentityService.getEditSessionIdentifier(workspaceFolder, cancellationToken);\n\t\t\tif (!workspaceFolderIdentity) { continue; }\n\t\t\tcurrentWorkspaceFoldersToIdentities.set(workspaceFolder, workspaceFolderIdentity);\n\t\t}\n\n\t\t// Match the current workspace folders to the incoming workspace folders\n\t\tfor (const [currentWorkspaceFolder, currentWorkspaceFolderIdentity] of currentWorkspaceFoldersToIdentities.entries()) {\n\n\t\t\t// Happy case: identities do not need further disambiguation\n\t\t\tconst incomingWorkspaceFolder = incomingIdentitiesToIncomingWorkspaceFolders[currentWorkspaceFolderIdentity];\n\t\t\tif (incomingWorkspaceFolder) {\n\t\t\t\t// There is an incoming workspace folder with the exact same identity as the current workspace folder\n\t\t\t\tincomingToCurrentWorkspaceFolderUris[incomingWorkspaceFolder] = currentWorkspaceFolder.uri.toString();\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Unhappy case: compare the identity of the current workspace folder to all incoming workspace folder identities\n\t\t\tlet hasCompleteMatch = false;\n\t\t\tfor (const [incomingIdentity, incomingFolder] of Object.entries(incomingIdentitiesToIncomingWorkspaceFolders)) {\n\t\t\t\tif (await this.editSessionIdentityService.provideEditSessionIdentityMatch(currentWorkspaceFolder, currentWorkspaceFolderIdentity, incomingIdentity, cancellationToken) === EditSessionIdentityMatch.Complete) {\n\t\t\t\t\tincomingToCurrentWorkspaceFolderUris[incomingFolder] = currentWorkspaceFolder.uri.toString();\n\t\t\t\t\thasCompleteMatch = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (hasCompleteMatch) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\n\t\tconst convertUri = (uriToConvert: URI) => {\n\t\t\t// Figure out which current folder the incoming URI is a child of\n\t\t\tfor (const incomingFolderUriKey of Object.keys(incomingToCurrentWorkspaceFolderUris)) {\n\t\t\t\tconst incomingFolderUri = URI.parse(incomingFolderUriKey);\n\t\t\t\tif (isEqualOrParent(incomingFolderUri, uriToConvert)) {\n\t\t\t\t\tconst currentWorkspaceFolderUri = incomingToCurrentWorkspaceFolderUris[incomingFolderUriKey];\n\n\t\t\t\t\t// Compute the relative file path section of the uri to convert relative to the folder it came from\n\t\t\t\t\tconst relativeFilePath = relativePath(incomingFolderUri, uriToConvert);\n\n\t\t\t\t\t// Reparent the relative file path under the current workspace folder it belongs to\n\t\t\t\t\tif (relativeFilePath) {\n\t\t\t\t\t\treturn joinPath(URI.parse(currentWorkspaceFolderUri), relativeFilePath);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// No conversion was possible; return the original URI\n\t\t\treturn uriToConvert;\n\t\t};\n\n\t\t// Recursively look for any URIs in the provided object and\n\t\t// replace them with the URIs of the current workspace folders\n\t\tconst uriReplacer = (obj: any, depth = 0) => {\n\t\t\tif (!obj || depth > 200) {\n\t\t\t\treturn obj;\n\t\t\t}\n\n\t\t\tif (obj instanceof VSBuffer || obj instanceof Uint8Array) {\n\t\t\t\treturn <any>obj;\n\t\t\t}\n\n\t\t\tif (URI.isUri(obj)) {\n\t\t\t\treturn convertUri(obj);\n\t\t\t}\n\n\t\t\tif (Array.isArray(obj)) {\n\t\t\t\tfor (let i = 0; i < obj.length; ++i) {\n\t\t\t\t\tobj[i] = uriReplacer(obj[i], depth + 1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// walk object\n\t\t\t\tfor (const key in obj) {\n\t\t\t\t\tif (Object.hasOwnProperty.call(obj, key)) {\n\t\t\t\t\t\tobj[key] = uriReplacer(obj[key], depth + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn obj;\n\t\t};\n\n\t\treturn uriReplacer;\n\t}\n}\n\nregisterSingleton(IWorkspaceIdentityService, WorkspaceIdentityService, InstantiationType.Delayed);\n"]}