{"version":3,"sources":["file:///workspace/appflow/src/vs/workbench/services/editor/common/editorGroupsService.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;IAcnF,QAAA,GAAG,GAAoB,IAAA,mBAAG,EAAmC,qBAAqB,CAAC,CAAC;IAEjG,IAAkB,cAKjB;IALD,WAAkB,cAAc;QAC/B,+CAAE,CAAA;QACF,mDAAI,CAAA;QACJ,mDAAI,CAAA;QACJ,qDAAK,CAAA;IACN,CAAC,EALiB,cAAc,8BAAd,cAAc,QAK/B;IAED,IAAkB,gBAGjB;IAHD,WAAkB,gBAAgB;QACjC,mEAAU,CAAA;QACV,+DAAQ,CAAA;IACT,CAAC,EAHiB,gBAAgB,gCAAhB,gBAAgB,QAGjC;IAED,IAAkB,aAKjB;IALD,WAAkB,aAAa;QAC9B,mDAAK,CAAA;QACL,iDAAI,CAAA;QACJ,iDAAI,CAAA;QACJ,yDAAQ,CAAA;IACT,CAAC,EALiB,aAAa,6BAAb,aAAa,QAK9B;IAOD,IAAkB,iBAkBjB;IAlBD,WAAkB,iBAAiB;QAElC;;;WAGG;QACH,iEAAQ,CAAA;QAER;;WAEG;QACH,yDAAI,CAAA;QAEJ;;;WAGG;QACH,6DAAM,CAAA;IACP,CAAC,EAlBiB,iBAAiB,iCAAjB,iBAAiB,QAkBlC;IAgCD,IAAkB,cAGjB;IAHD,WAAkB,cAAc;QAC/B,mEAAY,CAAA;QACZ,mEAAY,CAAA;IACb,CAAC,EAHiB,cAAc,8BAAd,cAAc,QAG/B;IAkCD,SAAgB,GAAG,CAAiB,WAAoB;QACvD,MAAM,SAAS,GAAG,WAA6C,CAAC;QAEhE,OAAO,IAAA,YAAG,EAAW,SAAS,EAAE,MAAM,CAAC,IAAI,IAAA,YAAG,EAAW,SAAS,EAAE,WAAW,CAAC,CAAC;IAClF,CAAC;IAJD,kBAIC;IAED,IAAkB,WAgBjB;IAhBD,WAAkB,WAAW;QAE5B;;WAEG;QACH,+DAAa,CAAA;QAEb;;WAEG;QACH,6EAAoB,CAAA;QAEpB;;WAEG;QACH,mEAAe,CAAA;IAChB,CAAC,EAhBiB,WAAW,2BAAX,WAAW,QAgB5B;IA+QD,IAAkB,iBAIjB;IAJD,WAAkB,iBAAiB;QAClC,qEAAc,CAAA;QACd,uEAAe,CAAA;QACf,uEAAe,CAAA;IAChB,CAAC,EAJiB,iBAAiB,iCAAjB,iBAAiB,QAIlC;IAgTD,SAAgB,GAAG,CAAW,GAAY;QACzC,MAAM,KAAK,GAAG,GAA+B,CAAC;QAE9C,OAAO,CAAC,CAAC,KAAK,IAAI,OAAO,KAAK,CAAC,EAAE,KAAK,QAAQ,IAAI,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC;IAChF,CAAC;IAJD,kBAIC;IAED,8BAA8B;IAE9B,SAAgB,GAAG,CAA+B,oBAAyB;QAC1E,MAAM,uBAAuB,GAAG,oBAAoB,CAAC,QAAQ,CAAC,0CAA0C,CAAC,CAAC;QAE1G,IAAI,uBAAuB,KAAK,MAAM,EAAE;YACvC,mCAA2B;SAC3B;QAED,oCAA4B;IAC7B,CAAC;IARD,kBAQC;;AAED,YAAY","file":"editorGroupsService.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event } from 'vs/base/common/event';\nimport { createDecorator } from 'vs/platform/instantiation/common/instantiation';\nimport { IEditorPane, GroupIdentifier, EditorInputWithOptions, CloseDirection, IEditorPartOptions, IEditorPartOptionsChangeEvent, EditorsOrder, IVisibleEditorPane, IEditorCloseEvent, IUntypedEditorInput, isEditorInput, IEditorWillMoveEvent, IEditorWillOpenEvent, IMatchEditorOptions, IActiveEditorChangeEvent, IFindEditorOptions } from 'vs/workbench/common/editor';\nimport { EditorInput } from 'vs/workbench/common/editor/editorInput';\nimport { IEditorOptions } from 'vs/platform/editor/common/editor';\nimport { IConfigurationService } from 'vs/platform/configuration/common/configuration';\nimport { IDimension } from 'vs/editor/common/core/dimension';\nimport { IDisposable } from 'vs/base/common/lifecycle';\nimport { IContextKeyService } from 'vs/platform/contextkey/common/contextkey';\nimport { URI } from 'vs/base/common/uri';\nimport { IGroupModelChangeEvent } from 'vs/workbench/common/editor/editorGroupModel';\n\nexport const IEditorGroupsService = createDecorator<IEditorGroupsService>('editorGroupsService');\n\nexport const enum GroupDirection {\n\tUP,\n\tDOWN,\n\tLEFT,\n\tRIGHT\n}\n\nexport const enum GroupOrientation {\n\tHORIZONTAL,\n\tVERTICAL\n}\n\nexport const enum GroupLocation {\n\tFIRST,\n\tLAST,\n\tNEXT,\n\tPREVIOUS\n}\n\nexport interface IFindGroupScope {\n\tdirection?: GroupDirection;\n\tlocation?: GroupLocation;\n}\n\nexport const enum GroupsArrangement {\n\n\t/**\n\t * Make the current active group consume the maximum\n\t * amount of space possible.\n\t */\n\tMAXIMIZE,\n\n\t/**\n\t * Size all groups evenly.\n\t */\n\tEVEN,\n\n\t/**\n\t * Will behave like MINIMIZE_OTHERS if the active\n\t * group is not already maximized and EVEN otherwise\n\t */\n\tTOGGLE\n}\n\nexport interface GroupLayoutArgument {\n\n\t/**\n\t * Only applies when there are multiple groups\n\t * arranged next to each other in a row or column.\n\t * If provided, their sum must be 1 to be applied\n\t * per row or column.\n\t */\n\tsize?: number;\n\n\t/**\n\t * Editor groups  will be laid out orthogonal to the\n\t * parent orientation.\n\t */\n\tgroups?: GroupLayoutArgument[];\n}\n\nexport interface EditorGroupLayout {\n\n\t/**\n\t * The initial orientation of the editor groups at the root.\n\t */\n\torientation: GroupOrientation;\n\n\t/**\n\t * The editor groups at the root of the layout.\n\t */\n\tgroups: GroupLayoutArgument[];\n}\n\nexport const enum MergeGroupMode {\n\tCOPY_EDITORS,\n\tMOVE_EDITORS\n}\n\nexport interface IMergeGroupOptions {\n\tmode?: MergeGroupMode;\n\tindex?: number;\n}\n\nexport interface ICloseEditorOptions {\n\tpreserveFocus?: boolean;\n}\n\nexport type ICloseEditorsFilter = {\n\texcept?: EditorInput;\n\tdirection?: CloseDirection;\n\tsavedOnly?: boolean;\n\texcludeSticky?: boolean;\n};\n\nexport interface ICloseAllEditorsOptions {\n\texcludeSticky?: boolean;\n}\n\nexport interface IEditorReplacement {\n\teditor: EditorInput;\n\treplacement: EditorInput;\n\toptions?: IEditorOptions;\n\n\t/**\n\t * Skips asking the user for confirmation and doesn't\n\t * save the document. Only use this if you really need to!\n\t */\n\tforceReplaceDirty?: boolean;\n}\n\nexport function isEditorReplacement(replacement: unknown): replacement is IEditorReplacement {\n\tconst candidate = replacement as IEditorReplacement | undefined;\n\n\treturn isEditorInput(candidate?.editor) && isEditorInput(candidate?.replacement);\n}\n\nexport const enum GroupsOrder {\n\n\t/**\n\t * Groups sorted by creation order (oldest one first)\n\t */\n\tCREATION_TIME,\n\n\t/**\n\t * Groups sorted by most recent activity (most recent active first)\n\t */\n\tMOST_RECENTLY_ACTIVE,\n\n\t/**\n\t * Groups sorted by grid widget order\n\t */\n\tGRID_APPEARANCE\n}\n\nexport interface IEditorSideGroup {\n\n\t/**\n\t * Open an editor in this group.\n\t *\n\t * @returns a promise that resolves around an IEditor instance unless\n\t * the call failed, or the editor was not opened as active editor.\n\t */\n\topenEditor(editor: EditorInput, options?: IEditorOptions): Promise<IEditorPane | undefined>;\n}\n\nexport interface IEditorGroupsService {\n\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * An event for when the active editor group changes. The active editor\n\t * group is the default location for new editors to open.\n\t */\n\treadonly onDidChangeActiveGroup: Event<IEditorGroup>;\n\n\t/**\n\t * An event for when a new group was added.\n\t */\n\treadonly onDidAddGroup: Event<IEditorGroup>;\n\n\t/**\n\t * An event for when a group was removed.\n\t */\n\treadonly onDidRemoveGroup: Event<IEditorGroup>;\n\n\t/**\n\t * An event for when a group was moved.\n\t */\n\treadonly onDidMoveGroup: Event<IEditorGroup>;\n\n\t/**\n\t * An event for when a group gets activated.\n\t */\n\treadonly onDidActivateGroup: Event<IEditorGroup>;\n\n\t/**\n\t * An event for when the group container is layed out.\n\t */\n\treadonly onDidLayout: Event<IDimension>;\n\n\t/**\n\t * An event for when the group container is scrolled.\n\t */\n\treadonly onDidScroll: Event<void>;\n\n\t/**\n\t * An event for when the index of a group changes.\n\t */\n\treadonly onDidChangeGroupIndex: Event<IEditorGroup>;\n\n\t/**\n\t * An event for when the locked state of a group changes.\n\t */\n\treadonly onDidChangeGroupLocked: Event<IEditorGroup>;\n\n\t/**\n\t * The size of the editor groups area.\n\t */\n\treadonly contentDimension: IDimension;\n\n\t/**\n\t * An active group is the default location for new editors to open.\n\t */\n\treadonly activeGroup: IEditorGroup;\n\n\t/**\n\t * A side group allows a subset of methods on a group that is either\n\t * created to the side or picked if already there.\n\t */\n\treadonly sideGroup: IEditorSideGroup;\n\n\t/**\n\t * All groups that are currently visible in the editor area in the\n\t * order of their creation (oldest first).\n\t */\n\treadonly groups: readonly IEditorGroup[];\n\n\t/**\n\t * The number of editor groups that are currently opened.\n\t */\n\treadonly count: number;\n\n\t/**\n\t * The current layout orientation of the root group.\n\t */\n\treadonly orientation: GroupOrientation;\n\n\t/**\n\t * A property that indicates when groups have been created\n\t * and are ready to be used.\n\t */\n\treadonly isReady: boolean;\n\n\t/**\n\t * A promise that resolves when groups have been created\n\t * and are ready to be used.\n\t *\n\t * Await this promise to safely work on the editor groups model\n\t * (for example, install editor group listeners).\n\t *\n\t * Use the `whenRestored` property to await visible editors\n\t * having fully resolved.\n\t */\n\treadonly whenReady: Promise<void>;\n\n\t/**\n\t * A promise that resolves when groups have been restored.\n\t *\n\t * For groups with active editor, the promise will resolve\n\t * when the visible editor has finished to resolve.\n\t *\n\t * Use the `whenReady` property to not await editors to\n\t * resolve.\n\t */\n\treadonly whenRestored: Promise<void>;\n\n\t/**\n\t * Find out if the editor group service has UI state to restore\n\t * from a previous session.\n\t */\n\treadonly hasRestorableState: boolean;\n\n\t/**\n\t * Get all groups that are currently visible in the editor area.\n\t *\n\t * @param order the order of the editors to use\n\t */\n\tgetGroups(order: GroupsOrder): readonly IEditorGroup[];\n\n\t/**\n\t * Allows to convert a group identifier to a group.\n\t */\n\tgetGroup(identifier: GroupIdentifier): IEditorGroup | undefined;\n\n\t/**\n\t * Set a group as active. An active group is the default location for new editors to open.\n\t */\n\tactivateGroup(group: IEditorGroup | GroupIdentifier): IEditorGroup;\n\n\t/**\n\t * Returns the size of a group.\n\t */\n\tgetSize(group: IEditorGroup | GroupIdentifier): { width: number; height: number };\n\n\t/**\n\t * Sets the size of a group.\n\t */\n\tsetSize(group: IEditorGroup | GroupIdentifier, size: { width: number; height: number }): void;\n\n\t/**\n\t * Arrange all groups according to the provided arrangement.\n\t */\n\tarrangeGroups(arrangement: GroupsArrangement): void;\n\n\t/**\n\t * Applies the provided layout by either moving existing groups or creating new groups.\n\t */\n\tapplyLayout(layout: EditorGroupLayout): void;\n\n\t/**\n\t * Returns an editor layout describing the current grid\n\t */\n\tgetLayout(): EditorGroupLayout;\n\n\t/**\n\t * Enable or disable centered editor layout.\n\t */\n\tcenterLayout(active: boolean): void;\n\n\t/**\n\t * Find out if the editor layout is currently centered.\n\t */\n\tisLayoutCentered(): boolean;\n\n\t/**\n\t * Sets the orientation of the root group to be either vertical or horizontal.\n\t */\n\tsetGroupOrientation(orientation: GroupOrientation): void;\n\n\t/**\n\t * Find a group in a specific scope:\n\t * * `GroupLocation.FIRST`: the first group\n\t * * `GroupLocation.LAST`: the last group\n\t * * `GroupLocation.NEXT`: the next group from either the active one or `source`\n\t * * `GroupLocation.PREVIOUS`: the previous group from either the active one or `source`\n\t * * `GroupDirection.UP`: the next group above the active one or `source`\n\t * * `GroupDirection.DOWN`: the next group below the active one or `source`\n\t * * `GroupDirection.LEFT`: the next group to the left of the active one or `source`\n\t * * `GroupDirection.RIGHT`: the next group to the right of the active one or `source`\n\t *\n\t * @param scope the scope of the group to search in\n\t * @param source optional source to search from\n\t * @param wrap optionally wrap around if reaching the edge of groups\n\t */\n\tfindGroup(scope: IFindGroupScope, source?: IEditorGroup | GroupIdentifier, wrap?: boolean): IEditorGroup | undefined;\n\n\t/**\n\t * Add a new group to the editor area. A new group is added by splitting a provided one in\n\t * one of the four directions.\n\t *\n\t * @param location the group from which to split to add a new group\n\t * @param direction the direction of where to split to\n\t */\n\taddGroup(location: IEditorGroup | GroupIdentifier, direction: GroupDirection): IEditorGroup;\n\n\t/**\n\t * Remove a group from the editor area.\n\t */\n\tremoveGroup(group: IEditorGroup | GroupIdentifier): void;\n\n\t/**\n\t * Move a group to a new group in the editor area.\n\t *\n\t * @param group the group to move\n\t * @param location the group from which to split to add the moved group\n\t * @param direction the direction of where to split to\n\t */\n\tmoveGroup(group: IEditorGroup | GroupIdentifier, location: IEditorGroup | GroupIdentifier, direction: GroupDirection): IEditorGroup;\n\n\t/**\n\t * Merge the editors of a group into a target group. By default, all editors will\n\t * move and the source group will close. This behaviour can be configured via the\n\t * `IMergeGroupOptions` options.\n\t *\n\t * @param group the group to merge\n\t * @param target the target group to merge into\n\t * @param options controls how the merge should be performed. by default all editors\n\t * will be moved over to the target and the source group will close. Configure to\n\t * `MOVE_EDITORS_KEEP_GROUP` to prevent the source group from closing. Set to\n\t * `COPY_EDITORS` to copy the editors into the target instead of moding them.\n\t */\n\tmergeGroup(group: IEditorGroup | GroupIdentifier, target: IEditorGroup | GroupIdentifier, options?: IMergeGroupOptions): IEditorGroup;\n\n\t/**\n\t * Merge all editor groups into the active one.\n\t */\n\tmergeAllGroups(): IEditorGroup;\n\n\t/**\n\t * Copy a group to a new group in the editor area.\n\t *\n\t * @param group the group to copy\n\t * @param location the group from which to split to add the copied group\n\t * @param direction the direction of where to split to\n\t */\n\tcopyGroup(group: IEditorGroup | GroupIdentifier, location: IEditorGroup | GroupIdentifier, direction: GroupDirection): IEditorGroup;\n\n\t/**\n\t * Access the options of the editor part.\n\t */\n\treadonly partOptions: IEditorPartOptions;\n\n\t/**\n\t * An event that notifies when editor part options change.\n\t */\n\treadonly onDidChangeEditorPartOptions: Event<IEditorPartOptionsChangeEvent>;\n\n\t/**\n\t * Enforce editor part options temporarily.\n\t */\n\tenforcePartOptions(options: IEditorPartOptions): IDisposable;\n}\n\nexport const enum OpenEditorContext {\n\tNEW_EDITOR = 1,\n\tMOVE_EDITOR = 2,\n\tCOPY_EDITOR = 3\n}\n\nexport interface IEditorGroup {\n\n\t/**\n\t * An event which fires whenever the underlying group model changes.\n\t */\n\treadonly onDidModelChange: Event<IGroupModelChangeEvent>;\n\n\t/**\n\t * An event that is fired when the group gets disposed.\n\t */\n\treadonly onWillDispose: Event<void>;\n\n\t/**\n\t * An event that is fired when the active editor in the group changed.\n\t */\n\treadonly onDidActiveEditorChange: Event<IActiveEditorChangeEvent>;\n\n\t/**\n\t * An event that is fired when an editor is about to close.\n\t */\n\treadonly onWillCloseEditor: Event<IEditorCloseEvent>;\n\n\t/**\n\t * An event that is fired when an editor is closed.\n\t */\n\treadonly onDidCloseEditor: Event<IEditorCloseEvent>;\n\n\t/**\n\t * An event that is fired when an editor is about to move to\n\t * a different group.\n\t */\n\treadonly onWillMoveEditor: Event<IEditorWillMoveEvent>;\n\n\t/**\n\t * An event that is fired when an editor is about to be opened\n\t * in the group.\n\t */\n\treadonly onWillOpenEditor: Event<IEditorWillOpenEvent>;\n\n\t/**\n\t * A unique identifier of this group that remains identical even if the\n\t * group is moved to different locations.\n\t */\n\treadonly id: GroupIdentifier;\n\n\t/**\n\t * A number that indicates the position of this group in the visual\n\t * order of groups from left to right and top to bottom. The lowest\n\t * index will likely be top-left while the largest index in most\n\t * cases should be bottom-right, but that depends on the grid.\n\t */\n\treadonly index: number;\n\n\t/**\n\t * A human readable label for the group. This label can change depending\n\t * on the layout of all editor groups. Clients should listen on the\n\t * `onDidGroupModelChange` event to react to that.\n\t */\n\treadonly label: string;\n\n\t/**\n\t * A human readable label for the group to be used by screen readers.\n\t */\n\treadonly ariaLabel: string;\n\n\t/**\n\t * The active editor pane is the currently visible editor pane of the group.\n\t */\n\treadonly activeEditorPane: IVisibleEditorPane | undefined;\n\n\t/**\n\t * The active editor is the currently visible editor of the group\n\t * within the current active editor pane.\n\t */\n\treadonly activeEditor: EditorInput | null;\n\n\t/**\n\t * The editor in the group that is in preview mode if any. There can\n\t * only ever be one editor in preview mode.\n\t */\n\treadonly previewEditor: EditorInput | null;\n\n\t/**\n\t * The number of opened editors in this group.\n\t */\n\treadonly count: number;\n\n\t/**\n\t * Whether the group has editors or not.\n\t */\n\treadonly isEmpty: boolean;\n\n\t/**\n\t * Whether this editor group is locked or not. Locked editor groups\n\t * will only be considered for editors to open in when the group is\n\t * explicitly provided for the editor.\n\t *\n\t * Note: editor group locking only applies when more than one group\n\t * is opened.\n\t */\n\treadonly isLocked: boolean;\n\n\t/**\n\t * The number of sticky editors in this group.\n\t */\n\treadonly stickyCount: number;\n\n\t/**\n\t * All opened editors in the group in sequential order of their appearance.\n\t */\n\treadonly editors: readonly EditorInput[];\n\n\t/**\n\t * The scoped context key service for this group.\n\t */\n\treadonly scopedContextKeyService: IContextKeyService;\n\n\t/**\n\t * Get all editors that are currently opened in the group.\n\t *\n\t * @param order the order of the editors to use\n\t * @param options options to select only specific editors as instructed\n\t */\n\tgetEditors(order: EditorsOrder, options?: { excludeSticky?: boolean }): readonly EditorInput[];\n\n\t/**\n\t * Finds all editors for the given resource that are currently\n\t * opened in the group. This method will return an entry for\n\t * each editor that reports a `resource` that matches the\n\t * provided one.\n\t *\n\t * @param resource the resource of the editor to find\n\t * @param options whether to support side by side editors or not\n\t */\n\tfindEditors(resource: URI, options?: IFindEditorOptions): readonly EditorInput[];\n\n\t/**\n\t * Returns the editor at a specific index of the group.\n\t */\n\tgetEditorByIndex(index: number): EditorInput | undefined;\n\n\t/**\n\t * Returns the index of the editor in the group or -1 if not opened.\n\t */\n\tgetIndexOfEditor(editor: EditorInput): number;\n\n\t/**\n\t * Whether the editor is the first in the group.\n\t */\n\tisFirst(editor: EditorInput): boolean;\n\n\t/**\n\t * Whether the editor is the last in the group.\n\t */\n\tisLast(editor: EditorInput): boolean;\n\n\t/**\n\t * Open an editor in this group.\n\t *\n\t * @returns a promise that resolves around an IEditor instance unless\n\t * the call failed, or the editor was not opened as active editor.\n\t */\n\topenEditor(editor: EditorInput, options?: IEditorOptions): Promise<IEditorPane | undefined>;\n\n\t/**\n\t * Opens editors in this group.\n\t *\n\t * @returns a promise that resolves around an IEditor instance unless\n\t * the call failed, or the editor was not opened as active editor. Since\n\t * a group can only ever have one active editor, even if many editors are\n\t * opened, the result will only be one editor.\n\t */\n\topenEditors(editors: EditorInputWithOptions[]): Promise<IEditorPane | undefined>;\n\n\t/**\n\t * Find out if the provided editor is pinned in the group.\n\t */\n\tisPinned(editorOrIndex: EditorInput | number): boolean;\n\n\t/**\n\t * Find out if the provided editor or index of editor is sticky in the group.\n\t */\n\tisSticky(editorOrIndex: EditorInput | number): boolean;\n\n\t/**\n\t * Find out if the provided editor is active in the group.\n\t */\n\tisActive(editor: EditorInput | IUntypedEditorInput): boolean;\n\n\t/**\n\t * Find out if a certain editor is included in the group.\n\t *\n\t * @param candidate the editor to find\n\t * @param options fine tune how to match editors\n\t */\n\tcontains(candidate: EditorInput | IUntypedEditorInput, options?: IMatchEditorOptions): boolean;\n\n\t/**\n\t * Move an editor from this group either within this group or to another group.\n\t */\n\tmoveEditor(editor: EditorInput, target: IEditorGroup, options?: IEditorOptions): void;\n\n\t/**\n\t * Move editors from this group either within this group or to another group.\n\t */\n\tmoveEditors(editors: EditorInputWithOptions[], target: IEditorGroup): void;\n\n\t/**\n\t * Copy an editor from this group to another group.\n\t *\n\t * Note: It is currently not supported to show the same editor more than once in the same group.\n\t */\n\tcopyEditor(editor: EditorInput, target: IEditorGroup, options?: IEditorOptions): void;\n\n\t/**\n\t * Copy editors from this group to another group.\n\t *\n\t * Note: It is currently not supported to show the same editor more than once in the same group.\n\t */\n\tcopyEditors(editors: EditorInputWithOptions[], target: IEditorGroup): void;\n\n\t/**\n\t * Close an editor from the group. This may trigger a confirmation dialog if\n\t * the editor is dirty and thus returns a promise as value.\n\t *\n\t * @param editor the editor to close, or the currently active editor\n\t * if unspecified.\n\t *\n\t * @returns a promise when the editor is closed or not. If `true`, the editor\n\t * is closed and if `false` there was a veto closing the editor, e.g. when it\n\t * is dirty.\n\t */\n\tcloseEditor(editor?: EditorInput, options?: ICloseEditorOptions): Promise<boolean>;\n\n\t/**\n\t * Closes specific editors in this group. This may trigger a confirmation dialog if\n\t * there are dirty editors and thus returns a promise as value.\n\t *\n\t * @returns a promise whether the editors were closed or not. If `true`, the editors\n\t * were closed and if `false` there was a veto closing the editors, e.g. when one\n\t * is dirty.\n\t */\n\tcloseEditors(editors: EditorInput[] | ICloseEditorsFilter, options?: ICloseEditorOptions): Promise<boolean>;\n\n\t/**\n\t * Closes all editors from the group. This may trigger a confirmation dialog if\n\t * there are dirty editors and thus returns a promise as value.\n\t *\n\t * @returns a promise when all editors are closed.\n\t */\n\tcloseAllEditors(options?: ICloseAllEditorsOptions): Promise<boolean>;\n\n\t/**\n\t * Replaces editors in this group with the provided replacement.\n\t *\n\t * @param editors the editors to replace\n\t *\n\t * @returns a promise that is resolved when the replaced active\n\t * editor (if any) has finished loading.\n\t */\n\treplaceEditors(editors: IEditorReplacement[]): Promise<void>;\n\n\t/**\n\t * Set an editor to be pinned. A pinned editor is not replaced\n\t * when another editor opens at the same location.\n\t *\n\t * @param editor the editor to pin, or the currently active editor\n\t * if unspecified.\n\t */\n\tpinEditor(editor?: EditorInput): void;\n\n\t/**\n\t * Set an editor to be sticky. A sticky editor is showing in the beginning\n\t * of the tab stripe and will not be impacted by close operations.\n\t *\n\t * @param editor the editor to make sticky, or the currently active editor\n\t * if unspecified.\n\t */\n\tstickEditor(editor?: EditorInput): void;\n\n\t/**\n\t * Set an editor to be non-sticky and thus moves back to a location after\n\t * sticky editors and can be closed normally.\n\t *\n\t * @param editor the editor to make unsticky, or the currently active editor\n\t * if unspecified.\n\t */\n\tunstickEditor(editor?: EditorInput): void;\n\n\t/**\n\t * Whether this editor group should be locked or not.\n\t *\n\t * See {@linkcode IEditorGroup.isLocked `isLocked`}\n\t */\n\tlock(locked: boolean): void;\n\n\t/**\n\t * Move keyboard focus into the group.\n\t */\n\tfocus(): void;\n}\n\nexport function isEditorGroup(obj: unknown): obj is IEditorGroup {\n\tconst group = obj as IEditorGroup | undefined;\n\n\treturn !!group && typeof group.id === 'number' && Array.isArray(group.editors);\n}\n\n//#region Editor Group Helpers\n\nexport function preferredSideBySideGroupDirection(configurationService: IConfigurationService): GroupDirection.DOWN | GroupDirection.RIGHT {\n\tconst openSideBySideDirection = configurationService.getValue('workbench.editor.openSideBySideDirection');\n\n\tif (openSideBySideDirection === 'down') {\n\t\treturn GroupDirection.DOWN;\n\t}\n\n\treturn GroupDirection.RIGHT;\n}\n\n//#endregion\n"]}