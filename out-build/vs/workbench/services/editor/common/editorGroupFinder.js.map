{"version":3,"sources":["file:///workspace/appflow/src/vs/workbench/services/editor/common/editorGroupFinder.ts"],"names":[],"mappings":"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","file":"editorGroupFinder.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IConfigurationService } from 'vs/platform/configuration/common/configuration';\nimport { EditorActivation } from 'vs/platform/editor/common/editor';\nimport { ServicesAccessor } from 'vs/platform/instantiation/common/instantiation';\nimport { EditorInputWithOptions, isEditorInputWithOptions, IUntypedEditorInput, isEditorInput, EditorInputCapabilities } from 'vs/workbench/common/editor';\nimport { EditorInput } from 'vs/workbench/common/editor/editorInput';\nimport { IEditorGroup, GroupsOrder, preferredSideBySideGroupDirection, IEditorGroupsService } from 'vs/workbench/services/editor/common/editorGroupsService';\nimport { PreferredGroup, SIDE_GROUP } from 'vs/workbench/services/editor/common/editorService';\n\n/**\n * Finds the target `IEditorGroup` given the instructions provided\n * that is best for the editor and matches the preferred group if\n * possible.\n */\nexport function findGroup(accessor: ServicesAccessor, editor: IUntypedEditorInput, preferredGroup: PreferredGroup | undefined): [IEditorGroup, EditorActivation | undefined];\nexport function findGroup(accessor: ServicesAccessor, editor: EditorInputWithOptions, preferredGroup: PreferredGroup | undefined): [IEditorGroup, EditorActivation | undefined];\nexport function findGroup(accessor: ServicesAccessor, editor: EditorInputWithOptions | IUntypedEditorInput, preferredGroup: PreferredGroup | undefined): [IEditorGroup, EditorActivation | undefined];\nexport function findGroup(accessor: ServicesAccessor, editor: EditorInputWithOptions | IUntypedEditorInput, preferredGroup: PreferredGroup | undefined): [IEditorGroup, EditorActivation | undefined] {\n\tconst editorGroupService = accessor.get(IEditorGroupsService);\n\tconst configurationService = accessor.get(IConfigurationService);\n\n\tconst group = doFindGroup(editor, preferredGroup, editorGroupService, configurationService);\n\n\t// Resolve editor activation strategy\n\tlet activation: EditorActivation | undefined = undefined;\n\tif (\n\t\teditorGroupService.activeGroup !== group && \t// only if target group is not already active\n\t\teditor.options && !editor.options.inactive &&\t\t// never for inactive editors\n\t\teditor.options.preserveFocus &&\t\t\t\t\t\t// only if preserveFocus\n\t\ttypeof editor.options.activation !== 'number' &&\t// only if activation is not already defined (either true or false)\n\t\tpreferredGroup !== SIDE_GROUP\t\t\t\t\t\t// never for the SIDE_GROUP\n\t) {\n\t\t// If the resolved group is not the active one, we typically\n\t\t// want the group to become active. There are a few cases\n\t\t// where we stay away from encorcing this, e.g. if the caller\n\t\t// is already providing `activation`.\n\t\t//\n\t\t// Specifically for historic reasons we do not activate a\n\t\t// group is it is opened as `SIDE_GROUP` with `preserveFocus:true`.\n\t\t// repeated Alt-clicking of files in the explorer always open\n\t\t// into the same side group and not cause a group to be created each time.\n\t\tactivation = EditorActivation.ACTIVATE;\n\t}\n\n\treturn [group, activation];\n}\n\nfunction doFindGroup(input: EditorInputWithOptions | IUntypedEditorInput, preferredGroup: PreferredGroup | undefined, editorGroupService: IEditorGroupsService, configurationService: IConfigurationService): IEditorGroup {\n\tlet group: IEditorGroup | undefined;\n\tconst editor = isEditorInputWithOptions(input) ? input.editor : input;\n\tconst options = input.options;\n\n\t// Group: Instance of Group\n\tif (preferredGroup && typeof preferredGroup !== 'number') {\n\t\tgroup = preferredGroup;\n\t}\n\n\t// Group: Specific Group\n\telse if (typeof preferredGroup === 'number' && preferredGroup >= 0) {\n\t\tgroup = editorGroupService.getGroup(preferredGroup);\n\t}\n\n\t// Group: Side by Side\n\telse if (preferredGroup === SIDE_GROUP) {\n\t\tconst direction = preferredSideBySideGroupDirection(configurationService);\n\n\t\tlet candidateGroup = editorGroupService.findGroup({ direction });\n\t\tif (!candidateGroup || isGroupLockedForEditor(candidateGroup, editor)) {\n\t\t\t// Create new group either when the candidate group\n\t\t\t// is locked or was not found in the direction\n\t\t\tcandidateGroup = editorGroupService.addGroup(editorGroupService.activeGroup, direction);\n\t\t}\n\n\t\tgroup = candidateGroup;\n\t}\n\n\t// Group: Unspecified without a specific index to open\n\telse if (!options || typeof options.index !== 'number') {\n\t\tconst groupsByLastActive = editorGroupService.getGroups(GroupsOrder.MOST_RECENTLY_ACTIVE);\n\n\t\t// Respect option to reveal an editor if it is already visible in any group\n\t\tif (options?.revealIfVisible) {\n\t\t\tfor (const lastActiveGroup of groupsByLastActive) {\n\t\t\t\tif (isActive(lastActiveGroup, editor)) {\n\t\t\t\t\tgroup = lastActiveGroup;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Respect option to reveal an editor if it is open (not necessarily visible)\n\t\t// Still prefer to reveal an editor in a group where the editor is active though.\n\t\t// We also try to reveal an editor if it has the `Singleton` capability which\n\t\t// indicates that the same editor cannot be opened across groups.\n\t\tif (!group) {\n\t\t\tif (options?.revealIfOpened || configurationService.getValue<boolean>('workbench.editor.revealIfOpen') || (isEditorInput(editor) && editor.hasCapability(EditorInputCapabilities.Singleton))) {\n\t\t\t\tlet groupWithInputActive: IEditorGroup | undefined = undefined;\n\t\t\t\tlet groupWithInputOpened: IEditorGroup | undefined = undefined;\n\n\t\t\t\tfor (const group of groupsByLastActive) {\n\t\t\t\t\tif (isOpened(group, editor)) {\n\t\t\t\t\t\tif (!groupWithInputOpened) {\n\t\t\t\t\t\t\tgroupWithInputOpened = group;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!groupWithInputActive && group.isActive(editor)) {\n\t\t\t\t\t\t\tgroupWithInputActive = group;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (groupWithInputOpened && groupWithInputActive) {\n\t\t\t\t\t\tbreak; // we found all groups we wanted\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Prefer a target group where the input is visible\n\t\t\t\tgroup = groupWithInputActive || groupWithInputOpened;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Fallback to active group if target not valid but avoid\n\t// locked editor groups unless editor is already opened there\n\tif (!group) {\n\t\tlet candidateGroup = editorGroupService.activeGroup;\n\n\t\t// Locked group: find the next non-locked group\n\t\t// going up the neigbours of the group or create\n\t\t// a new group otherwise\n\t\tif (isGroupLockedForEditor(candidateGroup, editor)) {\n\t\t\tfor (const group of editorGroupService.getGroups(GroupsOrder.MOST_RECENTLY_ACTIVE)) {\n\t\t\t\tif (isGroupLockedForEditor(group, editor)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tcandidateGroup = group;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (isGroupLockedForEditor(candidateGroup, editor)) {\n\t\t\t\t// Group is still locked, so we have to create a new\n\t\t\t\t// group to the side of the candidate group\n\t\t\t\tgroup = editorGroupService.addGroup(candidateGroup, preferredSideBySideGroupDirection(configurationService));\n\t\t\t} else {\n\t\t\t\tgroup = candidateGroup;\n\t\t\t}\n\t\t}\n\n\t\t// Non-locked group: take as is\n\t\telse {\n\t\t\tgroup = candidateGroup;\n\t\t}\n\t}\n\n\treturn group;\n}\n\nfunction isGroupLockedForEditor(group: IEditorGroup, editor: EditorInput | IUntypedEditorInput): boolean {\n\tif (!group.isLocked) {\n\t\t// only relevant for locked editor groups\n\t\treturn false;\n\t}\n\n\tif (isOpened(group, editor)) {\n\t\t// special case: the locked group contains\n\t\t// the provided editor. in that case we do not want\n\t\t// to open the editor in any different group.\n\t\treturn false;\n\t}\n\n\t// group is locked for this editor\n\treturn true;\n}\n\nfunction isActive(group: IEditorGroup, editor: EditorInput | IUntypedEditorInput): boolean {\n\tif (!group.activeEditor) {\n\t\treturn false;\n\t}\n\n\treturn group.activeEditor.matches(editor);\n}\n\nfunction isOpened(group: IEditorGroup, editor: EditorInput | IUntypedEditorInput): boolean {\n\tfor (const typedEditor of group.editors) {\n\t\tif (typedEditor.matches(editor)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n"]}