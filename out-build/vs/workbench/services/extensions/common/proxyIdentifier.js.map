{"version":3,"sources":["file:///workspace/appflow/src/vs/workbench/services/extensions/common/proxyIdentifier.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;IA6BhG,MAAa,GAAG;iBACD,UAAK,GAAG,CAAH,AAAI,CAAC;QAMxB,YAAY,GAAW;YALvB,0BAAqB,GAAS,SAAS,CAAC;YAMvC,IAAI,CAAC,GAAG,GAAG,GAAG,CAAC;YACf,IAAI,CAAC,GAAG,GAAG,CAAC,EAAE,GAAG,CAAa,KAAK,CAAC,CAAC;QACtC,CAAC;;IAVF,kBAWC;IAED,MAAM,WAAW,GAA2B,EAAE,CAAC;IAE/C,SAAgB,GAAG,CAAsB,UAAkB;QAC1D,MAAM,MAAM,GAAG,IAAI,GAAG,CAAgB,UAAU,CAAC,CAAC;QAClD,WAAW,CAAC,MAAM,CAAC,GAAG,CAAC,GAAG,MAAM,CAAC;QACjC,OAAO,MAAM,CAAC;IACf,CAAC;IAJD,kBAIC;IAsBD,SAAgB,GAAG,CAAyB,GAAW;QACtD,OAAO,WAAW,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC;IAC7B,CAAC;IAFD,kBAEC;IAED;;OAEG;IACH,MAAa,GAAG;QACf,YACiB,KAAQ;YAAR,UAAK,GAAL,KAAK,CAAG;QACrB,CAAC;KACL;IAJD,kBAIC","file":"proxyIdentifier.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport type { VSBuffer } from 'vs/base/common/buffer';\nimport type { CancellationToken } from 'vs/base/common/cancellation';\n\nexport interface IRPCProtocol {\n\t/**\n\t * Returns a proxy to an object addressable/named in the extension host process or in the renderer process.\n\t */\n\tgetProxy<T>(identifier: ProxyIdentifier<T>): Proxied<T>;\n\n\t/**\n\t * Register manually created instance.\n\t */\n\tset<T, R extends T>(identifier: ProxyIdentifier<T>, instance: R): R;\n\n\t/**\n\t * Assert these identifiers are already registered via `.set`.\n\t */\n\tassertRegistered(identifiers: ProxyIdentifier<any>[]): void;\n\n\t/**\n\t * Wait for the write buffer (if applicable) to become empty.\n\t */\n\tdrain(): Promise<void>;\n\n\tdispose(): void;\n}\n\nexport class ProxyIdentifier<T> {\n\tpublic static count = 0;\n\t_proxyIdentifierBrand: void = undefined;\n\n\tpublic readonly sid: string;\n\tpublic readonly nid: number;\n\n\tconstructor(sid: string) {\n\t\tthis.sid = sid;\n\t\tthis.nid = (++ProxyIdentifier.count);\n\t}\n}\n\nconst identifiers: ProxyIdentifier<any>[] = [];\n\nexport function createProxyIdentifier<T>(identifier: string): ProxyIdentifier<T> {\n\tconst result = new ProxyIdentifier<T>(identifier);\n\tidentifiers[result.nid] = result;\n\treturn result;\n}\n\n/**\n * Mapped-type that replaces all JSONable-types with their toJSON-result type\n */\nexport type Dto<T> = T extends { toJSON(): infer U }\n\t? U\n\t: T extends VSBuffer // VSBuffer is understood by rpc-logic\n\t? T\n\t: T extends CancellationToken // CancellationToken is understood by rpc-logic\n\t? T\n\t: T extends Function // functions are dropped during JSON-stringify\n\t? never\n\t: T extends object // recurse\n\t? { [k in keyof T]: Dto<T[k]>; }\n\t: T;\n\nexport type Proxied<T> = { [K in keyof T]: T[K] extends (...args: infer A) => infer R\n\t? (...args: { [K in keyof A]: Dto<A[K]> }) => Promise<Dto<Awaited<R>>>\n\t: never\n};\n\nexport function getStringIdentifierForProxy(nid: number): string {\n\treturn identifiers[nid].sid;\n}\n\n/**\n * Marks the object as containing buffers that should be serialized more efficiently.\n */\nexport class SerializableObjectWithBuffers<T> {\n\tconstructor(\n\t\tpublic readonly value: T\n\t) { }\n}\n"]}