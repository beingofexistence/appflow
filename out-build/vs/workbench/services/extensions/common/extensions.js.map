{"version":3,"sources":["file:///workspace/appflow/src/vs/workbench/services/extensions/common/extensions.ts"],"names":[],"mappings":"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","file":"extensions.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event } from 'vs/base/common/event';\nimport Severity from 'vs/base/common/severity';\nimport { URI } from 'vs/base/common/uri';\nimport { IMessagePassingProtocol } from 'vs/base/parts/ipc/common/ipc';\nimport { getExtensionId, getGalleryExtensionId } from 'vs/platform/extensionManagement/common/extensionManagementUtil';\nimport { ImplicitActivationEvents } from 'vs/platform/extensionManagement/common/implicitActivationEvents';\nimport { ExtensionIdentifier, ExtensionIdentifierMap, ExtensionIdentifierSet, ExtensionType, IExtension, IExtensionContributions, IExtensionDescription, TargetPlatform } from 'vs/platform/extensions/common/extensions';\nimport { createDecorator } from 'vs/platform/instantiation/common/instantiation';\nimport { IV8Profile } from 'vs/platform/profiling/common/profiling';\nimport { ExtensionHostKind } from 'vs/workbench/services/extensions/common/extensionHostKind';\nimport { IExtensionDescriptionDelta, IExtensionDescriptionSnapshot } from 'vs/workbench/services/extensions/common/extensionHostProtocol';\nimport { ExtensionRunningLocation } from 'vs/workbench/services/extensions/common/extensionRunningLocation';\nimport { ApiProposalName } from 'vs/workbench/services/extensions/common/extensionsApiProposals';\nimport { IExtensionPoint } from 'vs/workbench/services/extensions/common/extensionsRegistry';\n\nexport const nullExtensionDescription = Object.freeze<IExtensionDescription>({\n\tidentifier: new ExtensionIdentifier('nullExtensionDescription'),\n\tname: 'Null Extension Description',\n\tversion: '0.0.0',\n\tpublisher: 'vscode',\n\tengines: { vscode: '' },\n\textensionLocation: URI.parse('void:location'),\n\tisBuiltin: false,\n\ttargetPlatform: TargetPlatform.UNDEFINED,\n\tisUserBuiltin: false,\n\tisUnderDevelopment: false,\n});\n\nexport type WebWorkerExtHostConfigValue = boolean | 'auto';\nexport const webWorkerExtHostConfig = 'extensions.webWorker';\n\nexport const IExtensionService = createDecorator<IExtensionService>('extensionService');\n\nexport interface IMessage {\n\ttype: Severity;\n\tmessage: string;\n\textensionId: ExtensionIdentifier;\n\textensionPointId: string;\n}\n\nexport interface IExtensionsStatus {\n\tid: ExtensionIdentifier;\n\tmessages: IMessage[];\n\tactivationStarted: boolean;\n\tactivationTimes: ActivationTimes | undefined;\n\truntimeErrors: Error[];\n\trunningLocation: ExtensionRunningLocation | null;\n}\n\nexport class MissingExtensionDependency {\n\tconstructor(readonly dependency: string) { }\n}\n\n/**\n * e.g.\n * ```\n * {\n *    startTime: 1511954813493000,\n *    endTime: 1511954835590000,\n *    deltas: [ 100, 1500, 123456, 1500, 100000 ],\n *    ids: [ 'idle', 'self', 'extension1', 'self', 'idle' ]\n * }\n * ```\n */\nexport interface IExtensionHostProfile {\n\t/**\n\t * Profiling start timestamp in microseconds.\n\t */\n\tstartTime: number;\n\t/**\n\t * Profiling end timestamp in microseconds.\n\t */\n\tendTime: number;\n\t/**\n\t * Duration of segment in microseconds.\n\t */\n\tdeltas: number[];\n\t/**\n\t * Segment identifier: extension id or one of the four known strings.\n\t */\n\tids: ProfileSegmentId[];\n\n\t/**\n\t * Get the information as a .cpuprofile.\n\t */\n\tdata: IV8Profile;\n\n\t/**\n\t * Get the aggregated time per segmentId\n\t */\n\tgetAggregatedTimes(): Map<ProfileSegmentId, number>;\n}\n\nexport const enum ExtensionHostStartup {\n\t/**\n\t * The extension host should be launched immediately and doesn't require a `$startExtensionHost` call.\n\t */\n\tEagerAutoStart = 1,\n\t/**\n\t * The extension host should be launched immediately and needs a `$startExtensionHost` call.\n\t */\n\tEagerManualStart = 2,\n\t/**\n\t * The extension host should be launched lazily and only when it has extensions it needs to host. It needs a `$startExtensionHost` call.\n\t */\n\tLazy = 3,\n}\n\nexport interface IExtensionHost {\n\treadonly runningLocation: ExtensionRunningLocation;\n\treadonly remoteAuthority: string | null;\n\treadonly startup: ExtensionHostStartup;\n\t/**\n\t * A collection of extensions which includes information about which\n\t * extension will execute or is executing on this extension host.\n\t * **NOTE**: this will reflect extensions correctly only after `start()` resolves.\n\t */\n\treadonly extensions: ExtensionHostExtensions | null;\n\treadonly onExit: Event<[number, string | null]>;\n\n\tstart(): Promise<IMessagePassingProtocol>;\n\tgetInspectPort(): number | undefined;\n\tenableInspectPort(): Promise<boolean>;\n\tdispose(): void;\n}\n\nexport class ExtensionHostExtensions {\n\tprivate _versionId: number;\n\tprivate _allExtensions: IExtensionDescription[];\n\tprivate _myExtensions: ExtensionIdentifier[];\n\n\tpublic get versionId(): number {\n\t\treturn this._versionId;\n\t}\n\n\tpublic get allExtensions(): IExtensionDescription[] {\n\t\treturn this._allExtensions;\n\t}\n\n\tpublic get myExtensions(): ExtensionIdentifier[] {\n\t\treturn this._myExtensions;\n\t}\n\n\tconstructor(versionId: number, allExtensions: readonly IExtensionDescription[], myExtensions: ExtensionIdentifier[]) {\n\t\tthis._versionId = versionId;\n\t\tthis._allExtensions = allExtensions.slice(0);\n\t\tthis._myExtensions = myExtensions.slice(0);\n\t}\n\n\ttoSnapshot(): IExtensionDescriptionSnapshot {\n\t\treturn {\n\t\t\tversionId: this._versionId,\n\t\t\tallExtensions: this._allExtensions,\n\t\t\tmyExtensions: this._myExtensions,\n\t\t\tactivationEvents: ImplicitActivationEvents.createActivationEventsMap(this._allExtensions)\n\t\t};\n\t}\n\n\tpublic set(versionId: number, allExtensions: IExtensionDescription[], myExtensions: ExtensionIdentifier[]): IExtensionDescriptionDelta {\n\t\tif (this._versionId > versionId) {\n\t\t\tthrow new Error(`ExtensionHostExtensions: invalid versionId ${versionId} (current: ${this._versionId})`);\n\t\t}\n\t\tconst toRemove: ExtensionIdentifier[] = [];\n\t\tconst toAdd: IExtensionDescription[] = [];\n\t\tconst myToRemove: ExtensionIdentifier[] = [];\n\t\tconst myToAdd: ExtensionIdentifier[] = [];\n\n\t\tconst oldExtensionsMap = extensionDescriptionArrayToMap(this._allExtensions);\n\t\tconst newExtensionsMap = extensionDescriptionArrayToMap(allExtensions);\n\t\tconst extensionsAreTheSame = (a: IExtensionDescription, b: IExtensionDescription) => {\n\t\t\treturn (\n\t\t\t\t(a.extensionLocation.toString() === b.extensionLocation.toString())\n\t\t\t\t|| (a.isBuiltin === b.isBuiltin)\n\t\t\t\t|| (a.isUserBuiltin === b.isUserBuiltin)\n\t\t\t\t|| (a.isUnderDevelopment === b.isUnderDevelopment)\n\t\t\t);\n\t\t};\n\n\t\tfor (const oldExtension of this._allExtensions) {\n\t\t\tconst newExtension = newExtensionsMap.get(oldExtension.identifier);\n\t\t\tif (!newExtension) {\n\t\t\t\ttoRemove.push(oldExtension.identifier);\n\t\t\t\toldExtensionsMap.delete(oldExtension.identifier);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!extensionsAreTheSame(oldExtension, newExtension)) {\n\t\t\t\t// The new extension is different than the old one\n\t\t\t\t// (e.g. maybe it executes in a different location)\n\t\t\t\ttoRemove.push(oldExtension.identifier);\n\t\t\t\toldExtensionsMap.delete(oldExtension.identifier);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tfor (const newExtension of allExtensions) {\n\t\t\tconst oldExtension = oldExtensionsMap.get(newExtension.identifier);\n\t\t\tif (!oldExtension) {\n\t\t\t\ttoAdd.push(newExtension);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!extensionsAreTheSame(oldExtension, newExtension)) {\n\t\t\t\t// The new extension is different than the old one\n\t\t\t\t// (e.g. maybe it executes in a different location)\n\t\t\t\ttoRemove.push(oldExtension.identifier);\n\t\t\t\toldExtensionsMap.delete(oldExtension.identifier);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tconst myOldExtensionsSet = new ExtensionIdentifierSet(this._myExtensions);\n\t\tconst myNewExtensionsSet = new ExtensionIdentifierSet(myExtensions);\n\t\tfor (const oldExtensionId of this._myExtensions) {\n\t\t\tif (!myNewExtensionsSet.has(oldExtensionId)) {\n\t\t\t\tmyToRemove.push(oldExtensionId);\n\t\t\t}\n\t\t}\n\t\tfor (const newExtensionId of myExtensions) {\n\t\t\tif (!myOldExtensionsSet.has(newExtensionId)) {\n\t\t\t\tmyToAdd.push(newExtensionId);\n\t\t\t}\n\t\t}\n\n\t\tconst addActivationEvents = ImplicitActivationEvents.createActivationEventsMap(toAdd);\n\t\tconst delta = { versionId, toRemove, toAdd, addActivationEvents, myToRemove, myToAdd };\n\t\tthis.delta(delta);\n\t\treturn delta;\n\t}\n\n\tpublic delta(extensionsDelta: IExtensionDescriptionDelta): IExtensionDescriptionDelta | null {\n\t\tif (this._versionId >= extensionsDelta.versionId) {\n\t\t\t// ignore older deltas\n\t\t\treturn null;\n\t\t}\n\n\t\tconst { toRemove, toAdd, myToRemove, myToAdd } = extensionsDelta;\n\t\t// First handle removals\n\t\tconst toRemoveSet = new ExtensionIdentifierSet(toRemove);\n\t\tconst myToRemoveSet = new ExtensionIdentifierSet(myToRemove);\n\t\tfor (let i = 0; i < this._allExtensions.length; i++) {\n\t\t\tif (toRemoveSet.has(this._allExtensions[i].identifier)) {\n\t\t\t\tthis._allExtensions.splice(i, 1);\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\t\tfor (let i = 0; i < this._myExtensions.length; i++) {\n\t\t\tif (myToRemoveSet.has(this._myExtensions[i])) {\n\t\t\t\tthis._myExtensions.splice(i, 1);\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\t\t// Then handle additions\n\t\tfor (const extension of toAdd) {\n\t\t\tthis._allExtensions.push(extension);\n\t\t}\n\t\tfor (const extensionId of myToAdd) {\n\t\t\tthis._myExtensions.push(extensionId);\n\t\t}\n\n\t\treturn extensionsDelta;\n\t}\n\n\tpublic containsExtension(extensionId: ExtensionIdentifier): boolean {\n\t\tfor (const myExtensionId of this._myExtensions) {\n\t\t\tif (ExtensionIdentifier.equals(myExtensionId, extensionId)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}\n\nfunction extensionDescriptionArrayToMap(extensions: IExtensionDescription[]): ExtensionIdentifierMap<IExtensionDescription> {\n\tconst result = new ExtensionIdentifierMap<IExtensionDescription>();\n\tfor (const extension of extensions) {\n\t\tresult.set(extension.identifier, extension);\n\t}\n\treturn result;\n}\n\nexport function isProposedApiEnabled(extension: IExtensionDescription, proposal: ApiProposalName): boolean {\n\tif (!extension.enabledApiProposals) {\n\t\treturn false;\n\t}\n\treturn extension.enabledApiProposals.includes(proposal);\n}\n\nexport function checkProposedApiEnabled(extension: IExtensionDescription, proposal: ApiProposalName): void {\n\tif (!isProposedApiEnabled(extension, proposal)) {\n\t\tthrow new Error(`Extension '${extension.identifier.value}' CANNOT use API proposal: ${proposal}.\\nIts package.json#enabledApiProposals-property declares: ${extension.enabledApiProposals?.join(', ') ?? '[]'} but NOT ${proposal}.\\n The missing proposal MUST be added and you must start in extension development mode or use the following command line switch: --enable-proposed-api ${extension.identifier.value}`);\n\t}\n}\n\n\n/**\n * Extension id or one of the four known program states.\n */\nexport type ProfileSegmentId = string | 'idle' | 'program' | 'gc' | 'self';\n\nexport interface ExtensionActivationReason {\n\treadonly startup: boolean;\n\treadonly extensionId: ExtensionIdentifier;\n\treadonly activationEvent: string;\n}\n\nexport class ActivationTimes {\n\tconstructor(\n\t\tpublic readonly codeLoadingTime: number,\n\t\tpublic readonly activateCallTime: number,\n\t\tpublic readonly activateResolvedTime: number,\n\t\tpublic readonly activationReason: ExtensionActivationReason\n\t) {\n\t}\n}\n\nexport class ExtensionPointContribution<T> {\n\treadonly description: IExtensionDescription;\n\treadonly value: T;\n\n\tconstructor(description: IExtensionDescription, value: T) {\n\t\tthis.description = description;\n\t\tthis.value = value;\n\t}\n}\n\nexport interface IWillActivateEvent {\n\treadonly event: string;\n\treadonly activation: Promise<void>;\n}\n\nexport interface IResponsiveStateChangeEvent {\n\textensionHostKind: ExtensionHostKind;\n\tisResponsive: boolean;\n\t/**\n\t * Return the inspect port or `0`. `0` means inspection is not possible.\n\t */\n\tgetInspectPort(tryEnableInspector: boolean): Promise<number>;\n}\n\nexport const enum ActivationKind {\n\tNormal = 0,\n\tImmediate = 1\n}\n\nexport interface WillStopExtensionHostsEvent {\n\n\t/**\n\t * A human readable reason for stopping the extension hosts\n\t * that e.g. can be shown in a confirmation dialog to the\n\t * user.\n\t */\n\treadonly reason: string;\n\n\t/**\n\t * Allows to veto the stopping of extension hosts. The veto can be a long running\n\t * operation.\n\t *\n\t * @param reason a human readable reason for vetoing the extension host stop in case\n\t * where the resolved `value: true`.\n\t */\n\tveto(value: boolean | Promise<boolean>, reason: string): void;\n}\n\nexport interface IExtensionService {\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * An event emitted when extensions are registered after their extension points got handled.\n\t *\n\t * This event will also fire on startup to signal the installed extensions.\n\t *\n\t * @returns the extensions that got registered\n\t */\n\tonDidRegisterExtensions: Event<void>;\n\n\t/**\n\t * @event\n\t * Fired when extensions status changes.\n\t * The event contains the ids of the extensions that have changed.\n\t */\n\tonDidChangeExtensionsStatus: Event<ExtensionIdentifier[]>;\n\n\t/**\n\t * Fired when the available extensions change (i.e. when extensions are added or removed).\n\t */\n\tonDidChangeExtensions: Event<{ readonly added: readonly IExtensionDescription[]; readonly removed: readonly IExtensionDescription[] }>;\n\n\t/**\n\t * All registered extensions.\n\t * - List will be empty initially during workbench startup and will be filled with extensions as they are registered\n\t * - Listen to `onDidChangeExtensions` event for any changes to the extensions list. It will change as extensions get registered or de-reigstered.\n\t * - Listen to `onDidRegisterExtensions` event or wait for `whenInstalledExtensionsRegistered` promise to get the initial list of registered extensions.\n\t */\n\treadonly extensions: readonly IExtensionDescription[];\n\n\t/**\n\t * An event that is fired when activation happens.\n\t */\n\tonWillActivateByEvent: Event<IWillActivateEvent>;\n\n\t/**\n\t * An event that is fired when an extension host changes its\n\t * responsive-state.\n\t */\n\tonDidChangeResponsiveChange: Event<IResponsiveStateChangeEvent>;\n\n\t/**\n\t * Fired before stop of extension hosts happens. Allows listeners to veto against the\n\t * stop to prevent it from happening.\n\t */\n\tonWillStop: Event<WillStopExtensionHostsEvent>;\n\n\t/**\n\t * Send an activation event and activate interested extensions.\n\t *\n\t * This will wait for the normal startup of the extension host(s).\n\t *\n\t * In extraordinary circumstances, if the activation event needs to activate\n\t * one or more extensions before the normal startup is finished, then you can use\n\t * `ActivationKind.Immediate`. Please do not use this flag unless really necessary\n\t * and you understand all consequences.\n\t */\n\tactivateByEvent(activationEvent: string, activationKind?: ActivationKind): Promise<void>;\n\n\t/**\n\t * Determine if `activateByEvent(activationEvent)` has resolved already.\n\t *\n\t * i.e. the activation event is finished and all interested extensions are already active.\n\t */\n\tactivationEventIsDone(activationEvent: string): boolean;\n\n\t/**\n\t * An promise that resolves when the installed extensions are registered after\n\t * their extension points got handled.\n\t */\n\twhenInstalledExtensionsRegistered(): Promise<boolean>;\n\n\t/**\n\t * Return a specific extension\n\t * @param id An extension id\n\t */\n\tgetExtension(id: string): Promise<IExtensionDescription | undefined>;\n\n\t/**\n\t * Returns `true` if the given extension can be added. Otherwise `false`.\n\t * @param extension An extension\n\t */\n\tcanAddExtension(extension: IExtensionDescription): boolean;\n\n\t/**\n\t * Returns `true` if the given extension can be removed. Otherwise `false`.\n\t * @param extension An extension\n\t */\n\tcanRemoveExtension(extension: IExtensionDescription): boolean;\n\n\t/**\n\t * Read all contributions to an extension point.\n\t */\n\treadExtensionPointContributions<T extends IExtensionContributions[keyof IExtensionContributions]>(extPoint: IExtensionPoint<T>): Promise<ExtensionPointContribution<T>[]>;\n\n\t/**\n\t * Get information about extensions status.\n\t */\n\tgetExtensionsStatus(): { [id: string]: IExtensionsStatus };\n\n\t/**\n\t * Return the inspect ports (if inspection is possible) for extension hosts of kind `extensionHostKind`.\n\t */\n\tgetInspectPorts(extensionHostKind: ExtensionHostKind, tryEnableInspector: boolean): Promise<number[]>;\n\n\t/**\n\t * Stops the extension hosts.\n\t *\n\t * @param reason a human readable reason for stopping the extension hosts. This maybe\n\t * can be presented to the user when showing dialogs.\n\t *\n\t * @returns a promise that resolves to `true` if the extension hosts were stopped, `false`\n\t * if the operation was vetoed by listeners of the `onWillStop` event.\n\t */\n\tstopExtensionHosts(reason: string): Promise<boolean>;\n\n\t/**\n\t * Starts the extension hosts.\n\t */\n\tstartExtensionHosts(): Promise<void>;\n\n\t/**\n\t * Modify the environment of the remote extension host\n\t * @param env New properties for the remote extension host\n\t */\n\tsetRemoteEnvironment(env: { [key: string]: string | null }): Promise<void>;\n}\n\nexport interface IInternalExtensionService {\n\t_activateById(extensionId: ExtensionIdentifier, reason: ExtensionActivationReason): Promise<void>;\n\t_onWillActivateExtension(extensionId: ExtensionIdentifier): void;\n\t_onDidActivateExtension(extensionId: ExtensionIdentifier, codeLoadingTime: number, activateCallTime: number, activateResolvedTime: number, activationReason: ExtensionActivationReason): void;\n\t_onDidActivateExtensionError(extensionId: ExtensionIdentifier, error: Error): void;\n\t_onExtensionRuntimeError(extensionId: ExtensionIdentifier, err: Error): void;\n}\n\nexport interface ProfileSession {\n\tstop(): Promise<IExtensionHostProfile>;\n}\n\nexport function toExtension(extensionDescription: IExtensionDescription): IExtension {\n\treturn {\n\t\ttype: extensionDescription.isBuiltin ? ExtensionType.System : ExtensionType.User,\n\t\tisBuiltin: extensionDescription.isBuiltin || extensionDescription.isUserBuiltin,\n\t\tidentifier: { id: getGalleryExtensionId(extensionDescription.publisher, extensionDescription.name), uuid: extensionDescription.uuid },\n\t\tmanifest: extensionDescription,\n\t\tlocation: extensionDescription.extensionLocation,\n\t\ttargetPlatform: extensionDescription.targetPlatform,\n\t\tvalidations: [],\n\t\tisValid: true\n\t};\n}\n\nexport function toExtensionDescription(extension: IExtension, isUnderDevelopment?: boolean): IExtensionDescription {\n\treturn {\n\t\tidentifier: new ExtensionIdentifier(getExtensionId(extension.manifest.publisher, extension.manifest.name)),\n\t\tisBuiltin: extension.type === ExtensionType.System,\n\t\tisUserBuiltin: extension.type === ExtensionType.User && extension.isBuiltin,\n\t\tisUnderDevelopment: !!isUnderDevelopment,\n\t\textensionLocation: extension.location,\n\t\t...extension.manifest,\n\t\tuuid: extension.identifier.uuid,\n\t\ttargetPlatform: extension.targetPlatform\n\t};\n}\n\n\nexport class NullExtensionService implements IExtensionService {\n\tdeclare readonly _serviceBrand: undefined;\n\tonDidRegisterExtensions: Event<void> = Event.None;\n\tonDidChangeExtensionsStatus: Event<ExtensionIdentifier[]> = Event.None;\n\tonDidChangeExtensions = Event.None;\n\tonWillActivateByEvent: Event<IWillActivateEvent> = Event.None;\n\tonDidChangeResponsiveChange: Event<IResponsiveStateChangeEvent> = Event.None;\n\tonWillStop: Event<WillStopExtensionHostsEvent> = Event.None;\n\treadonly extensions = [];\n\tactivateByEvent(_activationEvent: string): Promise<void> { return Promise.resolve(undefined); }\n\tactivationEventIsDone(_activationEvent: string): boolean { return false; }\n\twhenInstalledExtensionsRegistered(): Promise<boolean> { return Promise.resolve(true); }\n\tgetExtension() { return Promise.resolve(undefined); }\n\treadExtensionPointContributions<T>(_extPoint: IExtensionPoint<T>): Promise<ExtensionPointContribution<T>[]> { return Promise.resolve(Object.create(null)); }\n\tgetExtensionsStatus(): { [id: string]: IExtensionsStatus } { return Object.create(null); }\n\tgetInspectPorts(_extensionHostKind: ExtensionHostKind, _tryEnableInspector: boolean): Promise<number[]> { return Promise.resolve([]); }\n\tstopExtensionHosts(): any { }\n\tasync startExtensionHosts(): Promise<void> { }\n\tasync setRemoteEnvironment(_env: { [key: string]: string | null }): Promise<void> { }\n\tcanAddExtension(): boolean { return false; }\n\tcanRemoveExtension(): boolean { return false; }\n}\n"]}