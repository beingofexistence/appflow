{"version":3,"sources":["file:///workspace/appflow/src/vs/workbench/services/extensions/electron-sandbox/extensionHostProfiler.ts"],"names":[],"mappings":"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","file":"extensionHostProfiler.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { TernarySearchTree } from 'vs/base/common/ternarySearchTree';\nimport { IExtensionHostProfile, IExtensionService, ProfileSegmentId, ProfileSession } from 'vs/workbench/services/extensions/common/extensions';\nimport { IExtensionDescription } from 'vs/platform/extensions/common/extensions';\nimport { Schemas } from 'vs/base/common/network';\nimport { URI } from 'vs/base/common/uri';\nimport { IV8InspectProfilingService, IV8Profile, IV8ProfileNode } from 'vs/platform/profiling/common/profiling';\nimport { once } from 'vs/base/common/functional';\n\nexport class ExtensionHostProfiler {\n\n\tconstructor(\n\t\tprivate readonly _port: number,\n\t\t@IExtensionService private readonly _extensionService: IExtensionService,\n\t\t@IV8InspectProfilingService private readonly _profilingService: IV8InspectProfilingService,\n\t) {\n\t}\n\n\tpublic async start(): Promise<ProfileSession> {\n\n\t\tconst id = await this._profilingService.startProfiling({ port: this._port });\n\n\t\treturn {\n\t\t\tstop: once(async () => {\n\t\t\t\tconst profile = await this._profilingService.stopProfiling(id);\n\t\t\t\tawait this._extensionService.whenInstalledExtensionsRegistered();\n\t\t\t\tconst extensions = this._extensionService.extensions;\n\t\t\t\treturn this._distill(profile, extensions);\n\t\t\t})\n\t\t};\n\t}\n\n\tprivate _distill(profile: IV8Profile, extensions: readonly IExtensionDescription[]): IExtensionHostProfile {\n\t\tconst searchTree = TernarySearchTree.forUris<IExtensionDescription>();\n\t\tfor (const extension of extensions) {\n\t\t\tif (extension.extensionLocation.scheme === Schemas.file) {\n\t\t\t\tsearchTree.set(URI.file(extension.extensionLocation.fsPath), extension);\n\t\t\t}\n\t\t}\n\n\t\tconst nodes = profile.nodes;\n\t\tconst idsToNodes = new Map<number, IV8ProfileNode>();\n\t\tconst idsToSegmentId = new Map<number, ProfileSegmentId | null>();\n\t\tfor (const node of nodes) {\n\t\t\tidsToNodes.set(node.id, node);\n\t\t}\n\n\t\tfunction visit(node: IV8ProfileNode, segmentId: ProfileSegmentId | null) {\n\t\t\tif (!segmentId) {\n\t\t\t\tswitch (node.callFrame.functionName) {\n\t\t\t\t\tcase '(root)':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '(program)':\n\t\t\t\t\t\tsegmentId = 'program';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '(garbage collector)':\n\t\t\t\t\t\tsegmentId = 'gc';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tsegmentId = 'self';\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (segmentId === 'self' && node.callFrame.url) {\n\t\t\t\tlet extension: IExtensionDescription | undefined;\n\t\t\t\ttry {\n\t\t\t\t\textension = searchTree.findSubstr(URI.parse(node.callFrame.url));\n\t\t\t\t} catch {\n\t\t\t\t\t// ignore\n\t\t\t\t}\n\t\t\t\tif (extension) {\n\t\t\t\t\tsegmentId = extension.identifier.value;\n\t\t\t\t}\n\t\t\t}\n\t\t\tidsToSegmentId.set(node.id, segmentId);\n\n\t\t\tif (node.children) {\n\t\t\t\tfor (const child of node.children) {\n\t\t\t\t\tconst childNode = idsToNodes.get(child);\n\t\t\t\t\tif (childNode) {\n\t\t\t\t\t\tvisit(childNode, segmentId);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvisit(nodes[0], null);\n\n\t\tconst samples = profile.samples || [];\n\t\tconst timeDeltas = profile.timeDeltas || [];\n\t\tconst distilledDeltas: number[] = [];\n\t\tconst distilledIds: ProfileSegmentId[] = [];\n\n\t\tlet currSegmentTime = 0;\n\t\tlet currSegmentId: string | undefined;\n\t\tfor (let i = 0; i < samples.length; i++) {\n\t\t\tconst id = samples[i];\n\t\t\tconst segmentId = idsToSegmentId.get(id);\n\t\t\tif (segmentId !== currSegmentId) {\n\t\t\t\tif (currSegmentId) {\n\t\t\t\t\tdistilledIds.push(currSegmentId);\n\t\t\t\t\tdistilledDeltas.push(currSegmentTime);\n\t\t\t\t}\n\t\t\t\tcurrSegmentId = segmentId ?? undefined;\n\t\t\t\tcurrSegmentTime = 0;\n\t\t\t}\n\t\t\tcurrSegmentTime += timeDeltas[i];\n\t\t}\n\t\tif (currSegmentId) {\n\t\t\tdistilledIds.push(currSegmentId);\n\t\t\tdistilledDeltas.push(currSegmentTime);\n\t\t}\n\n\t\treturn {\n\t\t\tstartTime: profile.startTime,\n\t\t\tendTime: profile.endTime,\n\t\t\tdeltas: distilledDeltas,\n\t\t\tids: distilledIds,\n\t\t\tdata: profile,\n\t\t\tgetAggregatedTimes: () => {\n\t\t\t\tconst segmentsToTime = new Map<ProfileSegmentId, number>();\n\t\t\t\tfor (let i = 0; i < distilledIds.length; i++) {\n\t\t\t\t\tconst id = distilledIds[i];\n\t\t\t\t\tsegmentsToTime.set(id, (segmentsToTime.get(id) || 0) + distilledDeltas[i]);\n\t\t\t\t}\n\t\t\t\treturn segmentsToTime;\n\t\t\t}\n\t\t};\n\t}\n}\n"]}