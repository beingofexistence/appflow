{"version":3,"sources":["file:///workspace/appflow/src/vs/workbench/services/sharedProcess/electron-sandbox/sharedProcessService.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;;;;;;;;;;IAYzF,IAAM,IAAI,GAAV,MAAM,IAAqB,SAAQ,eAAG;QAQ5C,YACU,QAAgB,EACZ,CAAgC;YAE7C,KAAK,EAAE,CAAC;YAHC,aAAQ,GAAR,QAAQ,CAAQ;YACK,MAAC,GAAD,CAAC,CAAc;YAJ7B,MAAC,GAAiB,IAAI,WAAG,EAAM,CAAC;YAQhD,IAAI,CAAC,CAAC,GAA6B,IAAI,CAAC,CAAC,EAAQ,CAAC;QACnD,CAAC;QAEO,KAAK,CAAC,CAAC;YACd,IAAI,CAAC,CAAC,CAAU,KAAK,CAAC,iCAAiC,CAAC,CAAC;YAEzD,6DAA6D;YAC7D,4DAA4D;YAC5D,4DAA4D;YAC5D,0DAA0D;YAC1D,2DAA2D;YAC3D,iDAAiD;YAEjD,MAAM,OAAO,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC,CAAe,IAAI,EAAE,EAAE,IAAA,WAAG,EAAK,IAAI,CAAC,CAAC,CAAC,CAAC;YAEjE,yDAAyD;YACzD,IAAA,kBAAI,EAAC,+BAA+B,CAAC,CAAC;YACtC,IAAI,CAAC,CAAC,CAAU,KAAK,CAAC,qDAAqD,CAAC,CAAC;YAC7E,MAAM,IAAI,GAAG,MAAM,IAAA,YAAG,EAAS,oBAAI,CAA2B,OAAO,EAAE,oBAAI,CAA2B,QAAQ,CAAC,CAAC;YAChH,IAAA,kBAAI,EAAC,8BAA8B,CAAC,CAAC;YACrC,IAAI,CAAC,CAAC,CAAU,KAAK,CAAC,yDAAyD,CAAC,CAAC;YAEjF,OAAO,IAAI,CAAC,CAAC,CAAS,IAAI,YAAiB,CAAC,IAAI,EAAE,UAAU,IAAI,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC;QAC/E,CAAC;QAED,cAAc;YACb,IAAI,CAAC,IAAI,CAAC,CAAC,CAAe,MAAM,EAAE,EAAE;gBACnC,IAAI,CAAC,CAAC,CAAe,IAAI,EAAE,CAAC;aAC5B;QACF,CAAC;QAED,UAAU,CAAC,WAAmB;YAC7B,OAAO,IAAA,SAAG,EAAe,IAAI,CAAC,CAAC,CAA2B,IAAI,CAAC,UAAU,CAAC,EAAE,CAAC,UAAU,CAAC,UAAU,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;QACnH,CAAC;QAED,eAAe,CAAC,WAAmB,EAAE,OAA+B;YACnE,IAAI,CAAC,CAAC,CAA2B,IAAI,CAAC,UAAU,CAAC,EAAE,CAAC,UAAU,CAAC,eAAe,CAAC,WAAW,EAAE,OAAO,CAAC,CAAC,CAAC;QACvG,CAAC;QAED,KAAK,CAAC,mBAAmB;YAExB,6CAA6C;YAC7C,MAAM,IAAI,CAAC,CAAC,CAA2B;YAEvC,0CAA0C;YAC1C,IAAI,CAAC,CAAC,CAAU,KAAK,CAAC,iEAAiE,CAAC,CAAC;YACzF,MAAM,IAAI,GAAG,MAAM,IAAA,YAAG,EAAS,oBAAI,CAAuB,OAAO,EAAE,oBAAI,CAAuB,QAAQ,CAAC,CAAC;YACxG,IAAI,CAAC,CAAC,CAAU,KAAK,CAAC,qEAAqE,CAAC,CAAC;YAE7F,OAAO,IAAI,CAAC;QACb,CAAC;KACD,CAAA;IAjEY,oBAAI;mBAAJ,IAAI;QAUd,WAAA,SAAG,CAAA;OAVO,IAAI,CAiEhB","file":"sharedProcessService.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Client as MessagePortClient } from 'vs/base/parts/ipc/common/ipc.mp';\nimport { IChannel, IServerChannel, getDelayedChannel } from 'vs/base/parts/ipc/common/ipc';\nimport { ILogService } from 'vs/platform/log/common/log';\nimport { Disposable } from 'vs/base/common/lifecycle';\nimport { ISharedProcessService } from 'vs/platform/ipc/electron-sandbox/services';\nimport { SharedProcessChannelConnection, SharedProcessRawConnection } from 'vs/platform/sharedProcess/common/sharedProcess';\nimport { mark } from 'vs/base/common/performance';\nimport { Barrier, timeout } from 'vs/base/common/async';\nimport { acquirePort } from 'vs/base/parts/ipc/electron-sandbox/ipc.mp';\n\nexport class SharedProcessService extends Disposable implements ISharedProcessService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate readonly withSharedProcessConnection: Promise<MessagePortClient>;\n\n\tprivate readonly restoredBarrier = new Barrier();\n\n\tconstructor(\n\t\treadonly windowId: number,\n\t\t@ILogService private readonly logService: ILogService\n\t) {\n\t\tsuper();\n\n\t\tthis.withSharedProcessConnection = this.connect();\n\t}\n\n\tprivate async connect(): Promise<MessagePortClient> {\n\t\tthis.logService.trace('Renderer->SharedProcess#connect');\n\n\t\t// Our performance tests show that a connection to the shared\n\t\t// process can have significant overhead to the startup time\n\t\t// of the window because the shared process could be created\n\t\t// as a result. As such, make sure we await the `Restored`\n\t\t// phase before making a connection attempt, but also add a\n\t\t// timeout to be safe against possible deadlocks.\n\n\t\tawait Promise.race([this.restoredBarrier.wait(), timeout(2000)]);\n\n\t\t// Acquire a message port connected to the shared process\n\t\tmark('code/willConnectSharedProcess');\n\t\tthis.logService.trace('Renderer->SharedProcess#connect: before acquirePort');\n\t\tconst port = await acquirePort(SharedProcessChannelConnection.request, SharedProcessChannelConnection.response);\n\t\tmark('code/didConnectSharedProcess');\n\t\tthis.logService.trace('Renderer->SharedProcess#connect: connection established');\n\n\t\treturn this._register(new MessagePortClient(port, `window:${this.windowId}`));\n\t}\n\n\tnotifyRestored(): void {\n\t\tif (!this.restoredBarrier.isOpen()) {\n\t\t\tthis.restoredBarrier.open();\n\t\t}\n\t}\n\n\tgetChannel(channelName: string): IChannel {\n\t\treturn getDelayedChannel(this.withSharedProcessConnection.then(connection => connection.getChannel(channelName)));\n\t}\n\n\tregisterChannel(channelName: string, channel: IServerChannel<string>): void {\n\t\tthis.withSharedProcessConnection.then(connection => connection.registerChannel(channelName, channel));\n\t}\n\n\tasync createRawConnection(): Promise<MessagePort> {\n\n\t\t// Await initialization of the shared process\n\t\tawait this.withSharedProcessConnection;\n\n\t\t// Create a new port to the shared process\n\t\tthis.logService.trace('Renderer->SharedProcess#createRawConnection: before acquirePort');\n\t\tconst port = await acquirePort(SharedProcessRawConnection.request, SharedProcessRawConnection.response);\n\t\tthis.logService.trace('Renderer->SharedProcess#createRawConnection: connection established');\n\n\t\treturn port;\n\t}\n}\n"]}