{"version":3,"sources":["file:///workspace/appflow/src/vs/workbench/services/path/common/pathService.ts"],"names":[],"mappings":"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","file":"pathService.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { isValidBasename } from 'vs/base/common/extpath';\nimport { Schemas } from 'vs/base/common/network';\nimport { IPath, win32, posix } from 'vs/base/common/path';\nimport { OperatingSystem, OS } from 'vs/base/common/platform';\nimport { basename } from 'vs/base/common/resources';\nimport { URI } from 'vs/base/common/uri';\nimport { createDecorator } from 'vs/platform/instantiation/common/instantiation';\nimport { getVirtualWorkspaceScheme } from 'vs/platform/workspace/common/virtualWorkspace';\nimport { IWorkspaceContextService } from 'vs/platform/workspace/common/workspace';\nimport { IWorkbenchEnvironmentService } from 'vs/workbench/services/environment/common/environmentService';\nimport { IRemoteAgentService } from 'vs/workbench/services/remote/common/remoteAgentService';\n\nexport const IPathService = createDecorator<IPathService>('pathService');\n\n/**\n * Provides access to path related properties that will match the\n * environment. If the environment is connected to a remote, the\n * path properties will match that of the remotes operating system.\n */\nexport interface IPathService {\n\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * The correct path library to use for the target environment. If\n\t * the environment is connected to a remote, this will be the\n\t * path library of the remote file system. Otherwise it will be\n\t * the local file system's path library depending on the OS.\n\t */\n\treadonly path: Promise<IPath>;\n\n\t/**\n\t * Determines the best default URI scheme for the current workspace.\n\t * It uses information about whether we're running remote, in browser,\n\t * or native combined with information about the current workspace to\n\t * find the best default scheme.\n\t */\n\treadonly defaultUriScheme: string;\n\n\t/**\n\t * Converts the given path to a file URI to use for the target\n\t * environment. If the environment is connected to a remote, it\n\t * will use the path separators according to the remote file\n\t * system. Otherwise it will use the local file system's path\n\t * separators.\n\t */\n\tfileURI(path: string): Promise<URI>;\n\n\t/**\n\t * Resolves the user-home directory for the target environment.\n\t * If the envrionment is connected to a remote, this will be the\n\t * remote's user home directory, otherwise the local one unless\n\t * `preferLocal` is set to `true`.\n\t */\n\tuserHome(options: { preferLocal: true }): URI;\n\tuserHome(options?: { preferLocal: boolean }): Promise<URI>;\n\n\t/**\n\t * Figures out if the provided resource has a valid file name\n\t * for the operating system the file is saved to.\n\t *\n\t * Note: this currently only supports `file` and `vscode-file`\n\t * protocols where we know the limits of the file systems behind\n\t * these OS. Other remotes are not supported and this method\n\t * will always return `true` for them.\n\t */\n\thasValidBasename(resource: URI, basename?: string): Promise<boolean>;\n\thasValidBasename(resource: URI, os: OperatingSystem, basename?: string): boolean;\n\n\t/**\n\t * @deprecated use `userHome` instead.\n\t */\n\treadonly resolvedUserHome: URI | undefined;\n}\n\nexport abstract class AbstractPathService implements IPathService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate resolveOS: Promise<OperatingSystem>;\n\n\tprivate resolveUserHome: Promise<URI>;\n\tprivate maybeUnresolvedUserHome: URI | undefined;\n\n\tconstructor(\n\t\tprivate localUserHome: URI,\n\t\t@IRemoteAgentService private readonly remoteAgentService: IRemoteAgentService,\n\t\t@IWorkbenchEnvironmentService private readonly environmentService: IWorkbenchEnvironmentService,\n\t\t@IWorkspaceContextService private contextService: IWorkspaceContextService\n\t) {\n\n\t\t// OS\n\t\tthis.resolveOS = (async () => {\n\t\t\tconst env = await this.remoteAgentService.getEnvironment();\n\n\t\t\treturn env?.os || OS;\n\t\t})();\n\n\t\t// User Home\n\t\tthis.resolveUserHome = (async () => {\n\t\t\tconst env = await this.remoteAgentService.getEnvironment();\n\t\t\tconst userHome = this.maybeUnresolvedUserHome = env?.userHome ?? localUserHome;\n\n\t\t\treturn userHome;\n\t\t})();\n\t}\n\n\thasValidBasename(resource: URI, basename?: string): Promise<boolean>;\n\thasValidBasename(resource: URI, os: OperatingSystem, basename?: string): boolean;\n\thasValidBasename(resource: URI, arg2?: string | OperatingSystem, basename?: string): boolean | Promise<boolean> {\n\n\t\t// async version\n\t\tif (typeof arg2 === 'string' || typeof arg2 === 'undefined') {\n\t\t\treturn this.resolveOS.then(os => this.doHasValidBasename(resource, os, arg2));\n\t\t}\n\n\t\t// sync version\n\t\treturn this.doHasValidBasename(resource, arg2, basename);\n\t}\n\n\tprivate doHasValidBasename(resource: URI, os: OperatingSystem, name?: string): boolean {\n\n\t\t// Our `isValidBasename` method only works with our\n\t\t// standard schemes for files on disk, either locally\n\t\t// or remote.\n\t\tif (resource.scheme === Schemas.file || resource.scheme === Schemas.vscodeRemote) {\n\t\t\treturn isValidBasename(name ?? basename(resource), os === OperatingSystem.Windows);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tget defaultUriScheme(): string {\n\t\treturn AbstractPathService.findDefaultUriScheme(this.environmentService, this.contextService);\n\t}\n\n\tstatic findDefaultUriScheme(environmentService: IWorkbenchEnvironmentService, contextService: IWorkspaceContextService): string {\n\t\tif (environmentService.remoteAuthority) {\n\t\t\treturn Schemas.vscodeRemote;\n\t\t}\n\n\t\tconst virtualWorkspace = getVirtualWorkspaceScheme(contextService.getWorkspace());\n\t\tif (virtualWorkspace) {\n\t\t\treturn virtualWorkspace;\n\t\t}\n\n\t\tconst firstFolder = contextService.getWorkspace().folders[0];\n\t\tif (firstFolder) {\n\t\t\treturn firstFolder.uri.scheme;\n\t\t}\n\n\t\tconst configuration = contextService.getWorkspace().configuration;\n\t\tif (configuration) {\n\t\t\treturn configuration.scheme;\n\t\t}\n\n\t\treturn Schemas.file;\n\t}\n\n\tuserHome(options?: { preferLocal: boolean }): Promise<URI>;\n\tuserHome(options: { preferLocal: true }): URI;\n\tuserHome(options?: { preferLocal: boolean }): Promise<URI> | URI {\n\t\treturn options?.preferLocal ? this.localUserHome : this.resolveUserHome;\n\t}\n\n\tget resolvedUserHome(): URI | undefined {\n\t\treturn this.maybeUnresolvedUserHome;\n\t}\n\n\tget path(): Promise<IPath> {\n\t\treturn this.resolveOS.then(os => {\n\t\t\treturn os === OperatingSystem.Windows ?\n\t\t\t\twin32 :\n\t\t\t\tposix;\n\t\t});\n\t}\n\n\tasync fileURI(_path: string): Promise<URI> {\n\t\tlet authority = '';\n\n\t\t// normalize to fwd-slashes on windows,\n\t\t// on other systems bwd-slashes are valid\n\t\t// filename character, eg /f\\oo/ba\\r.txt\n\t\tconst os = await this.resolveOS;\n\t\tif (os === OperatingSystem.Windows) {\n\t\t\t_path = _path.replace(/\\\\/g, '/');\n\t\t}\n\n\t\t// check for authority as used in UNC shares\n\t\t// or use the path as given\n\t\tif (_path[0] === '/' && _path[1] === '/') {\n\t\t\tconst idx = _path.indexOf('/', 2);\n\t\t\tif (idx === -1) {\n\t\t\t\tauthority = _path.substring(2);\n\t\t\t\t_path = '/';\n\t\t\t} else {\n\t\t\t\tauthority = _path.substring(2, idx);\n\t\t\t\t_path = _path.substring(idx) || '/';\n\t\t\t}\n\t\t}\n\n\t\treturn URI.from({\n\t\t\tscheme: Schemas.file,\n\t\t\tauthority,\n\t\t\tpath: _path,\n\t\t\tquery: '',\n\t\t\tfragment: ''\n\t\t});\n\t}\n}\n"]}