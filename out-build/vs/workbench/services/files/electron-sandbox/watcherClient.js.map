{"version":3,"sources":["file:///workspace/appflow/src/vs/workbench/services/files/electron-sandbox/watcherClient.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;IAOhG,MAAa,IAAuB,SAAQ,aAAG;QAE9C,YACC,aAAmD,EACnD,YAAwC,EACxC,cAAuB,EACN,CAA0C;YAE3D,KAAK,CAAC,aAAa,EAAE,YAAY,EAAE,cAAc,CAAC,CAAC;YAFlC,MAAC,GAAD,CAAC,CAAyC;YAI3D,IAAI,CAAC,CAAC,EAAK,CAAC;QACb,CAAC;QAEkB,CAAC,CAAa,WAAgB;YAChD,MAAM,OAAO,GAAG,kBAAY,CAAC,SAAS,CAAoB,IAAA,SAAG,EAAe,CAAC,KAAK,IAAI,EAAE;gBAEvF,uDAAuD;gBACvD,EAAE;gBACF,sDAAsD;gBACtD,wDAAwD;gBACxD,mCAAmC;gBACnC,EAAE;gBACF,2DAA2D;gBAC3D,+DAA+D;gBAC/D,MAAM,EAAE,MAAM,EAAE,cAAc,EAAE,GAAG,MAAM,IAAI,CAAC,CAAC,CAAoC,YAAY,CAAC;oBAC/F,QAAQ,EAAE,4CAA4C;oBACtD,IAAI,EAAE,aAAa;iBACnB,CAAC,CAAC;gBAEH,yDAAyD;gBACzD,wDAAwD;gBACxD,wDAAwD;gBAExD,cAAc,CAAC,IAAI,CAAC,CAAC,EAAE,MAAM,EAAE,EAAE,EAAE;oBAClC,IAAI,MAAM,EAAE,IAAI,KAAK,CAAC,EAAE;wBACvB,IAAI,CAAC,CAAC,CAAK,kCAAkC,MAAM,CAAC,IAAI,aAAa,MAAM,CAAC,MAAM,EAAE,CAAC,CAAC;qBACtF;yBAAM;wBACN,IAAI,CAAC,CAAC,CAAO,+CAA+C,MAAM,EAAE,IAAI,aAAa,MAAM,EAAE,MAAM,EAAE,CAAC,CAAC;qBACvG;gBACF,CAAC,CAAC,CAAC;gBAEH,OAAO,MAAM,CAAC,UAAU,CAAC,SAAS,CAAC,CAAC;YACrC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;YAEP,sDAAsD;YACtD,qDAAqD;YACrD,sDAAsD;YACtD,8BAA8B;YAC9B,oDAAoD;YACpD,WAAW,CAAC,GAAG,CAAC,IAAA,eAAG,EAAU,GAAG,EAAE,CAAC,OAAO,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;YAEpD,OAAO,OAAO,CAAC;QAChB,CAAC;KACD;IArDD,oBAqDC","file":"watcherClient.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { DisposableStore, toDisposable } from 'vs/base/common/lifecycle';\nimport { getDelayedChannel, ProxyChannel } from 'vs/base/parts/ipc/common/ipc';\nimport { AbstractUniversalWatcherClient, IDiskFileChange, ILogMessage, IRecursiveWatcher } from 'vs/platform/files/common/watcher';\nimport { IUtilityProcessWorkerWorkbenchService } from 'vs/workbench/services/utilityProcess/electron-sandbox/utilityProcessWorkerWorkbenchService';\n\nexport class UniversalWatcherClient extends AbstractUniversalWatcherClient {\n\n\tconstructor(\n\t\tonFileChanges: (changes: IDiskFileChange[]) => void,\n\t\tonLogMessage: (msg: ILogMessage) => void,\n\t\tverboseLogging: boolean,\n\t\tprivate readonly utilityProcessWorkerWorkbenchService: IUtilityProcessWorkerWorkbenchService\n\t) {\n\t\tsuper(onFileChanges, onLogMessage, verboseLogging);\n\n\t\tthis.init();\n\t}\n\n\tprotected override createWatcher(disposables: DisposableStore): IRecursiveWatcher {\n\t\tconst watcher = ProxyChannel.toService<IRecursiveWatcher>(getDelayedChannel((async () => {\n\n\t\t\t// Acquire universal watcher via utility process worker\n\t\t\t//\n\t\t\t// We explicitly do not add the worker as a disposable\n\t\t\t// because we need to call `stop` on disposal to prevent\n\t\t\t// a crash on shutdown (see below).\n\t\t\t//\n\t\t\t// The utility process worker services ensures to terminate\n\t\t\t// the process automatically when the window closes or reloads.\n\t\t\tconst { client, onDidTerminate } = await this.utilityProcessWorkerWorkbenchService.createWorker({\n\t\t\t\tmoduleId: 'vs/platform/files/node/watcher/watcherMain',\n\t\t\t\ttype: 'fileWatcher'\n\t\t\t});\n\n\t\t\t// React on unexpected termination of the watcher process\n\t\t\t// by listening to the `onDidTerminate` event. We do not\n\t\t\t// consider an exit code of `0` as abnormal termination.\n\n\t\t\tonDidTerminate.then(({ reason }) => {\n\t\t\t\tif (reason?.code === 0) {\n\t\t\t\t\tthis.trace(`terminated by itself with code ${reason.code}, signal: ${reason.signal}`);\n\t\t\t\t} else {\n\t\t\t\t\tthis.onError(`terminated by itself unexpectedly with code ${reason?.code}, signal: ${reason?.signal}`);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn client.getChannel('watcher');\n\t\t})()));\n\n\t\t// Looks like universal watcher needs an explicit stop\n\t\t// to prevent access on data structures after process\n\t\t// exit. This only seem to be happening when used from\n\t\t// Electron, not pure node.js.\n\t\t// https://github.com/microsoft/vscode/issues/136264\n\t\tdisposables.add(toDisposable(() => watcher.stop()));\n\n\t\treturn watcher;\n\t}\n}\n"]}