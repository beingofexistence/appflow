{"version":3,"sources":["file:///workspace/appflow/src/vs/workbench/services/workingCopy/common/workingCopyEditorService.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;;;;;;;;;;IAWnF,QAAA,GAAG,GAAyB,IAAA,mBAAG,EAAwC,0BAA0B,CAAC,CAAC;IAyCzG,IAAM,GAAG,GAAT,MAAM,GAAyB,SAAQ,eAAG;QAShD,YAA4B,CAAmC;YAC9D,KAAK,EAAE,CAAC;YADoC,MAAC,GAAD,CAAC,CAAiB;YAL9C,MAAC,GAAuB,IAAI,CAAC,CAAC,CAAS,IAAI,WAAG,EAAiC,CAAC,CAAC;YACzF,yBAAoB,GAAG,IAAI,CAAC,CAAC,CAAqB,KAAK,CAAC;YAEhD,MAAC,GAAU,IAAI,GAAG,EAA6B,CAAC;QAIjE,CAAC;QAED,eAAe,CAAC,OAAkC;YAEjD,oCAAoC;YACpC,IAAI,CAAC,CAAC,CAAQ,GAAG,CAAC,OAAO,CAAC,CAAC;YAC3B,IAAI,CAAC,CAAC,CAAqB,IAAI,CAAC,OAAO,CAAC,CAAC;YAEzC,OAAO,IAAA,eAAG,EAAU,GAAG,EAAE,CAAC,IAAI,CAAC,CAAC,CAAQ,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC;QAC1D,CAAC;QAED,UAAU,CAAC,WAAyB;YACnC,KAAK,MAAM,gBAAgB,IAAI,IAAI,CAAC,CAAC,CAAa,UAAU,2CAAmC,EAAE;gBAChG,IAAI,IAAI,CAAC,CAAC,CAAM,WAAW,EAAE,gBAAgB,CAAC,MAAM,CAAC,EAAE;oBACtD,OAAO,gBAAgB,CAAC;iBACxB;aACD;YAED,OAAO,SAAS,CAAC;QAClB,CAAC;QAEO,CAAC,CAAM,WAAyB,EAAE,MAAW;YACpD,KAAK,MAAM,OAAO,IAAI,IAAI,CAAC,CAAC,EAAS;gBACpC,IAAI,OAAO,CAAC,MAAM,CAAC,WAAW,EAAE,MAAM,CAAC,EAAE;oBACxC,OAAO,IAAI,CAAC;iBACZ;aACD;YAED,OAAO,KAAK,CAAC;QACd,CAAC;KACD,CAAA;IAzCY,kBAAG;kBAAH,GAAG;QASF,WAAA,mBAAG,CAAA;OATJ,GAAG,CAyCf;IAED,mBAAmB;IACnB,IAAA,gBAAG,EAAe,WAAG,EAAwB,GAAG,oCAAiD,CAAC","file":"workingCopyEditorService.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { createDecorator } from 'vs/platform/instantiation/common/instantiation';\nimport { InstantiationType, registerSingleton } from 'vs/platform/instantiation/common/extensions';\nimport { EditorsOrder, IEditorIdentifier } from 'vs/workbench/common/editor';\nimport { EditorInput } from 'vs/workbench/common/editor/editorInput';\nimport { IWorkingCopy, IWorkingCopyIdentifier } from 'vs/workbench/services/workingCopy/common/workingCopy';\nimport { Disposable, IDisposable, toDisposable } from 'vs/base/common/lifecycle';\nimport { IEditorService } from 'vs/workbench/services/editor/common/editorService';\n\nexport const IWorkingCopyEditorService = createDecorator<IWorkingCopyEditorService>('workingCopyEditorService');\n\nexport interface IWorkingCopyEditorHandler {\n\n\t/**\n\t * Whether the handler is capable of opening the specific backup in\n\t * an editor.\n\t */\n\thandles(workingCopy: IWorkingCopyIdentifier): boolean | Promise<boolean>;\n\n\t/**\n\t * Whether the provided working copy is opened in the provided editor.\n\t */\n\tisOpen(workingCopy: IWorkingCopyIdentifier, editor: EditorInput): boolean;\n\n\t/**\n\t * Create an editor that is suitable of opening the provided working copy.\n\t */\n\tcreateEditor(workingCopy: IWorkingCopyIdentifier): EditorInput | Promise<EditorInput>;\n}\n\nexport interface IWorkingCopyEditorService {\n\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * An event fired whenever a handler is registered.\n\t */\n\treadonly onDidRegisterHandler: Event<IWorkingCopyEditorHandler>;\n\n\t/**\n\t * Register a handler to the working copy editor service.\n\t */\n\tregisterHandler(handler: IWorkingCopyEditorHandler): IDisposable;\n\n\t/**\n\t * Finds the first editor that can handle the provided working copy.\n\t */\n\tfindEditor(workingCopy: IWorkingCopy): IEditorIdentifier | undefined;\n}\n\nexport class WorkingCopyEditorService extends Disposable implements IWorkingCopyEditorService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate readonly _onDidRegisterHandler = this._register(new Emitter<IWorkingCopyEditorHandler>());\n\treadonly onDidRegisterHandler = this._onDidRegisterHandler.event;\n\n\tprivate readonly handlers = new Set<IWorkingCopyEditorHandler>();\n\n\tconstructor(@IEditorService private readonly editorService: IEditorService) {\n\t\tsuper();\n\t}\n\n\tregisterHandler(handler: IWorkingCopyEditorHandler): IDisposable {\n\n\t\t// Add to registry and emit as event\n\t\tthis.handlers.add(handler);\n\t\tthis._onDidRegisterHandler.fire(handler);\n\n\t\treturn toDisposable(() => this.handlers.delete(handler));\n\t}\n\n\tfindEditor(workingCopy: IWorkingCopy): IEditorIdentifier | undefined {\n\t\tfor (const editorIdentifier of this.editorService.getEditors(EditorsOrder.MOST_RECENTLY_ACTIVE)) {\n\t\t\tif (this.isOpen(workingCopy, editorIdentifier.editor)) {\n\t\t\t\treturn editorIdentifier;\n\t\t\t}\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tprivate isOpen(workingCopy: IWorkingCopy, editor: EditorInput): boolean {\n\t\tfor (const handler of this.handlers) {\n\t\t\tif (handler.isOpen(workingCopy, editor)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n}\n\n// Register Service\nregisterSingleton(IWorkingCopyEditorService, WorkingCopyEditorService, InstantiationType.Delayed);\n"]}