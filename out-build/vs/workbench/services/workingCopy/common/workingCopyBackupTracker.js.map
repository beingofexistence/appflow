{"version":3,"sources":["file:///workspace/appflow/src/vs/workbench/services/workingCopy/common/workingCopyBackupTracker.ts"],"names":[],"mappings":"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","file":"workingCopyBackupTracker.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IWorkingCopyBackupService } from 'vs/workbench/services/workingCopy/common/workingCopyBackup';\nimport { Disposable, IDisposable, toDisposable } from 'vs/base/common/lifecycle';\nimport { IWorkingCopyService } from 'vs/workbench/services/workingCopy/common/workingCopyService';\nimport { IWorkingCopy, IWorkingCopyIdentifier, WorkingCopyCapabilities } from 'vs/workbench/services/workingCopy/common/workingCopy';\nimport { ILogService } from 'vs/platform/log/common/log';\nimport { ShutdownReason, ILifecycleService, LifecyclePhase, InternalBeforeShutdownEvent } from 'vs/workbench/services/lifecycle/common/lifecycle';\nimport { CancellationTokenSource } from 'vs/base/common/cancellation';\nimport { AutoSaveMode, IFilesConfigurationService } from 'vs/workbench/services/filesConfiguration/common/filesConfigurationService';\nimport { IWorkingCopyEditorHandler, IWorkingCopyEditorService } from 'vs/workbench/services/workingCopy/common/workingCopyEditorService';\nimport { Promises } from 'vs/base/common/async';\nimport { IEditorService } from 'vs/workbench/services/editor/common/editorService';\nimport { EditorsOrder } from 'vs/workbench/common/editor';\nimport { EditorInput } from 'vs/workbench/common/editor/editorInput';\nimport { IEditorGroupsService } from 'vs/workbench/services/editor/common/editorGroupsService';\n\n/**\n * The working copy backup tracker deals with:\n * - restoring backups that exist\n * - creating backups for modified working copies\n * - deleting backups for saved working copies\n * - handling backups on shutdown\n */\nexport abstract class WorkingCopyBackupTracker extends Disposable {\n\n\tconstructor(\n\t\tprotected readonly workingCopyBackupService: IWorkingCopyBackupService,\n\t\tprotected readonly workingCopyService: IWorkingCopyService,\n\t\tprotected readonly logService: ILogService,\n\t\tprivate readonly lifecycleService: ILifecycleService,\n\t\tprotected readonly filesConfigurationService: IFilesConfigurationService,\n\t\tprivate readonly workingCopyEditorService: IWorkingCopyEditorService,\n\t\tprotected readonly editorService: IEditorService,\n\t\tprivate readonly editorGroupService: IEditorGroupsService\n\t) {\n\t\tsuper();\n\n\t\t// Fill in initial modified working copies\n\t\tfor (const workingCopy of this.workingCopyService.modifiedWorkingCopies) {\n\t\t\tthis.onDidRegister(workingCopy);\n\t\t}\n\n\t\tthis.registerListeners();\n\t}\n\n\tprivate registerListeners() {\n\n\t\t// Working Copy events\n\t\tthis._register(this.workingCopyService.onDidRegister(workingCopy => this.onDidRegister(workingCopy)));\n\t\tthis._register(this.workingCopyService.onDidUnregister(workingCopy => this.onDidUnregister(workingCopy)));\n\t\tthis._register(this.workingCopyService.onDidChangeDirty(workingCopy => this.onDidChangeDirty(workingCopy)));\n\t\tthis._register(this.workingCopyService.onDidChangeContent(workingCopy => this.onDidChangeContent(workingCopy)));\n\n\t\t// Lifecycle\n\t\tthis._register(this.lifecycleService.onBeforeShutdown(event => (event as InternalBeforeShutdownEvent).finalVeto(() => this.onFinalBeforeShutdown(event.reason), 'veto.backups')));\n\t\tthis._register(this.lifecycleService.onWillShutdown(() => this.onWillShutdown()));\n\n\t\t// Once a handler registers, restore backups\n\t\tthis._register(this.workingCopyEditorService.onDidRegisterHandler(handler => this.restoreBackups(handler)));\n\t}\n\n\tprotected abstract onFinalBeforeShutdown(reason: ShutdownReason): boolean | Promise<boolean>;\n\n\tprivate onWillShutdown(): void {\n\n\t\t// Here we know that we will shutdown. Any backup operation that is\n\t\t// already scheduled or being scheduled from this moment on runs\n\t\t// at the risk of corrupting a backup because the backup operation\n\t\t// might terminate at any given time now. As such, we need to disable\n\t\t// this tracker from performing more backups by cancelling pending\n\t\t// operations and suspending the tracker without resuming.\n\n\t\tthis.cancelBackupOperations();\n\t\tthis.suspendBackupOperations();\n\t}\n\n\n\t//#region Backup Creator\n\n\t// Delay creation of backups when content changes to avoid too much\n\t// load on the backup service when the user is typing into the editor\n\t// Since we always schedule a backup, even when auto save is on, we\n\t// have different scheduling delays based on auto save. This helps to\n\t// avoid a (not critical but also not really wanted) race between saving\n\t// (after 1s per default) and making a backup of the working copy.\n\tprivate static readonly DEFAULT_BACKUP_SCHEDULE_DELAYS = {\n\t\t[AutoSaveMode.OFF]: 1000,\n\t\t[AutoSaveMode.ON_FOCUS_CHANGE]: 1000,\n\t\t[AutoSaveMode.ON_WINDOW_CHANGE]: 1000,\n\t\t[AutoSaveMode.AFTER_SHORT_DELAY]: 2000, // explicitly higher to prevent races\n\t\t[AutoSaveMode.AFTER_LONG_DELAY]: 1000\n\t};\n\n\t// A map from working copy to a version ID we compute on each content\n\t// change. This version ID allows to e.g. ask if a backup for a specific\n\t// content has been made before closing.\n\tprivate readonly mapWorkingCopyToContentVersion = new Map<IWorkingCopy, number>();\n\n\t// A map of scheduled pending backup operations for working copies\n\t// Given https://github.com/microsoft/vscode/issues/158038, we explicitly\n\t// do not store `IWorkingCopy` but the identifier in the map, since it\n\t// looks like GC is not running for the working copy otherwise.\n\tprotected readonly pendingBackupOperations = new Map<IWorkingCopyIdentifier, { disposable: IDisposable; cancel: () => void }>();\n\n\tprivate suspended = false;\n\n\tprivate onDidRegister(workingCopy: IWorkingCopy): void {\n\t\tif (this.suspended) {\n\t\t\tthis.logService.warn(`[backup tracker] suspended, ignoring register event`, workingCopy.resource.toString(), workingCopy.typeId);\n\t\t\treturn;\n\t\t}\n\n\t\tif (workingCopy.isModified()) {\n\t\t\tthis.scheduleBackup(workingCopy);\n\t\t}\n\t}\n\n\tprivate onDidUnregister(workingCopy: IWorkingCopy): void {\n\n\t\t// Remove from content version map\n\t\tthis.mapWorkingCopyToContentVersion.delete(workingCopy);\n\n\t\t// Check suspended\n\t\tif (this.suspended) {\n\t\t\tthis.logService.warn(`[backup tracker] suspended, ignoring unregister event`, workingCopy.resource.toString(), workingCopy.typeId);\n\t\t\treturn;\n\t\t}\n\n\t\t// Discard backup\n\t\tthis.discardBackup(workingCopy);\n\t}\n\n\tprivate onDidChangeDirty(workingCopy: IWorkingCopy): void {\n\t\tif (this.suspended) {\n\t\t\tthis.logService.warn(`[backup tracker] suspended, ignoring dirty change event`, workingCopy.resource.toString(), workingCopy.typeId);\n\t\t\treturn;\n\t\t}\n\n\t\tif (workingCopy.isDirty()) {\n\t\t\tthis.scheduleBackup(workingCopy);\n\t\t} else {\n\t\t\tthis.discardBackup(workingCopy);\n\t\t}\n\t}\n\n\tprivate onDidChangeContent(workingCopy: IWorkingCopy): void {\n\n\t\t// Increment content version ID\n\t\tconst contentVersionId = this.getContentVersion(workingCopy);\n\t\tthis.mapWorkingCopyToContentVersion.set(workingCopy, contentVersionId + 1);\n\n\t\t// Check suspended\n\t\tif (this.suspended) {\n\t\t\tthis.logService.warn(`[backup tracker] suspended, ignoring content change event`, workingCopy.resource.toString(), workingCopy.typeId);\n\t\t\treturn;\n\t\t}\n\n\t\t// Schedule backup for modified working copies\n\t\tif (workingCopy.isModified()) {\n\t\t\t// this listener will make sure that the backup is\n\t\t\t// pushed out for as long as the user is still changing\n\t\t\t// the content of the working copy.\n\t\t\tthis.scheduleBackup(workingCopy);\n\t\t}\n\t}\n\n\tprivate scheduleBackup(workingCopy: IWorkingCopy): void {\n\n\t\t// Clear any running backup operation\n\t\tthis.cancelBackupOperation(workingCopy);\n\n\t\tthis.logService.trace(`[backup tracker] scheduling backup`, workingCopy.resource.toString(), workingCopy.typeId);\n\n\t\t// Schedule new backup\n\t\tconst workingCopyIdentifier = { resource: workingCopy.resource, typeId: workingCopy.typeId };\n\t\tconst cts = new CancellationTokenSource();\n\t\tconst handle = setTimeout(async () => {\n\t\t\tif (cts.token.isCancellationRequested) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Backup if modified\n\t\t\tif (workingCopy.isModified()) {\n\t\t\t\tthis.logService.trace(`[backup tracker] creating backup`, workingCopy.resource.toString(), workingCopy.typeId);\n\n\t\t\t\ttry {\n\t\t\t\t\tconst backup = await workingCopy.backup(cts.token);\n\t\t\t\t\tif (cts.token.isCancellationRequested) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (workingCopy.isModified()) {\n\t\t\t\t\t\tthis.logService.trace(`[backup tracker] storing backup`, workingCopy.resource.toString(), workingCopy.typeId);\n\n\t\t\t\t\t\tawait this.workingCopyBackupService.backup(workingCopy, backup.content, this.getContentVersion(workingCopy), backup.meta, cts.token);\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthis.logService.error(error);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Clear disposable unless we got canceled which would\n\t\t\t// indicate another operation has started meanwhile\n\t\t\tif (!cts.token.isCancellationRequested) {\n\t\t\t\tthis.doClearPendingBackupOperation(workingCopyIdentifier);\n\t\t\t}\n\t\t}, this.getBackupScheduleDelay(workingCopy));\n\n\t\t// Keep in map for disposal as needed\n\t\tthis.pendingBackupOperations.set(workingCopyIdentifier, {\n\t\t\tcancel: () => {\n\t\t\t\tthis.logService.trace(`[backup tracker] clearing pending backup creation`, workingCopy.resource.toString(), workingCopy.typeId);\n\n\t\t\t\tcts.cancel();\n\t\t\t},\n\t\t\tdisposable: toDisposable(() => {\n\t\t\t\tcts.dispose();\n\t\t\t\tclearTimeout(handle);\n\t\t\t})\n\t\t});\n\t}\n\n\tprotected getBackupScheduleDelay(workingCopy: IWorkingCopy): number {\n\t\tif (typeof workingCopy.backupDelay === 'number') {\n\t\t\treturn workingCopy.backupDelay; // respect working copy override\n\t\t}\n\n\t\tlet autoSaveMode = this.filesConfigurationService.getAutoSaveMode();\n\t\tif (workingCopy.capabilities & WorkingCopyCapabilities.Untitled) {\n\t\t\tautoSaveMode = AutoSaveMode.OFF; // auto-save is never on for untitled working copies\n\t\t}\n\n\t\treturn WorkingCopyBackupTracker.DEFAULT_BACKUP_SCHEDULE_DELAYS[autoSaveMode];\n\t}\n\n\tprotected getContentVersion(workingCopy: IWorkingCopy): number {\n\t\treturn this.mapWorkingCopyToContentVersion.get(workingCopy) || 0;\n\t}\n\n\tprivate discardBackup(workingCopy: IWorkingCopy): void {\n\n\t\t// Clear any running backup operation\n\t\tthis.cancelBackupOperation(workingCopy);\n\n\t\t// Schedule backup discard asap\n\t\tconst workingCopyIdentifier = { resource: workingCopy.resource, typeId: workingCopy.typeId };\n\t\tconst cts = new CancellationTokenSource();\n\t\tthis.doDiscardBackup(workingCopyIdentifier, cts);\n\n\t\t// Keep in map for disposal as needed\n\t\tthis.pendingBackupOperations.set(workingCopyIdentifier, {\n\t\t\tcancel: () => {\n\t\t\t\tthis.logService.trace(`[backup tracker] clearing pending backup discard`, workingCopy.resource.toString(), workingCopy.typeId);\n\n\t\t\t\tcts.cancel();\n\t\t\t},\n\t\t\tdisposable: cts\n\t\t});\n\t}\n\n\tprivate async doDiscardBackup(workingCopyIdentifier: IWorkingCopyIdentifier, cts: CancellationTokenSource) {\n\t\tthis.logService.trace(`[backup tracker] discarding backup`, workingCopyIdentifier.resource.toString(), workingCopyIdentifier.typeId);\n\n\t\t// Discard backup\n\t\ttry {\n\t\t\tawait this.workingCopyBackupService.discardBackup(workingCopyIdentifier, cts.token);\n\t\t} catch (error) {\n\t\t\tthis.logService.error(error);\n\t\t}\n\n\t\t// Clear disposable unless we got canceled which would\n\t\t// indicate another operation has started meanwhile\n\t\tif (!cts.token.isCancellationRequested) {\n\t\t\tthis.doClearPendingBackupOperation(workingCopyIdentifier);\n\t\t}\n\t}\n\n\tprivate cancelBackupOperation(workingCopy: IWorkingCopy): void {\n\n\t\t// Given a working copy we want to find the matching\n\t\t// identifier in our pending operations map because\n\t\t// we cannot use the working copy directly, as the\n\t\t// identifier might have different object identity.\n\n\t\tlet workingCopyIdentifier: IWorkingCopyIdentifier | undefined = undefined;\n\t\tfor (const [identifier] of this.pendingBackupOperations) {\n\t\t\tif (identifier.resource.toString() === workingCopy.resource.toString() && identifier.typeId === workingCopy.typeId) {\n\t\t\t\tworkingCopyIdentifier = identifier;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (workingCopyIdentifier) {\n\t\t\tthis.doClearPendingBackupOperation(workingCopyIdentifier, { cancel: true });\n\t\t}\n\t}\n\n\tprivate doClearPendingBackupOperation(workingCopyIdentifier: IWorkingCopyIdentifier, options?: { cancel: boolean }): void {\n\t\tconst pendingBackupOperation = this.pendingBackupOperations.get(workingCopyIdentifier);\n\t\tif (!pendingBackupOperation) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (options?.cancel) {\n\t\t\tpendingBackupOperation.cancel();\n\t\t}\n\n\t\tpendingBackupOperation.disposable.dispose();\n\n\t\tthis.pendingBackupOperations.delete(workingCopyIdentifier);\n\t}\n\n\tprotected cancelBackupOperations(): void {\n\t\tfor (const [, operation] of this.pendingBackupOperations) {\n\t\t\toperation.cancel();\n\t\t\toperation.disposable.dispose();\n\t\t}\n\n\t\tthis.pendingBackupOperations.clear();\n\t}\n\n\tprotected suspendBackupOperations(): { resume: () => void } {\n\t\tthis.suspended = true;\n\n\t\treturn { resume: () => this.suspended = false };\n\t}\n\n\t//#endregion\n\n\n\t//#region Backup Restorer\n\n\tprotected readonly unrestoredBackups = new Set<IWorkingCopyIdentifier>();\n\tprotected readonly whenReady = this.resolveBackupsToRestore();\n\n\tprivate _isReady = false;\n\tprotected get isReady(): boolean { return this._isReady; }\n\n\tprivate async resolveBackupsToRestore(): Promise<void> {\n\n\t\t// Wait for resolving backups until we are restored to reduce startup pressure\n\t\tawait this.lifecycleService.when(LifecyclePhase.Restored);\n\n\t\t// Remember each backup that needs to restore\n\t\tfor (const backup of await this.workingCopyBackupService.getBackups()) {\n\t\t\tthis.unrestoredBackups.add(backup);\n\t\t}\n\n\t\tthis._isReady = true;\n\t}\n\n\tprotected async restoreBackups(handler: IWorkingCopyEditorHandler): Promise<void> {\n\n\t\t// Wait for backups to be resolved\n\t\tawait this.whenReady;\n\n\t\t// Figure out already opened editors for backups vs\n\t\t// non-opened.\n\t\tconst openedEditorsForBackups = new Set<EditorInput>();\n\t\tconst nonOpenedEditorsForBackups = new Set<EditorInput>();\n\n\t\t// Ensure each backup that can be handled has an\n\t\t// associated editor.\n\t\tconst restoredBackups = new Set<IWorkingCopyIdentifier>();\n\t\tfor (const unrestoredBackup of this.unrestoredBackups) {\n\t\t\tconst canHandleUnrestoredBackup = await handler.handles(unrestoredBackup);\n\t\t\tif (!canHandleUnrestoredBackup) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Collect already opened editors for backup\n\t\t\tlet hasOpenedEditorForBackup = false;\n\t\t\tfor (const { editor } of this.editorService.getEditors(EditorsOrder.MOST_RECENTLY_ACTIVE)) {\n\t\t\t\tconst isUnrestoredBackupOpened = handler.isOpen(unrestoredBackup, editor);\n\t\t\t\tif (isUnrestoredBackupOpened) {\n\t\t\t\t\topenedEditorsForBackups.add(editor);\n\t\t\t\t\thasOpenedEditorForBackup = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Otherwise, make sure to create at least one editor\n\t\t\t// for the backup to show\n\t\t\tif (!hasOpenedEditorForBackup) {\n\t\t\t\tnonOpenedEditorsForBackups.add(await handler.createEditor(unrestoredBackup));\n\t\t\t}\n\n\t\t\t// Remember as (potentially) restored\n\t\t\trestoredBackups.add(unrestoredBackup);\n\t\t}\n\n\t\t// Ensure editors are opened for each backup without editor\n\t\t// in the background without stealing focus\n\t\tif (nonOpenedEditorsForBackups.size > 0) {\n\t\t\tawait this.editorGroupService.activeGroup.openEditors([...nonOpenedEditorsForBackups].map(nonOpenedEditorForBackup => ({\n\t\t\t\teditor: nonOpenedEditorForBackup,\n\t\t\t\toptions: {\n\t\t\t\t\tpinned: true,\n\t\t\t\t\tpreserveFocus: true,\n\t\t\t\t\tinactive: true\n\t\t\t\t}\n\t\t\t})));\n\n\t\t\tfor (const nonOpenedEditorForBackup of nonOpenedEditorsForBackups) {\n\t\t\t\topenedEditorsForBackups.add(nonOpenedEditorForBackup);\n\t\t\t}\n\t\t}\n\n\t\t// Then, resolve each opened editor to make sure the working copy\n\t\t// is loaded and the modified editor appears properly.\n\t\t// We only do that for editors that are not active in a group\n\t\t// already to prevent calling `resolve` twice!\n\t\tawait Promises.settled([...openedEditorsForBackups].map(async openedEditorForBackup => {\n\t\t\tif (this.editorService.isVisible(openedEditorForBackup)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\treturn openedEditorForBackup.resolve();\n\t\t}));\n\n\t\t// Finally, remove all handled backups from the list\n\t\tfor (const restoredBackup of restoredBackups) {\n\t\t\tthis.unrestoredBackups.delete(restoredBackup);\n\t\t}\n\t}\n\n\t//#endregion\n}\n"]}