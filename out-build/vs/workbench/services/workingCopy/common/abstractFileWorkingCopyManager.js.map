{"version":3,"sources":["file:///workspace/appflow/src/vs/workbench/services/workingCopy/common/abstractFileWorkingCopyManager.ts"],"names":[],"mappings":"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","file":"abstractFileWorkingCopyManager.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { Disposable, dispose, IDisposable } from 'vs/base/common/lifecycle';\nimport { ResourceMap } from 'vs/base/common/map';\nimport { Promises } from 'vs/base/common/async';\nimport { IFileService } from 'vs/platform/files/common/files';\nimport { URI } from 'vs/base/common/uri';\nimport { ILogService } from 'vs/platform/log/common/log';\nimport { IWorkingCopyBackupService } from 'vs/workbench/services/workingCopy/common/workingCopyBackup';\nimport { IFileWorkingCopy, IFileWorkingCopyModel } from 'vs/workbench/services/workingCopy/common/fileWorkingCopy';\n\nexport interface IBaseFileWorkingCopyManager<M extends IFileWorkingCopyModel, W extends IFileWorkingCopy<M>> extends IDisposable {\n\n\t/**\n\t * An event for when a file working copy was created.\n\t */\n\treadonly onDidCreate: Event<W>;\n\n\t/**\n\t * Access to all known file working copies within the manager.\n\t */\n\treadonly workingCopies: readonly W[];\n\n\t/**\n\t * Returns the file working copy for the provided resource\n\t * or `undefined` if none.\n\t */\n\tget(resource: URI): W | undefined;\n\n\t/**\n\t * Disposes all working copies of the manager and disposes the manager. This\n\t * method is different from `dispose` in that it will unregister any working\n\t * copy from the `IWorkingCopyService`. Since this impact things like backups,\n\t * the method is `async` because it needs to trigger `save` for any dirty\n\t * working copy to preserve the data.\n\t *\n\t * Callers should make sure to e.g. close any editors associated with the\n\t * working copy.\n\t */\n\tdestroy(): Promise<void>;\n}\n\nexport abstract class BaseFileWorkingCopyManager<M extends IFileWorkingCopyModel, W extends IFileWorkingCopy<M>> extends Disposable implements IBaseFileWorkingCopyManager<M, W> {\n\n\tprivate readonly _onDidCreate = this._register(new Emitter<W>());\n\treadonly onDidCreate = this._onDidCreate.event;\n\n\tprivate readonly mapResourceToWorkingCopy = new ResourceMap<W>();\n\tprivate readonly mapResourceToDisposeListener = new ResourceMap<IDisposable>();\n\n\tconstructor(\n\t\t@IFileService protected readonly fileService: IFileService,\n\t\t@ILogService protected readonly logService: ILogService,\n\t\t@IWorkingCopyBackupService protected readonly workingCopyBackupService: IWorkingCopyBackupService\n\t) {\n\t\tsuper();\n\t}\n\n\tprotected has(resource: URI): boolean {\n\t\treturn this.mapResourceToWorkingCopy.has(resource);\n\t}\n\n\tprotected add(resource: URI, workingCopy: W): void {\n\t\tconst knownWorkingCopy = this.get(resource);\n\t\tif (knownWorkingCopy === workingCopy) {\n\t\t\treturn; // already cached\n\t\t}\n\n\t\t// Add to our working copy map\n\t\tthis.mapResourceToWorkingCopy.set(resource, workingCopy);\n\n\t\t// Update our dispose listener to remove it on dispose\n\t\tthis.mapResourceToDisposeListener.get(resource)?.dispose();\n\t\tthis.mapResourceToDisposeListener.set(resource, workingCopy.onWillDispose(() => this.remove(resource)));\n\n\t\t// Signal creation event\n\t\tthis._onDidCreate.fire(workingCopy);\n\t}\n\n\tprotected remove(resource: URI): boolean {\n\n\t\t// Dispose any existing listener\n\t\tconst disposeListener = this.mapResourceToDisposeListener.get(resource);\n\t\tif (disposeListener) {\n\t\t\tdispose(disposeListener);\n\t\t\tthis.mapResourceToDisposeListener.delete(resource);\n\t\t}\n\n\t\t// Remove from our working copy map\n\t\treturn this.mapResourceToWorkingCopy.delete(resource);\n\t}\n\n\t//#region Get / Get all\n\n\tget workingCopies(): W[] {\n\t\treturn [...this.mapResourceToWorkingCopy.values()];\n\t}\n\n\tget(resource: URI): W | undefined {\n\t\treturn this.mapResourceToWorkingCopy.get(resource);\n\t}\n\n\t//#endregion\n\n\t//#region Lifecycle\n\n\toverride dispose(): void {\n\t\tsuper.dispose();\n\n\t\t// Clear working copy caches\n\t\t//\n\t\t// Note: we are not explicitly disposing the working copies\n\t\t// known to the manager because this can have unwanted side\n\t\t// effects such as backups getting discarded once the working\n\t\t// copy unregisters. We have an explicit `destroy`\n\t\t// for that purpose (https://github.com/microsoft/vscode/pull/123555)\n\t\t//\n\t\tthis.mapResourceToWorkingCopy.clear();\n\n\t\t// Dispose the dispose listeners\n\t\tdispose(this.mapResourceToDisposeListener.values());\n\t\tthis.mapResourceToDisposeListener.clear();\n\t}\n\n\tasync destroy(): Promise<void> {\n\n\t\t// Make sure all dirty working copies are saved to disk\n\t\ttry {\n\t\t\tawait Promises.settled(this.workingCopies.map(async workingCopy => {\n\t\t\t\tif (workingCopy.isDirty()) {\n\t\t\t\t\tawait this.saveWithFallback(workingCopy);\n\t\t\t\t}\n\t\t\t}));\n\t\t} catch (error) {\n\t\t\tthis.logService.error(error);\n\t\t}\n\n\t\t// Dispose all working copies\n\t\tdispose(this.mapResourceToWorkingCopy.values());\n\n\t\t// Finally dispose manager\n\t\tthis.dispose();\n\t}\n\n\tprivate async saveWithFallback(workingCopy: W): Promise<void> {\n\n\t\t// First try regular save\n\t\tlet saveSuccess = false;\n\t\ttry {\n\t\t\tsaveSuccess = await workingCopy.save();\n\t\t} catch (error) {\n\t\t\t// Ignore\n\t\t}\n\n\t\t// Then fallback to backup if that exists\n\t\tif (!saveSuccess || workingCopy.isDirty()) {\n\t\t\tconst backup = await this.workingCopyBackupService.resolve(workingCopy);\n\t\t\tif (backup) {\n\t\t\t\tawait this.fileService.writeFile(workingCopy.resource, backup.value, { unlock: true });\n\t\t\t}\n\t\t}\n\t}\n\n\t//#endregion\n}\n"]}