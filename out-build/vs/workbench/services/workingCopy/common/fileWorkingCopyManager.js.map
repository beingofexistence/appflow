{"version":3,"sources":["vs/workbench/services/workingCopy/common/fileWorkingCopyManager.ts"],"names":[],"mappings":"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","file":"fileWorkingCopyManager.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { localize } from 'vs/nls';\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { Promises } from 'vs/base/common/async';\nimport { VSBufferReadableStream } from 'vs/base/common/buffer';\nimport { CancellationToken } from 'vs/base/common/cancellation';\nimport { Disposable } from 'vs/base/common/lifecycle';\nimport { toLocalResource, joinPath, isEqual, basename, dirname } from 'vs/base/common/resources';\nimport { URI } from 'vs/base/common/uri';\nimport { IFileDialogService, IDialogService } from 'vs/platform/dialogs/common/dialogs';\nimport { IFileService } from 'vs/platform/files/common/files';\nimport { ISaveOptions, SaveSourceRegistry } from 'vs/workbench/common/editor';\nimport { IWorkbenchEnvironmentService } from 'vs/workbench/services/environment/common/environmentService';\nimport { IPathService } from 'vs/workbench/services/path/common/pathService';\nimport { IUriIdentityService } from 'vs/platform/uriIdentity/common/uriIdentity';\nimport { IStoredFileWorkingCopy, IStoredFileWorkingCopyModel, IStoredFileWorkingCopyModelFactory, IStoredFileWorkingCopyResolveOptions, StoredFileWorkingCopyState } from 'vs/workbench/services/workingCopy/common/storedFileWorkingCopy';\nimport { StoredFileWorkingCopyManager, IStoredFileWorkingCopyManager, IStoredFileWorkingCopyManagerResolveOptions } from 'vs/workbench/services/workingCopy/common/storedFileWorkingCopyManager';\nimport { IUntitledFileWorkingCopy, IUntitledFileWorkingCopyModel, IUntitledFileWorkingCopyModelFactory, UntitledFileWorkingCopy } from 'vs/workbench/services/workingCopy/common/untitledFileWorkingCopy';\nimport { INewOrExistingUntitledFileWorkingCopyOptions, INewUntitledFileWorkingCopyOptions, INewUntitledFileWorkingCopyWithAssociatedResourceOptions, IUntitledFileWorkingCopyManager, UntitledFileWorkingCopyManager } from 'vs/workbench/services/workingCopy/common/untitledFileWorkingCopyManager';\nimport { IWorkingCopyFileService } from 'vs/workbench/services/workingCopy/common/workingCopyFileService';\nimport { IBaseFileWorkingCopyManager } from 'vs/workbench/services/workingCopy/common/abstractFileWorkingCopyManager';\nimport { IFileWorkingCopy } from 'vs/workbench/services/workingCopy/common/fileWorkingCopy';\nimport { ILabelService } from 'vs/platform/label/common/label';\nimport { ILogService } from 'vs/platform/log/common/log';\nimport { INotificationService } from 'vs/platform/notification/common/notification';\nimport { IEditorService } from 'vs/workbench/services/editor/common/editorService';\nimport { IElevatedFileService } from 'vs/workbench/services/files/common/elevatedFileService';\nimport { IFilesConfigurationService } from 'vs/workbench/services/filesConfiguration/common/filesConfigurationService';\nimport { ILifecycleService } from 'vs/workbench/services/lifecycle/common/lifecycle';\nimport { IWorkingCopyBackupService } from 'vs/workbench/services/workingCopy/common/workingCopyBackup';\nimport { IWorkingCopyEditorService } from 'vs/workbench/services/workingCopy/common/workingCopyEditorService';\nimport { IWorkingCopyService } from 'vs/workbench/services/workingCopy/common/workingCopyService';\nimport { Schemas } from 'vs/base/common/network';\nimport { IDecorationData, IDecorationsProvider, IDecorationsService } from 'vs/workbench/services/decorations/common/decorations';\nimport { Codicon } from 'vs/base/common/codicons';\nimport { listErrorForeground } from 'vs/platform/theme/common/colorRegistry';\n\nexport interface IFileWorkingCopyManager<S extends IStoredFileWorkingCopyModel, U extends IUntitledFileWorkingCopyModel> extends IBaseFileWorkingCopyManager<S | U, IFileWorkingCopy<S | U>> {\n\n\t/**\n\t * Provides access to the manager for stored file working copies.\n\t */\n\treadonly stored: IStoredFileWorkingCopyManager<S>;\n\n\t/**\n\t * Provides access to the manager for untitled file working copies.\n\t */\n\treadonly untitled: IUntitledFileWorkingCopyManager<U>;\n\n\t/**\n\t * Allows to resolve a stored file working copy. If the manager already knows\n\t * about a stored file working copy with the same `URI`, it will return that\n\t * existing stored file working copy. There will never be more than one\n\t * stored file working copy per `URI` until the stored file working copy is\n\t * disposed.\n\t *\n\t * Use the `IStoredFileWorkingCopyResolveOptions.reload` option to control the\n\t * behaviour for when a stored file working copy was previously already resolved\n\t * with regards to resolving it again from the underlying file resource\n\t * or not.\n\t *\n\t * Note: Callers must `dispose` the working copy when no longer needed.\n\t *\n\t * @param resource used as unique identifier of the stored file working copy in\n\t * case one is already known for this `URI`.\n\t * @param options\n\t */\n\tresolve(resource: URI, options?: IStoredFileWorkingCopyManagerResolveOptions): Promise<IStoredFileWorkingCopy<S>>;\n\n\t/**\n\t * Create a new untitled file working copy with optional initial contents.\n\t *\n\t * Note: Callers must `dispose` the working copy when no longer needed.\n\t */\n\tresolve(options?: INewUntitledFileWorkingCopyOptions): Promise<IUntitledFileWorkingCopy<U>>;\n\n\t/**\n\t * Create a new untitled file working copy with optional initial contents\n\t * and associated resource. The associated resource will be used when\n\t * saving and will not require to ask the user for a file path.\n\t *\n\t * Note: Callers must `dispose` the working copy when no longer needed.\n\t */\n\tresolve(options?: INewUntitledFileWorkingCopyWithAssociatedResourceOptions): Promise<IUntitledFileWorkingCopy<U>>;\n\n\t/**\n\t * Creates a new untitled file working copy with optional initial contents\n\t * with the provided resource or return an existing untitled file working\n\t * copy otherwise.\n\t *\n\t * Note: Callers must `dispose` the working copy when no longer needed.\n\t */\n\tresolve(options?: INewOrExistingUntitledFileWorkingCopyOptions): Promise<IUntitledFileWorkingCopy<U>>;\n\n\t/**\n\t * Implements \"Save As\" for file based working copies. The API is `URI` based\n\t * because it works even without resolved file working copies. If a file working\n\t * copy exists for any given `URI`, the implementation will deal with them properly\n\t * (e.g. dirty contents of the source will be written to the target and the source\n\t * will be reverted).\n\t *\n\t * Note: it is possible that the returned file working copy has a different `URI`\n\t * than the `target` that was passed in. Based on URI identity, the file working\n\t * copy may chose to return an existing file working copy with different casing\n\t * to respect file systems that are case insensitive.\n\t *\n\t * Note: Callers must `dispose` the working copy when no longer needed.\n\t *\n\t * Note: Untitled file working copies are being disposed when saved.\n\t *\n\t * @param source the source resource to save as\n\t * @param target the optional target resource to save to. if not defined, the user\n\t * will be asked for input\n\t * @returns the target stored working copy that was saved to or `undefined` in case of\n\t * cancellation\n\t */\n\tsaveAs(source: URI, target: URI, options?: ISaveOptions): Promise<IStoredFileWorkingCopy<S> | undefined>;\n\tsaveAs(source: URI, target: undefined, options?: IFileWorkingCopySaveAsOptions): Promise<IStoredFileWorkingCopy<S> | undefined>;\n}\n\nexport interface IFileWorkingCopySaveAsOptions extends ISaveOptions {\n\n\t/**\n\t * Optional target resource to suggest to the user in case\n\t * no target resource is provided to save to.\n\t */\n\tsuggestedTarget?: URI;\n}\n\nexport class FileWorkingCopyManager<S extends IStoredFileWorkingCopyModel, U extends IUntitledFileWorkingCopyModel> extends Disposable implements IFileWorkingCopyManager<S, U> {\n\n\treadonly onDidCreate: Event<IFileWorkingCopy<S | U>>;\n\n\tprivate static readonly FILE_WORKING_COPY_SAVE_CREATE_SOURCE = SaveSourceRegistry.registerSource('fileWorkingCopyCreate.source', localize('fileWorkingCopyCreate.source', \"File Created\"));\n\tprivate static readonly FILE_WORKING_COPY_SAVE_REPLACE_SOURCE = SaveSourceRegistry.registerSource('fileWorkingCopyReplace.source', localize('fileWorkingCopyReplace.source', \"File Replaced\"));\n\n\treadonly stored: IStoredFileWorkingCopyManager<S>;\n\treadonly untitled: IUntitledFileWorkingCopyManager<U>;\n\n\tconstructor(\n\t\tprivate readonly workingCopyTypeId: string,\n\t\tprivate readonly storedWorkingCopyModelFactory: IStoredFileWorkingCopyModelFactory<S>,\n\t\tprivate readonly untitledWorkingCopyModelFactory: IUntitledFileWorkingCopyModelFactory<U>,\n\t\t@IFileService private readonly fileService: IFileService,\n\t\t@ILifecycleService lifecycleService: ILifecycleService,\n\t\t@ILabelService labelService: ILabelService,\n\t\t@ILogService private readonly logService: ILogService,\n\t\t@IWorkingCopyFileService private readonly workingCopyFileService: IWorkingCopyFileService,\n\t\t@IWorkingCopyBackupService workingCopyBackupService: IWorkingCopyBackupService,\n\t\t@IUriIdentityService private readonly uriIdentityService: IUriIdentityService,\n\t\t@IFileDialogService private readonly fileDialogService: IFileDialogService,\n\t\t@IFilesConfigurationService filesConfigurationService: IFilesConfigurationService,\n\t\t@IWorkingCopyService workingCopyService: IWorkingCopyService,\n\t\t@INotificationService notificationService: INotificationService,\n\t\t@IWorkingCopyEditorService workingCopyEditorService: IWorkingCopyEditorService,\n\t\t@IEditorService editorService: IEditorService,\n\t\t@IElevatedFileService elevatedFileService: IElevatedFileService,\n\t\t@IPathService private readonly pathService: IPathService,\n\t\t@IWorkbenchEnvironmentService private readonly environmentService: IWorkbenchEnvironmentService,\n\t\t@IDialogService private readonly dialogService: IDialogService,\n\t\t@IDecorationsService private readonly decorationsService: IDecorationsService\n\t) {\n\t\tsuper();\n\n\t\t// Stored file working copies manager\n\t\tthis.stored = this._register(new StoredFileWorkingCopyManager(\n\t\t\tthis.workingCopyTypeId,\n\t\t\tthis.storedWorkingCopyModelFactory,\n\t\t\tfileService, lifecycleService, labelService, logService, workingCopyFileService,\n\t\t\tworkingCopyBackupService, uriIdentityService, filesConfigurationService, workingCopyService,\n\t\t\tnotificationService, workingCopyEditorService, editorService, elevatedFileService\n\t\t));\n\n\t\t// Untitled file working copies manager\n\t\tthis.untitled = this._register(new UntitledFileWorkingCopyManager(\n\t\t\tthis.workingCopyTypeId,\n\t\t\tthis.untitledWorkingCopyModelFactory,\n\t\t\tasync (workingCopy, options) => {\n\t\t\t\tconst result = await this.saveAs(workingCopy.resource, undefined, options);\n\n\t\t\t\treturn result ? true : false;\n\t\t\t},\n\t\t\tfileService, labelService, logService, workingCopyBackupService, workingCopyService\n\t\t));\n\n\t\t// Events\n\t\tthis.onDidCreate = Event.any<IFileWorkingCopy<S | U>>(this.stored.onDidCreate, this.untitled.onDidCreate);\n\n\t\t// Decorations\n\t\tthis.provideDecorations();\n\t}\n\n\t//#region decorations\n\n\tprivate provideDecorations(): void {\n\n\t\t// File working copy decorations\n\t\tconst provider = this._register(new class extends Disposable implements IDecorationsProvider {\n\n\t\t\treadonly label = localize('fileWorkingCopyDecorations', \"File Working Copy Decorations\");\n\n\t\t\tprivate readonly _onDidChange = this._register(new Emitter<URI[]>());\n\t\t\treadonly onDidChange = this._onDidChange.event;\n\n\t\t\tconstructor(private readonly stored: IStoredFileWorkingCopyManager<S>) {\n\t\t\t\tsuper();\n\n\t\t\t\tthis.registerListeners();\n\t\t\t}\n\n\t\t\tprivate registerListeners(): void {\n\n\t\t\t\t// Creates\n\t\t\t\tthis._register(this.stored.onDidResolve(workingCopy => {\n\t\t\t\t\tif (workingCopy.isReadonly() || workingCopy.hasState(StoredFileWorkingCopyState.ORPHAN)) {\n\t\t\t\t\t\tthis._onDidChange.fire([workingCopy.resource]);\n\t\t\t\t\t}\n\t\t\t\t}));\n\n\t\t\t\t// Removals: once a stored working copy is no longer\n\t\t\t\t// under our control, make sure to signal this as\n\t\t\t\t// decoration change because from this point on we\n\t\t\t\t// have no way of updating the decoration anymore.\n\t\t\t\tthis._register(this.stored.onDidRemove(workingCopyUri => this._onDidChange.fire([workingCopyUri])));\n\n\t\t\t\t// Changes\n\t\t\t\tthis._register(this.stored.onDidChangeReadonly(workingCopy => this._onDidChange.fire([workingCopy.resource])));\n\t\t\t\tthis._register(this.stored.onDidChangeOrphaned(workingCopy => this._onDidChange.fire([workingCopy.resource])));\n\t\t\t}\n\n\t\t\tprovideDecorations(uri: URI): IDecorationData | undefined {\n\t\t\t\tconst workingCopy = this.stored.get(uri);\n\t\t\t\tif (!workingCopy || workingCopy.isDisposed()) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\tconst isReadonly = workingCopy.isReadonly();\n\t\t\t\tconst isOrphaned = workingCopy.hasState(StoredFileWorkingCopyState.ORPHAN);\n\n\t\t\t\t// Readonly + Orphaned\n\t\t\t\tif (isReadonly && isOrphaned) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tcolor: listErrorForeground,\n\t\t\t\t\t\tletter: Codicon.lockSmall,\n\t\t\t\t\t\tstrikethrough: true,\n\t\t\t\t\t\ttooltip: localize('readonlyAndDeleted', \"Deleted, Read-only\"),\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t// Readonly\n\t\t\t\telse if (isReadonly) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tletter: Codicon.lockSmall,\n\t\t\t\t\t\ttooltip: localize('readonly', \"Read-only\"),\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t// Orphaned\n\t\t\t\telse if (isOrphaned) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tcolor: listErrorForeground,\n\t\t\t\t\t\tstrikethrough: true,\n\t\t\t\t\t\ttooltip: localize('deleted', \"Deleted\"),\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t}(this.stored));\n\n\t\tthis._register(this.decorationsService.registerDecorationsProvider(provider));\n\t}\n\n\t//#endregin\n\n\t//#region get / get all\n\n\tget workingCopies(): (IUntitledFileWorkingCopy<U> | IStoredFileWorkingCopy<S>)[] {\n\t\treturn [...this.stored.workingCopies, ...this.untitled.workingCopies];\n\t}\n\n\tget(resource: URI): IUntitledFileWorkingCopy<U> | IStoredFileWorkingCopy<S> | undefined {\n\t\treturn this.stored.get(resource) ?? this.untitled.get(resource);\n\t}\n\n\t//#endregion\n\n\t//#region resolve\n\n\tresolve(options?: INewUntitledFileWorkingCopyOptions): Promise<IUntitledFileWorkingCopy<U>>;\n\tresolve(options?: INewUntitledFileWorkingCopyWithAssociatedResourceOptions): Promise<IUntitledFileWorkingCopy<U>>;\n\tresolve(options?: INewOrExistingUntitledFileWorkingCopyOptions): Promise<IUntitledFileWorkingCopy<U>>;\n\tresolve(resource: URI, options?: IStoredFileWorkingCopyResolveOptions): Promise<IStoredFileWorkingCopy<S>>;\n\tresolve(arg1?: URI | INewUntitledFileWorkingCopyOptions | INewUntitledFileWorkingCopyWithAssociatedResourceOptions | INewOrExistingUntitledFileWorkingCopyOptions, arg2?: IStoredFileWorkingCopyResolveOptions): Promise<IUntitledFileWorkingCopy<U> | IStoredFileWorkingCopy<S>> {\n\t\tif (URI.isUri(arg1)) {\n\n\t\t\t// Untitled: via untitled manager\n\t\t\tif (arg1.scheme === Schemas.untitled) {\n\t\t\t\treturn this.untitled.resolve({ untitledResource: arg1 });\n\t\t\t}\n\n\t\t\t// else: via stored file manager\n\t\t\telse {\n\t\t\t\treturn this.stored.resolve(arg1, arg2);\n\t\t\t}\n\t\t}\n\n\t\treturn this.untitled.resolve(arg1);\n\t}\n\n\t//#endregion\n\n\t//#region Save\n\n\tasync saveAs(source: URI, target?: URI, options?: IFileWorkingCopySaveAsOptions): Promise<IStoredFileWorkingCopy<S> | undefined> {\n\n\t\t// Get to target resource\n\t\tif (!target) {\n\t\t\tconst workingCopy = this.get(source);\n\t\t\tif (workingCopy instanceof UntitledFileWorkingCopy && workingCopy.hasAssociatedFilePath) {\n\t\t\t\ttarget = await this.suggestSavePath(source);\n\t\t\t} else {\n\t\t\t\ttarget = await this.fileDialogService.pickFileToSave(await this.suggestSavePath(options?.suggestedTarget ?? source), options?.availableFileSystems);\n\t\t\t}\n\t\t}\n\n\t\tif (!target) {\n\t\t\treturn; // user canceled\n\t\t}\n\n\t\t// Just save if target is same as working copies own resource\n\t\t// and we are not saving an untitled file working copy\n\t\tif (this.fileService.hasProvider(source) && isEqual(source, target)) {\n\t\t\treturn this.doSave(source, { ...options, force: true  /* force to save, even if not dirty (https://github.com/microsoft/vscode/issues/99619) */ });\n\t\t}\n\n\t\t// If the target is different but of same identity, we\n\t\t// move the source to the target, knowing that the\n\t\t// underlying file system cannot have both and then save.\n\t\t// However, this will only work if the source exists\n\t\t// and is not orphaned, so we need to check that too.\n\t\tif (this.fileService.hasProvider(source) && this.uriIdentityService.extUri.isEqual(source, target) && (await this.fileService.exists(source))) {\n\n\t\t\t// Move via working copy file service to enable participants\n\t\t\tawait this.workingCopyFileService.move([{ file: { source, target } }], CancellationToken.None);\n\n\t\t\t// At this point we don't know whether we have a\n\t\t\t// working copy for the source or the target URI so we\n\t\t\t// simply try to save with both resources.\n\t\t\treturn (await this.doSave(source, options)) ?? (await this.doSave(target, options));\n\t\t}\n\n\t\t// Perform normal \"Save As\"\n\t\treturn this.doSaveAs(source, target, options);\n\t}\n\n\tprivate async doSave(resource: URI, options?: ISaveOptions): Promise<IStoredFileWorkingCopy<S> | undefined> {\n\n\t\t// Save is only possible with stored file working copies,\n\t\t// any other have to go via `saveAs` flow.\n\t\tconst storedFileWorkingCopy = this.stored.get(resource);\n\t\tif (storedFileWorkingCopy) {\n\t\t\tconst success = await storedFileWorkingCopy.save(options);\n\t\t\tif (success) {\n\t\t\t\treturn storedFileWorkingCopy;\n\t\t\t}\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tprivate async doSaveAs(source: URI, target: URI, options?: IFileWorkingCopySaveAsOptions): Promise<IStoredFileWorkingCopy<S> | undefined> {\n\t\tlet sourceContents: VSBufferReadableStream;\n\n\t\t// If the source is an existing file working copy, we can directly\n\t\t// use that to copy the contents to the target destination\n\t\tconst sourceWorkingCopy = this.get(source);\n\t\tif (sourceWorkingCopy?.isResolved()) {\n\t\t\tsourceContents = await sourceWorkingCopy.model.snapshot(CancellationToken.None);\n\t\t}\n\n\t\t// Otherwise we resolve the contents from the underlying file\n\t\telse {\n\t\t\tsourceContents = (await this.fileService.readFileStream(source)).value;\n\t\t}\n\n\t\t// Resolve target\n\t\tconst { targetFileExists, targetStoredFileWorkingCopy } = await this.doResolveSaveTarget(source, target);\n\n\t\t// Confirm to overwrite if we have an untitled file working copy with associated path where\n\t\t// the file actually exists on disk and we are instructed to save to that file path.\n\t\t// This can happen if the file was created after the untitled file was opened.\n\t\t// See https://github.com/microsoft/vscode/issues/67946\n\t\tif (\n\t\t\tsourceWorkingCopy instanceof UntitledFileWorkingCopy &&\n\t\t\tsourceWorkingCopy.hasAssociatedFilePath &&\n\t\t\ttargetFileExists &&\n\t\t\tthis.uriIdentityService.extUri.isEqual(target, toLocalResource(sourceWorkingCopy.resource, this.environmentService.remoteAuthority, this.pathService.defaultUriScheme))\n\t\t) {\n\t\t\tconst overwrite = await this.confirmOverwrite(target);\n\t\t\tif (!overwrite) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t}\n\n\t\t// Take over content from source to target\n\t\tawait targetStoredFileWorkingCopy.model?.update(sourceContents, CancellationToken.None);\n\n\t\t// Set source options depending on target exists or not\n\t\tif (!options?.source) {\n\t\t\toptions = {\n\t\t\t\t...options,\n\t\t\t\tsource: targetFileExists ? FileWorkingCopyManager.FILE_WORKING_COPY_SAVE_REPLACE_SOURCE : FileWorkingCopyManager.FILE_WORKING_COPY_SAVE_CREATE_SOURCE\n\t\t\t};\n\t\t}\n\n\t\t// Save target\n\t\tconst success = await targetStoredFileWorkingCopy.save({ ...options, force: true  /* force to save, even if not dirty (https://github.com/microsoft/vscode/issues/99619) */ });\n\t\tif (!success) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Revert the source\n\t\ttry {\n\t\t\tawait sourceWorkingCopy?.revert();\n\t\t} catch (error) {\n\n\t\t\t// It is possible that reverting the source fails, for example\n\t\t\t// when a remote is disconnected and we cannot read it anymore.\n\t\t\t// However, this should not interrupt the \"Save As\" flow, so\n\t\t\t// we gracefully catch the error and just log it.\n\n\t\t\tthis.logService.error(error);\n\t\t}\n\n\t\treturn targetStoredFileWorkingCopy;\n\t}\n\n\tprivate async doResolveSaveTarget(source: URI, target: URI): Promise<{ targetFileExists: boolean; targetStoredFileWorkingCopy: IStoredFileWorkingCopy<S> }> {\n\n\t\t// Prefer an existing stored file working copy if it is already resolved\n\t\t// for the given target resource\n\t\tlet targetFileExists = false;\n\t\tlet targetStoredFileWorkingCopy = this.stored.get(target);\n\t\tif (targetStoredFileWorkingCopy?.isResolved()) {\n\t\t\ttargetFileExists = true;\n\t\t}\n\n\t\t// Otherwise create the target working copy empty if\n\t\t// it does not exist already and resolve it from there\n\t\telse {\n\t\t\ttargetFileExists = await this.fileService.exists(target);\n\n\t\t\t// Create target file adhoc if it does not exist yet\n\t\t\tif (!targetFileExists) {\n\t\t\t\tawait this.workingCopyFileService.create([{ resource: target }], CancellationToken.None);\n\t\t\t}\n\n\t\t\t// At this point we need to resolve the target working copy\n\t\t\t// and we have to do an explicit check if the source URI\n\t\t\t// equals the target via URI identity. If they match and we\n\t\t\t// have had an existing working copy with the source, we\n\t\t\t// prefer that one over resolving the target. Otherwise we\n\t\t\t// would potentially introduce a\n\t\t\tif (this.uriIdentityService.extUri.isEqual(source, target) && this.get(source)) {\n\t\t\t\ttargetStoredFileWorkingCopy = await this.stored.resolve(source);\n\t\t\t} else {\n\t\t\t\ttargetStoredFileWorkingCopy = await this.stored.resolve(target);\n\t\t\t}\n\t\t}\n\n\t\treturn { targetFileExists, targetStoredFileWorkingCopy };\n\t}\n\n\tprivate async confirmOverwrite(resource: URI): Promise<boolean> {\n\t\tconst { confirmed } = await this.dialogService.confirm({\n\t\t\ttype: 'warning',\n\t\t\tmessage: localize('confirmOverwrite', \"'{0}' already exists. Do you want to replace it?\", basename(resource)),\n\t\t\tdetail: localize('irreversible', \"A file or folder with the name '{0}' already exists in the folder '{1}'. Replacing it will overwrite its current contents.\", basename(resource), basename(dirname(resource))),\n\t\t\tprimaryButton: localize({ key: 'replaceButtonLabel', comment: ['&& denotes a mnemonic'] }, \"&&Replace\")\n\t\t});\n\n\t\treturn confirmed;\n\t}\n\n\tprivate async suggestSavePath(resource: URI): Promise<URI> {\n\n\t\t// 1.) Just take the resource as is if the file service can handle it\n\t\tif (this.fileService.hasProvider(resource)) {\n\t\t\treturn resource;\n\t\t}\n\n\t\t// 2.) Pick the associated file path for untitled working copies if any\n\t\tconst workingCopy = this.get(resource);\n\t\tif (workingCopy instanceof UntitledFileWorkingCopy && workingCopy.hasAssociatedFilePath) {\n\t\t\treturn toLocalResource(resource, this.environmentService.remoteAuthority, this.pathService.defaultUriScheme);\n\t\t}\n\n\t\tconst defaultFilePath = await this.fileDialogService.defaultFilePath();\n\n\t\t// 3.) Pick the working copy name if valid joined with default path\n\t\tif (workingCopy) {\n\t\t\tconst candidatePath = joinPath(defaultFilePath, workingCopy.name);\n\t\t\tif (await this.pathService.hasValidBasename(candidatePath, workingCopy.name)) {\n\t\t\t\treturn candidatePath;\n\t\t\t}\n\t\t}\n\n\t\t// 4.) Finally fallback to the name of the resource joined with default path\n\t\treturn joinPath(defaultFilePath, basename(resource));\n\t}\n\n\t//#endregion\n\n\t//#region Lifecycle\n\n\tasync destroy(): Promise<void> {\n\t\tawait Promises.settled([\n\t\t\tthis.stored.destroy(),\n\t\t\tthis.untitled.destroy()\n\t\t]);\n\t}\n\n\t//#endregion\n}\n"]}