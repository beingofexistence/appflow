{"version":3,"sources":["vs/workbench/services/workingCopy/common/storedFileWorkingCopyManager.ts"],"names":[],"mappings":"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","file":"storedFileWorkingCopyManager.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { localize } from 'vs/nls';\nimport { DisposableStore, dispose, IDisposable } from 'vs/base/common/lifecycle';\nimport { Event, Emitter } from 'vs/base/common/event';\nimport { StoredFileWorkingCopy, StoredFileWorkingCopyState, IStoredFileWorkingCopy, IStoredFileWorkingCopyModel, IStoredFileWorkingCopyModelFactory, IStoredFileWorkingCopyResolveOptions, IStoredFileWorkingCopySaveEvent as IBaseStoredFileWorkingCopySaveEvent } from 'vs/workbench/services/workingCopy/common/storedFileWorkingCopy';\nimport { ResourceMap } from 'vs/base/common/map';\nimport { Promises, ResourceQueue } from 'vs/base/common/async';\nimport { FileChangesEvent, FileChangeType, FileOperation, IFileService, IFileSystemProviderCapabilitiesChangeEvent, IFileSystemProviderRegistrationEvent } from 'vs/platform/files/common/files';\nimport { ILifecycleService } from 'vs/workbench/services/lifecycle/common/lifecycle';\nimport { URI } from 'vs/base/common/uri';\nimport { VSBufferReadableStream } from 'vs/base/common/buffer';\nimport { ILabelService } from 'vs/platform/label/common/label';\nimport { ILogService } from 'vs/platform/log/common/log';\nimport { joinPath } from 'vs/base/common/resources';\nimport { IWorkingCopyFileService, WorkingCopyFileEvent } from 'vs/workbench/services/workingCopy/common/workingCopyFileService';\nimport { IUriIdentityService } from 'vs/platform/uriIdentity/common/uriIdentity';\nimport { CancellationToken } from 'vs/base/common/cancellation';\nimport { IWorkingCopyBackupService } from 'vs/workbench/services/workingCopy/common/workingCopyBackup';\nimport { BaseFileWorkingCopyManager, IBaseFileWorkingCopyManager } from 'vs/workbench/services/workingCopy/common/abstractFileWorkingCopyManager';\nimport { INotificationService } from 'vs/platform/notification/common/notification';\nimport { IEditorService } from 'vs/workbench/services/editor/common/editorService';\nimport { IElevatedFileService } from 'vs/workbench/services/files/common/elevatedFileService';\nimport { IFilesConfigurationService } from 'vs/workbench/services/filesConfiguration/common/filesConfigurationService';\nimport { IWorkingCopyEditorService } from 'vs/workbench/services/workingCopy/common/workingCopyEditorService';\nimport { IWorkingCopyService } from 'vs/workbench/services/workingCopy/common/workingCopyService';\nimport { isWeb } from 'vs/base/common/platform';\nimport { onUnexpectedError } from 'vs/base/common/errors';\n\n/**\n * The only one that should be dealing with `IStoredFileWorkingCopy` and handle all\n * operations that are working copy related, such as save/revert, backup\n * and resolving.\n */\nexport interface IStoredFileWorkingCopyManager<M extends IStoredFileWorkingCopyModel> extends IBaseFileWorkingCopyManager<M, IStoredFileWorkingCopy<M>> {\n\n\t/**\n\t * An event for when a stored file working copy was resolved.\n\t */\n\treadonly onDidResolve: Event<IStoredFileWorkingCopy<M>>;\n\n\t/**\n\t * An event for when a stored file working copy changed it's dirty state.\n\t */\n\treadonly onDidChangeDirty: Event<IStoredFileWorkingCopy<M>>;\n\n\t/**\n\t * An event for when a stored file working copy changed it's readonly state.\n\t */\n\treadonly onDidChangeReadonly: Event<IStoredFileWorkingCopy<M>>;\n\n\t/**\n\t * An event for when a stored file working copy changed it's orphaned state.\n\t */\n\treadonly onDidChangeOrphaned: Event<IStoredFileWorkingCopy<M>>;\n\n\t/**\n\t * An event for when a stored file working copy failed to save.\n\t */\n\treadonly onDidSaveError: Event<IStoredFileWorkingCopy<M>>;\n\n\t/**\n\t * An event for when a stored file working copy successfully saved.\n\t */\n\treadonly onDidSave: Event<IStoredFileWorkingCopySaveEvent<M>>;\n\n\t/**\n\t * An event for when a stored file working copy was reverted.\n\t */\n\treadonly onDidRevert: Event<IStoredFileWorkingCopy<M>>;\n\n\t/**\n\t * An event for when a stored file working copy is removed from the manager.\n\t */\n\treadonly onDidRemove: Event<URI>;\n\n\t/**\n\t * Allows to resolve a stored file working copy. If the manager already knows\n\t * about a stored file working copy with the same `URI`, it will return that\n\t * existing stored file working copy. There will never be more than one\n\t * stored file working copy per `URI` until the stored file working copy is\n\t * disposed.\n\t *\n\t * Use the `IStoredFileWorkingCopyResolveOptions.reload` option to control the\n\t * behaviour for when a stored file working copy was previously already resolved\n\t * with regards to resolving it again from the underlying file resource\n\t * or not.\n\t *\n\t * Note: Callers must `dispose` the working copy when no longer needed.\n\t *\n\t * @param resource used as unique identifier of the stored file working copy in\n\t * case one is already known for this `URI`.\n\t * @param options\n\t */\n\tresolve(resource: URI, options?: IStoredFileWorkingCopyManagerResolveOptions): Promise<IStoredFileWorkingCopy<M>>;\n\n\t/**\n\t * Waits for the stored file working copy to be ready to be disposed. There may be\n\t * conditions under which the stored file working copy cannot be disposed, e.g. when\n\t * it is dirty. Once the promise is settled, it is safe to dispose.\n\t */\n\tcanDispose(workingCopy: IStoredFileWorkingCopy<M>): true | Promise<true>;\n}\n\nexport interface IStoredFileWorkingCopySaveEvent<M extends IStoredFileWorkingCopyModel> extends IBaseStoredFileWorkingCopySaveEvent {\n\n\t/**\n\t * The stored file working copy that was successfully saved.\n\t */\n\treadonly workingCopy: IStoredFileWorkingCopy<M>;\n}\n\nexport interface IStoredFileWorkingCopyManagerResolveOptions extends IStoredFileWorkingCopyResolveOptions {\n\n\t/**\n\t * If the stored file working copy was already resolved before,\n\t * allows to trigger a reload of it to fetch the latest contents.\n\t */\n\treadonly reload?: {\n\n\t\t/**\n\t\t * Controls whether the reload happens in the background\n\t\t * or whether `resolve` will await the reload to happen.\n\t\t */\n\t\treadonly async: boolean;\n\n\t\t/**\n\t\t * Controls whether to force reading the contents from the\n\t\t * underlying resource even if the resource did not change.\n\t\t */\n\t\treadonly force?: boolean;\n\t};\n}\n\nexport class StoredFileWorkingCopyManager<M extends IStoredFileWorkingCopyModel> extends BaseFileWorkingCopyManager<M, IStoredFileWorkingCopy<M>> implements IStoredFileWorkingCopyManager<M> {\n\n\t//#region Events\n\n\tprivate readonly _onDidResolve = this._register(new Emitter<IStoredFileWorkingCopy<M>>());\n\treadonly onDidResolve = this._onDidResolve.event;\n\n\tprivate readonly _onDidChangeDirty = this._register(new Emitter<IStoredFileWorkingCopy<M>>());\n\treadonly onDidChangeDirty = this._onDidChangeDirty.event;\n\n\tprivate readonly _onDidChangeReadonly = this._register(new Emitter<IStoredFileWorkingCopy<M>>());\n\treadonly onDidChangeReadonly = this._onDidChangeReadonly.event;\n\n\tprivate readonly _onDidChangeOrphaned = this._register(new Emitter<IStoredFileWorkingCopy<M>>());\n\treadonly onDidChangeOrphaned = this._onDidChangeOrphaned.event;\n\n\tprivate readonly _onDidSaveError = this._register(new Emitter<IStoredFileWorkingCopy<M>>());\n\treadonly onDidSaveError = this._onDidSaveError.event;\n\n\tprivate readonly _onDidSave = this._register(new Emitter<IStoredFileWorkingCopySaveEvent<M>>());\n\treadonly onDidSave = this._onDidSave.event;\n\n\tprivate readonly _onDidRevert = this._register(new Emitter<IStoredFileWorkingCopy<M>>());\n\treadonly onDidRevert = this._onDidRevert.event;\n\n\tprivate readonly _onDidRemove = this._register(new Emitter<URI>());\n\treadonly onDidRemove = this._onDidRemove.event;\n\n\t//#endregion\n\n\tprivate readonly mapResourceToWorkingCopyListeners = new ResourceMap<IDisposable>();\n\tprivate readonly mapResourceToPendingWorkingCopyResolve = new ResourceMap<Promise<void>>();\n\n\tprivate readonly workingCopyResolveQueue = this._register(new ResourceQueue());\n\n\tconstructor(\n\t\tprivate readonly workingCopyTypeId: string,\n\t\tprivate readonly modelFactory: IStoredFileWorkingCopyModelFactory<M>,\n\t\t@IFileService fileService: IFileService,\n\t\t@ILifecycleService private readonly lifecycleService: ILifecycleService,\n\t\t@ILabelService private readonly labelService: ILabelService,\n\t\t@ILogService logService: ILogService,\n\t\t@IWorkingCopyFileService private readonly workingCopyFileService: IWorkingCopyFileService,\n\t\t@IWorkingCopyBackupService workingCopyBackupService: IWorkingCopyBackupService,\n\t\t@IUriIdentityService private readonly uriIdentityService: IUriIdentityService,\n\t\t@IFilesConfigurationService private readonly filesConfigurationService: IFilesConfigurationService,\n\t\t@IWorkingCopyService private readonly workingCopyService: IWorkingCopyService,\n\t\t@INotificationService private readonly notificationService: INotificationService,\n\t\t@IWorkingCopyEditorService private readonly workingCopyEditorService: IWorkingCopyEditorService,\n\t\t@IEditorService private readonly editorService: IEditorService,\n\t\t@IElevatedFileService private readonly elevatedFileService: IElevatedFileService\n\t) {\n\t\tsuper(fileService, logService, workingCopyBackupService);\n\n\t\tthis.registerListeners();\n\t}\n\n\tprivate registerListeners(): void {\n\n\t\t// Update working copies from file change events\n\t\tthis._register(this.fileService.onDidFilesChange(e => this.onDidFilesChange(e)));\n\n\t\t// File system provider changes\n\t\tthis._register(this.fileService.onDidChangeFileSystemProviderCapabilities(e => this.onDidChangeFileSystemProviderCapabilities(e)));\n\t\tthis._register(this.fileService.onDidChangeFileSystemProviderRegistrations(e => this.onDidChangeFileSystemProviderRegistrations(e)));\n\n\t\t// Working copy operations\n\t\tthis._register(this.workingCopyFileService.onWillRunWorkingCopyFileOperation(e => this.onWillRunWorkingCopyFileOperation(e)));\n\t\tthis._register(this.workingCopyFileService.onDidFailWorkingCopyFileOperation(e => this.onDidFailWorkingCopyFileOperation(e)));\n\t\tthis._register(this.workingCopyFileService.onDidRunWorkingCopyFileOperation(e => this.onDidRunWorkingCopyFileOperation(e)));\n\n\t\t// Lifecycle\n\t\tif (isWeb) {\n\t\t\tthis._register(this.lifecycleService.onBeforeShutdown(event => event.veto(this.onBeforeShutdownWeb(), 'veto.fileWorkingCopyManager')));\n\t\t} else {\n\t\t\tthis._register(this.lifecycleService.onWillShutdown(event => event.join(this.onWillShutdownDesktop(), { id: 'join.fileWorkingCopyManager', label: localize('join.fileWorkingCopyManager', \"Saving working copies\") })));\n\t\t}\n\t}\n\n\tprivate onBeforeShutdownWeb(): boolean {\n\t\tif (this.workingCopies.some(workingCopy => workingCopy.hasState(StoredFileWorkingCopyState.PENDING_SAVE))) {\n\t\t\t// stored file working copies are pending to be saved:\n\t\t\t// veto because web does not support long running shutdown\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tprivate async onWillShutdownDesktop(): Promise<void> {\n\t\tlet pendingSavedWorkingCopies: IStoredFileWorkingCopy<M>[];\n\n\t\t// As long as stored file working copies are pending to be saved, we prolong the shutdown\n\t\t// until that has happened to ensure we are not shutting down in the middle of\n\t\t// writing to the working copy (https://github.com/microsoft/vscode/issues/116600).\n\t\twhile ((pendingSavedWorkingCopies = this.workingCopies.filter(workingCopy => workingCopy.hasState(StoredFileWorkingCopyState.PENDING_SAVE))).length > 0) {\n\t\t\tawait Promises.settled(pendingSavedWorkingCopies.map(workingCopy => workingCopy.joinState(StoredFileWorkingCopyState.PENDING_SAVE)));\n\t\t}\n\t}\n\n\t//#region Resolve from file or file provider changes\n\n\tprivate onDidChangeFileSystemProviderCapabilities(e: IFileSystemProviderCapabilitiesChangeEvent): void {\n\n\t\t// Resolve working copies again for file systems that changed\n\t\t// capabilities to fetch latest metadata (e.g. readonly)\n\t\t// into all working copies.\n\t\tthis.queueWorkingCopyReloads(e.scheme);\n\t}\n\n\tprivate onDidChangeFileSystemProviderRegistrations(e: IFileSystemProviderRegistrationEvent): void {\n\t\tif (!e.added) {\n\t\t\treturn; // only if added\n\t\t}\n\n\t\t// Resolve working copies again for file systems that registered\n\t\t// to account for capability changes: extensions may unregister\n\t\t// and register the same provider with different capabilities,\n\t\t// so we want to ensure to fetch latest metadata (e.g. readonly)\n\t\t// into all working copies.\n\t\tthis.queueWorkingCopyReloads(e.scheme);\n\t}\n\n\tprivate onDidFilesChange(e: FileChangesEvent): void {\n\n\t\t// Trigger a resolve for any update or add event that impacts\n\t\t// the working copy. We also consider the added event\n\t\t// because it could be that a file was added and updated\n\t\t// right after.\n\t\tthis.queueWorkingCopyReloads(e);\n\t}\n\n\tprivate queueWorkingCopyReloads(scheme: string): void;\n\tprivate queueWorkingCopyReloads(e: FileChangesEvent): void;\n\tprivate queueWorkingCopyReloads(schemeOrEvent: string | FileChangesEvent): void {\n\t\tfor (const workingCopy of this.workingCopies) {\n\t\t\tif (workingCopy.isDirty()) {\n\t\t\t\tcontinue; // never reload dirty working copies\n\t\t\t}\n\n\t\t\tlet resolveWorkingCopy = false;\n\t\t\tif (typeof schemeOrEvent === 'string') {\n\t\t\t\tresolveWorkingCopy = schemeOrEvent === workingCopy.resource.scheme;\n\t\t\t} else {\n\t\t\t\tresolveWorkingCopy = schemeOrEvent.contains(workingCopy.resource, FileChangeType.UPDATED, FileChangeType.ADDED);\n\t\t\t}\n\n\t\t\tif (resolveWorkingCopy) {\n\t\t\t\tthis.queueWorkingCopyReload(workingCopy);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate queueWorkingCopyReload(workingCopy: IStoredFileWorkingCopy<M>): void {\n\n\t\t// Resolves a working copy to update (use a queue to prevent accumulation of\n\t\t// resolve when the resolving actually takes long. At most we only want the\n\t\t// queue to have a size of 2 (1 running resolve and 1 queued resolve).\n\t\tconst queue = this.workingCopyResolveQueue.queueFor(workingCopy.resource);\n\t\tif (queue.size <= 1) {\n\t\t\tqueue.queue(async () => {\n\t\t\t\ttry {\n\t\t\t\t\tawait this.reload(workingCopy);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthis.logService.error(error);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\t//#endregion\n\n\t//#region Working Copy File Events\n\n\tprivate readonly mapCorrelationIdToWorkingCopiesToRestore = new Map<number, { source: URI; target: URI; snapshot?: VSBufferReadableStream }[]>();\n\n\tprivate onWillRunWorkingCopyFileOperation(e: WorkingCopyFileEvent): void {\n\n\t\t// Move / Copy: remember working copies to restore after the operation\n\t\tif (e.operation === FileOperation.MOVE || e.operation === FileOperation.COPY) {\n\t\t\te.waitUntil((async () => {\n\t\t\t\tconst workingCopiesToRestore: { source: URI; target: URI; snapshot?: VSBufferReadableStream }[] = [];\n\n\t\t\t\tfor (const { source, target } of e.files) {\n\t\t\t\t\tif (source) {\n\t\t\t\t\t\tif (this.uriIdentityService.extUri.isEqual(source, target)) {\n\t\t\t\t\t\t\tcontinue; // ignore if resources are considered equal\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Find all working copies that related to source (can be many if resource is a folder)\n\t\t\t\t\t\tconst sourceWorkingCopies: IStoredFileWorkingCopy<M>[] = [];\n\t\t\t\t\t\tfor (const workingCopy of this.workingCopies) {\n\t\t\t\t\t\t\tif (this.uriIdentityService.extUri.isEqualOrParent(workingCopy.resource, source)) {\n\t\t\t\t\t\t\t\tsourceWorkingCopies.push(workingCopy);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Remember each source working copy to load again after move is done\n\t\t\t\t\t\t// with optional content to restore if it was dirty\n\t\t\t\t\t\tfor (const sourceWorkingCopy of sourceWorkingCopies) {\n\t\t\t\t\t\t\tconst sourceResource = sourceWorkingCopy.resource;\n\n\t\t\t\t\t\t\t// If the source is the actual working copy, just use target as new resource\n\t\t\t\t\t\t\tlet targetResource: URI;\n\t\t\t\t\t\t\tif (this.uriIdentityService.extUri.isEqual(sourceResource, source)) {\n\t\t\t\t\t\t\t\ttargetResource = target;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Otherwise a parent folder of the source is being moved, so we need\n\t\t\t\t\t\t\t// to compute the target resource based on that\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\ttargetResource = joinPath(target, sourceResource.path.substr(source.path.length + 1));\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tworkingCopiesToRestore.push({\n\t\t\t\t\t\t\t\tsource: sourceResource,\n\t\t\t\t\t\t\t\ttarget: targetResource,\n\t\t\t\t\t\t\t\tsnapshot: sourceWorkingCopy.isDirty() ? await sourceWorkingCopy.model?.snapshot(CancellationToken.None) : undefined\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.mapCorrelationIdToWorkingCopiesToRestore.set(e.correlationId, workingCopiesToRestore);\n\t\t\t})());\n\t\t}\n\t}\n\n\tprivate onDidFailWorkingCopyFileOperation(e: WorkingCopyFileEvent): void {\n\n\t\t// Move / Copy: restore dirty flag on working copies to restore that were dirty\n\t\tif ((e.operation === FileOperation.MOVE || e.operation === FileOperation.COPY)) {\n\t\t\tconst workingCopiesToRestore = this.mapCorrelationIdToWorkingCopiesToRestore.get(e.correlationId);\n\t\t\tif (workingCopiesToRestore) {\n\t\t\t\tthis.mapCorrelationIdToWorkingCopiesToRestore.delete(e.correlationId);\n\n\t\t\t\tfor (const workingCopy of workingCopiesToRestore) {\n\n\t\t\t\t\t// Snapshot presence means this working copy used to be modified and so we restore that\n\t\t\t\t\t// flag. we do NOT have to restore the content because the working copy was only soft\n\t\t\t\t\t// reverted and did not loose its original modified contents.\n\n\t\t\t\t\tif (workingCopy.snapshot) {\n\t\t\t\t\t\tthis.get(workingCopy.source)?.markModified();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate onDidRunWorkingCopyFileOperation(e: WorkingCopyFileEvent): void {\n\t\tswitch (e.operation) {\n\n\t\t\t// Create: Revert existing working copies\n\t\t\tcase FileOperation.CREATE:\n\t\t\t\te.waitUntil((async () => {\n\t\t\t\t\tfor (const { target } of e.files) {\n\t\t\t\t\t\tconst workingCopy = this.get(target);\n\t\t\t\t\t\tif (workingCopy && !workingCopy.isDisposed()) {\n\t\t\t\t\t\t\tawait workingCopy.revert();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t})());\n\t\t\t\tbreak;\n\n\t\t\t// Move/Copy: restore working copies that were loaded before the operation took place\n\t\t\tcase FileOperation.MOVE:\n\t\t\tcase FileOperation.COPY:\n\t\t\t\te.waitUntil((async () => {\n\t\t\t\t\tconst workingCopiesToRestore = this.mapCorrelationIdToWorkingCopiesToRestore.get(e.correlationId);\n\t\t\t\t\tif (workingCopiesToRestore) {\n\t\t\t\t\t\tthis.mapCorrelationIdToWorkingCopiesToRestore.delete(e.correlationId);\n\n\t\t\t\t\t\tawait Promises.settled(workingCopiesToRestore.map(async workingCopyToRestore => {\n\n\t\t\t\t\t\t\t// Restore the working copy at the target. if we have previous dirty content, we pass it\n\t\t\t\t\t\t\t// over to be used, otherwise we force a reload from disk. this is important\n\t\t\t\t\t\t\t// because we know the file has changed on disk after the move and the working copy might\n\t\t\t\t\t\t\t// have still existed with the previous state. this ensures that the working copy is not\n\t\t\t\t\t\t\t// tracking a stale state.\n\t\t\t\t\t\t\tawait this.resolve(workingCopyToRestore.target, {\n\t\t\t\t\t\t\t\treload: { async: false }, // enforce a reload\n\t\t\t\t\t\t\t\tcontents: workingCopyToRestore.snapshot\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}));\n\t\t\t\t\t}\n\t\t\t\t})());\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t//#endregion\n\n\t//#region Reload & Resolve\n\n\tprivate async reload(workingCopy: IStoredFileWorkingCopy<M>): Promise<void> {\n\n\t\t// Await a pending working copy resolve first before proceeding\n\t\t// to ensure that we never resolve a working copy more than once\n\t\t// in parallel.\n\t\tawait this.joinPendingResolves(workingCopy.resource);\n\n\t\tif (workingCopy.isDirty() || workingCopy.isDisposed() || !this.has(workingCopy.resource)) {\n\t\t\treturn; // the working copy possibly got dirty or disposed, so return early then\n\t\t}\n\n\t\t// Trigger reload\n\t\tawait this.doResolve(workingCopy, { reload: { async: false } });\n\t}\n\n\tasync resolve(resource: URI, options?: IStoredFileWorkingCopyManagerResolveOptions): Promise<IStoredFileWorkingCopy<M>> {\n\n\t\t// Await a pending working copy resolve first before proceeding\n\t\t// to ensure that we never resolve a working copy more than once\n\t\t// in parallel.\n\t\tconst pendingResolve = this.joinPendingResolves(resource);\n\t\tif (pendingResolve) {\n\t\t\tawait pendingResolve;\n\t\t}\n\n\t\t// Trigger resolve\n\t\treturn this.doResolve(resource, options);\n\t}\n\n\tprivate async doResolve(resourceOrWorkingCopy: URI | IStoredFileWorkingCopy<M>, options?: IStoredFileWorkingCopyManagerResolveOptions): Promise<IStoredFileWorkingCopy<M>> {\n\t\tlet workingCopy: IStoredFileWorkingCopy<M> | undefined;\n\t\tlet resource: URI;\n\t\tif (URI.isUri(resourceOrWorkingCopy)) {\n\t\t\tresource = resourceOrWorkingCopy;\n\t\t\tworkingCopy = this.get(resource);\n\t\t} else {\n\t\t\tresource = resourceOrWorkingCopy.resource;\n\t\t\tworkingCopy = resourceOrWorkingCopy;\n\t\t}\n\n\t\tlet workingCopyResolve: Promise<void>;\n\t\tlet didCreateWorkingCopy = false;\n\n\t\tconst resolveOptions: IStoredFileWorkingCopyResolveOptions = {\n\t\t\tcontents: options?.contents,\n\t\t\tforceReadFromFile: options?.reload?.force\n\t\t};\n\n\t\t// Working copy exists\n\t\tif (workingCopy) {\n\n\t\t\t// Always reload if contents are provided\n\t\t\tif (options?.contents) {\n\t\t\t\tworkingCopyResolve = workingCopy.resolve(resolveOptions);\n\t\t\t}\n\n\t\t\t// Reload async or sync based on options\n\t\t\telse if (options?.reload) {\n\n\t\t\t\t// Async reload: trigger a reload but return immediately\n\t\t\t\tif (options.reload.async) {\n\t\t\t\t\tworkingCopyResolve = Promise.resolve();\n\t\t\t\t\t(async () => {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tawait workingCopy.resolve(resolveOptions);\n\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\tonUnexpectedError(error);\n\t\t\t\t\t\t}\n\t\t\t\t\t})();\n\t\t\t\t}\n\n\t\t\t\t// Sync reload: do not return until working copy reloaded\n\t\t\t\telse {\n\t\t\t\t\tworkingCopyResolve = workingCopy.resolve(resolveOptions);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Do not reload\n\t\t\telse {\n\t\t\t\tworkingCopyResolve = Promise.resolve();\n\t\t\t}\n\t\t}\n\n\t\t// Stored file working copy does not exist\n\t\telse {\n\t\t\tdidCreateWorkingCopy = true;\n\n\t\t\tworkingCopy = new StoredFileWorkingCopy(\n\t\t\t\tthis.workingCopyTypeId,\n\t\t\t\tresource,\n\t\t\t\tthis.labelService.getUriBasenameLabel(resource),\n\t\t\t\tthis.modelFactory,\n\t\t\t\tasync options => { await this.resolve(resource, { ...options, reload: { async: false } }); },\n\t\t\t\tthis.fileService, this.logService, this.workingCopyFileService, this.filesConfigurationService,\n\t\t\t\tthis.workingCopyBackupService, this.workingCopyService, this.notificationService, this.workingCopyEditorService,\n\t\t\t\tthis.editorService, this.elevatedFileService\n\t\t\t);\n\n\t\t\tworkingCopyResolve = workingCopy.resolve(resolveOptions);\n\n\t\t\tthis.registerWorkingCopy(workingCopy);\n\t\t}\n\n\t\t// Store pending resolve to avoid race conditions\n\t\tthis.mapResourceToPendingWorkingCopyResolve.set(resource, workingCopyResolve);\n\n\t\t// Make known to manager (if not already known)\n\t\tthis.add(resource, workingCopy);\n\n\t\t// Emit some events if we created the working copy\n\t\tif (didCreateWorkingCopy) {\n\n\t\t\t// If the working copy is dirty right from the beginning,\n\t\t\t// make sure to emit this as an event\n\t\t\tif (workingCopy.isDirty()) {\n\t\t\t\tthis._onDidChangeDirty.fire(workingCopy);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tawait workingCopyResolve;\n\t\t} catch (error) {\n\n\t\t\t// Automatically dispose the working copy if we created\n\t\t\t// it because we cannot dispose a working copy we do not\n\t\t\t// own (https://github.com/microsoft/vscode/issues/138850)\n\t\t\tif (didCreateWorkingCopy) {\n\t\t\t\tworkingCopy.dispose();\n\t\t\t}\n\n\t\t\tthrow error;\n\t\t} finally {\n\n\t\t\t// Remove from pending resolves\n\t\t\tthis.mapResourceToPendingWorkingCopyResolve.delete(resource);\n\t\t}\n\n\t\t// Stored file working copy can be dirty if a backup was restored, so we make sure to\n\t\t// have this event delivered if we created the working copy here\n\t\tif (didCreateWorkingCopy && workingCopy.isDirty()) {\n\t\t\tthis._onDidChangeDirty.fire(workingCopy);\n\t\t}\n\n\t\treturn workingCopy;\n\t}\n\n\tprivate joinPendingResolves(resource: URI): Promise<void> | undefined {\n\t\tconst pendingWorkingCopyResolve = this.mapResourceToPendingWorkingCopyResolve.get(resource);\n\t\tif (!pendingWorkingCopyResolve) {\n\t\t\treturn;\n\t\t}\n\n\t\treturn this.doJoinPendingResolves(resource);\n\t}\n\n\tprivate async doJoinPendingResolves(resource: URI): Promise<void> {\n\n\t\t// While we have pending working copy resolves, ensure\n\t\t// to await the last one finishing before returning.\n\t\t// This prevents a race when multiple clients await\n\t\t// the pending resolve and then all trigger the resolve\n\t\t// at the same time.\n\t\tlet currentWorkingCopyResolve: Promise<void> | undefined;\n\t\twhile (this.mapResourceToPendingWorkingCopyResolve.has(resource)) {\n\t\t\tconst nextPendingWorkingCopyResolve = this.mapResourceToPendingWorkingCopyResolve.get(resource);\n\t\t\tif (nextPendingWorkingCopyResolve === currentWorkingCopyResolve) {\n\t\t\t\treturn; // already awaited on - return\n\t\t\t}\n\n\t\t\tcurrentWorkingCopyResolve = nextPendingWorkingCopyResolve;\n\t\t\ttry {\n\t\t\t\tawait nextPendingWorkingCopyResolve;\n\t\t\t} catch (error) {\n\t\t\t\t// ignore any error here, it will bubble to the original requestor\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate registerWorkingCopy(workingCopy: IStoredFileWorkingCopy<M>): void {\n\n\t\t// Install working copy listeners\n\t\tconst workingCopyListeners = new DisposableStore();\n\t\tworkingCopyListeners.add(workingCopy.onDidResolve(() => this._onDidResolve.fire(workingCopy)));\n\t\tworkingCopyListeners.add(workingCopy.onDidChangeDirty(() => this._onDidChangeDirty.fire(workingCopy)));\n\t\tworkingCopyListeners.add(workingCopy.onDidChangeReadonly(() => this._onDidChangeReadonly.fire(workingCopy)));\n\t\tworkingCopyListeners.add(workingCopy.onDidChangeOrphaned(() => this._onDidChangeOrphaned.fire(workingCopy)));\n\t\tworkingCopyListeners.add(workingCopy.onDidSaveError(() => this._onDidSaveError.fire(workingCopy)));\n\t\tworkingCopyListeners.add(workingCopy.onDidSave(e => this._onDidSave.fire({ workingCopy, ...e })));\n\t\tworkingCopyListeners.add(workingCopy.onDidRevert(() => this._onDidRevert.fire(workingCopy)));\n\n\t\t// Keep for disposal\n\t\tthis.mapResourceToWorkingCopyListeners.set(workingCopy.resource, workingCopyListeners);\n\t}\n\n\tprotected override remove(resource: URI): boolean {\n\t\tconst removed = super.remove(resource);\n\n\t\t// Dispose any existing working copy listeners\n\t\tconst workingCopyListener = this.mapResourceToWorkingCopyListeners.get(resource);\n\t\tif (workingCopyListener) {\n\t\t\tdispose(workingCopyListener);\n\t\t\tthis.mapResourceToWorkingCopyListeners.delete(resource);\n\t\t}\n\n\t\tif (removed) {\n\t\t\tthis._onDidRemove.fire(resource);\n\t\t}\n\n\t\treturn removed;\n\t}\n\n\t//#endregion\n\n\t//#region Lifecycle\n\n\tcanDispose(workingCopy: IStoredFileWorkingCopy<M>): true | Promise<true> {\n\n\t\t// Quick return if working copy already disposed or not dirty and not resolving\n\t\tif (\n\t\t\tworkingCopy.isDisposed() ||\n\t\t\t(!this.mapResourceToPendingWorkingCopyResolve.has(workingCopy.resource) && !workingCopy.isDirty())\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Promise based return in all other cases\n\t\treturn this.doCanDispose(workingCopy);\n\t}\n\n\tprivate async doCanDispose(workingCopy: IStoredFileWorkingCopy<M>): Promise<true> {\n\n\t\t// Await any pending resolves first before proceeding\n\t\tconst pendingResolve = this.joinPendingResolves(workingCopy.resource);\n\t\tif (pendingResolve) {\n\t\t\tawait pendingResolve;\n\n\t\t\treturn this.canDispose(workingCopy);\n\t\t}\n\n\t\t// Dirty working copy: we do not allow to dispose dirty working copys\n\t\t// to prevent data loss cases. dirty working copys can only be disposed when\n\t\t// they are either saved or reverted\n\t\tif (workingCopy.isDirty()) {\n\t\t\tawait Event.toPromise(workingCopy.onDidChangeDirty);\n\n\t\t\treturn this.canDispose(workingCopy);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\toverride dispose(): void {\n\t\tsuper.dispose();\n\n\t\t// Clear pending working copy resolves\n\t\tthis.mapResourceToPendingWorkingCopyResolve.clear();\n\n\t\t// Dispose the working copy change listeners\n\t\tdispose(this.mapResourceToWorkingCopyListeners.values());\n\t\tthis.mapResourceToWorkingCopyListeners.clear();\n\t}\n\n\t//#endregion\n}\n"]}