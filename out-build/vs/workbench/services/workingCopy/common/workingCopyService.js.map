{"version":3,"sources":["file:///workspace/appflow/src/vs/workbench/services/workingCopy/common/workingCopyService.ts"],"names":[],"mappings":"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","file":"workingCopyService.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { createDecorator } from 'vs/platform/instantiation/common/instantiation';\nimport { InstantiationType, registerSingleton } from 'vs/platform/instantiation/common/extensions';\nimport { Event, Emitter } from 'vs/base/common/event';\nimport { URI } from 'vs/base/common/uri';\nimport { Disposable, IDisposable, toDisposable, DisposableStore, DisposableMap } from 'vs/base/common/lifecycle';\nimport { ResourceMap } from 'vs/base/common/map';\nimport { IWorkingCopy, IWorkingCopyIdentifier, IWorkingCopySaveEvent as IBaseWorkingCopySaveEvent } from 'vs/workbench/services/workingCopy/common/workingCopy';\n\nexport const IWorkingCopyService = createDecorator<IWorkingCopyService>('workingCopyService');\n\nexport interface IWorkingCopySaveEvent extends IBaseWorkingCopySaveEvent {\n\n\t/**\n\t * The working copy that was saved.\n\t */\n\treadonly workingCopy: IWorkingCopy;\n}\n\nexport interface IWorkingCopyService {\n\n\treadonly _serviceBrand: undefined;\n\n\n\t//#region Events\n\n\t/**\n\t * An event for when a working copy was registered.\n\t */\n\treadonly onDidRegister: Event<IWorkingCopy>;\n\n\t/**\n\t * An event for when a working copy was unregistered.\n\t */\n\treadonly onDidUnregister: Event<IWorkingCopy>;\n\n\t/**\n\t * An event for when a working copy dirty state changed.\n\t */\n\treadonly onDidChangeDirty: Event<IWorkingCopy>;\n\n\t/**\n\t * An event for when a working copy's content changed.\n\t */\n\treadonly onDidChangeContent: Event<IWorkingCopy>;\n\n\t/**\n\t * An event for when a working copy was saved.\n\t */\n\treadonly onDidSave: Event<IWorkingCopySaveEvent>;\n\n\t//#endregion\n\n\n\t//#region Dirty Tracking\n\n\t/**\n\t * The number of dirty working copies that are registered.\n\t */\n\treadonly dirtyCount: number;\n\n\t/**\n\t * All dirty working copies that are registered.\n\t */\n\treadonly dirtyWorkingCopies: readonly IWorkingCopy[];\n\n\t/**\n\t * The number of modified working copies that are registered,\n\t * including scratchpads, which are never dirty.\n\t */\n\treadonly modifiedCount: number;\n\n\t/**\n\t * All working copies with unsaved changes,\n\t * including scratchpads, which are never dirty.\n\t */\n\treadonly modifiedWorkingCopies: readonly IWorkingCopy[];\n\n\t/**\n\t * Whether there is any registered working copy that is dirty.\n\t */\n\treadonly hasDirty: boolean;\n\n\t/**\n\t * Figure out if working copies with the given\n\t * resource are dirty or not.\n\t *\n\t * @param resource the URI of the working copy\n\t * @param typeId optional type identifier to only\n\t * consider working copies of that type.\n\t */\n\tisDirty(resource: URI, typeId?: string): boolean;\n\n\t//#endregion\n\n\n\t//#region Registry\n\n\t/**\n\t * All working copies that are registered.\n\t */\n\treadonly workingCopies: readonly IWorkingCopy[];\n\n\t/**\n\t * Register a new working copy with the service. This method will\n\t * throw if you try to register a working copy on a resource that\n\t * has already been registered.\n\t *\n\t * Overall there can only ever be 1 working copy with the same\n\t * resource.\n\t */\n\tregisterWorkingCopy(workingCopy: IWorkingCopy): IDisposable;\n\n\t/**\n\t * Whether a working copy with the given resource or identifier\n\t * exists.\n\t */\n\thas(identifier: IWorkingCopyIdentifier): boolean;\n\thas(resource: URI): boolean;\n\n\t/**\n\t * Returns a working copy with the given identifier or `undefined`\n\t * if no such working copy exists.\n\t */\n\tget(identifier: IWorkingCopyIdentifier): IWorkingCopy | undefined;\n\n\t/**\n\t * Returns all working copies with the given resource or `undefined`\n\t * if no such working copy exists.\n\t */\n\tgetAll(resource: URI): readonly IWorkingCopy[] | undefined;\n\n\t//#endregion\n}\n\nexport class WorkingCopyService extends Disposable implements IWorkingCopyService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\t//#region Events\n\n\tprivate readonly _onDidRegister = this._register(new Emitter<IWorkingCopy>());\n\treadonly onDidRegister = this._onDidRegister.event;\n\n\tprivate readonly _onDidUnregister = this._register(new Emitter<IWorkingCopy>());\n\treadonly onDidUnregister = this._onDidUnregister.event;\n\n\tprivate readonly _onDidChangeDirty = this._register(new Emitter<IWorkingCopy>());\n\treadonly onDidChangeDirty = this._onDidChangeDirty.event;\n\n\tprivate readonly _onDidChangeContent = this._register(new Emitter<IWorkingCopy>());\n\treadonly onDidChangeContent = this._onDidChangeContent.event;\n\n\tprivate readonly _onDidSave = this._register(new Emitter<IWorkingCopySaveEvent>());\n\treadonly onDidSave = this._onDidSave.event;\n\n\t//#endregion\n\n\n\t//#region Registry\n\n\tget workingCopies(): IWorkingCopy[] { return Array.from(this._workingCopies.values()); }\n\tprivate _workingCopies = new Set<IWorkingCopy>();\n\n\tprivate readonly mapResourceToWorkingCopies = new ResourceMap<Map<string, IWorkingCopy>>();\n\tprivate readonly mapWorkingCopyToListeners = this._register(new DisposableMap<IWorkingCopy>());\n\n\tregisterWorkingCopy(workingCopy: IWorkingCopy): IDisposable {\n\t\tlet workingCopiesForResource = this.mapResourceToWorkingCopies.get(workingCopy.resource);\n\t\tif (workingCopiesForResource?.has(workingCopy.typeId)) {\n\t\t\tthrow new Error(`Cannot register more than one working copy with the same resource ${workingCopy.resource.toString()} and type ${workingCopy.typeId}.`);\n\t\t}\n\n\t\t// Registry (all)\n\t\tthis._workingCopies.add(workingCopy);\n\n\t\t// Registry (type based)\n\t\tif (!workingCopiesForResource) {\n\t\t\tworkingCopiesForResource = new Map();\n\t\t\tthis.mapResourceToWorkingCopies.set(workingCopy.resource, workingCopiesForResource);\n\t\t}\n\t\tworkingCopiesForResource.set(workingCopy.typeId, workingCopy);\n\n\t\t// Wire in Events\n\t\tconst disposables = new DisposableStore();\n\t\tdisposables.add(workingCopy.onDidChangeContent(() => this._onDidChangeContent.fire(workingCopy)));\n\t\tdisposables.add(workingCopy.onDidChangeDirty(() => this._onDidChangeDirty.fire(workingCopy)));\n\t\tdisposables.add(workingCopy.onDidSave(e => this._onDidSave.fire({ workingCopy, ...e })));\n\t\tthis.mapWorkingCopyToListeners.set(workingCopy, disposables);\n\n\t\t// Send some initial events\n\t\tthis._onDidRegister.fire(workingCopy);\n\t\tif (workingCopy.isDirty()) {\n\t\t\tthis._onDidChangeDirty.fire(workingCopy);\n\t\t}\n\n\t\treturn toDisposable(() => {\n\n\t\t\t// Unregister working copy\n\t\t\tthis.unregisterWorkingCopy(workingCopy);\n\n\t\t\t// Signal as event\n\t\t\tthis._onDidUnregister.fire(workingCopy);\n\t\t});\n\t}\n\n\tprotected unregisterWorkingCopy(workingCopy: IWorkingCopy): void {\n\n\t\t// Registry (all)\n\t\tthis._workingCopies.delete(workingCopy);\n\n\t\t// Registry (type based)\n\t\tconst workingCopiesForResource = this.mapResourceToWorkingCopies.get(workingCopy.resource);\n\t\tif (workingCopiesForResource?.delete(workingCopy.typeId) && workingCopiesForResource.size === 0) {\n\t\t\tthis.mapResourceToWorkingCopies.delete(workingCopy.resource);\n\t\t}\n\n\t\t// If copy is dirty, ensure to fire an event to signal the dirty change\n\t\t// (a disposed working copy cannot account for being dirty in our model)\n\t\tif (workingCopy.isDirty()) {\n\t\t\tthis._onDidChangeDirty.fire(workingCopy);\n\t\t}\n\n\t\t// Remove all listeners associated to working copy\n\t\tthis.mapWorkingCopyToListeners.deleteAndDispose(workingCopy);\n\t}\n\n\thas(identifier: IWorkingCopyIdentifier): boolean;\n\thas(resource: URI): boolean;\n\thas(resourceOrIdentifier: URI | IWorkingCopyIdentifier): boolean {\n\t\tif (URI.isUri(resourceOrIdentifier)) {\n\t\t\treturn this.mapResourceToWorkingCopies.has(resourceOrIdentifier);\n\t\t}\n\n\t\treturn this.mapResourceToWorkingCopies.get(resourceOrIdentifier.resource)?.has(resourceOrIdentifier.typeId) ?? false;\n\t}\n\n\tget(identifier: IWorkingCopyIdentifier): IWorkingCopy | undefined {\n\t\treturn this.mapResourceToWorkingCopies.get(identifier.resource)?.get(identifier.typeId);\n\t}\n\n\tgetAll(resource: URI): readonly IWorkingCopy[] | undefined {\n\t\tconst workingCopies = this.mapResourceToWorkingCopies.get(resource);\n\t\tif (!workingCopies) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn Array.from(workingCopies.values());\n\t}\n\n\t//#endregion\n\n\n\t//#region Dirty Tracking\n\n\tget hasDirty(): boolean {\n\t\tfor (const workingCopy of this._workingCopies) {\n\t\t\tif (workingCopy.isDirty()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tget dirtyCount(): number {\n\t\tlet totalDirtyCount = 0;\n\n\t\tfor (const workingCopy of this._workingCopies) {\n\t\t\tif (workingCopy.isDirty()) {\n\t\t\t\ttotalDirtyCount++;\n\t\t\t}\n\t\t}\n\n\t\treturn totalDirtyCount;\n\t}\n\n\tget dirtyWorkingCopies(): IWorkingCopy[] {\n\t\treturn this.workingCopies.filter(workingCopy => workingCopy.isDirty());\n\t}\n\n\tget modifiedCount(): number {\n\t\tlet totalModifiedCount = 0;\n\n\t\tfor (const workingCopy of this._workingCopies) {\n\t\t\tif (workingCopy.isModified()) {\n\t\t\t\ttotalModifiedCount++;\n\t\t\t}\n\t\t}\n\n\t\treturn totalModifiedCount;\n\t}\n\n\tget modifiedWorkingCopies(): IWorkingCopy[] {\n\t\treturn this.workingCopies.filter(workingCopy => workingCopy.isModified());\n\t}\n\n\tisDirty(resource: URI, typeId?: string): boolean {\n\t\tconst workingCopies = this.mapResourceToWorkingCopies.get(resource);\n\t\tif (workingCopies) {\n\n\t\t\t// For a specific type\n\t\t\tif (typeof typeId === 'string') {\n\t\t\t\treturn workingCopies.get(typeId)?.isDirty() ?? false;\n\t\t\t}\n\n\t\t\t// Across all working copies\n\t\t\telse {\n\t\t\t\tfor (const [, workingCopy] of workingCopies) {\n\t\t\t\t\tif (workingCopy.isDirty()) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t//#endregion\n}\n\nregisterSingleton(IWorkingCopyService, WorkingCopyService, InstantiationType.Delayed);\n"]}