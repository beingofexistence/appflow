{"version":3,"sources":["file:///workspace/appflow/src/vs/workbench/services/workingCopy/common/workingCopyBackupService.ts"],"names":[],"mappings":"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","file":"workingCopyBackupService.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { joinPath } from 'vs/base/common/resources';\nimport { URI } from 'vs/base/common/uri';\nimport { coalesce } from 'vs/base/common/arrays';\nimport { equals, deepClone } from 'vs/base/common/objects';\nimport { Promises, ResourceQueue } from 'vs/base/common/async';\nimport { IResolvedWorkingCopyBackup, IWorkingCopyBackupService } from 'vs/workbench/services/workingCopy/common/workingCopyBackup';\nimport { IFileService, FileOperationError, FileOperationResult } from 'vs/platform/files/common/files';\nimport { ResourceMap } from 'vs/base/common/map';\nimport { isReadableStream, peekStream } from 'vs/base/common/stream';\nimport { bufferToStream, prefixedBufferReadable, prefixedBufferStream, readableToBuffer, streamToBuffer, VSBuffer, VSBufferReadable, VSBufferReadableStream } from 'vs/base/common/buffer';\nimport { Disposable } from 'vs/base/common/lifecycle';\nimport { ILogService } from 'vs/platform/log/common/log';\nimport { CancellationToken } from 'vs/base/common/cancellation';\nimport { Schemas } from 'vs/base/common/network';\nimport { hash } from 'vs/base/common/hash';\nimport { isEmptyObject } from 'vs/base/common/types';\nimport { IWorkingCopyBackupMeta, IWorkingCopyIdentifier, NO_TYPE_ID } from 'vs/workbench/services/workingCopy/common/workingCopy';\n\nexport class WorkingCopyBackupsModel {\n\n\tprivate readonly cache = new ResourceMap<{ versionId?: number; meta?: IWorkingCopyBackupMeta }>();\n\n\tstatic async create(backupRoot: URI, fileService: IFileService): Promise<WorkingCopyBackupsModel> {\n\t\tconst model = new WorkingCopyBackupsModel(backupRoot, fileService);\n\n\t\tawait model.resolve();\n\n\t\treturn model;\n\t}\n\n\tprivate constructor(private backupRoot: URI, private fileService: IFileService) { }\n\n\tprivate async resolve(): Promise<void> {\n\t\ttry {\n\t\t\tconst backupRootStat = await this.fileService.resolve(this.backupRoot);\n\t\t\tif (backupRootStat.children) {\n\t\t\t\tawait Promises.settled(backupRootStat.children\n\t\t\t\t\t.filter(child => child.isDirectory)\n\t\t\t\t\t.map(async backupSchemaFolder => {\n\n\t\t\t\t\t\t// Read backup directory for backups\n\t\t\t\t\t\tconst backupSchemaFolderStat = await this.fileService.resolve(backupSchemaFolder.resource);\n\n\t\t\t\t\t\t// Remember known backups in our caches\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// Note: this does NOT account for resolving\n\t\t\t\t\t\t// associated meta data because that requires\n\t\t\t\t\t\t// opening the backup and reading the meta\n\t\t\t\t\t\t// preamble. Instead, when backups are actually\n\t\t\t\t\t\t// resolved, the meta data will be added via\n\t\t\t\t\t\t// additional `update` calls.\n\t\t\t\t\t\tif (backupSchemaFolderStat.children) {\n\t\t\t\t\t\t\tfor (const backupForSchema of backupSchemaFolderStat.children) {\n\t\t\t\t\t\t\t\tif (!backupForSchema.isDirectory) {\n\t\t\t\t\t\t\t\t\tthis.add(backupForSchema.resource);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}));\n\t\t\t}\n\t\t} catch (error) {\n\t\t\t// ignore any errors\n\t\t}\n\t}\n\n\tadd(resource: URI, versionId = 0, meta?: IWorkingCopyBackupMeta): void {\n\t\tthis.cache.set(resource, {\n\t\t\tversionId,\n\t\t\tmeta: deepClone(meta)\n\t\t});\n\t}\n\n\tupdate(resource: URI, meta?: IWorkingCopyBackupMeta): void {\n\t\tconst entry = this.cache.get(resource);\n\t\tif (entry) {\n\t\t\tentry.meta = deepClone(meta);\n\t\t}\n\t}\n\n\tcount(): number {\n\t\treturn this.cache.size;\n\t}\n\n\thas(resource: URI, versionId?: number, meta?: IWorkingCopyBackupMeta): boolean {\n\t\tconst entry = this.cache.get(resource);\n\t\tif (!entry) {\n\t\t\treturn false; // unknown resource\n\t\t}\n\n\t\tif (typeof versionId === 'number' && versionId !== entry.versionId) {\n\t\t\treturn false; // different versionId\n\t\t}\n\n\t\tif (meta && !equals(meta, entry.meta)) {\n\t\t\treturn false; // different metadata\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tget(): URI[] {\n\t\treturn Array.from(this.cache.keys());\n\t}\n\n\tremove(resource: URI): void {\n\t\tthis.cache.delete(resource);\n\t}\n\n\tclear(): void {\n\t\tthis.cache.clear();\n\t}\n}\n\nexport abstract class WorkingCopyBackupService extends Disposable implements IWorkingCopyBackupService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate impl: WorkingCopyBackupServiceImpl | InMemoryWorkingCopyBackupService;\n\n\tconstructor(\n\t\tbackupWorkspaceHome: URI | undefined,\n\t\t@IFileService protected fileService: IFileService,\n\t\t@ILogService private readonly logService: ILogService\n\t) {\n\t\tsuper();\n\n\t\tthis.impl = this._register(this.initialize(backupWorkspaceHome));\n\t}\n\n\tprivate initialize(backupWorkspaceHome: URI | undefined): WorkingCopyBackupServiceImpl | InMemoryWorkingCopyBackupService {\n\t\tif (backupWorkspaceHome) {\n\t\t\treturn new WorkingCopyBackupServiceImpl(backupWorkspaceHome, this.fileService, this.logService);\n\t\t}\n\n\t\treturn new InMemoryWorkingCopyBackupService();\n\t}\n\n\treinitialize(backupWorkspaceHome: URI | undefined): void {\n\n\t\t// Re-init implementation (unless we are running in-memory)\n\t\tif (this.impl instanceof WorkingCopyBackupServiceImpl) {\n\t\t\tif (backupWorkspaceHome) {\n\t\t\t\tthis.impl.initialize(backupWorkspaceHome);\n\t\t\t} else {\n\t\t\t\tthis.impl = new InMemoryWorkingCopyBackupService();\n\t\t\t}\n\t\t}\n\t}\n\n\thasBackups(): Promise<boolean> {\n\t\treturn this.impl.hasBackups();\n\t}\n\n\thasBackupSync(identifier: IWorkingCopyIdentifier, versionId?: number, meta?: IWorkingCopyBackupMeta): boolean {\n\t\treturn this.impl.hasBackupSync(identifier, versionId, meta);\n\t}\n\n\tbackup(identifier: IWorkingCopyIdentifier, content?: VSBufferReadableStream | VSBufferReadable, versionId?: number, meta?: IWorkingCopyBackupMeta, token?: CancellationToken): Promise<void> {\n\t\treturn this.impl.backup(identifier, content, versionId, meta, token);\n\t}\n\n\tdiscardBackup(identifier: IWorkingCopyIdentifier, token?: CancellationToken): Promise<void> {\n\t\treturn this.impl.discardBackup(identifier, token);\n\t}\n\n\tdiscardBackups(filter?: { except: IWorkingCopyIdentifier[] }): Promise<void> {\n\t\treturn this.impl.discardBackups(filter);\n\t}\n\n\tgetBackups(): Promise<IWorkingCopyIdentifier[]> {\n\t\treturn this.impl.getBackups();\n\t}\n\n\tresolve<T extends IWorkingCopyBackupMeta>(identifier: IWorkingCopyIdentifier): Promise<IResolvedWorkingCopyBackup<T> | undefined> {\n\t\treturn this.impl.resolve(identifier);\n\t}\n\n\ttoBackupResource(identifier: IWorkingCopyIdentifier): URI {\n\t\treturn this.impl.toBackupResource(identifier);\n\t}\n\n\tjoinBackups(): Promise<void> {\n\t\treturn this.impl.joinBackups();\n\t}\n}\n\nclass WorkingCopyBackupServiceImpl extends Disposable implements IWorkingCopyBackupService {\n\n\tprivate static readonly PREAMBLE_END_MARKER = '\\n';\n\tprivate static readonly PREAMBLE_END_MARKER_CHARCODE = '\\n'.charCodeAt(0);\n\tprivate static readonly PREAMBLE_META_SEPARATOR = ' '; // using a character that is know to be escaped in a URI as separator\n\tprivate static readonly PREAMBLE_MAX_LENGTH = 10000;\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate readonly ioOperationQueues = this._register(new ResourceQueue()); // queue IO operations to ensure write/delete file order\n\n\tprivate ready!: Promise<WorkingCopyBackupsModel>;\n\tprivate model: WorkingCopyBackupsModel | undefined = undefined;\n\n\tconstructor(\n\t\tprivate backupWorkspaceHome: URI,\n\t\t@IFileService private readonly fileService: IFileService,\n\t\t@ILogService private readonly logService: ILogService\n\t) {\n\t\tsuper();\n\n\t\tthis.initialize(backupWorkspaceHome);\n\t}\n\n\tinitialize(backupWorkspaceResource: URI): void {\n\t\tthis.backupWorkspaceHome = backupWorkspaceResource;\n\n\t\tthis.ready = this.doInitialize();\n\t}\n\n\tprivate async doInitialize(): Promise<WorkingCopyBackupsModel> {\n\n\t\t// Create backup model\n\t\tthis.model = await WorkingCopyBackupsModel.create(this.backupWorkspaceHome, this.fileService);\n\n\t\treturn this.model;\n\t}\n\n\tasync hasBackups(): Promise<boolean> {\n\t\tconst model = await this.ready;\n\n\t\t// Ensure to await any pending backup operations\n\t\tawait this.joinBackups();\n\n\t\treturn model.count() > 0;\n\t}\n\n\thasBackupSync(identifier: IWorkingCopyIdentifier, versionId?: number, meta?: IWorkingCopyBackupMeta): boolean {\n\t\tif (!this.model) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst backupResource = this.toBackupResource(identifier);\n\n\t\treturn this.model.has(backupResource, versionId, meta);\n\t}\n\n\tasync backup(identifier: IWorkingCopyIdentifier, content?: VSBufferReadable | VSBufferReadableStream, versionId?: number, meta?: IWorkingCopyBackupMeta, token?: CancellationToken): Promise<void> {\n\t\tconst model = await this.ready;\n\t\tif (token?.isCancellationRequested) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst backupResource = this.toBackupResource(identifier);\n\t\tif (model.has(backupResource, versionId, meta)) {\n\t\t\t// return early if backup version id matches requested one\n\t\t\treturn;\n\t\t}\n\n\t\treturn this.ioOperationQueues.queueFor(backupResource).queue(async () => {\n\t\t\tif (token?.isCancellationRequested) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (model.has(backupResource, versionId, meta)) {\n\t\t\t\t// return early if backup version id matches requested one\n\t\t\t\t// this can happen when multiple backup IO operations got\n\t\t\t\t// scheduled, racing against each other.\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Encode as: Resource + META-START + Meta + END\n\t\t\t// and respect max length restrictions in case\n\t\t\t// meta is too large.\n\t\t\tlet preamble = this.createPreamble(identifier, meta);\n\t\t\tif (preamble.length >= WorkingCopyBackupServiceImpl.PREAMBLE_MAX_LENGTH) {\n\t\t\t\tpreamble = this.createPreamble(identifier);\n\t\t\t}\n\n\t\t\t// Update backup with value\n\t\t\tconst preambleBuffer = VSBuffer.fromString(preamble);\n\t\t\tlet backupBuffer: VSBuffer | VSBufferReadableStream | VSBufferReadable;\n\t\t\tif (isReadableStream(content)) {\n\t\t\t\tbackupBuffer = prefixedBufferStream(preambleBuffer, content);\n\t\t\t} else if (content) {\n\t\t\t\tbackupBuffer = prefixedBufferReadable(preambleBuffer, content);\n\t\t\t} else {\n\t\t\t\tbackupBuffer = VSBuffer.concat([preambleBuffer, VSBuffer.fromString('')]);\n\t\t\t}\n\n\t\t\t// Write backup via file service\n\t\t\tawait this.fileService.writeFile(backupResource, backupBuffer);\n\n\t\t\t//\n\t\t\t// Update model\n\t\t\t//\n\t\t\t// Note: not checking for cancellation here because a successful\n\t\t\t// write into the backup file should be noted in the model to\n\t\t\t// prevent the model being out of sync with the backup file\n\t\t\tmodel.add(backupResource, versionId, meta);\n\t\t});\n\t}\n\n\tprivate createPreamble(identifier: IWorkingCopyIdentifier, meta?: IWorkingCopyBackupMeta): string {\n\t\treturn `${identifier.resource.toString()}${WorkingCopyBackupServiceImpl.PREAMBLE_META_SEPARATOR}${JSON.stringify({ ...meta, typeId: identifier.typeId })}${WorkingCopyBackupServiceImpl.PREAMBLE_END_MARKER}`;\n\t}\n\n\tasync discardBackups(filter?: { except: IWorkingCopyIdentifier[] }): Promise<void> {\n\t\tconst model = await this.ready;\n\n\t\t// Discard all but some backups\n\t\tconst except = filter?.except;\n\t\tif (Array.isArray(except) && except.length > 0) {\n\t\t\tconst exceptMap = new ResourceMap<boolean>();\n\t\t\tfor (const exceptWorkingCopy of except) {\n\t\t\t\texceptMap.set(this.toBackupResource(exceptWorkingCopy), true);\n\t\t\t}\n\n\t\t\tawait Promises.settled(model.get().map(async backupResource => {\n\t\t\t\tif (!exceptMap.has(backupResource)) {\n\t\t\t\t\tawait this.doDiscardBackup(backupResource);\n\t\t\t\t}\n\t\t\t}));\n\t\t}\n\n\t\t// Discard all backups\n\t\telse {\n\t\t\tawait this.deleteIgnoreFileNotFound(this.backupWorkspaceHome);\n\n\t\t\tmodel.clear();\n\t\t}\n\t}\n\n\tdiscardBackup(identifier: IWorkingCopyIdentifier, token?: CancellationToken): Promise<void> {\n\t\tconst backupResource = this.toBackupResource(identifier);\n\n\t\treturn this.doDiscardBackup(backupResource, token);\n\t}\n\n\tprivate async doDiscardBackup(backupResource: URI, token?: CancellationToken): Promise<void> {\n\t\tconst model = await this.ready;\n\t\tif (token?.isCancellationRequested) {\n\t\t\treturn;\n\t\t}\n\n\t\treturn this.ioOperationQueues.queueFor(backupResource).queue(async () => {\n\t\t\tif (token?.isCancellationRequested) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Delete backup file ignoring any file not found errors\n\t\t\tawait this.deleteIgnoreFileNotFound(backupResource);\n\n\t\t\t//\n\t\t\t// Update model\n\t\t\t//\n\t\t\t// Note: not checking for cancellation here because a successful\n\t\t\t// delete of the backup file should be noted in the model to\n\t\t\t// prevent the model being out of sync with the backup file\n\t\t\tmodel.remove(backupResource);\n\t\t});\n\t}\n\n\tprivate async deleteIgnoreFileNotFound(backupResource: URI): Promise<void> {\n\t\ttry {\n\t\t\tawait this.fileService.del(backupResource, { recursive: true });\n\t\t} catch (error) {\n\t\t\tif ((<FileOperationError>error).fileOperationResult !== FileOperationResult.FILE_NOT_FOUND) {\n\t\t\t\tthrow error; // re-throw any other error than file not found which is OK\n\t\t\t}\n\t\t}\n\t}\n\n\tasync getBackups(): Promise<IWorkingCopyIdentifier[]> {\n\t\tconst model = await this.ready;\n\n\t\t// Ensure to await any pending backup operations\n\t\tawait this.joinBackups();\n\n\t\tconst backups = await Promise.all(model.get().map(backupResource => this.resolveIdentifier(backupResource, model)));\n\n\t\treturn coalesce(backups);\n\t}\n\n\tprivate async resolveIdentifier(backupResource: URI, model: WorkingCopyBackupsModel): Promise<IWorkingCopyIdentifier | undefined> {\n\t\tlet res: IWorkingCopyIdentifier | undefined = undefined;\n\n\t\tawait this.ioOperationQueues.queueFor(backupResource).queue(async () => {\n\t\t\tif (!model.has(backupResource)) {\n\t\t\t\treturn; // require backup to be present\n\t\t\t}\n\n\t\t\t// Read the entire backup preamble by reading up to\n\t\t\t// `PREAMBLE_MAX_LENGTH` in the backup file until\n\t\t\t// the `PREAMBLE_END_MARKER` is found\n\t\t\tconst backupPreamble = await this.readToMatchingString(backupResource, WorkingCopyBackupServiceImpl.PREAMBLE_END_MARKER, WorkingCopyBackupServiceImpl.PREAMBLE_MAX_LENGTH);\n\t\t\tif (!backupPreamble) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Figure out the offset in the preamble where meta\n\t\t\t// information possibly starts. This can be `-1` for\n\t\t\t// older backups without meta.\n\t\t\tconst metaStartIndex = backupPreamble.indexOf(WorkingCopyBackupServiceImpl.PREAMBLE_META_SEPARATOR);\n\n\t\t\t// Extract the preamble content for resource and meta\n\t\t\tlet resourcePreamble: string;\n\t\t\tlet metaPreamble: string | undefined;\n\t\t\tif (metaStartIndex > 0) {\n\t\t\t\tresourcePreamble = backupPreamble.substring(0, metaStartIndex);\n\t\t\t\tmetaPreamble = backupPreamble.substr(metaStartIndex + 1);\n\t\t\t} else {\n\t\t\t\tresourcePreamble = backupPreamble;\n\t\t\t\tmetaPreamble = undefined;\n\t\t\t}\n\n\t\t\t// Try to parse the meta preamble for figuring out\n\t\t\t// `typeId` and `meta` if defined.\n\t\t\tconst { typeId, meta } = this.parsePreambleMeta(metaPreamble);\n\n\t\t\t// Update model entry with now resolved meta\n\t\t\tmodel.update(backupResource, meta);\n\n\t\t\tres = {\n\t\t\t\ttypeId: typeId ?? NO_TYPE_ID,\n\t\t\t\tresource: URI.parse(resourcePreamble)\n\t\t\t};\n\t\t});\n\n\t\treturn res;\n\t}\n\n\tprivate async readToMatchingString(backupResource: URI, matchingString: string, maximumBytesToRead: number): Promise<string | undefined> {\n\t\tconst contents = (await this.fileService.readFile(backupResource, { length: maximumBytesToRead })).value.toString();\n\n\t\tconst matchingStringIndex = contents.indexOf(matchingString);\n\t\tif (matchingStringIndex >= 0) {\n\t\t\treturn contents.substr(0, matchingStringIndex);\n\t\t}\n\n\t\t// Unable to find matching string in file\n\t\treturn undefined;\n\t}\n\n\tasync resolve<T extends IWorkingCopyBackupMeta>(identifier: IWorkingCopyIdentifier): Promise<IResolvedWorkingCopyBackup<T> | undefined> {\n\t\tconst backupResource = this.toBackupResource(identifier);\n\n\t\tconst model = await this.ready;\n\n\t\tlet res: IResolvedWorkingCopyBackup<T> | undefined = undefined;\n\n\t\tawait this.ioOperationQueues.queueFor(backupResource).queue(async () => {\n\t\t\tif (!model.has(backupResource)) {\n\t\t\t\treturn; // require backup to be present\n\t\t\t}\n\n\t\t\t// Load the backup content and peek into the first chunk\n\t\t\t// to be able to resolve the meta data\n\t\t\tconst backupStream = await this.fileService.readFileStream(backupResource);\n\t\t\tconst peekedBackupStream = await peekStream(backupStream.value, 1);\n\t\t\tconst firstBackupChunk = VSBuffer.concat(peekedBackupStream.buffer);\n\n\t\t\t// We have seen reports (e.g. https://github.com/microsoft/vscode/issues/78500) where\n\t\t\t// if VSCode goes down while writing the backup file, the file can turn empty because\n\t\t\t// it always first gets truncated and then written to. In this case, we will not find\n\t\t\t// the meta-end marker ('\\n') and as such the backup can only be invalid. We bail out\n\t\t\t// here if that is the case.\n\t\t\tconst preambleEndIndex = firstBackupChunk.buffer.indexOf(WorkingCopyBackupServiceImpl.PREAMBLE_END_MARKER_CHARCODE);\n\t\t\tif (preambleEndIndex === -1) {\n\t\t\t\tthis.logService.trace(`Backup: Could not find meta end marker in ${backupResource}. The file is probably corrupt (filesize: ${backupStream.size}).`);\n\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tconst preambelRaw = firstBackupChunk.slice(0, preambleEndIndex).toString();\n\n\t\t\t// Extract meta data (if any)\n\t\t\tlet meta: T | undefined;\n\t\t\tconst metaStartIndex = preambelRaw.indexOf(WorkingCopyBackupServiceImpl.PREAMBLE_META_SEPARATOR);\n\t\t\tif (metaStartIndex !== -1) {\n\t\t\t\tmeta = this.parsePreambleMeta(preambelRaw.substr(metaStartIndex + 1)).meta as T;\n\t\t\t}\n\n\t\t\t// Update model entry with now resolved meta\n\t\t\tmodel.update(backupResource, meta);\n\n\t\t\t// Build a new stream without the preamble\n\t\t\tconst firstBackupChunkWithoutPreamble = firstBackupChunk.slice(preambleEndIndex + 1);\n\t\t\tlet value: VSBufferReadableStream;\n\t\t\tif (peekedBackupStream.ended) {\n\t\t\t\tvalue = bufferToStream(firstBackupChunkWithoutPreamble);\n\t\t\t} else {\n\t\t\t\tvalue = prefixedBufferStream(firstBackupChunkWithoutPreamble, peekedBackupStream.stream);\n\t\t\t}\n\n\t\t\tres = { value, meta };\n\t\t});\n\n\t\treturn res;\n\t}\n\n\tprivate parsePreambleMeta<T extends IWorkingCopyBackupMeta>(preambleMetaRaw: string | undefined): { typeId: string | undefined; meta: T | undefined } {\n\t\tlet typeId: string | undefined = undefined;\n\t\tlet meta: T | undefined = undefined;\n\n\t\tif (preambleMetaRaw) {\n\t\t\ttry {\n\t\t\t\tmeta = JSON.parse(preambleMetaRaw);\n\t\t\t\ttypeId = meta?.typeId;\n\n\t\t\t\t// `typeId` is a property that we add so we\n\t\t\t\t// remove it when returning to clients.\n\t\t\t\tif (typeof meta?.typeId === 'string') {\n\t\t\t\t\tdelete meta.typeId;\n\n\t\t\t\t\tif (isEmptyObject(meta)) {\n\t\t\t\t\t\tmeta = undefined;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\t// ignore JSON parse errors\n\t\t\t}\n\t\t}\n\n\t\treturn { typeId, meta };\n\t}\n\n\ttoBackupResource(identifier: IWorkingCopyIdentifier): URI {\n\t\treturn joinPath(this.backupWorkspaceHome, identifier.resource.scheme, hashIdentifier(identifier));\n\t}\n\n\tjoinBackups(): Promise<void> {\n\t\treturn this.ioOperationQueues.whenDrained();\n\t}\n}\n\nexport class InMemoryWorkingCopyBackupService extends Disposable implements IWorkingCopyBackupService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate backups = new ResourceMap<{ typeId: string; content: VSBuffer; meta?: IWorkingCopyBackupMeta }>();\n\n\tconstructor() {\n\t\tsuper();\n\t}\n\n\tasync hasBackups(): Promise<boolean> {\n\t\treturn this.backups.size > 0;\n\t}\n\n\thasBackupSync(identifier: IWorkingCopyIdentifier, versionId?: number): boolean {\n\t\tconst backupResource = this.toBackupResource(identifier);\n\n\t\treturn this.backups.has(backupResource);\n\t}\n\n\tasync backup(identifier: IWorkingCopyIdentifier, content?: VSBufferReadable | VSBufferReadableStream, versionId?: number, meta?: IWorkingCopyBackupMeta, token?: CancellationToken): Promise<void> {\n\t\tconst backupResource = this.toBackupResource(identifier);\n\t\tthis.backups.set(backupResource, {\n\t\t\ttypeId: identifier.typeId,\n\t\t\tcontent: content instanceof VSBuffer ? content : content ? isReadableStream(content) ? await streamToBuffer(content) : readableToBuffer(content) : VSBuffer.fromString(''),\n\t\t\tmeta\n\t\t});\n\t}\n\n\tasync resolve<T extends IWorkingCopyBackupMeta>(identifier: IWorkingCopyIdentifier): Promise<IResolvedWorkingCopyBackup<T> | undefined> {\n\t\tconst backupResource = this.toBackupResource(identifier);\n\t\tconst backup = this.backups.get(backupResource);\n\t\tif (backup) {\n\t\t\treturn { value: bufferToStream(backup.content), meta: backup.meta as T | undefined };\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tasync getBackups(): Promise<IWorkingCopyIdentifier[]> {\n\t\treturn Array.from(this.backups.entries()).map(([resource, backup]) => ({ typeId: backup.typeId, resource }));\n\t}\n\n\tasync discardBackup(identifier: IWorkingCopyIdentifier): Promise<void> {\n\t\tthis.backups.delete(this.toBackupResource(identifier));\n\t}\n\n\tasync discardBackups(filter?: { except: IWorkingCopyIdentifier[] }): Promise<void> {\n\t\tconst except = filter?.except;\n\t\tif (Array.isArray(except) && except.length > 0) {\n\t\t\tconst exceptMap = new ResourceMap<boolean>();\n\t\t\tfor (const exceptWorkingCopy of except) {\n\t\t\t\texceptMap.set(this.toBackupResource(exceptWorkingCopy), true);\n\t\t\t}\n\n\t\t\tfor (const backup of await this.getBackups()) {\n\t\t\t\tif (!exceptMap.has(this.toBackupResource(backup))) {\n\t\t\t\t\tawait this.discardBackup(backup);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthis.backups.clear();\n\t\t}\n\t}\n\n\ttoBackupResource(identifier: IWorkingCopyIdentifier): URI {\n\t\treturn URI.from({ scheme: Schemas.inMemory, path: hashIdentifier(identifier) });\n\t}\n\n\tasync joinBackups(): Promise<void> {\n\t\treturn;\n\t}\n}\n\n/*\n * Exported only for testing\n */\nexport function hashIdentifier(identifier: IWorkingCopyIdentifier): string {\n\n\t// IMPORTANT: for backwards compatibility, ensure that\n\t// we ignore the `typeId` unless a value is provided.\n\t// To preserve previous backups without type id, we\n\t// need to just hash the resource. Otherwise we use\n\t// the type id as a seed to the resource path.\n\tlet resource: URI;\n\tif (identifier.typeId.length > 0) {\n\t\tconst typeIdHash = hashString(identifier.typeId);\n\t\tif (identifier.resource.path) {\n\t\t\tresource = joinPath(identifier.resource, typeIdHash);\n\t\t} else {\n\t\t\tresource = identifier.resource.with({ path: typeIdHash });\n\t\t}\n\t} else {\n\t\tresource = identifier.resource;\n\t}\n\n\treturn hashPath(resource);\n}\n\nfunction hashPath(resource: URI): string {\n\tconst str = resource.scheme === Schemas.file || resource.scheme === Schemas.untitled ? resource.fsPath : resource.toString();\n\n\treturn hashString(str);\n}\n\nfunction hashString(str: string): string {\n\treturn hash(str).toString(16);\n}\n"]}