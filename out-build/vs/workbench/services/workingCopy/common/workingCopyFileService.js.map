{"version":3,"sources":["file:///workspace/appflow/src/vs/workbench/services/workingCopy/common/workingCopyFileService.ts"],"names":[],"mappings":"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","file":"workingCopyFileService.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { createDecorator, IInstantiationService } from 'vs/platform/instantiation/common/instantiation';\nimport { InstantiationType, registerSingleton } from 'vs/platform/instantiation/common/extensions';\nimport { Event, AsyncEmitter, IWaitUntil } from 'vs/base/common/event';\nimport { Promises } from 'vs/base/common/async';\nimport { insert } from 'vs/base/common/arrays';\nimport { URI } from 'vs/base/common/uri';\nimport { Disposable, IDisposable, toDisposable } from 'vs/base/common/lifecycle';\nimport { IFileService, FileOperation, IFileStatWithMetadata } from 'vs/platform/files/common/files';\nimport { CancellationToken } from 'vs/base/common/cancellation';\nimport { IWorkingCopyService } from 'vs/workbench/services/workingCopy/common/workingCopyService';\nimport { IWorkingCopy } from 'vs/workbench/services/workingCopy/common/workingCopy';\nimport { IUriIdentityService } from 'vs/platform/uriIdentity/common/uriIdentity';\nimport { WorkingCopyFileOperationParticipant } from 'vs/workbench/services/workingCopy/common/workingCopyFileOperationParticipant';\nimport { VSBuffer, VSBufferReadable, VSBufferReadableStream } from 'vs/base/common/buffer';\nimport { SaveReason } from 'vs/workbench/common/editor';\nimport { IProgress, IProgressStep } from 'vs/platform/progress/common/progress';\nimport { StoredFileWorkingCopySaveParticipant } from 'vs/workbench/services/workingCopy/common/storedFileWorkingCopySaveParticipant';\nimport { IStoredFileWorkingCopy, IStoredFileWorkingCopyModel } from 'vs/workbench/services/workingCopy/common/storedFileWorkingCopy';\n\nexport const IWorkingCopyFileService = createDecorator<IWorkingCopyFileService>('workingCopyFileService');\n\nexport interface SourceTargetPair {\n\n\t/**\n\t * The source resource that is defined for move operations.\n\t */\n\treadonly source?: URI;\n\n\t/**\n\t * The target resource the event is about.\n\t */\n\treadonly target: URI;\n}\n\nexport interface IFileOperationUndoRedoInfo {\n\n\t/**\n\t * Id of the undo group that the file operation belongs to.\n\t */\n\tundoRedoGroupId?: number;\n\n\t/**\n\t * Flag indicates if the operation is an undo.\n\t */\n\tisUndoing?: boolean;\n}\n\nexport interface WorkingCopyFileEvent extends IWaitUntil {\n\n\t/**\n\t * An identifier to correlate the operation through the\n\t * different event types (before, after, error).\n\t */\n\treadonly correlationId: number;\n\n\t/**\n\t * The file operation that is taking place.\n\t */\n\treadonly operation: FileOperation;\n\n\t/**\n\t * The array of source/target pair of files involved in given operation.\n\t */\n\treadonly files: readonly SourceTargetPair[];\n}\n\nexport interface IWorkingCopyFileOperationParticipant {\n\n\t/**\n\t * Participate in a file operation of working copies. Allows to\n\t * change the working copies before they are being saved to disk.\n\t */\n\tparticipate(\n\t\tfiles: SourceTargetPair[],\n\t\toperation: FileOperation,\n\t\tundoInfo: IFileOperationUndoRedoInfo | undefined,\n\t\ttimeout: number,\n\t\ttoken: CancellationToken\n\t): Promise<void>;\n}\n\nexport interface IStoredFileWorkingCopySaveParticipant {\n\n\t/**\n\t * Participate in a save operation of file stored working copies.\n\t * Allows to make changes before content is being saved to disk.\n\t */\n\tparticipate(\n\t\tworkingCopy: IStoredFileWorkingCopy<IStoredFileWorkingCopyModel>,\n\t\tcontext: { reason: SaveReason },\n\t\tprogress: IProgress<IProgressStep>,\n\t\ttoken: CancellationToken\n\t): Promise<void>;\n}\n\nexport interface ICreateOperation {\n\tresource: URI;\n\toverwrite?: boolean;\n}\n\nexport interface ICreateFileOperation extends ICreateOperation {\n\tcontents?: VSBuffer | VSBufferReadable | VSBufferReadableStream;\n}\n\nexport interface IDeleteOperation {\n\tresource: URI;\n\tuseTrash?: boolean;\n\trecursive?: boolean;\n}\n\nexport interface IMoveOperation {\n\tfile: Required<SourceTargetPair>;\n\toverwrite?: boolean;\n}\n\nexport interface ICopyOperation extends IMoveOperation { }\n\n/**\n * Returns the working copies for a given resource.\n */\ntype WorkingCopyProvider = (resourceOrFolder: URI) => IWorkingCopy[];\n\n/**\n * A service that allows to perform file operations with working copy support.\n * Any operation that would leave a stale dirty working copy behind will make\n * sure to revert the working copy first.\n *\n * On top of that events are provided to participate in each state of the\n * operation to perform additional work.\n */\nexport interface IWorkingCopyFileService {\n\n\treadonly _serviceBrand: undefined;\n\n\t//#region Events\n\n\t/**\n\t * An event that is fired when a certain working copy IO operation is about to run.\n\t *\n\t * Participants can join this event with a long running operation to keep some state\n\t * before the operation is started, but working copies should not be changed at this\n\t * point in time. For that purpose, use the `IWorkingCopyFileOperationParticipant` API.\n\t */\n\treadonly onWillRunWorkingCopyFileOperation: Event<WorkingCopyFileEvent>;\n\n\t/**\n\t * An event that is fired after a working copy IO operation has failed.\n\t *\n\t * Participants can join this event with a long running operation to clean up as needed.\n\t */\n\treadonly onDidFailWorkingCopyFileOperation: Event<WorkingCopyFileEvent>;\n\n\t/**\n\t * An event that is fired after a working copy IO operation has been performed.\n\t *\n\t * Participants can join this event with a long running operation to make changes\n\t * after the operation has finished.\n\t */\n\treadonly onDidRunWorkingCopyFileOperation: Event<WorkingCopyFileEvent>;\n\n\t//#endregion\n\n\n\t//#region File operation participants\n\n\t/**\n\t * Adds a participant for file operations on working copies.\n\t */\n\taddFileOperationParticipant(participant: IWorkingCopyFileOperationParticipant): IDisposable;\n\n\t//#endregion\n\n\n\t//#region Stored File Working Copy save participants\n\n\t/**\n\t * Whether save participants are present for stored file working copies.\n\t */\n\tget hasSaveParticipants(): boolean;\n\n\t/**\n\t * Adds a participant for save operations on stored file working copies.\n\t */\n\taddSaveParticipant(participant: IStoredFileWorkingCopySaveParticipant): IDisposable;\n\n\t/**\n\t * Runs all available save participants for stored file working copies.\n\t */\n\trunSaveParticipants(workingCopy: IStoredFileWorkingCopy<IStoredFileWorkingCopyModel>, context: { reason: SaveReason }, token: CancellationToken): Promise<void>;\n\n\t//#endregion\n\n\n\t//#region File operations\n\n\t/**\n\t * Will create a resource with the provided optional contents, optionally overwriting any target.\n\t *\n\t * Working copy owners can listen to the `onWillRunWorkingCopyFileOperation` and\n\t * `onDidRunWorkingCopyFileOperation` events to participate.\n\t */\n\tcreate(operations: ICreateFileOperation[], token: CancellationToken, undoInfo?: IFileOperationUndoRedoInfo): Promise<readonly IFileStatWithMetadata[]>;\n\n\t/**\n\t * Will create a folder and any parent folder that needs to be created.\n\t *\n\t * Working copy owners can listen to the `onWillRunWorkingCopyFileOperation` and\n\t * `onDidRunWorkingCopyFileOperation` events to participate.\n\t *\n\t * Note: events will only be emitted for the provided resource, but not any\n\t * parent folders that are being created as part of the operation.\n\t */\n\tcreateFolder(operations: ICreateOperation[], token: CancellationToken, undoInfo?: IFileOperationUndoRedoInfo): Promise<readonly IFileStatWithMetadata[]>;\n\n\t/**\n\t * Will move working copies matching the provided resources and corresponding children\n\t * to the target resources using the associated file service for those resources.\n\t *\n\t * Working copy owners can listen to the `onWillRunWorkingCopyFileOperation` and\n\t * `onDidRunWorkingCopyFileOperation` events to participate.\n\t */\n\tmove(operations: IMoveOperation[], token: CancellationToken, undoInfo?: IFileOperationUndoRedoInfo): Promise<readonly IFileStatWithMetadata[]>;\n\n\t/**\n\t * Will copy working copies matching the provided resources and corresponding children\n\t * to the target resources using the associated file service for those resources.\n\t *\n\t * Working copy owners can listen to the `onWillRunWorkingCopyFileOperation` and\n\t * `onDidRunWorkingCopyFileOperation` events to participate.\n\t */\n\tcopy(operations: ICopyOperation[], token: CancellationToken, undoInfo?: IFileOperationUndoRedoInfo): Promise<readonly IFileStatWithMetadata[]>;\n\n\t/**\n\t * Will delete working copies matching the provided resources and children\n\t * using the associated file service for those resources.\n\t *\n\t * Working copy owners can listen to the `onWillRunWorkingCopyFileOperation` and\n\t * `onDidRunWorkingCopyFileOperation` events to participate.\n\t */\n\tdelete(operations: IDeleteOperation[], token: CancellationToken, undoInfo?: IFileOperationUndoRedoInfo): Promise<void>;\n\n\t//#endregion\n\n\n\t//#region Path related\n\n\t/**\n\t * Register a new provider for working copies based on a resource.\n\t *\n\t * @return a disposable that unregisters the provider.\n\t */\n\tregisterWorkingCopyProvider(provider: WorkingCopyProvider): IDisposable;\n\n\t/**\n\t * Will return all working copies that are dirty matching the provided resource.\n\t * If the resource is a folder and the scheme supports file operations, a working\n\t * copy that is dirty and is a child of that folder will also be returned.\n\t */\n\tgetDirty(resource: URI): readonly IWorkingCopy[];\n\n\t//#endregion\n}\n\nexport class WorkingCopyFileService extends Disposable implements IWorkingCopyFileService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\t//#region Events\n\n\tprivate readonly _onWillRunWorkingCopyFileOperation = this._register(new AsyncEmitter<WorkingCopyFileEvent>());\n\treadonly onWillRunWorkingCopyFileOperation = this._onWillRunWorkingCopyFileOperation.event;\n\n\tprivate readonly _onDidFailWorkingCopyFileOperation = this._register(new AsyncEmitter<WorkingCopyFileEvent>());\n\treadonly onDidFailWorkingCopyFileOperation = this._onDidFailWorkingCopyFileOperation.event;\n\n\tprivate readonly _onDidRunWorkingCopyFileOperation = this._register(new AsyncEmitter<WorkingCopyFileEvent>());\n\treadonly onDidRunWorkingCopyFileOperation = this._onDidRunWorkingCopyFileOperation.event;\n\n\t//#endregion\n\n\tprivate correlationIds = 0;\n\n\tconstructor(\n\t\t@IFileService private readonly fileService: IFileService,\n\t\t@IWorkingCopyService private readonly workingCopyService: IWorkingCopyService,\n\t\t@IInstantiationService private readonly instantiationService: IInstantiationService,\n\t\t@IUriIdentityService private readonly uriIdentityService: IUriIdentityService\n\t) {\n\t\tsuper();\n\n\t\t// register a default working copy provider that uses the working copy service\n\t\tthis._register(this.registerWorkingCopyProvider(resource => {\n\t\t\treturn this.workingCopyService.workingCopies.filter(workingCopy => {\n\t\t\t\tif (this.fileService.hasProvider(resource)) {\n\t\t\t\t\t// only check for parents if the resource can be handled\n\t\t\t\t\t// by the file system where we then assume a folder like\n\t\t\t\t\t// path structure\n\t\t\t\t\treturn this.uriIdentityService.extUri.isEqualOrParent(workingCopy.resource, resource);\n\t\t\t\t}\n\n\t\t\t\treturn this.uriIdentityService.extUri.isEqual(workingCopy.resource, resource);\n\t\t\t});\n\t\t}));\n\t}\n\n\n\t//#region File operations\n\n\tcreate(operations: ICreateFileOperation[], token: CancellationToken, undoInfo?: IFileOperationUndoRedoInfo): Promise<IFileStatWithMetadata[]> {\n\t\treturn this.doCreateFileOrFolder(operations, true, token, undoInfo);\n\t}\n\n\tcreateFolder(operations: ICreateOperation[], token: CancellationToken, undoInfo?: IFileOperationUndoRedoInfo): Promise<IFileStatWithMetadata[]> {\n\t\treturn this.doCreateFileOrFolder(operations, false, token, undoInfo);\n\t}\n\n\tasync doCreateFileOrFolder(operations: (ICreateFileOperation | ICreateOperation)[], isFile: boolean, token: CancellationToken, undoInfo?: IFileOperationUndoRedoInfo): Promise<IFileStatWithMetadata[]> {\n\t\tif (operations.length === 0) {\n\t\t\treturn [];\n\t\t}\n\n\t\t// validate create operation before starting\n\t\tif (isFile) {\n\t\t\tconst validateCreates = await Promises.settled(operations.map(operation => this.fileService.canCreateFile(operation.resource, { overwrite: operation.overwrite })));\n\t\t\tconst error = validateCreates.find(validateCreate => validateCreate instanceof Error);\n\t\t\tif (error instanceof Error) {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t}\n\n\t\t// file operation participant\n\t\tconst files = operations.map(operation => ({ target: operation.resource }));\n\t\tawait this.runFileOperationParticipants(files, FileOperation.CREATE, undoInfo, token);\n\n\t\t// before events\n\t\tconst event = { correlationId: this.correlationIds++, operation: FileOperation.CREATE, files };\n\t\tawait this._onWillRunWorkingCopyFileOperation.fireAsync(event, CancellationToken.None /* intentional: we currently only forward cancellation to participants */);\n\n\t\t// now actually create on disk\n\t\tlet stats: IFileStatWithMetadata[];\n\t\ttry {\n\t\t\tif (isFile) {\n\t\t\t\tstats = await Promises.settled(operations.map(operation => this.fileService.createFile(operation.resource, (operation as ICreateFileOperation).contents, { overwrite: operation.overwrite })));\n\t\t\t} else {\n\t\t\t\tstats = await Promises.settled(operations.map(operation => this.fileService.createFolder(operation.resource)));\n\t\t\t}\n\t\t} catch (error) {\n\n\t\t\t// error event\n\t\t\tawait this._onDidFailWorkingCopyFileOperation.fireAsync(event, CancellationToken.None /* intentional: we currently only forward cancellation to participants */);\n\n\t\t\tthrow error;\n\t\t}\n\n\t\t// after event\n\t\tawait this._onDidRunWorkingCopyFileOperation.fireAsync(event, CancellationToken.None /* intentional: we currently only forward cancellation to participants */);\n\n\t\treturn stats;\n\t}\n\n\tasync move(operations: IMoveOperation[], token: CancellationToken, undoInfo?: IFileOperationUndoRedoInfo): Promise<IFileStatWithMetadata[]> {\n\t\treturn this.doMoveOrCopy(operations, true, token, undoInfo);\n\t}\n\n\tasync copy(operations: ICopyOperation[], token: CancellationToken, undoInfo?: IFileOperationUndoRedoInfo): Promise<IFileStatWithMetadata[]> {\n\t\treturn this.doMoveOrCopy(operations, false, token, undoInfo);\n\t}\n\n\tprivate async doMoveOrCopy(operations: IMoveOperation[] | ICopyOperation[], move: boolean, token: CancellationToken, undoInfo?: IFileOperationUndoRedoInfo): Promise<IFileStatWithMetadata[]> {\n\t\tconst stats: IFileStatWithMetadata[] = [];\n\n\t\t// validate move/copy operation before starting\n\t\tfor (const { file: { source, target }, overwrite } of operations) {\n\t\t\tconst validateMoveOrCopy = await (move ? this.fileService.canMove(source, target, overwrite) : this.fileService.canCopy(source, target, overwrite));\n\t\t\tif (validateMoveOrCopy instanceof Error) {\n\t\t\t\tthrow validateMoveOrCopy;\n\t\t\t}\n\t\t}\n\n\t\t// file operation participant\n\t\tconst files = operations.map(o => o.file);\n\t\tawait this.runFileOperationParticipants(files, move ? FileOperation.MOVE : FileOperation.COPY, undoInfo, token);\n\n\t\t// before event\n\t\tconst event = { correlationId: this.correlationIds++, operation: move ? FileOperation.MOVE : FileOperation.COPY, files };\n\t\tawait this._onWillRunWorkingCopyFileOperation.fireAsync(event, CancellationToken.None /* intentional: we currently only forward cancellation to participants */);\n\n\t\ttry {\n\t\t\tfor (const { file: { source, target }, overwrite } of operations) {\n\t\t\t\t// if source and target are not equal, handle dirty working copies\n\t\t\t\t// depending on the operation:\n\t\t\t\t// - move: revert both source and target (if any)\n\t\t\t\t// - copy: revert target (if any)\n\t\t\t\tif (!this.uriIdentityService.extUri.isEqual(source, target)) {\n\t\t\t\t\tconst dirtyWorkingCopies = (move ? [...this.getDirty(source), ...this.getDirty(target)] : this.getDirty(target));\n\t\t\t\t\tawait Promises.settled(dirtyWorkingCopies.map(dirtyWorkingCopy => dirtyWorkingCopy.revert({ soft: true })));\n\t\t\t\t}\n\n\t\t\t\t// now we can rename the source to target via file operation\n\t\t\t\tif (move) {\n\t\t\t\t\tstats.push(await this.fileService.move(source, target, overwrite));\n\t\t\t\t} else {\n\t\t\t\t\tstats.push(await this.fileService.copy(source, target, overwrite));\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (error) {\n\n\t\t\t// error event\n\t\t\tawait this._onDidFailWorkingCopyFileOperation.fireAsync(event, CancellationToken.None /* intentional: we currently only forward cancellation to participants */);\n\n\t\t\tthrow error;\n\t\t}\n\n\t\t// after event\n\t\tawait this._onDidRunWorkingCopyFileOperation.fireAsync(event, CancellationToken.None /* intentional: we currently only forward cancellation to participants */);\n\n\t\treturn stats;\n\t}\n\n\tasync delete(operations: IDeleteOperation[], token: CancellationToken, undoInfo?: IFileOperationUndoRedoInfo): Promise<void> {\n\n\t\t// validate delete operation before starting\n\t\tfor (const operation of operations) {\n\t\t\tconst validateDelete = await this.fileService.canDelete(operation.resource, { recursive: operation.recursive, useTrash: operation.useTrash });\n\t\t\tif (validateDelete instanceof Error) {\n\t\t\t\tthrow validateDelete;\n\t\t\t}\n\t\t}\n\n\t\t// file operation participant\n\t\tconst files = operations.map(operation => ({ target: operation.resource }));\n\t\tawait this.runFileOperationParticipants(files, FileOperation.DELETE, undoInfo, token);\n\n\t\t// before events\n\t\tconst event = { correlationId: this.correlationIds++, operation: FileOperation.DELETE, files };\n\t\tawait this._onWillRunWorkingCopyFileOperation.fireAsync(event, CancellationToken.None /* intentional: we currently only forward cancellation to participants */);\n\n\t\t// check for any existing dirty working copies for the resource\n\t\t// and do a soft revert before deleting to be able to close\n\t\t// any opened editor with these working copies\n\t\tfor (const operation of operations) {\n\t\t\tconst dirtyWorkingCopies = this.getDirty(operation.resource);\n\t\t\tawait Promises.settled(dirtyWorkingCopies.map(dirtyWorkingCopy => dirtyWorkingCopy.revert({ soft: true })));\n\t\t}\n\n\t\t// now actually delete from disk\n\t\ttry {\n\t\t\tfor (const operation of operations) {\n\t\t\t\tawait this.fileService.del(operation.resource, { recursive: operation.recursive, useTrash: operation.useTrash });\n\t\t\t}\n\t\t} catch (error) {\n\n\t\t\t// error event\n\t\t\tawait this._onDidFailWorkingCopyFileOperation.fireAsync(event, CancellationToken.None /* intentional: we currently only forward cancellation to participants */);\n\n\t\t\tthrow error;\n\t\t}\n\n\t\t// after event\n\t\tawait this._onDidRunWorkingCopyFileOperation.fireAsync(event, CancellationToken.None /* intentional: we currently only forward cancellation to participants */);\n\t}\n\n\t//#endregion\n\n\n\t//#region File operation participants\n\n\tprivate readonly fileOperationParticipants = this._register(this.instantiationService.createInstance(WorkingCopyFileOperationParticipant));\n\n\taddFileOperationParticipant(participant: IWorkingCopyFileOperationParticipant): IDisposable {\n\t\treturn this.fileOperationParticipants.addFileOperationParticipant(participant);\n\t}\n\n\tprivate runFileOperationParticipants(files: SourceTargetPair[], operation: FileOperation, undoInfo: IFileOperationUndoRedoInfo | undefined, token: CancellationToken): Promise<void> {\n\t\treturn this.fileOperationParticipants.participate(files, operation, undoInfo, token);\n\t}\n\n\t//#endregion\n\n\t//#region Save participants (stored file working copies only)\n\n\tprivate readonly saveParticipants = this._register(this.instantiationService.createInstance(StoredFileWorkingCopySaveParticipant));\n\n\tget hasSaveParticipants(): boolean { return this.saveParticipants.length > 0; }\n\n\taddSaveParticipant(participant: IStoredFileWorkingCopySaveParticipant): IDisposable {\n\t\treturn this.saveParticipants.addSaveParticipant(participant);\n\t}\n\n\trunSaveParticipants(workingCopy: IStoredFileWorkingCopy<IStoredFileWorkingCopyModel>, context: { reason: SaveReason }, token: CancellationToken): Promise<void> {\n\t\treturn this.saveParticipants.participate(workingCopy, context, token);\n\t}\n\n\t//#endregion\n\n\n\t//#region Path related\n\n\tprivate readonly workingCopyProviders: WorkingCopyProvider[] = [];\n\n\tregisterWorkingCopyProvider(provider: WorkingCopyProvider): IDisposable {\n\t\tconst remove = insert(this.workingCopyProviders, provider);\n\n\t\treturn toDisposable(remove);\n\t}\n\n\tgetDirty(resource: URI): IWorkingCopy[] {\n\t\tconst dirtyWorkingCopies = new Set<IWorkingCopy>();\n\t\tfor (const provider of this.workingCopyProviders) {\n\t\t\tfor (const workingCopy of provider(resource)) {\n\t\t\t\tif (workingCopy.isDirty()) {\n\t\t\t\t\tdirtyWorkingCopies.add(workingCopy);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn Array.from(dirtyWorkingCopies);\n\t}\n\n\t//#endregion\n}\n\nregisterSingleton(IWorkingCopyFileService, WorkingCopyFileService, InstantiationType.Delayed);\n"]}