{"version":3,"sources":["file:///workspace/appflow/src/vs/workbench/services/lifecycle/common/lifecycle.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;IAMnF,QAAA,GAAG,GAAiB,IAAA,mBAAG,EAAgC,kBAAkB,CAAC,CAAC;IAyGxF,IAAkB,cAqBjB;IArBD,WAAkB,cAAc;QAE/B;;WAEG;QACH,qDAAS,CAAA;QAET;;WAEG;QACH,mDAAI,CAAA;QAEJ;;WAEG;QACH,uDAAM,CAAA;QAEN;;WAEG;QACH,mDAAI,CAAA;IACL,CAAC,EArBiB,cAAc,8BAAd,cAAc,QAqB/B;IAED,IAAkB,WAIjB;IAJD,WAAkB,WAAW;QAC5B,uDAAa,CAAA;QACb,iEAAkB,CAAA;QAClB,iEAAkB,CAAA;IACnB,CAAC,EAJiB,WAAW,2BAAX,WAAW,QAI5B;IAED,SAAgB,GAAG,CAAiB,WAAwB;QAC3D,QAAQ,WAAW,EAAE;YACpB,kCAA0B,CAAC,CAAC,OAAO,WAAW,CAAC;YAC/C,uCAA+B,CAAC,CAAC,OAAO,gBAAgB,CAAC;YACzD,uCAA+B,CAAC,CAAC,OAAO,gBAAgB,CAAC;SACzD;IACF,CAAC;IAND,kBAMC;IAED,IAAkB,cA6BjB;IA7BD,WAAkB,cAAc;QAE/B;;;;;WAKG;QACH,2DAAY,CAAA;QAEZ;;;;;WAKG;QACH,qDAAS,CAAA;QAET;;;WAGG;QACH,2DAAY,CAAA;QAEZ;;;WAGG;QACH,+DAAc,CAAA;IACf,CAAC,EA7BiB,cAAc,8BAAd,cAAc,QA6B/B;IAED,SAAgB,GAAG,CAAoB,KAAqB;QAC3D,QAAQ,KAAK,EAAE;YACd,oCAA4B,CAAC,CAAC,OAAO,UAAU,CAAC;YAChD,iCAAyB,CAAC,CAAC,OAAO,OAAO,CAAC;YAC1C,oCAA4B,CAAC,CAAC,OAAO,UAAU,CAAC;YAChD,sCAA8B,CAAC,CAAC,OAAO,YAAY,CAAC;SACpD;IACF,CAAC;IAPD,kBAOC","file":"lifecycle.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken } from 'vs/base/common/cancellation';\nimport { Event } from 'vs/base/common/event';\nimport { createDecorator } from 'vs/platform/instantiation/common/instantiation';\n\nexport const ILifecycleService = createDecorator<ILifecycleService>('lifecycleService');\n\n/**\n * An event that is send out when the window is about to close. Clients have a chance to veto\n * the closing by either calling veto with a boolean \"true\" directly or with a promise that\n * resolves to a boolean. Returning a promise is useful in cases of long running operations\n * on shutdown.\n *\n * Note: It is absolutely important to avoid long running promises if possible. Please try hard\n * to return a boolean directly. Returning a promise has quite an impact on the shutdown sequence!\n */\nexport interface BeforeShutdownEvent {\n\n\t/**\n\t * The reason why the application will be shutting down.\n\t */\n\treadonly reason: ShutdownReason;\n\n\t/**\n\t * Allows to veto the shutdown. The veto can be a long running operation but it\n\t * will block the application from closing.\n\t *\n\t * @param id to identify the veto operation in case it takes very long or never\n\t * completes.\n\t */\n\tveto(value: boolean | Promise<boolean>, id: string): void;\n}\n\nexport interface InternalBeforeShutdownEvent extends BeforeShutdownEvent {\n\n\t/**\n\t * Allows to set a veto operation to run after all other\n\t * vetos have been handled from the `BeforeShutdownEvent`\n\t *\n\t * This method is hidden from the API because it is intended\n\t * to be only used once internally.\n\t */\n\tfinalVeto(vetoFn: () => boolean | Promise<boolean>, id: string): void;\n}\n\n/**\n * An event that signals an error happened during `onBeforeShutdown` veto handling.\n * In this case the shutdown operation will not proceed because this is an unexpected\n * condition that is treated like a veto.\n */\nexport interface BeforeShutdownErrorEvent {\n\n\t/**\n\t * The reason why the application is shutting down.\n\t */\n\treadonly reason: ShutdownReason;\n\n\t/**\n\t * The error that happened during shutdown handling.\n\t */\n\treadonly error: Error;\n}\n\nexport interface IWillShutdownEventJoiner {\n\tid: string;\n\tlabel: string;\n}\n\n/**\n * An event that is send out when the window closes. Clients have a chance to join the closing\n * by providing a promise from the join method. Returning a promise is useful in cases of long\n * running operations on shutdown.\n *\n * Note: It is absolutely important to avoid long running promises if possible. Please try hard\n * to return a boolean directly. Returning a promise has quite an impact on the shutdown sequence!\n */\nexport interface WillShutdownEvent {\n\n\t/**\n\t * The reason why the application is shutting down.\n\t */\n\treadonly reason: ShutdownReason;\n\n\t/**\n\t * A token that will signal cancellation when the\n\t * shutdown was forced by the user.\n\t */\n\treadonly token: CancellationToken;\n\n\t/**\n\t * Allows to join the shutdown. The promise can be a long running operation but it\n\t * will block the application from closing.\n\t *\n\t * @param joiner to identify the join operation in case it takes very long or never\n\t * completes.\n\t */\n\tjoin(promise: Promise<void>, joiner: IWillShutdownEventJoiner): void;\n\n\t/**\n\t * Allows to access the joiners that have not finished joining this event.\n\t */\n\tjoiners(): IWillShutdownEventJoiner[];\n\n\t/**\n\t * Allows to enforce the shutdown, even when there are\n\t * pending `join` operations to complete.\n\t */\n\tforce(): void;\n}\n\nexport const enum ShutdownReason {\n\n\t/**\n\t * The window is closed.\n\t */\n\tCLOSE = 1,\n\n\t/**\n\t * The window closes because the application quits.\n\t */\n\tQUIT,\n\n\t/**\n\t * The window is reloaded.\n\t */\n\tRELOAD,\n\n\t/**\n\t * The window is loaded into a different workspace context.\n\t */\n\tLOAD\n}\n\nexport const enum StartupKind {\n\tNewWindow = 1,\n\tReloadedWindow = 3,\n\tReopenedWindow = 4\n}\n\nexport function StartupKindToString(startupKind: StartupKind): string {\n\tswitch (startupKind) {\n\t\tcase StartupKind.NewWindow: return 'NewWindow';\n\t\tcase StartupKind.ReloadedWindow: return 'ReloadedWindow';\n\t\tcase StartupKind.ReopenedWindow: return 'ReopenedWindow';\n\t}\n}\n\nexport const enum LifecyclePhase {\n\n\t/**\n\t * The first phase signals that we are about to startup getting ready.\n\t *\n\t * Note: doing work in this phase blocks an editor from showing to\n\t * the user, so please rather consider to use `Restored` phase.\n\t */\n\tStarting = 1,\n\n\t/**\n\t * Services are ready and the window is about to restore its UI state.\n\t *\n\t * Note: doing work in this phase blocks an editor from showing to\n\t * the user, so please rather consider to use `Restored` phase.\n\t */\n\tReady = 2,\n\n\t/**\n\t * Views, panels and editors have restored. Editors are given a bit of\n\t * time to restore their contents.\n\t */\n\tRestored = 3,\n\n\t/**\n\t * The last phase after views, panels and editors have restored and\n\t * some time has passed (2-5 seconds).\n\t */\n\tEventually = 4\n}\n\nexport function LifecyclePhaseToString(phase: LifecyclePhase): string {\n\tswitch (phase) {\n\t\tcase LifecyclePhase.Starting: return 'Starting';\n\t\tcase LifecyclePhase.Ready: return 'Ready';\n\t\tcase LifecyclePhase.Restored: return 'Restored';\n\t\tcase LifecyclePhase.Eventually: return 'Eventually';\n\t}\n}\n\n/**\n * A lifecycle service informs about lifecycle events of the\n * application, such as shutdown.\n */\nexport interface ILifecycleService {\n\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Value indicates how this window got loaded.\n\t */\n\treadonly startupKind: StartupKind;\n\n\t/**\n\t * A flag indicating in what phase of the lifecycle we currently are.\n\t */\n\tphase: LifecyclePhase;\n\n\t/**\n\t * Fired before shutdown happens. Allows listeners to veto against the\n\t * shutdown to prevent it from happening.\n\t *\n\t * The event carries a shutdown reason that indicates how the shutdown was triggered.\n\t */\n\treadonly onBeforeShutdown: Event<BeforeShutdownEvent>;\n\n\t/**\n\t * Fired when the shutdown was prevented by a component giving veto.\n\t */\n\treadonly onShutdownVeto: Event<void>;\n\n\t/**\n\t * Fired when an error happened during `onBeforeShutdown` veto handling.\n\t * In this case the shutdown operation will not proceed because this is\n\t * an unexpected condition that is treated like a veto.\n\t *\n\t * The event carries a shutdown reason that indicates how the shutdown was triggered.\n\t */\n\treadonly onBeforeShutdownError: Event<BeforeShutdownErrorEvent>;\n\n\t/**\n\t * Fired when no client is preventing the shutdown from happening (from `onBeforeShutdown`).\n\t *\n\t * This event can be joined with a long running operation via `WillShutdownEvent#join()` to\n\t * handle long running shutdown operations.\n\t *\n\t * The event carries a shutdown reason that indicates how the shutdown was triggered.\n\t */\n\treadonly onWillShutdown: Event<WillShutdownEvent>;\n\n\t/**\n\t * Fired when the shutdown is about to happen after long running shutdown operations\n\t * have finished (from `onWillShutdown`).\n\t *\n\t * This event should be used to dispose resources.\n\t */\n\treadonly onDidShutdown: Event<void>;\n\n\t/**\n\t * Returns a promise that resolves when a certain lifecycle phase\n\t * has started.\n\t */\n\twhen(phase: LifecyclePhase): Promise<void>;\n\n\t/**\n\t * Triggers a shutdown of the workbench. Depending on native or web, this can have\n\t * different implementations and behaviour.\n\t *\n\t * **Note:** this should normally not be called. See related methods in `IHostService`\n\t * and `INativeHostService` to close a window or quit the application.\n\t */\n\tshutdown(): Promise<void>;\n}\n"]}