{"version":3,"sources":["file:///workspace/appflow/src/vs/workbench/services/commands/common/commandService.ts"],"names":[],"mappings":"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","file":"commandService.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IInstantiationService } from 'vs/platform/instantiation/common/instantiation';\nimport { ICommandService, ICommandEvent, CommandsRegistry } from 'vs/platform/commands/common/commands';\nimport { IExtensionService } from 'vs/workbench/services/extensions/common/extensions';\nimport { Event, Emitter } from 'vs/base/common/event';\nimport { Disposable } from 'vs/base/common/lifecycle';\nimport { ILogService } from 'vs/platform/log/common/log';\nimport { InstantiationType, registerSingleton } from 'vs/platform/instantiation/common/extensions';\nimport { timeout } from 'vs/base/common/async';\n\nexport class CommandService extends Disposable implements ICommandService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate _extensionHostIsReady: boolean = false;\n\tprivate _starActivation: Promise<void> | null;\n\n\tprivate readonly _onWillExecuteCommand: Emitter<ICommandEvent> = this._register(new Emitter<ICommandEvent>());\n\tpublic readonly onWillExecuteCommand: Event<ICommandEvent> = this._onWillExecuteCommand.event;\n\n\tprivate readonly _onDidExecuteCommand: Emitter<ICommandEvent> = new Emitter<ICommandEvent>();\n\tpublic readonly onDidExecuteCommand: Event<ICommandEvent> = this._onDidExecuteCommand.event;\n\n\tconstructor(\n\t\t@IInstantiationService private readonly _instantiationService: IInstantiationService,\n\t\t@IExtensionService private readonly _extensionService: IExtensionService,\n\t\t@ILogService private readonly _logService: ILogService\n\t) {\n\t\tsuper();\n\t\tthis._extensionService.whenInstalledExtensionsRegistered().then(value => this._extensionHostIsReady = value);\n\t\tthis._starActivation = null;\n\t}\n\n\tprivate _activateStar(): Promise<void> {\n\t\tif (!this._starActivation) {\n\t\t\t// wait for * activation, limited to at most 30s\n\t\t\tthis._starActivation = Promise.race<any>([\n\t\t\t\tthis._extensionService.activateByEvent(`*`),\n\t\t\t\ttimeout(30000)\n\t\t\t]);\n\t\t}\n\t\treturn this._starActivation;\n\t}\n\n\tasync executeCommand<T>(id: string, ...args: any[]): Promise<T> {\n\t\tthis._logService.trace('CommandService#executeCommand', id);\n\n\t\tconst activationEvent = `onCommand:${id}`;\n\t\tconst commandIsRegistered = !!CommandsRegistry.getCommand(id);\n\n\t\tif (commandIsRegistered) {\n\n\t\t\t// if the activation event has already resolved (i.e. subsequent call),\n\t\t\t// we will execute the registered command immediately\n\t\t\tif (this._extensionService.activationEventIsDone(activationEvent)) {\n\t\t\t\treturn this._tryExecuteCommand(id, args);\n\t\t\t}\n\n\t\t\t// if the extension host didn't start yet, we will execute the registered\n\t\t\t// command immediately and send an activation event, but not wait for it\n\t\t\tif (!this._extensionHostIsReady) {\n\t\t\t\tthis._extensionService.activateByEvent(activationEvent); // intentionally not awaited\n\t\t\t\treturn this._tryExecuteCommand(id, args);\n\t\t\t}\n\n\t\t\t// we will wait for a simple activation event (e.g. in case an extension wants to overwrite it)\n\t\t\tawait this._extensionService.activateByEvent(activationEvent);\n\t\t\treturn this._tryExecuteCommand(id, args);\n\t\t}\n\n\t\t// finally, if the command is not registered we will send a simple activation event\n\t\t// as well as a * activation event raced against registration and against 30s\n\t\tawait Promise.all([\n\t\t\tthis._extensionService.activateByEvent(activationEvent),\n\t\t\tPromise.race<any>([\n\t\t\t\t// race * activation against command registration\n\t\t\t\tthis._activateStar(),\n\t\t\t\tEvent.toPromise(Event.filter(CommandsRegistry.onDidRegisterCommand, e => e === id))\n\t\t\t]),\n\t\t]);\n\t\treturn this._tryExecuteCommand(id, args);\n\t}\n\n\tprivate _tryExecuteCommand(id: string, args: any[]): Promise<any> {\n\t\tconst command = CommandsRegistry.getCommand(id);\n\t\tif (!command) {\n\t\t\treturn Promise.reject(new Error(`command '${id}' not found`));\n\t\t}\n\t\ttry {\n\t\t\tthis._onWillExecuteCommand.fire({ commandId: id, args });\n\t\t\tconst result = this._instantiationService.invokeFunction(command.handler, ...args);\n\t\t\tthis._onDidExecuteCommand.fire({ commandId: id, args });\n\t\t\treturn Promise.resolve(result);\n\t\t} catch (err) {\n\t\t\treturn Promise.reject(err);\n\t\t}\n\t}\n}\n\nregisterSingleton(ICommandService, CommandService, InstantiationType.Delayed);\n"]}