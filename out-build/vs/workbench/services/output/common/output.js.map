{"version":3,"sources":["file:///workspace/appflow/src/vs/workbench/services/output/common/output.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;IAQhG;;OAEG;IACU,QAAA,GAAG,GAAW,oBAAoB,CAAC;IAEhD;;OAEG;IACU,QAAA,GAAG,GAAa,QAAQ,CAAC;IAEtC;;OAEG;IACU,QAAA,GAAG,GAAc,KAAK,CAAC;IAEpC;;OAEG;IACU,QAAA,GAAG,GAAQ,wBAAwB,CAAC;IAEjD;;OAEG;IACU,QAAA,GAAG,GAAU,KAAK,CAAC;IAEhC;;OAEG;IACU,QAAA,GAAG,GAAW,KAAK,CAAC;IAEjC;;OAEG;IACU,QAAA,GAAG,GAAc,wBAAwB,CAAC;IAE1C,QAAA,GAAG,GAAiB,IAAI,gBAAG,CAAoB,UAAU,EAAE,KAAK,CAAC,CAAC;IAElE,QAAA,GAAG,GAAyB,IAAI,gBAAG,CAAoB,iBAAiB,EAAE,KAAK,CAAC,CAAC;IAEjF,QAAA,GAAG,GAA0B,IAAI,gBAAG,CAAoB,uBAAuB,EAAE,KAAK,CAAC,CAAC;IAExF,QAAA,GAAG,GAAc,IAAA,mBAAG,EAA6B,eAAe,CAAC,CAAC;IAyC/E,IAAY,uBAIX;IAJD,WAAY,uBAAuB;QAClC,yEAAU,CAAA;QACV,2EAAO,CAAA;QACP,uEAAK,CAAA;IACN,CAAC,EAJW,uBAAuB,uCAAvB,uBAAuB,QAIlC;IA8CY,QAAA,GAAG,GAAU;QACzB,cAAc,EAAE,wCAAwC;KACxD,CAAC;IAyCF,MAAM,qBAAqB;QAA3B;YACS,MAAC,GAAU,IAAI,GAAG,EAAoC,CAAC;YAE9C,MAAC,GAAuB,IAAI,WAAG,EAAc,CAAC;YACtD,yBAAoB,GAAkB,IAAI,CAAC,CAAC,CAAqB,KAAK,CAAC;YAE/D,MAAC,GAAqB,IAAI,WAAG,EAAc,CAAC;YACpD,uBAAkB,GAAkB,IAAI,CAAC,CAAC,CAAmB,KAAK,CAAC;QAuB7E,CAAC;QArBO,eAAe,CAAC,UAAoC;YAC1D,IAAI,CAAC,IAAI,CAAC,CAAC,CAAQ,GAAG,CAAC,UAAU,CAAC,EAAE,CAAC,EAAE;gBACtC,IAAI,CAAC,CAAC,CAAQ,GAAG,CAAC,UAAU,CAAC,EAAE,EAAE,UAAU,CAAC,CAAC;gBAC7C,IAAI,CAAC,CAAC,CAAqB,IAAI,CAAC,UAAU,CAAC,EAAE,CAAC,CAAC;aAC/C;QACF,CAAC;QAEM,WAAW;YACjB,MAAM,MAAM,GAA+B,EAAE,CAAC;YAC9C,IAAI,CAAC,CAAC,CAAQ,OAAO,CAAC,KAAK,CAAC,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;YACnD,OAAO,MAAM,CAAC;QACf,CAAC;QAEM,UAAU,CAAC,EAAU;YAC3B,OAAO,IAAI,CAAC,CAAC,CAAQ,GAAG,CAAC,EAAE,CAAC,CAAC;QAC9B,CAAC;QAEM,aAAa,CAAC,EAAU;YAC9B,IAAI,CAAC,CAAC,CAAQ,MAAM,CAAC,EAAE,CAAC,CAAC;YACzB,IAAI,CAAC,CAAC,CAAmB,IAAI,CAAC,EAAE,CAAC,CAAC;QACnC,CAAC;KACD;IAED,cAAG,CAAM,GAAG,CAAC,WAAG,CAAQ,cAAc,EAAE,IAAI,qBAAqB,EAAE,CAAC,CAAC;IAExD,QAAA,GAAG,GAA6B,IAAI,gBAAG,CAAmB,qBAAqB,EAAE,EAAE,CAAC,CAAC","file":"output.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event, Emitter } from 'vs/base/common/event';\nimport { Registry } from 'vs/platform/registry/common/platform';\nimport { URI } from 'vs/base/common/uri';\nimport { RawContextKey } from 'vs/platform/contextkey/common/contextkey';\nimport { createDecorator } from 'vs/platform/instantiation/common/instantiation';\n\n/**\n * Mime type used by the output editor.\n */\nexport const OUTPUT_MIME = 'text/x-code-output';\n\n/**\n * Output resource scheme.\n */\nexport const OUTPUT_SCHEME = 'output';\n\n/**\n * Id used by the output editor.\n */\nexport const OUTPUT_MODE_ID = 'Log';\n\n/**\n * Mime type used by the log output editor.\n */\nexport const LOG_MIME = 'text/x-code-log-output';\n\n/**\n * Log resource scheme.\n */\nexport const LOG_SCHEME = 'log';\n\n/**\n * Id used by the log output editor.\n */\nexport const LOG_MODE_ID = 'log';\n\n/**\n * Output view id\n */\nexport const OUTPUT_VIEW_ID = 'workbench.panel.output';\n\nexport const CONTEXT_IN_OUTPUT = new RawContextKey<boolean>('inOutput', false);\n\nexport const CONTEXT_ACTIVE_LOG_OUTPUT = new RawContextKey<boolean>('activeLogOutput', false);\n\nexport const CONTEXT_OUTPUT_SCROLL_LOCK = new RawContextKey<boolean>(`outputView.scrollLock`, false);\n\nexport const IOutputService = createDecorator<IOutputService>('outputService');\n\n/**\n * The output service to manage output from the various processes running.\n */\nexport interface IOutputService {\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Given the channel id returns the output channel instance.\n\t * Channel should be first registered via OutputChannelRegistry.\n\t */\n\tgetChannel(id: string): IOutputChannel | undefined;\n\n\t/**\n\t * Given the channel id returns the registered output channel descriptor.\n\t */\n\tgetChannelDescriptor(id: string): IOutputChannelDescriptor | undefined;\n\n\t/**\n\t * Returns an array of all known output channels descriptors.\n\t */\n\tgetChannelDescriptors(): IOutputChannelDescriptor[];\n\n\t/**\n\t * Returns the currently active channel.\n\t * Only one channel can be active at a given moment.\n\t */\n\tgetActiveChannel(): IOutputChannel | undefined;\n\n\t/**\n\t * Show the channel with the passed id.\n\t */\n\tshowChannel(id: string, preserveFocus?: boolean): Promise<void>;\n\n\t/**\n\t * Allows to register on active output channel change.\n\t */\n\tonActiveOutputChannel: Event<string>;\n}\n\nexport enum OutputChannelUpdateMode {\n\tAppend = 1,\n\tReplace,\n\tClear\n}\n\nexport interface IOutputChannel {\n\n\t/**\n\t * Identifier of the output channel.\n\t */\n\tid: string;\n\n\t/**\n\t * Label of the output channel to be displayed to the user.\n\t */\n\tlabel: string;\n\n\t/**\n\t * URI of the output channel.\n\t */\n\turi: URI;\n\n\t/**\n\t * Appends output to the channel.\n\t */\n\tappend(output: string): void;\n\n\t/**\n\t * Clears all received output for this channel.\n\t */\n\tclear(): void;\n\n\t/**\n\t * Replaces the content of the channel with given output\n\t */\n\treplace(output: string): void;\n\n\t/**\n\t * Update the channel.\n\t */\n\tupdate(mode: OutputChannelUpdateMode.Append): void;\n\tupdate(mode: OutputChannelUpdateMode, till: number): void;\n\n\t/**\n\t * Disposes the output channel.\n\t */\n\tdispose(): void;\n}\n\nexport const Extensions = {\n\tOutputChannels: 'workbench.contributions.outputChannels'\n};\n\nexport interface IOutputChannelDescriptor {\n\tid: string;\n\tlabel: string;\n\tlog: boolean;\n\tlanguageId?: string;\n\tfile?: URI;\n\textensionId?: string;\n}\n\nexport interface IFileOutputChannelDescriptor extends IOutputChannelDescriptor {\n\tfile: URI;\n}\n\nexport interface IOutputChannelRegistry {\n\n\treadonly onDidRegisterChannel: Event<string>;\n\treadonly onDidRemoveChannel: Event<string>;\n\n\t/**\n\t * Make an output channel known to the output world.\n\t */\n\tregisterChannel(descriptor: IOutputChannelDescriptor): void;\n\n\t/**\n\t * Returns the list of channels known to the output world.\n\t */\n\tgetChannels(): IOutputChannelDescriptor[];\n\n\t/**\n\t * Returns the channel with the passed id.\n\t */\n\tgetChannel(id: string): IOutputChannelDescriptor | undefined;\n\n\t/**\n\t * Remove the output channel with the passed id.\n\t */\n\tremoveChannel(id: string): void;\n}\n\nclass OutputChannelRegistry implements IOutputChannelRegistry {\n\tprivate channels = new Map<string, IOutputChannelDescriptor>();\n\n\tprivate readonly _onDidRegisterChannel = new Emitter<string>();\n\treadonly onDidRegisterChannel: Event<string> = this._onDidRegisterChannel.event;\n\n\tprivate readonly _onDidRemoveChannel = new Emitter<string>();\n\treadonly onDidRemoveChannel: Event<string> = this._onDidRemoveChannel.event;\n\n\tpublic registerChannel(descriptor: IOutputChannelDescriptor): void {\n\t\tif (!this.channels.has(descriptor.id)) {\n\t\t\tthis.channels.set(descriptor.id, descriptor);\n\t\t\tthis._onDidRegisterChannel.fire(descriptor.id);\n\t\t}\n\t}\n\n\tpublic getChannels(): IOutputChannelDescriptor[] {\n\t\tconst result: IOutputChannelDescriptor[] = [];\n\t\tthis.channels.forEach(value => result.push(value));\n\t\treturn result;\n\t}\n\n\tpublic getChannel(id: string): IOutputChannelDescriptor | undefined {\n\t\treturn this.channels.get(id);\n\t}\n\n\tpublic removeChannel(id: string): void {\n\t\tthis.channels.delete(id);\n\t\tthis._onDidRemoveChannel.fire(id);\n\t}\n}\n\nRegistry.add(Extensions.OutputChannels, new OutputChannelRegistry());\n\nexport const ACTIVE_OUTPUT_CHANNEL_CONTEXT = new RawContextKey<string>('activeOutputChannel', '');\n"]}