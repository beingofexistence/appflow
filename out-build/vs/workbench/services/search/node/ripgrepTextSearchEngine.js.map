{"version":3,"sources":["file:///workspace/appflow/src/vs/workbench/services/search/node/ripgrepTextSearchEngine.ts"],"names":[],"mappings":"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","file":"ripgrepTextSearchEngine.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as cp from 'child_process';\nimport { EventEmitter } from 'events';\nimport { StringDecoder } from 'string_decoder';\nimport { coalesce } from 'vs/base/common/arrays';\nimport { CancellationToken } from 'vs/base/common/cancellation';\nimport { groupBy } from 'vs/base/common/collections';\nimport { splitGlobAware } from 'vs/base/common/glob';\nimport * as path from 'vs/base/common/path';\nimport { createRegExp, escapeRegExpCharacters } from 'vs/base/common/strings';\nimport { URI } from 'vs/base/common/uri';\nimport { Progress } from 'vs/platform/progress/common/progress';\nimport { IExtendedExtensionSearchOptions, SearchError, SearchErrorCode, serializeSearchError } from 'vs/workbench/services/search/common/search';\nimport { Range, TextSearchComplete, TextSearchContext, TextSearchMatch, TextSearchOptions, TextSearchPreviewOptions, TextSearchQuery, TextSearchResult } from 'vs/workbench/services/search/common/searchExtTypes';\nimport { AST as ReAST, RegExpParser, RegExpVisitor } from 'vscode-regexpp';\nimport { rgPath } from '@vscode/ripgrep';\nimport { anchorGlob, createTextSearchResult, IOutputChannel, Maybe } from './ripgrepSearchUtils';\n\n// If @vscode/ripgrep is in an .asar file, then the binary is unpacked.\nconst rgDiskPath = rgPath.replace(/\\bnode_modules\\.asar\\b/, 'node_modules.asar.unpacked');\n\nexport class RipgrepTextSearchEngine {\n\n\tconstructor(private outputChannel: IOutputChannel) { }\n\n\tprovideTextSearchResults(query: TextSearchQuery, options: TextSearchOptions, progress: Progress<TextSearchResult>, token: CancellationToken): Promise<TextSearchComplete> {\n\t\tthis.outputChannel.appendLine(`provideTextSearchResults ${query.pattern}, ${JSON.stringify({\n\t\t\t...options,\n\t\t\t...{\n\t\t\t\tfolder: options.folder.toString()\n\t\t\t}\n\t\t})}`);\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\ttoken.onCancellationRequested(() => cancel());\n\n\t\t\tconst rgArgs = getRgArgs(query, options);\n\n\t\t\tconst cwd = options.folder.fsPath;\n\n\t\t\tconst escapedArgs = rgArgs\n\t\t\t\t.map(arg => arg.match(/^-/) ? arg : `'${arg}'`)\n\t\t\t\t.join(' ');\n\t\t\tthis.outputChannel.appendLine(`${rgDiskPath} ${escapedArgs}\\n - cwd: ${cwd}`);\n\n\t\t\tlet rgProc: Maybe<cp.ChildProcess> = cp.spawn(rgDiskPath, rgArgs, { cwd });\n\t\t\trgProc.on('error', e => {\n\t\t\t\tconsole.error(e);\n\t\t\t\tthis.outputChannel.appendLine('Error: ' + (e && e.message));\n\t\t\t\treject(serializeSearchError(new SearchError(e && e.message, SearchErrorCode.rgProcessError)));\n\t\t\t});\n\n\t\t\tlet gotResult = false;\n\t\t\tconst ripgrepParser = new RipgrepParser(options.maxResults, cwd, options.previewOptions);\n\t\t\tripgrepParser.on('result', (match: TextSearchResult) => {\n\t\t\t\tgotResult = true;\n\t\t\t\tdataWithoutResult = '';\n\t\t\t\tprogress.report(match);\n\t\t\t});\n\n\t\t\tlet isDone = false;\n\t\t\tconst cancel = () => {\n\t\t\t\tisDone = true;\n\n\t\t\t\trgProc?.kill();\n\n\t\t\t\tripgrepParser?.cancel();\n\t\t\t};\n\n\t\t\tlet limitHit = false;\n\t\t\tripgrepParser.on('hitLimit', () => {\n\t\t\t\tlimitHit = true;\n\t\t\t\tcancel();\n\t\t\t});\n\n\t\t\tlet dataWithoutResult = '';\n\t\t\trgProc.stdout!.on('data', data => {\n\t\t\t\tripgrepParser.handleData(data);\n\t\t\t\tif (!gotResult) {\n\t\t\t\t\tdataWithoutResult += data;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tlet gotData = false;\n\t\t\trgProc.stdout!.once('data', () => gotData = true);\n\n\t\t\tlet stderr = '';\n\t\t\trgProc.stderr!.on('data', data => {\n\t\t\t\tconst message = data.toString();\n\t\t\t\tthis.outputChannel.appendLine(message);\n\n\t\t\t\tif (stderr.length + message.length < 1e6) {\n\t\t\t\t\tstderr += message;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\trgProc.on('close', () => {\n\t\t\t\tthis.outputChannel.appendLine(gotData ? 'Got data from stdout' : 'No data from stdout');\n\t\t\t\tthis.outputChannel.appendLine(gotResult ? 'Got result from parser' : 'No result from parser');\n\t\t\t\tif (dataWithoutResult) {\n\t\t\t\t\tthis.outputChannel.appendLine(`Got data without result: ${dataWithoutResult}`);\n\t\t\t\t}\n\n\t\t\t\tthis.outputChannel.appendLine('');\n\n\t\t\t\tif (isDone) {\n\t\t\t\t\tresolve({ limitHit });\n\t\t\t\t} else {\n\t\t\t\t\t// Trigger last result\n\t\t\t\t\tripgrepParser.flush();\n\t\t\t\t\trgProc = null;\n\t\t\t\t\tlet searchError: Maybe<SearchError>;\n\t\t\t\t\tif (stderr && !gotData && (searchError = rgErrorMsgForDisplay(stderr))) {\n\t\t\t\t\t\treject(serializeSearchError(new SearchError(searchError.message, searchError.code)));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresolve({ limitHit });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n}\n\n/**\n * Read the first line of stderr and return an error for display or undefined, based on a list of\n * allowed properties.\n * Ripgrep produces stderr output which is not from a fatal error, and we only want the search to be\n * \"failed\" when a fatal error was produced.\n */\nfunction rgErrorMsgForDisplay(msg: string): Maybe<SearchError> {\n\tconst lines = msg.split('\\n');\n\tconst firstLine = lines[0].trim();\n\n\tif (lines.some(l => l.startsWith('regex parse error'))) {\n\t\treturn new SearchError(buildRegexParseError(lines), SearchErrorCode.regexParseError);\n\t}\n\n\tconst match = firstLine.match(/grep config error: unknown encoding: (.*)/);\n\tif (match) {\n\t\treturn new SearchError(`Unknown encoding: ${match[1]}`, SearchErrorCode.unknownEncoding);\n\t}\n\n\tif (firstLine.startsWith('error parsing glob')) {\n\t\t// Uppercase first letter\n\t\treturn new SearchError(firstLine.charAt(0).toUpperCase() + firstLine.substr(1), SearchErrorCode.globParseError);\n\t}\n\n\tif (firstLine.startsWith('the literal')) {\n\t\t// Uppercase first letter\n\t\treturn new SearchError(firstLine.charAt(0).toUpperCase() + firstLine.substr(1), SearchErrorCode.invalidLiteral);\n\t}\n\n\tif (firstLine.startsWith('PCRE2: error compiling pattern')) {\n\t\treturn new SearchError(firstLine, SearchErrorCode.regexParseError);\n\t}\n\n\treturn undefined;\n}\n\nfunction buildRegexParseError(lines: string[]): string {\n\tconst errorMessage: string[] = ['Regex parse error'];\n\tconst pcre2ErrorLine = lines.filter(l => (l.startsWith('PCRE2:')));\n\tif (pcre2ErrorLine.length >= 1) {\n\t\tconst pcre2ErrorMessage = pcre2ErrorLine[0].replace('PCRE2:', '');\n\t\tif (pcre2ErrorMessage.indexOf(':') !== -1 && pcre2ErrorMessage.split(':').length >= 2) {\n\t\t\tconst pcre2ActualErrorMessage = pcre2ErrorMessage.split(':')[1];\n\t\t\terrorMessage.push(':' + pcre2ActualErrorMessage);\n\t\t}\n\t}\n\n\treturn errorMessage.join('');\n}\n\n\nexport class RipgrepParser extends EventEmitter {\n\tprivate remainder = '';\n\tprivate isDone = false;\n\tprivate hitLimit = false;\n\tprivate stringDecoder: StringDecoder;\n\n\tprivate numResults = 0;\n\n\tconstructor(private maxResults: number, private rootFolder: string, private previewOptions?: TextSearchPreviewOptions) {\n\t\tsuper();\n\t\tthis.stringDecoder = new StringDecoder();\n\t}\n\n\tcancel(): void {\n\t\tthis.isDone = true;\n\t}\n\n\tflush(): void {\n\t\tthis.handleDecodedData(this.stringDecoder.end());\n\t}\n\n\n\toverride on(event: 'result', listener: (result: TextSearchResult) => void): this;\n\toverride on(event: 'hitLimit', listener: () => void): this;\n\toverride on(event: string, listener: (...args: any[]) => void): this {\n\t\tsuper.on(event, listener);\n\t\treturn this;\n\t}\n\n\thandleData(data: Buffer | string): void {\n\t\tif (this.isDone) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst dataStr = typeof data === 'string' ? data : this.stringDecoder.write(data);\n\t\tthis.handleDecodedData(dataStr);\n\t}\n\n\tprivate handleDecodedData(decodedData: string): void {\n\t\t// check for newline before appending to remainder\n\t\tlet newlineIdx = decodedData.indexOf('\\n');\n\n\t\t// If the previous data chunk didn't end in a newline, prepend it to this chunk\n\t\tconst dataStr = this.remainder + decodedData;\n\n\t\tif (newlineIdx >= 0) {\n\t\t\tnewlineIdx += this.remainder.length;\n\t\t} else {\n\t\t\t// Shortcut\n\t\t\tthis.remainder = dataStr;\n\t\t\treturn;\n\t\t}\n\n\t\tlet prevIdx = 0;\n\t\twhile (newlineIdx >= 0) {\n\t\t\tthis.handleLine(dataStr.substring(prevIdx, newlineIdx).trim());\n\t\t\tprevIdx = newlineIdx + 1;\n\t\t\tnewlineIdx = dataStr.indexOf('\\n', prevIdx);\n\t\t}\n\n\t\tthis.remainder = dataStr.substring(prevIdx);\n\t}\n\n\tprivate handleLine(outputLine: string): void {\n\t\tif (this.isDone || !outputLine) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet parsedLine: IRgMessage;\n\t\ttry {\n\t\t\tparsedLine = JSON.parse(outputLine);\n\t\t} catch (e) {\n\t\t\tthrow new Error(`malformed line from rg: ${outputLine}`);\n\t\t}\n\n\t\tif (parsedLine.type === 'match') {\n\t\t\tconst matchPath = bytesOrTextToString(parsedLine.data.path);\n\t\t\tconst uri = URI.file(path.join(this.rootFolder, matchPath));\n\t\t\tconst result = this.createTextSearchMatch(parsedLine.data, uri);\n\t\t\tthis.onResult(result);\n\n\t\t\tif (this.hitLimit) {\n\t\t\t\tthis.cancel();\n\t\t\t\tthis.emit('hitLimit');\n\t\t\t}\n\t\t} else if (parsedLine.type === 'context') {\n\t\t\tconst contextPath = bytesOrTextToString(parsedLine.data.path);\n\t\t\tconst uri = URI.file(path.join(this.rootFolder, contextPath));\n\t\t\tconst result = this.createTextSearchContext(parsedLine.data, uri);\n\t\t\tresult.forEach(r => this.onResult(r));\n\t\t}\n\t}\n\n\tprivate createTextSearchMatch(data: IRgMatch, uri: URI): TextSearchMatch {\n\t\tconst lineNumber = data.line_number - 1;\n\t\tconst fullText = bytesOrTextToString(data.lines);\n\t\tconst fullTextBytes = Buffer.from(fullText);\n\n\t\tlet prevMatchEnd = 0;\n\t\tlet prevMatchEndCol = 0;\n\t\tlet prevMatchEndLine = lineNumber;\n\n\t\t// it looks like certain regexes can match a line, but cause rg to not\n\t\t// emit any specific submatches for that line.\n\t\t// https://github.com/microsoft/vscode/issues/100569#issuecomment-738496991\n\t\tif (data.submatches.length === 0) {\n\t\t\tdata.submatches.push(\n\t\t\t\tfullText.length\n\t\t\t\t\t? { start: 0, end: 1, match: { text: fullText[0] } }\n\t\t\t\t\t: { start: 0, end: 0, match: { text: '' } }\n\t\t\t);\n\t\t}\n\n\t\tconst ranges = coalesce(data.submatches.map((match, i) => {\n\t\t\tif (this.hitLimit) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tthis.numResults++;\n\t\t\tif (this.numResults >= this.maxResults) {\n\t\t\t\t// Finish the line, then report the result below\n\t\t\t\tthis.hitLimit = true;\n\t\t\t}\n\n\t\t\tconst matchText = bytesOrTextToString(match.match);\n\n\t\t\tconst inBetweenText = fullTextBytes.slice(prevMatchEnd, match.start).toString();\n\t\t\tconst inBetweenStats = getNumLinesAndLastNewlineLength(inBetweenText);\n\t\t\tconst startCol = inBetweenStats.numLines > 0 ?\n\t\t\t\tinBetweenStats.lastLineLength :\n\t\t\t\tinBetweenStats.lastLineLength + prevMatchEndCol;\n\n\t\t\tconst stats = getNumLinesAndLastNewlineLength(matchText);\n\t\t\tconst startLineNumber = inBetweenStats.numLines + prevMatchEndLine;\n\t\t\tconst endLineNumber = stats.numLines + startLineNumber;\n\t\t\tconst endCol = stats.numLines > 0 ?\n\t\t\t\tstats.lastLineLength :\n\t\t\t\tstats.lastLineLength + startCol;\n\n\t\t\tprevMatchEnd = match.end;\n\t\t\tprevMatchEndCol = endCol;\n\t\t\tprevMatchEndLine = endLineNumber;\n\n\t\t\treturn new Range(startLineNumber, startCol, endLineNumber, endCol);\n\t\t}));\n\n\t\treturn createTextSearchResult(uri, fullText, <Range[]>ranges, this.previewOptions);\n\t}\n\n\tprivate createTextSearchContext(data: IRgMatch, uri: URI): TextSearchContext[] {\n\t\tconst text = bytesOrTextToString(data.lines);\n\t\tconst startLine = data.line_number;\n\t\treturn text\n\t\t\t.replace(/\\r?\\n$/, '')\n\t\t\t.split('\\n')\n\t\t\t.map((line, i) => {\n\t\t\t\treturn {\n\t\t\t\t\ttext: line,\n\t\t\t\t\turi,\n\t\t\t\t\tlineNumber: startLine + i\n\t\t\t\t};\n\t\t\t});\n\t}\n\n\tprivate onResult(match: TextSearchResult): void {\n\t\tthis.emit('result', match);\n\t}\n}\n\nfunction bytesOrTextToString(obj: any): string {\n\treturn obj.bytes ?\n\t\tBuffer.from(obj.bytes, 'base64').toString() :\n\t\tobj.text;\n}\n\nfunction getNumLinesAndLastNewlineLength(text: string): { numLines: number; lastLineLength: number } {\n\tconst re = /\\n/g;\n\tlet numLines = 0;\n\tlet lastNewlineIdx = -1;\n\tlet match: ReturnType<typeof re.exec>;\n\twhile (match = re.exec(text)) {\n\t\tnumLines++;\n\t\tlastNewlineIdx = match.index;\n\t}\n\n\tconst lastLineLength = lastNewlineIdx >= 0 ?\n\t\ttext.length - lastNewlineIdx - 1 :\n\t\ttext.length;\n\n\treturn { numLines, lastLineLength };\n}\n\n// exported for testing\nexport function getRgArgs(query: TextSearchQuery, options: TextSearchOptions): string[] {\n\tconst args = ['--hidden', '--no-require-git'];\n\targs.push(query.isCaseSensitive ? '--case-sensitive' : '--ignore-case');\n\n\tconst { doubleStarIncludes, otherIncludes } = groupBy(\n\t\toptions.includes,\n\t\t(include: string) => include.startsWith('**') ? 'doubleStarIncludes' : 'otherIncludes');\n\n\tif (otherIncludes && otherIncludes.length) {\n\t\tconst uniqueOthers = new Set<string>();\n\t\totherIncludes.forEach(other => { uniqueOthers.add(other); });\n\n\t\targs.push('-g', '!*');\n\t\tuniqueOthers\n\t\t\t.forEach(otherIncude => {\n\t\t\t\tspreadGlobComponents(otherIncude)\n\t\t\t\t\t.map(anchorGlob)\n\t\t\t\t\t.forEach(globArg => {\n\t\t\t\t\t\targs.push('-g', globArg);\n\t\t\t\t\t});\n\t\t\t});\n\t}\n\n\tif (doubleStarIncludes && doubleStarIncludes.length) {\n\t\tdoubleStarIncludes.forEach(globArg => {\n\t\t\targs.push('-g', globArg);\n\t\t});\n\t}\n\n\toptions.excludes\n\t\t.map(anchorGlob)\n\t\t.forEach(rgGlob => args.push('-g', `!${rgGlob}`));\n\n\tif (options.maxFileSize) {\n\t\targs.push('--max-filesize', options.maxFileSize + '');\n\t}\n\n\tif (options.useIgnoreFiles) {\n\t\tif (!options.useParentIgnoreFiles) {\n\t\t\targs.push('--no-ignore-parent');\n\t\t}\n\t} else {\n\t\t// Don't use .gitignore or .ignore\n\t\targs.push('--no-ignore');\n\t}\n\n\tif (options.followSymlinks) {\n\t\targs.push('--follow');\n\t}\n\n\tif (options.encoding && options.encoding !== 'utf8') {\n\t\targs.push('--encoding', options.encoding);\n\t}\n\n\t// Ripgrep handles -- as a -- arg separator. Only --.\n\t// - is ok, --- is ok, --some-flag is also ok. Need to special case.\n\tif (query.pattern === '--') {\n\t\tquery.isRegExp = true;\n\t\tquery.pattern = '\\\\-\\\\-';\n\t}\n\n\tif (query.isMultiline && !query.isRegExp) {\n\t\tquery.pattern = escapeRegExpCharacters(query.pattern);\n\t\tquery.isRegExp = true;\n\t}\n\n\tif ((<IExtendedExtensionSearchOptions>options).usePCRE2) {\n\t\targs.push('--pcre2');\n\t}\n\n\t// Allow $ to match /r/n\n\targs.push('--crlf');\n\n\tif (query.isRegExp) {\n\t\tquery.pattern = unicodeEscapesToPCRE2(query.pattern);\n\t\targs.push('--engine', 'auto');\n\t}\n\n\tlet searchPatternAfterDoubleDashes: Maybe<string>;\n\tif (query.isWordMatch) {\n\t\tconst regexp = createRegExp(query.pattern, !!query.isRegExp, { wholeWord: query.isWordMatch });\n\t\tconst regexpStr = regexp.source.replace(/\\\\\\//g, '/'); // RegExp.source arbitrarily returns escaped slashes. Search and destroy.\n\t\targs.push('--regexp', regexpStr);\n\t} else if (query.isRegExp) {\n\t\tlet fixedRegexpQuery = fixRegexNewline(query.pattern);\n\t\tfixedRegexpQuery = fixNewline(fixedRegexpQuery);\n\t\targs.push('--regexp', fixedRegexpQuery);\n\t} else {\n\t\tsearchPatternAfterDoubleDashes = query.pattern;\n\t\targs.push('--fixed-strings');\n\t}\n\n\targs.push('--no-config');\n\tif (!options.useGlobalIgnoreFiles) {\n\t\targs.push('--no-ignore-global');\n\t}\n\n\targs.push('--json');\n\n\tif (query.isMultiline) {\n\t\targs.push('--multiline');\n\t}\n\n\tif (options.beforeContext) {\n\t\targs.push('--before-context', options.beforeContext + '');\n\t}\n\n\tif (options.afterContext) {\n\t\targs.push('--after-context', options.afterContext + '');\n\t}\n\n\t// Folder to search\n\targs.push('--');\n\n\tif (searchPatternAfterDoubleDashes) {\n\t\t// Put the query after --, in case the query starts with a dash\n\t\targs.push(searchPatternAfterDoubleDashes);\n\t}\n\n\targs.push('.');\n\n\treturn args;\n}\n\n/**\n * `\"foo/*bar/something\"` -> `[\"foo\", \"foo/*bar\", \"foo/*bar/something\", \"foo/*bar/something/**\"]`\n */\nfunction spreadGlobComponents(globComponent: string): string[] {\n\tconst globComponentWithBraceExpansion = performBraceExpansionForRipgrep(globComponent);\n\n\treturn globComponentWithBraceExpansion.flatMap((globArg) => {\n\t\tconst components = splitGlobAware(globArg, '/');\n\t\treturn components.map((_, i) => components.slice(0, i + 1).join('/'));\n\t});\n\n}\n\nexport function unicodeEscapesToPCRE2(pattern: string): string {\n\t// Match \\u1234\n\tconst unicodePattern = /((?:[^\\\\]|^)(?:\\\\\\\\)*)\\\\u([a-z0-9]{4})/gi;\n\n\twhile (pattern.match(unicodePattern)) {\n\t\tpattern = pattern.replace(unicodePattern, `$1\\\\x{$2}`);\n\t}\n\n\t// Match \\u{1234}\n\t// \\u with 5-6 characters will be left alone because \\x only takes 4 characters.\n\tconst unicodePatternWithBraces = /((?:[^\\\\]|^)(?:\\\\\\\\)*)\\\\u\\{([a-z0-9]{4})\\}/gi;\n\twhile (pattern.match(unicodePatternWithBraces)) {\n\t\tpattern = pattern.replace(unicodePatternWithBraces, `$1\\\\x{$2}`);\n\t}\n\n\treturn pattern;\n}\n\nexport interface IRgMessage {\n\ttype: 'match' | 'context' | string;\n\tdata: IRgMatch;\n}\n\nexport interface IRgMatch {\n\tpath: IRgBytesOrText;\n\tlines: IRgBytesOrText;\n\tline_number: number;\n\tabsolute_offset: number;\n\tsubmatches: IRgSubmatch[];\n}\n\nexport interface IRgSubmatch {\n\tmatch: IRgBytesOrText;\n\tstart: number;\n\tend: number;\n}\n\nexport type IRgBytesOrText = { bytes: string } | { text: string };\n\nconst isLookBehind = (node: ReAST.Node) => node.type === 'Assertion' && node.kind === 'lookbehind';\n\nexport function fixRegexNewline(pattern: string): string {\n\t// we parse the pattern anew each tiem\n\tlet re: ReAST.Pattern;\n\ttry {\n\t\tre = new RegExpParser().parsePattern(pattern);\n\t} catch {\n\t\treturn pattern;\n\t}\n\n\tlet output = '';\n\tlet lastEmittedIndex = 0;\n\tconst replace = (start: number, end: number, text: string) => {\n\t\toutput += pattern.slice(lastEmittedIndex, start) + text;\n\t\tlastEmittedIndex = end;\n\t};\n\n\tconst context: ReAST.Node[] = [];\n\tconst visitor = new RegExpVisitor({\n\t\tonCharacterEnter(char) {\n\t\t\tif (char.raw !== '\\\\n') {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst parent = context[0];\n\t\t\tif (!parent) {\n\t\t\t\t// simple char, \\n -> \\r?\\n\n\t\t\t\treplace(char.start, char.end, '\\\\r?\\\\n');\n\t\t\t} else if (context.some(isLookBehind)) {\n\t\t\t\t// no-op in a lookbehind, see #100569\n\t\t\t} else if (parent.type === 'CharacterClass') {\n\t\t\t\tif (parent.negate) {\n\t\t\t\t\t// negative bracket expr, [^a-z\\n] -> (?![a-z]|\\r?\\n)\n\t\t\t\t\tconst otherContent = pattern.slice(parent.start + 2, char.start) + pattern.slice(char.end, parent.end - 1);\n\t\t\t\t\tif (parent.parent?.type === 'Quantifier') {\n\t\t\t\t\t\t// If quantified, we can't use a negative lookahead in a quantifier.\n\t\t\t\t\t\t// But `.` already doesn't match new lines, so we can just use that\n\t\t\t\t\t\t// (with any other negations) instead.\n\t\t\t\t\t\treplace(parent.start, parent.end, otherContent ? `[^${otherContent}]` : '.');\n\t\t\t\t\t} else {\n\t\t\t\t\t\treplace(parent.start, parent.end, '(?!\\\\r?\\\\n' + (otherContent ? `|[${otherContent}]` : '') + ')');\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// positive bracket expr, [a-z\\n] -> (?:[a-z]|\\r?\\n)\n\t\t\t\t\tconst otherContent = pattern.slice(parent.start + 1, char.start) + pattern.slice(char.end, parent.end - 1);\n\t\t\t\t\treplace(parent.start, parent.end, otherContent === '' ? '\\\\r?\\\\n' : `(?:[${otherContent}]|\\\\r?\\\\n)`);\n\t\t\t\t}\n\t\t\t} else if (parent.type === 'Quantifier') {\n\t\t\t\treplace(char.start, char.end, '(?:\\\\r?\\\\n)');\n\t\t\t}\n\t\t},\n\t\tonQuantifierEnter(node) {\n\t\t\tcontext.unshift(node);\n\t\t},\n\t\tonQuantifierLeave() {\n\t\t\tcontext.shift();\n\t\t},\n\t\tonCharacterClassRangeEnter(node) {\n\t\t\tcontext.unshift(node);\n\t\t},\n\t\tonCharacterClassRangeLeave() {\n\t\t\tcontext.shift();\n\t\t},\n\t\tonCharacterClassEnter(node) {\n\t\t\tcontext.unshift(node);\n\t\t},\n\t\tonCharacterClassLeave() {\n\t\t\tcontext.shift();\n\t\t},\n\t\tonAssertionEnter(node) {\n\t\t\tif (isLookBehind(node)) {\n\t\t\t\tcontext.push(node);\n\t\t\t}\n\t\t},\n\t\tonAssertionLeave(node) {\n\t\t\tif (context[0] === node) {\n\t\t\t\tcontext.shift();\n\t\t\t}\n\t\t},\n\t});\n\n\tvisitor.visit(re);\n\toutput += pattern.slice(lastEmittedIndex);\n\treturn output;\n}\n\nexport function fixNewline(pattern: string): string {\n\treturn pattern.replace(/\\n/g, '\\\\r?\\\\n');\n}\n\n// brace expansion for ripgrep\n\n/**\n * Split string given first opportunity for brace expansion in the string.\n * - If the brace is prepended by a \\ character, then it is escaped.\n * - Does not process escapes that are within the sub-glob.\n * - If two unescaped `{` occur before `}`, then ripgrep will return an error for brace nesting, so don't split on those.\n */\nfunction getEscapeAwareSplitStringForRipgrep(pattern: string): { fixedStart?: string; strInBraces: string; fixedEnd?: string } {\n\tlet inBraces = false;\n\tlet escaped = false;\n\tlet fixedStart = '';\n\tlet strInBraces = '';\n\tfor (let i = 0; i < pattern.length; i++) {\n\t\tconst char = pattern[i];\n\t\tswitch (char) {\n\t\t\tcase '\\\\':\n\t\t\t\tif (escaped) {\n\t\t\t\t\t// If we're already escaped, then just leave the escaped slash and the preceeding slash that escapes it.\n\t\t\t\t\t// The two escaped slashes will result in a single slash and whatever processes the glob later will properly process the escape\n\t\t\t\t\tif (inBraces) {\n\t\t\t\t\t\tstrInBraces += '\\\\' + char;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfixedStart += '\\\\' + char;\n\t\t\t\t\t}\n\t\t\t\t\tescaped = false;\n\t\t\t\t} else {\n\t\t\t\t\tescaped = true;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '{':\n\t\t\t\tif (escaped) {\n\t\t\t\t\t// if we escaped this opening bracket, then it is to be taken literally. Remove the `\\` because we've acknowleged it and add the `{` to the appropriate string\n\t\t\t\t\tif (inBraces) {\n\t\t\t\t\t\tstrInBraces += char;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfixedStart += char;\n\t\t\t\t\t}\n\t\t\t\t\tescaped = false;\n\t\t\t\t} else {\n\t\t\t\t\tif (inBraces) {\n\t\t\t\t\t\t// ripgrep treats this as attempting to do a nested alternate group, which is invalid. Return with pattern including changes from escaped braces.\n\t\t\t\t\t\treturn { strInBraces: fixedStart + '{' + strInBraces + '{' + pattern.substring(i + 1) };\n\t\t\t\t\t} else {\n\t\t\t\t\t\tinBraces = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '}':\n\t\t\t\tif (escaped) {\n\t\t\t\t\t// same as `}`, but for closing bracket\n\t\t\t\t\tif (inBraces) {\n\t\t\t\t\t\tstrInBraces += char;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfixedStart += char;\n\t\t\t\t\t}\n\t\t\t\t\tescaped = false;\n\t\t\t\t} else if (inBraces) {\n\t\t\t\t\t// we found an end bracket to a valid opening bracket. Return the appropriate strings.\n\t\t\t\t\treturn { fixedStart, strInBraces, fixedEnd: pattern.substring(i + 1) };\n\t\t\t\t} else {\n\t\t\t\t\t// if we're not in braces and not escaped, then this is a literal `}` character and we're still adding to fixedStart.\n\t\t\t\t\tfixedStart += char;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t// similar to the `\\\\` case, we didn't do anything with the escape, so we should re-insert it into the appropriate string\n\t\t\t\t// to be consumed later when individual parts of the glob are processed\n\t\t\t\tif (inBraces) {\n\t\t\t\t\tstrInBraces += (escaped ? '\\\\' : '') + char;\n\t\t\t\t} else {\n\t\t\t\t\tfixedStart += (escaped ? '\\\\' : '') + char;\n\t\t\t\t}\n\t\t\t\tescaped = false;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\n\t// we are haven't hit the last brace, so no splitting should occur. Return with pattern including changes from escaped braces.\n\treturn { strInBraces: fixedStart + (inBraces ? ('{' + strInBraces) : '') };\n}\n\n/**\n * Parses out curly braces and returns equivalent globs. Only supports one level of nesting.\n * Exported for testing.\n */\nexport function performBraceExpansionForRipgrep(pattern: string): string[] {\n\tconst { fixedStart, strInBraces, fixedEnd } = getEscapeAwareSplitStringForRipgrep(pattern);\n\tif (fixedStart === undefined || fixedEnd === undefined) {\n\t\treturn [strInBraces];\n\t}\n\n\tlet arr = splitGlobAware(strInBraces, ',');\n\n\tif (!arr.length) {\n\t\t// occurs if the braces are empty.\n\t\tarr = [''];\n\t}\n\n\tconst ends = performBraceExpansionForRipgrep(fixedEnd);\n\n\treturn arr.flatMap((elem) => {\n\t\tconst start = fixedStart + elem;\n\t\treturn ends.map((end) => {\n\t\t\treturn start + end;\n\t\t});\n\t});\n}\n"]}