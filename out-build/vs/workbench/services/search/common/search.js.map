{"version":3,"sources":["file:///workspace/appflow/src/vs/workbench/services/search/common/search.ts"],"names":[],"mappings":"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","file":"search.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { mapArrayOrNot } from 'vs/base/common/arrays';\nimport { CancellationToken } from 'vs/base/common/cancellation';\nimport * as glob from 'vs/base/common/glob';\nimport { IDisposable } from 'vs/base/common/lifecycle';\nimport * as objects from 'vs/base/common/objects';\nimport * as extpath from 'vs/base/common/extpath';\nimport { fuzzyContains, getNLines } from 'vs/base/common/strings';\nimport { URI, UriComponents } from 'vs/base/common/uri';\nimport { IFilesConfiguration } from 'vs/platform/files/common/files';\nimport { createDecorator } from 'vs/platform/instantiation/common/instantiation';\nimport { ITelemetryData } from 'vs/platform/telemetry/common/telemetry';\nimport { Event } from 'vs/base/common/event';\nimport * as paths from 'vs/base/common/path';\nimport { isCancellationError } from 'vs/base/common/errors';\nimport { TextSearchCompleteMessageType } from 'vs/workbench/services/search/common/searchExtTypes';\nimport { isThenable } from 'vs/base/common/async';\nimport { ResourceSet } from 'vs/base/common/map';\n\nexport { TextSearchCompleteMessageType };\n\nexport const VIEWLET_ID = 'workbench.view.search';\nexport const PANEL_ID = 'workbench.panel.search';\nexport const VIEW_ID = 'workbench.view.search';\nexport const SEARCH_RESULT_LANGUAGE_ID = 'search-result';\n\nexport const SEARCH_EXCLUDE_CONFIG = 'search.exclude';\n\n// Warning: this pattern is used in the search editor to detect offsets. If you\n// change this, also change the search-result built-in extension\nconst SEARCH_ELIDED_PREFIX = '⟪ ';\nconst SEARCH_ELIDED_SUFFIX = ' characters skipped ⟫';\nconst SEARCH_ELIDED_MIN_LEN = (SEARCH_ELIDED_PREFIX.length + SEARCH_ELIDED_SUFFIX.length + 5) * 2;\n\nexport const ISearchService = createDecorator<ISearchService>('searchService');\n\n/**\n * A service that enables to search for files or with in files.\n */\nexport interface ISearchService {\n\treadonly _serviceBrand: undefined;\n\ttextSearch(query: ITextQuery, token?: CancellationToken, onProgress?: (result: ISearchProgressItem) => void): Promise<ISearchComplete>;\n\ttextSearchSplitSyncAsync(query: ITextQuery, token?: CancellationToken | undefined, onProgress?: ((result: ISearchProgressItem) => void) | undefined, notebookFilesToIgnore?: ResourceSet, asyncNotebookFilesToIgnore?: Promise<ResourceSet>): { syncResults: ISearchComplete; asyncResults: Promise<ISearchComplete> };\n\tfileSearch(query: IFileQuery, token?: CancellationToken): Promise<ISearchComplete>;\n\tclearCache(cacheKey: string): Promise<void>;\n\tregisterSearchResultProvider(scheme: string, type: SearchProviderType, provider: ISearchResultProvider): IDisposable;\n}\n\n/**\n * TODO@roblou - split text from file search entirely, or share code in a more natural way.\n */\nexport const enum SearchProviderType {\n\tfile,\n\ttext\n}\n\nexport interface ISearchResultProvider {\n\ttextSearch(query: ITextQuery, onProgress?: (p: ISearchProgressItem) => void, token?: CancellationToken): Promise<ISearchComplete>;\n\tfileSearch(query: IFileQuery, token?: CancellationToken): Promise<ISearchComplete>;\n\tclearCache(cacheKey: string): Promise<void>;\n}\n\nexport interface IFolderQuery<U extends UriComponents = URI> {\n\tfolder: U;\n\tfolderName?: string;\n\texcludePattern?: glob.IExpression;\n\tincludePattern?: glob.IExpression;\n\tfileEncoding?: string;\n\tdisregardIgnoreFiles?: boolean;\n\tdisregardGlobalIgnoreFiles?: boolean;\n\tdisregardParentIgnoreFiles?: boolean;\n\tignoreSymlinks?: boolean;\n}\n\nexport interface ICommonQueryProps<U extends UriComponents> {\n\t/** For telemetry - indicates what is triggering the source */\n\t_reason?: string;\n\n\tfolderQueries: IFolderQuery<U>[];\n\tincludePattern?: glob.IExpression;\n\texcludePattern?: glob.IExpression;\n\textraFileResources?: U[];\n\n\tonlyOpenEditors?: boolean;\n\n\tmaxResults?: number;\n\tusingSearchPaths?: boolean;\n}\n\nexport interface IFileQueryProps<U extends UriComponents> extends ICommonQueryProps<U> {\n\ttype: QueryType.File;\n\tfilePattern?: string;\n\n\t/**\n\t * If true no results will be returned. Instead `limitHit` will indicate if at least one result exists or not.\n\t * Currently does not work with queries including a 'siblings clause'.\n\t */\n\texists?: boolean;\n\tsortByScore?: boolean;\n\tcacheKey?: string;\n}\n\nexport interface ITextQueryProps<U extends UriComponents> extends ICommonQueryProps<U> {\n\ttype: QueryType.Text;\n\tcontentPattern: IPatternInfo;\n\n\tpreviewOptions?: ITextSearchPreviewOptions;\n\tmaxFileSize?: number;\n\tusePCRE2?: boolean;\n\tafterContext?: number;\n\tbeforeContext?: number;\n\n\tuserDisabledExcludesAndIgnoreFiles?: boolean;\n}\n\nexport type IFileQuery = IFileQueryProps<URI>;\nexport type IRawFileQuery = IFileQueryProps<UriComponents>;\nexport type ITextQuery = ITextQueryProps<URI>;\nexport type IRawTextQuery = ITextQueryProps<UriComponents>;\n\nexport type IRawQuery = IRawTextQuery | IRawFileQuery;\nexport type ISearchQuery = ITextQuery | IFileQuery;\n\nexport const enum QueryType {\n\tFile = 1,\n\tText = 2\n}\n\n/* __GDPR__FRAGMENT__\n\t\"IPatternInfo\" : {\n\t\t\"isRegExp\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n\t\t\"isWordMatch\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n\t\t\"wordSeparators\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" },\n\t\t\"isMultiline\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n\t\t\"isCaseSensitive\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n\t\t\"isSmartCase\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true }\n\t}\n*/\nexport interface IPatternInfo {\n\tpattern: string;\n\tisRegExp?: boolean;\n\tisWordMatch?: boolean;\n\twordSeparators?: string;\n\tisMultiline?: boolean;\n\tisUnicode?: boolean;\n\tisCaseSensitive?: boolean;\n\tnotebookInfo?: INotebookPatternInfo;\n}\n\nexport interface INotebookPatternInfo {\n\tisInNotebookMarkdownInput?: boolean;\n\tisInNotebookMarkdownPreview?: boolean;\n\tisInNotebookCellInput?: boolean;\n\tisInNotebookCellOutput?: boolean;\n}\n\nexport interface IExtendedExtensionSearchOptions {\n\tusePCRE2?: boolean;\n}\n\nexport interface IFileMatch<U extends UriComponents = URI> {\n\tresource: U;\n\tresults?: ITextSearchResult[];\n}\n\nexport type IRawFileMatch2 = IFileMatch<UriComponents>;\n\nexport interface ITextSearchPreviewOptions {\n\tmatchLines: number;\n\tcharsPerLine: number;\n}\n\nexport interface ISearchRange {\n\treadonly startLineNumber: number;\n\treadonly startColumn: number;\n\treadonly endLineNumber: number;\n\treadonly endColumn: number;\n}\n\nexport interface ITextSearchResultPreview {\n\ttext: string;\n\tmatches: ISearchRange | ISearchRange[];\n\tcellFragment?: string;\n}\n\nexport interface ITextSearchMatch {\n\turi?: URI;\n\tranges: ISearchRange | ISearchRange[];\n\tpreview: ITextSearchResultPreview;\n\twebviewIndex?: number;\n}\n\nexport interface ITextSearchContext {\n\turi?: URI;\n\ttext: string;\n\tlineNumber: number;\n}\n\nexport type ITextSearchResult = ITextSearchMatch | ITextSearchContext;\n\nexport function resultIsMatch(result: ITextSearchResult): result is ITextSearchMatch {\n\treturn !!(<ITextSearchMatch>result).preview;\n}\n\nexport interface IProgressMessage {\n\tmessage: string;\n}\n\nexport type ISearchProgressItem = IFileMatch | IProgressMessage;\n\nexport function isFileMatch(p: ISearchProgressItem): p is IFileMatch {\n\treturn !!(<IFileMatch>p).resource;\n}\n\nexport function isProgressMessage(p: ISearchProgressItem | ISerializedSearchProgressItem): p is IProgressMessage {\n\treturn !!(p as IProgressMessage).message;\n}\n\nexport interface ITextSearchCompleteMessage {\n\ttext: string;\n\ttype: TextSearchCompleteMessageType;\n\ttrusted?: boolean;\n}\n\nexport interface ISearchCompleteStats {\n\tlimitHit?: boolean;\n\tmessages: ITextSearchCompleteMessage[];\n\tstats?: IFileSearchStats | ITextSearchStats;\n}\n\nexport interface ISearchComplete extends ISearchCompleteStats {\n\tresults: IFileMatch[];\n\texit?: SearchCompletionExitCode;\n}\n\nexport const enum SearchCompletionExitCode {\n\tNormal,\n\tNewSearchStarted\n}\n\nexport interface ITextSearchStats {\n\ttype: 'textSearchProvider' | 'searchProcess';\n}\n\nexport interface IFileSearchStats {\n\tfromCache: boolean;\n\tdetailStats: ISearchEngineStats | ICachedSearchStats | IFileSearchProviderStats;\n\n\tresultCount: number;\n\ttype: 'fileSearchProvider' | 'searchProcess';\n\tsortingTime?: number;\n}\n\nexport interface ICachedSearchStats {\n\tcacheWasResolved: boolean;\n\tcacheLookupTime: number;\n\tcacheFilterTime: number;\n\tcacheEntryCount: number;\n}\n\nexport interface ISearchEngineStats {\n\tfileWalkTime: number;\n\tdirectoriesWalked: number;\n\tfilesWalked: number;\n\tcmdTime: number;\n\tcmdResultCount?: number;\n}\n\nexport interface IFileSearchProviderStats {\n\tproviderTime: number;\n\tpostProcessTime: number;\n}\n\nexport class FileMatch implements IFileMatch {\n\tresults: ITextSearchResult[] = [];\n\tconstructor(public resource: URI) {\n\t\t// empty\n\t}\n}\n\nexport class TextSearchMatch implements ITextSearchMatch {\n\tranges: ISearchRange | ISearchRange[];\n\tpreview: ITextSearchResultPreview;\n\twebviewIndex?: number;\n\n\tconstructor(text: string, range: ISearchRange | ISearchRange[], previewOptions?: ITextSearchPreviewOptions, webviewIndex?: number) {\n\t\tthis.ranges = range;\n\t\tthis.webviewIndex = webviewIndex;\n\n\t\t// Trim preview if this is one match and a single-line match with a preview requested.\n\t\t// Otherwise send the full text, like for replace or for showing multiple previews.\n\t\t// TODO this is fishy.\n\t\tconst ranges = Array.isArray(range) ? range : [range];\n\t\tif (previewOptions && previewOptions.matchLines === 1 && isSingleLineRangeList(ranges)) {\n\t\t\t// 1 line preview requested\n\t\t\ttext = getNLines(text, previewOptions.matchLines);\n\n\t\t\tlet result = '';\n\t\t\tlet shift = 0;\n\t\t\tlet lastEnd = 0;\n\t\t\tconst leadingChars = Math.floor(previewOptions.charsPerLine / 5);\n\t\t\tconst matches: ISearchRange[] = [];\n\t\t\tfor (const range of ranges) {\n\t\t\t\tconst previewStart = Math.max(range.startColumn - leadingChars, 0);\n\t\t\t\tconst previewEnd = range.startColumn + previewOptions.charsPerLine;\n\t\t\t\tif (previewStart > lastEnd + leadingChars + SEARCH_ELIDED_MIN_LEN) {\n\t\t\t\t\tconst elision = SEARCH_ELIDED_PREFIX + (previewStart - lastEnd) + SEARCH_ELIDED_SUFFIX;\n\t\t\t\t\tresult += elision + text.slice(previewStart, previewEnd);\n\t\t\t\t\tshift += previewStart - (lastEnd + elision.length);\n\t\t\t\t} else {\n\t\t\t\t\tresult += text.slice(lastEnd, previewEnd);\n\t\t\t\t}\n\n\t\t\t\tmatches.push(new OneLineRange(0, range.startColumn - shift, range.endColumn - shift));\n\t\t\t\tlastEnd = previewEnd;\n\t\t\t}\n\n\t\t\tthis.preview = { text: result, matches: Array.isArray(this.ranges) ? matches : matches[0] };\n\t\t} else {\n\t\t\tconst firstMatchLine = Array.isArray(range) ? range[0].startLineNumber : range.startLineNumber;\n\n\t\t\tthis.preview = {\n\t\t\t\ttext,\n\t\t\t\tmatches: mapArrayOrNot(range, r => new SearchRange(r.startLineNumber - firstMatchLine, r.startColumn, r.endLineNumber - firstMatchLine, r.endColumn))\n\t\t\t};\n\t\t}\n\t}\n}\n\nfunction isSingleLineRangeList(ranges: ISearchRange[]): boolean {\n\tconst line = ranges[0].startLineNumber;\n\tfor (const r of ranges) {\n\t\tif (r.startLineNumber !== line || r.endLineNumber !== line) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nexport class SearchRange implements ISearchRange {\n\tstartLineNumber: number;\n\tstartColumn: number;\n\tendLineNumber: number;\n\tendColumn: number;\n\n\tconstructor(startLineNumber: number, startColumn: number, endLineNumber: number, endColumn: number) {\n\t\tthis.startLineNumber = startLineNumber;\n\t\tthis.startColumn = startColumn;\n\t\tthis.endLineNumber = endLineNumber;\n\t\tthis.endColumn = endColumn;\n\t}\n}\n\nexport class OneLineRange extends SearchRange {\n\tconstructor(lineNumber: number, startColumn: number, endColumn: number) {\n\t\tsuper(lineNumber, startColumn, lineNumber, endColumn);\n\t}\n}\n\nexport const enum ViewMode {\n\tList = 'list',\n\tTree = 'tree'\n}\n\nexport const enum SearchSortOrder {\n\tDefault = 'default',\n\tFileNames = 'fileNames',\n\tType = 'type',\n\tModified = 'modified',\n\tCountDescending = 'countDescending',\n\tCountAscending = 'countAscending'\n}\n\nexport interface ISearchConfigurationProperties {\n\texclude: glob.IExpression;\n\tuseRipgrep: boolean;\n\t/**\n\t * Use ignore file for file search.\n\t */\n\tuseIgnoreFiles: boolean;\n\tuseGlobalIgnoreFiles: boolean;\n\tuseParentIgnoreFiles: boolean;\n\tfollowSymlinks: boolean;\n\tsmartCase: boolean;\n\tglobalFindClipboard: boolean;\n\tlocation: 'sidebar' | 'panel';\n\tuseReplacePreview: boolean;\n\tshowLineNumbers: boolean;\n\tusePCRE2: boolean;\n\tactionsPosition: 'auto' | 'right';\n\tmaintainFileSearchCache: boolean;\n\tmaxResults: number | null;\n\tcollapseResults: 'auto' | 'alwaysCollapse' | 'alwaysExpand';\n\tsearchOnType: boolean;\n\tseedOnFocus: boolean;\n\tseedWithNearestWord: boolean;\n\tsearchOnTypeDebouncePeriod: number;\n\tmode: 'view' | 'reuseEditor' | 'newEditor';\n\tsearchEditor: {\n\t\tdoubleClickBehaviour: 'selectWord' | 'goToLocation' | 'openLocationToSide';\n\t\treusePriorSearchConfiguration: boolean;\n\t\tdefaultNumberOfContextLines: number | null;\n\t\texperimental: {};\n\t};\n\tsortOrder: SearchSortOrder;\n\tdecorations: {\n\t\tcolors: boolean;\n\t\tbadges: boolean;\n\t};\n\tdefaultViewMode: ViewMode;\n\texperimental: {\n\t\tclosedNotebookRichContentResults: boolean;\n\t\tquickAccess: {\n\t\t\tpreserveInput: boolean;\n\t\t};\n\t};\n}\n\nexport interface ISearchConfiguration extends IFilesConfiguration {\n\tsearch: ISearchConfigurationProperties;\n\teditor: {\n\t\twordSeparators: string;\n\t};\n}\n\nexport function getExcludes(configuration: ISearchConfiguration, includeSearchExcludes = true): glob.IExpression | undefined {\n\tconst fileExcludes = configuration && configuration.files && configuration.files.exclude;\n\tconst searchExcludes = includeSearchExcludes && configuration && configuration.search && configuration.search.exclude;\n\n\tif (!fileExcludes && !searchExcludes) {\n\t\treturn undefined;\n\t}\n\n\tif (!fileExcludes || !searchExcludes) {\n\t\treturn fileExcludes || searchExcludes;\n\t}\n\n\tlet allExcludes: glob.IExpression = Object.create(null);\n\t// clone the config as it could be frozen\n\tallExcludes = objects.mixin(allExcludes, objects.deepClone(fileExcludes));\n\tallExcludes = objects.mixin(allExcludes, objects.deepClone(searchExcludes), true);\n\n\treturn allExcludes;\n}\n\nexport function pathIncludedInQuery(queryProps: ICommonQueryProps<URI>, fsPath: string): boolean {\n\tif (queryProps.excludePattern && glob.match(queryProps.excludePattern, fsPath)) {\n\t\treturn false;\n\t}\n\n\tif (queryProps.includePattern || queryProps.usingSearchPaths) {\n\t\tif (queryProps.includePattern && glob.match(queryProps.includePattern, fsPath)) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// If searchPaths are being used, the extra file must be in a subfolder and match the pattern, if present\n\t\tif (queryProps.usingSearchPaths) {\n\t\t\treturn !!queryProps.folderQueries && queryProps.folderQueries.some(fq => {\n\t\t\t\tconst searchPath = fq.folder.fsPath;\n\t\t\t\tif (extpath.isEqualOrParent(fsPath, searchPath)) {\n\t\t\t\t\tconst relPath = paths.relative(searchPath, fsPath);\n\t\t\t\t\treturn !fq.includePattern || !!glob.match(fq.includePattern, relPath);\n\t\t\t\t} else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nexport enum SearchErrorCode {\n\tunknownEncoding = 1,\n\tregexParseError,\n\tglobParseError,\n\tinvalidLiteral,\n\trgProcessError,\n\tother,\n\tcanceled\n}\n\nexport class SearchError extends Error {\n\tconstructor(message: string, readonly code?: SearchErrorCode) {\n\t\tsuper(message);\n\t}\n}\n\nexport function deserializeSearchError(error: Error): SearchError {\n\tconst errorMsg = error.message;\n\n\tif (isCancellationError(error)) {\n\t\treturn new SearchError(errorMsg, SearchErrorCode.canceled);\n\t}\n\n\ttry {\n\t\tconst details = JSON.parse(errorMsg);\n\t\treturn new SearchError(details.message, details.code);\n\t} catch (e) {\n\t\treturn new SearchError(errorMsg, SearchErrorCode.other);\n\t}\n}\n\nexport function serializeSearchError(searchError: SearchError): Error {\n\tconst details = { message: searchError.message, code: searchError.code };\n\treturn new Error(JSON.stringify(details));\n}\nexport interface ITelemetryEvent {\n\teventName: string;\n\tdata: ITelemetryData;\n}\n\nexport interface IRawSearchService {\n\tfileSearch(search: IRawFileQuery): Event<ISerializedSearchProgressItem | ISerializedSearchComplete>;\n\ttextSearch(search: IRawTextQuery): Event<ISerializedSearchProgressItem | ISerializedSearchComplete>;\n\tclearCache(cacheKey: string): Promise<void>;\n}\n\nexport interface IRawFileMatch {\n\tbase?: string;\n\t/**\n\t * The path of the file relative to the containing `base` folder.\n\t * This path is exactly as it appears on the filesystem.\n\t */\n\trelativePath: string;\n\t/**\n\t * This path is transformed for search purposes. For example, this could be\n\t * the `relativePath` with the workspace folder name prepended. This way the\n\t * search algorithm would also match against the name of the containing folder.\n\t *\n\t * If not given, the search algorithm should use `relativePath`.\n\t */\n\tsearchPath: string | undefined;\n}\n\nexport interface ISearchEngine<T> {\n\tsearch: (onResult: (matches: T) => void, onProgress: (progress: IProgressMessage) => void, done: (error: Error | null, complete: ISearchEngineSuccess) => void) => void;\n\tcancel: () => void;\n}\n\nexport interface ISerializedSearchSuccess {\n\ttype: 'success';\n\tlimitHit: boolean;\n\tmessages: ITextSearchCompleteMessage[];\n\tstats?: IFileSearchStats | ITextSearchStats;\n}\n\nexport interface ISearchEngineSuccess {\n\tlimitHit: boolean;\n\tmessages: ITextSearchCompleteMessage[];\n\tstats: ISearchEngineStats;\n}\n\nexport interface ISerializedSearchError {\n\ttype: 'error';\n\terror: {\n\t\tmessage: string;\n\t\tstack: string;\n\t};\n}\n\nexport type ISerializedSearchComplete = ISerializedSearchSuccess | ISerializedSearchError;\n\nexport function isSerializedSearchComplete(arg: ISerializedSearchProgressItem | ISerializedSearchComplete): arg is ISerializedSearchComplete {\n\tif ((arg as any).type === 'error') {\n\t\treturn true;\n\t} else if ((arg as any).type === 'success') {\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n\nexport function isSerializedSearchSuccess(arg: ISerializedSearchComplete): arg is ISerializedSearchSuccess {\n\treturn arg.type === 'success';\n}\n\nexport function isSerializedFileMatch(arg: ISerializedSearchProgressItem): arg is ISerializedFileMatch {\n\treturn !!(<ISerializedFileMatch>arg).path;\n}\n\nexport function isFilePatternMatch(candidate: IRawFileMatch, normalizedFilePatternLowercase: string): boolean {\n\tconst pathToMatch = candidate.searchPath ? candidate.searchPath : candidate.relativePath;\n\treturn fuzzyContains(pathToMatch, normalizedFilePatternLowercase);\n}\n\nexport interface ISerializedFileMatch {\n\tpath: string;\n\tresults?: ITextSearchResult[];\n\tnumMatches?: number;\n}\n\n// Type of the possible values for progress calls from the engine\nexport type ISerializedSearchProgressItem = ISerializedFileMatch | ISerializedFileMatch[] | IProgressMessage;\nexport type IFileSearchProgressItem = IRawFileMatch | IRawFileMatch[] | IProgressMessage;\n\n\nexport class SerializableFileMatch implements ISerializedFileMatch {\n\tpath: string;\n\tresults: ITextSearchMatch[];\n\n\tconstructor(path: string) {\n\t\tthis.path = path;\n\t\tthis.results = [];\n\t}\n\n\taddMatch(match: ITextSearchMatch): void {\n\t\tthis.results.push(match);\n\t}\n\n\tserialize(): ISerializedFileMatch {\n\t\treturn {\n\t\t\tpath: this.path,\n\t\t\tresults: this.results,\n\t\t\tnumMatches: this.results.length\n\t\t};\n\t}\n}\n\n/**\n *  Computes the patterns that the provider handles. Discards sibling clauses and 'false' patterns\n */\nexport function resolvePatternsForProvider(globalPattern: glob.IExpression | undefined, folderPattern: glob.IExpression | undefined): string[] {\n\tconst merged = {\n\t\t...(globalPattern || {}),\n\t\t...(folderPattern || {})\n\t};\n\n\treturn Object.keys(merged)\n\t\t.filter(key => {\n\t\t\tconst value = merged[key];\n\t\t\treturn typeof value === 'boolean' && value;\n\t\t});\n}\n\nexport class QueryGlobTester {\n\n\tprivate _excludeExpression: glob.IExpression;\n\tprivate _parsedExcludeExpression: glob.ParsedExpression;\n\n\tprivate _parsedIncludeExpression: glob.ParsedExpression | null = null;\n\n\tconstructor(config: ISearchQuery, folderQuery: IFolderQuery) {\n\t\tthis._excludeExpression = {\n\t\t\t...(config.excludePattern || {}),\n\t\t\t...(folderQuery.excludePattern || {})\n\t\t};\n\t\tthis._parsedExcludeExpression = glob.parse(this._excludeExpression);\n\n\t\t// Empty includeExpression means include nothing, so no {} shortcuts\n\t\tlet includeExpression: glob.IExpression | undefined = config.includePattern;\n\t\tif (folderQuery.includePattern) {\n\t\t\tif (includeExpression) {\n\t\t\t\tincludeExpression = {\n\t\t\t\t\t...includeExpression,\n\t\t\t\t\t...folderQuery.includePattern\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tincludeExpression = folderQuery.includePattern;\n\t\t\t}\n\t\t}\n\n\t\tif (includeExpression) {\n\t\t\tthis._parsedIncludeExpression = glob.parse(includeExpression);\n\t\t}\n\t}\n\n\tmatchesExcludesSync(testPath: string, basename?: string, hasSibling?: (name: string) => boolean): boolean {\n\t\tif (this._parsedExcludeExpression && this._parsedExcludeExpression(testPath, basename, hasSibling)) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Guaranteed sync - siblingsFn should not return a promise.\n\t */\n\tincludedInQuerySync(testPath: string, basename?: string, hasSibling?: (name: string) => boolean): boolean {\n\t\tif (this._parsedExcludeExpression && this._parsedExcludeExpression(testPath, basename, hasSibling)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (this._parsedIncludeExpression && !this._parsedIncludeExpression(testPath, basename, hasSibling)) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Evaluating the exclude expression is only async if it includes sibling clauses. As an optimization, avoid doing anything with Promises\n\t * unless the expression is async.\n\t */\n\tincludedInQuery(testPath: string, basename?: string, hasSibling?: (name: string) => boolean | Promise<boolean>): Promise<boolean> | boolean {\n\t\tconst excluded = this._parsedExcludeExpression(testPath, basename, hasSibling);\n\n\t\tconst isIncluded = () => {\n\t\t\treturn this._parsedIncludeExpression ?\n\t\t\t\t!!(this._parsedIncludeExpression(testPath, basename, hasSibling)) :\n\t\t\t\ttrue;\n\t\t};\n\n\t\tif (isThenable(excluded)) {\n\t\t\treturn excluded.then(excluded => {\n\t\t\t\tif (excluded) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\treturn isIncluded();\n\t\t\t});\n\t\t}\n\n\t\treturn isIncluded();\n\t}\n\n\thasSiblingExcludeClauses(): boolean {\n\t\treturn hasSiblingClauses(this._excludeExpression);\n\t}\n}\n\nfunction hasSiblingClauses(pattern: glob.IExpression): boolean {\n\tfor (const key in pattern) {\n\t\tif (typeof pattern[key] !== 'boolean') {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nexport function hasSiblingPromiseFn(siblingsFn?: () => Promise<string[]>) {\n\tif (!siblingsFn) {\n\t\treturn undefined;\n\t}\n\n\tlet siblings: Promise<Record<string, true>>;\n\treturn (name: string) => {\n\t\tif (!siblings) {\n\t\t\tsiblings = (siblingsFn() || Promise.resolve([]))\n\t\t\t\t.then(list => list ? listToMap(list) : {});\n\t\t}\n\t\treturn siblings.then(map => !!map[name]);\n\t};\n}\n\nexport function hasSiblingFn(siblingsFn?: () => string[]) {\n\tif (!siblingsFn) {\n\t\treturn undefined;\n\t}\n\n\tlet siblings: Record<string, true>;\n\treturn (name: string) => {\n\t\tif (!siblings) {\n\t\t\tconst list = siblingsFn();\n\t\t\tsiblings = list ? listToMap(list) : {};\n\t\t}\n\t\treturn !!siblings[name];\n\t};\n}\n\nfunction listToMap(list: string[]) {\n\tconst map: Record<string, true> = {};\n\tfor (const key of list) {\n\t\tmap[key] = true;\n\t}\n\treturn map;\n}\n"]}