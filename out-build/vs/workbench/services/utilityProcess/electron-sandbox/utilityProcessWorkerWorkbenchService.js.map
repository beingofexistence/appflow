{"version":3,"sources":["file:///workspace/appflow/src/vs/workbench/services/utilityProcess/electron-sandbox/utilityProcessWorkerWorkbenchService.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;;;;;;;;;;IAanF,QAAA,IAAI,GAAoC,IAAA,mBAAG,EAAoD,sCAAsC,CAAC,CAAC;IAuD7I,IAAM,IAAI,GAAV,MAAM,IAAqC,SAAQ,eAAG;QAK5D,IAAY,CAAC;YACZ,IAAI,CAAC,IAAI,CAAC,CAAC,EAA6B;gBACvC,MAAM,OAAO,GAAG,IAAI,CAAC,CAAC,CAAkB,UAAU,CAAC,kCAAI,CAA+B,CAAC;gBACvF,IAAI,CAAC,CAAC,GAA8B,kBAAY,CAAC,SAAS,CAA+B,OAAO,CAAC,CAAC;aAClG;YAED,OAAO,IAAI,CAAC,CAAC,CAA4B;QAC1C,CAAC;QAID,YACU,QAAgB,EACZ,CAAgC,EACxB,CAAyC;YAE9D,KAAK,EAAE,CAAC;YAJC,aAAQ,GAAR,QAAQ,CAAQ;YACK,MAAC,GAAD,CAAC,CAAc;YACP,MAAC,GAAD,CAAC,CAAuB;YAfvD,MAAC,GAAwE,SAAS,CAAC;YAU1E,MAAC,GAAiB,IAAI,WAAG,EAAM,CAAC;QAQjD,CAAC;QAED,KAAK,CAAC,YAAY,CAAC,OAAqC;YACvD,IAAI,CAAC,CAAC,CAAU,KAAK,CAAC,uCAAuC,CAAC,CAAC;YAE/D,+DAA+D;YAC/D,2DAA2D;YAC3D,gEAAgE;YAChE,uDAAuD;YAEvD,MAAM,OAAO,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC,CAAe,IAAI,EAAE,EAAE,IAAA,WAAG,EAAK,IAAI,CAAC,CAAC,CAAC,CAAC;YAEjE,wEAAwE;YACxE,MAAM,KAAK,GAAG,IAAA,UAAG,GAAW,CAAC;YAC7B,MAAM,eAAe,GAAG,uDAAuD,CAAC;YAChF,MAAM,WAAW,GAAG,IAAA,YAAG,EAAS,SAAS,CAAC,8CAA8C,EAAE,eAAe,EAAE,KAAK,CAAC,CAAC;YAElH,iDAAiD;YACjD,wCAAwC;YACxC,MAAM,cAAc,GAAG,IAAI,CAAC,CAAC,CAA2B,YAAY,CAAC;gBACpE,OAAO;gBACP,KAAK,EAAE,EAAE,QAAQ,EAAE,IAAI,CAAC,QAAQ,EAAE,OAAO,EAAE,eAAe,EAAE,KAAK,EAAE;aACnE,CAAC,CAAC;YAEH,2DAA2D;YAC3D,MAAM,WAAW,GAAG,IAAI,eAAG,EAAc,CAAC;YAC1C,WAAW,CAAC,GAAG,CAAC,IAAA,eAAG,EAAU,GAAG,EAAE;gBACjC,IAAI,CAAC,CAAC,CAAU,KAAK,CAAC,wCAAwC,EAAE,OAAO,CAAC,CAAC;gBAEzE,IAAI,CAAC,CAAC,CAA2B,aAAa,CAAC;oBAC9C,OAAO;oBACP,KAAK,EAAE,EAAE,QAAQ,EAAE,IAAI,CAAC,QAAQ,EAAE;iBAClC,CAAC,CAAC;YACJ,CAAC,CAAC,CAAC,CAAC;YAEJ,MAAM,IAAI,GAAG,MAAM,WAAW,CAAC;YAC/B,MAAM,MAAM,GAAG,WAAW,CAAC,GAAG,CAAC,IAAI,YAAiB,CAAC,IAAI,EAAE,UAAU,IAAI,CAAC,QAAQ,WAAW,OAAO,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC;YAClH,IAAI,CAAC,CAAC,CAAU,KAAK,CAAC,sEAAsE,CAAC,CAAC;YAE9F,cAAc,CAAC,IAAI,CAAC,CAAC,EAAE,MAAM,EAAE,EAAE,EAAE;gBAClC,IAAI,MAAM,EAAE,IAAI,KAAK,CAAC,EAAE;oBACvB,IAAI,CAAC,CAAC,CAAU,KAAK,CAAC,yDAAyD,MAAM,CAAC,IAAI,aAAa,MAAM,CAAC,MAAM,EAAE,CAAC,CAAC;iBACxH;qBAAM;oBACN,IAAI,CAAC,CAAC,CAAU,KAAK,CAAC,6DAA6D,MAAM,EAAE,IAAI,aAAa,MAAM,EAAE,MAAM,EAAE,CAAC,CAAC;iBAC9H;YACF,CAAC,CAAC,CAAC;YAEH,OAAO,EAAE,MAAM,EAAE,cAAc,EAAE,OAAO,EAAE,GAAG,EAAE,CAAC,WAAW,CAAC,OAAO,EAAE,EAAE,CAAC;QACzE,CAAC;QAED,cAAc;YACb,IAAI,CAAC,IAAI,CAAC,CAAC,CAAe,MAAM,EAAE,EAAE;gBACnC,IAAI,CAAC,CAAC,CAAe,IAAI,EAAE,CAAC;aAC5B;QACF,CAAC;KACD,CAAA;IA7EY,oBAAI;mBAAJ,IAAI;QAkBd,WAAA,SAAG,CAAA;QACH,WAAA,yBAAI,CAAA;OAnBM,IAAI,CA6EhB","file":"utilityProcessWorkerWorkbenchService.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ILogService } from 'vs/platform/log/common/log';\nimport { Disposable, DisposableStore, IDisposable, toDisposable } from 'vs/base/common/lifecycle';\nimport { IMainProcessService } from 'vs/platform/ipc/common/mainProcessService';\nimport { Client as MessagePortClient } from 'vs/base/parts/ipc/common/ipc.mp';\nimport { createDecorator } from 'vs/platform/instantiation/common/instantiation';\nimport { IPCClient, ProxyChannel } from 'vs/base/parts/ipc/common/ipc';\nimport { generateUuid } from 'vs/base/common/uuid';\nimport { acquirePort } from 'vs/base/parts/ipc/electron-sandbox/ipc.mp';\nimport { IOnDidTerminateUtilityrocessWorkerProcess, ipcUtilityProcessWorkerChannelName, IUtilityProcessWorkerProcess, IUtilityProcessWorkerService } from 'vs/platform/utilityProcess/common/utilityProcessWorkerService';\nimport { Barrier, timeout } from 'vs/base/common/async';\n\nexport const IUtilityProcessWorkerWorkbenchService = createDecorator<IUtilityProcessWorkerWorkbenchService>('utilityProcessWorkerWorkbenchService');\n\nexport interface IUtilityProcessWorker extends IDisposable {\n\n\t/**\n\t * A IPC client to communicate to the worker process.\n\t */\n\tclient: IPCClient<string>;\n\n\t/**\n\t * A promise that resolves to an object once the\n\t * worker process terminates, giving information\n\t * how the process terminated.\n\t *\n\t * This can be used to figure out whether the worker\n\t * should be restarted in case of an unexpected\n\t * termination.\n\t */\n\tonDidTerminate: Promise<IOnDidTerminateUtilityrocessWorkerProcess>;\n}\n\nexport interface IUtilityProcessWorkerWorkbenchService {\n\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Will fork a new process with the provided module identifier in a utility\n\t * process and establishes a message port connection to that process.\n\t *\n\t * Requires the forked process to be AMD module that uses our IPC channel framework\n\t * to respond to the provided `channelName` as a server.\n\t *\n\t * The process will be automatically terminated when the workbench window closes,\n\t * crashes or loads/reloads.\n\t *\n\t * Note on affinity: repeated calls to `createWorkerChannel` with the same `moduleId`\n\t * from the same window will result in any previous forked process to get terminated.\n\t * In other words, it is not possible, nor intended to create multiple workers of\n\t * the same process from one window. The intent of these workers is to be reused per\n\t * window and the communication channel allows to dynamically update the processes\n\t * after the fact.\n\t *\n\t * @param process information around the process to fork as worker\n\t *\n\t * @returns the worker IPC client to communicate with. Provides a `dispose` method that\n\t * allows to terminate the worker if needed.\n\t */\n\tcreateWorker(process: IUtilityProcessWorkerProcess): Promise<IUtilityProcessWorker>;\n\n\t/**\n\t * Notifies the service that the workbench window has restored.\n\t */\n\tnotifyRestored(): void;\n}\n\nexport class UtilityProcessWorkerWorkbenchService extends Disposable implements IUtilityProcessWorkerWorkbenchService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate _utilityProcessWorkerService: IUtilityProcessWorkerService | undefined = undefined;\n\tprivate get utilityProcessWorkerService(): IUtilityProcessWorkerService {\n\t\tif (!this._utilityProcessWorkerService) {\n\t\t\tconst channel = this.mainProcessService.getChannel(ipcUtilityProcessWorkerChannelName);\n\t\t\tthis._utilityProcessWorkerService = ProxyChannel.toService<IUtilityProcessWorkerService>(channel);\n\t\t}\n\n\t\treturn this._utilityProcessWorkerService;\n\t}\n\n\tprivate readonly restoredBarrier = new Barrier();\n\n\tconstructor(\n\t\treadonly windowId: number,\n\t\t@ILogService private readonly logService: ILogService,\n\t\t@IMainProcessService private readonly mainProcessService: IMainProcessService\n\t) {\n\t\tsuper();\n\t}\n\n\tasync createWorker(process: IUtilityProcessWorkerProcess): Promise<IUtilityProcessWorker> {\n\t\tthis.logService.trace('Renderer->UtilityProcess#createWorker');\n\n\t\t// We want to avoid heavy utility process work to happen before\n\t\t// the window has restored. As such, make sure we await the\n\t\t// `Restored` phase before making a connection attempt, but also\n\t\t// add a timeout to be safe against possible deadlocks.\n\n\t\tawait Promise.race([this.restoredBarrier.wait(), timeout(2000)]);\n\n\t\t// Get ready to acquire the message port from the utility process worker\n\t\tconst nonce = generateUuid();\n\t\tconst responseChannel = 'vscode:createUtilityProcessWorkerMessageChannelResult';\n\t\tconst portPromise = acquirePort(undefined /* we trigger the request via service call! */, responseChannel, nonce);\n\n\t\t// Actually talk with the utility process service\n\t\t// to create a new process from a worker\n\t\tconst onDidTerminate = this.utilityProcessWorkerService.createWorker({\n\t\t\tprocess,\n\t\t\treply: { windowId: this.windowId, channel: responseChannel, nonce }\n\t\t});\n\n\t\t// Dispose worker upon disposal via utility process service\n\t\tconst disposables = new DisposableStore();\n\t\tdisposables.add(toDisposable(() => {\n\t\t\tthis.logService.trace('Renderer->UtilityProcess#disposeWorker', process);\n\n\t\t\tthis.utilityProcessWorkerService.disposeWorker({\n\t\t\t\tprocess,\n\t\t\t\treply: { windowId: this.windowId }\n\t\t\t});\n\t\t}));\n\n\t\tconst port = await portPromise;\n\t\tconst client = disposables.add(new MessagePortClient(port, `window:${this.windowId},module:${process.moduleId}`));\n\t\tthis.logService.trace('Renderer->UtilityProcess#createWorkerChannel: connection established');\n\n\t\tonDidTerminate.then(({ reason }) => {\n\t\t\tif (reason?.code === 0) {\n\t\t\t\tthis.logService.trace(`[UtilityProcessWorker]: terminated normally with code ${reason.code}, signal: ${reason.signal}`);\n\t\t\t} else {\n\t\t\t\tthis.logService.error(`[UtilityProcessWorker]: terminated unexpectedly with code ${reason?.code}, signal: ${reason?.signal}`);\n\t\t\t}\n\t\t});\n\n\t\treturn { client, onDidTerminate, dispose: () => disposables.dispose() };\n\t}\n\n\tnotifyRestored(): void {\n\t\tif (!this.restoredBarrier.isOpen()) {\n\t\t\tthis.restoredBarrier.open();\n\t\t}\n\t}\n}\n"]}