{"version":3,"sources":["file:///workspace/appflow/src/vs/workbench/services/host/browser/host.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;IAMnF,QAAA,GAAG,GAAY,IAAA,mBAAG,EAA2B,aAAa,CAAC,CAAC","file":"host.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event } from 'vs/base/common/event';\nimport { createDecorator } from 'vs/platform/instantiation/common/instantiation';\nimport { IWindowOpenable, IOpenWindowOptions, IOpenEmptyWindowOptions } from 'vs/platform/window/common/window';\n\nexport const IHostService = createDecorator<IHostService>('hostService');\n\n/**\n * A set of methods supported in both web and native environments.\n *\n * @see {@link INativeHostService} for methods that are specific to native\n * environments.\n */\nexport interface IHostService {\n\n\treadonly _serviceBrand: undefined;\n\n\n\t//#region Focus\n\n\t/**\n\t * Emitted when the window focus changes.\n\t */\n\treadonly onDidChangeFocus: Event<boolean>;\n\n\t/**\n\t * Find out if the window has focus or not.\n\t */\n\treadonly hasFocus: boolean;\n\n\t/**\n\t * Find out if the window had the last focus.\n\t */\n\thadLastFocus(): Promise<boolean>;\n\n\t/**\n\t * Attempt to bring the window to the foreground and focus it.\n\t *\n\t * @param options Pass `force: true` if you want to make the window take\n\t * focus even if the application does not have focus currently. This option\n\t * should only be used if it is necessary to steal focus from the current\n\t * focused application which may not be VSCode. It may not be supported\n\t * in all environments.\n\t */\n\tfocus(options?: { force: boolean }): Promise<void>;\n\n\t//#endregion\n\n\n\t//#region Window\n\n\t/**\n\t * Opens an empty window. The optional parameter allows to define if\n\t * a new window should open or the existing one change to an empty.\n\t */\n\topenWindow(options?: IOpenEmptyWindowOptions): Promise<void>;\n\n\t/**\n\t * Opens the provided array of openables in a window with the provided options.\n\t */\n\topenWindow(toOpen: IWindowOpenable[], options?: IOpenWindowOptions): Promise<void>;\n\n\t/**\n\t * Switch between fullscreen and normal window.\n\t */\n\ttoggleFullScreen(): Promise<void>;\n\n\t//#endregion\n\n\t//#region Lifecycle\n\n\t/**\n\t * Restart the entire application.\n\t */\n\trestart(): Promise<void>;\n\n\t/**\n\t * Reload the currently active window.\n\t */\n\treload(options?: { disableExtensions?: boolean }): Promise<void>;\n\n\t/**\n\t * Attempt to close the active window.\n\t */\n\tclose(): Promise<void>;\n\n\t/**\n\t * Execute an asynchronous `expectedShutdownTask`. While this task is\n\t * in progress, attempts to quit the application will not be vetoed with a dialog.\n\t */\n\twithExpectedShutdown<T>(expectedShutdownTask: () => Promise<T>): Promise<T>;\n\n\t//#endregion\n}\n"]}