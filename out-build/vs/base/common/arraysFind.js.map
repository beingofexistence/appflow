{"version":3,"sources":["file:///workspace/appflow/src/vs/base/common/arraysFind.ts"],"names":[],"mappings":"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","file":"arraysFind.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Comparator } from './arrays';\n\nexport function findLast<T>(array: readonly T[], predicate: (item: T) => boolean, fromIdx?: number): T | undefined {\n\tconst idx = findLastIdx(array, predicate);\n\tif (idx === -1) {\n\t\treturn undefined;\n\t}\n\treturn array[idx];\n}\n\nexport function findLastIdx<T>(array: readonly T[], predicate: (item: T) => boolean, fromIndex = array.length - 1): number {\n\tfor (let i = fromIndex; i >= 0; i--) {\n\t\tconst element = array[i];\n\n\t\tif (predicate(element)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\n/**\n * Finds the last item where predicate is true using binary search.\n * `predicate` must be monotonous, i.e. `arr.map(predicate)` must be like `[true, ..., true, false, ..., false]`!\n *\n * @returns `undefined` if no item matches, otherwise the last item that matches the predicate.\n */\nexport function findLastMonotonous<T>(array: readonly T[], predicate: (item: T) => boolean): T | undefined {\n\tconst idx = findLastIdxMonotonous(array, predicate);\n\treturn idx === -1 ? undefined : array[idx];\n}\n\n/**\n * Finds the last item where predicate is true using binary search.\n * `predicate` must be monotonous, i.e. `arr.map(predicate)` must be like `[true, ..., true, false, ..., false]`!\n *\n * @returns `startIdx - 1` if predicate is false for all items, otherwise the index of the last item that matches the predicate.\n */\nexport function findLastIdxMonotonous<T>(array: readonly T[], predicate: (item: T) => boolean, startIdx = 0, endIdxEx = array.length): number {\n\tlet i = startIdx;\n\tlet j = endIdxEx;\n\twhile (i < j) {\n\t\tconst k = Math.floor((i + j) / 2);\n\t\tif (predicate(array[k])) {\n\t\t\ti = k + 1;\n\t\t} else {\n\t\t\tj = k;\n\t\t}\n\t}\n\treturn i - 1;\n}\n\n/**\n * Finds the first item where predicate is true using binary search.\n * `predicate` must be monotonous, i.e. `arr.map(predicate)` must be like `[false, ..., false, true, ..., true]`!\n *\n * @returns `undefined` if no item matches, otherwise the first item that matches the predicate.\n */\nexport function findFirstMonotonous<T>(array: readonly T[], predicate: (item: T) => boolean): T | undefined {\n\tconst idx = findFirstIdxMonotonousOrArrLen(array, predicate);\n\treturn idx === array.length ? undefined : array[idx];\n}\n\n/**\n * Finds the first item where predicate is true using binary search.\n * `predicate` must be monotonous, i.e. `arr.map(predicate)` must be like `[false, ..., false, true, ..., true]`!\n *\n * @returns `endIdxEx` if predicate is false for all items, otherwise the index of the first item that matches the predicate.\n */\nexport function findFirstIdxMonotonousOrArrLen<T>(array: readonly T[], predicate: (item: T) => boolean, startIdx = 0, endIdxEx = array.length): number {\n\tlet i = startIdx;\n\tlet j = endIdxEx;\n\twhile (i < j) {\n\t\tconst k = Math.floor((i + j) / 2);\n\t\tif (predicate(array[k])) {\n\t\t\tj = k;\n\t\t} else {\n\t\t\ti = k + 1;\n\t\t}\n\t}\n\treturn i;\n}\n\nexport function findFirstIdxMonotonous<T>(array: readonly T[], predicate: (item: T) => boolean, startIdx = 0, endIdxEx = array.length): number {\n\tconst idx = findFirstIdxMonotonousOrArrLen(array, predicate, startIdx, endIdxEx);\n\treturn idx === array.length ? -1 : idx;\n}\n\n/**\n * Use this when\n * * You have a sorted array\n * * You query this array with a monotonous predicate to find the last item that has a certain property.\n * * You query this array multiple times with monotonous predicates that get weaker and weaker.\n */\nexport class MonotonousArray<T> {\n\tpublic static assertInvariants = false;\n\n\tprivate _findLastMonotonousLastIdx = 0;\n\tprivate _prevFindLastPredicate: ((item: T) => boolean) | undefined;\n\n\tconstructor(private readonly _array: readonly T[]) {\n\t}\n\n\t/**\n\t * The predicate must be monotonous, i.e. `arr.map(predicate)` must be like `[true, ..., true, false, ..., false]`!\n\t * For subsequent calls, current predicate must be weaker than (or equal to) the previous predicate, i.e. more entries must be `true`.\n\t */\n\tfindLastMonotonous(predicate: (item: T) => boolean): T | undefined {\n\t\tif (MonotonousArray.assertInvariants) {\n\t\t\tif (this._prevFindLastPredicate) {\n\t\t\t\tfor (const item of this._array) {\n\t\t\t\t\tif (this._prevFindLastPredicate(item) && !predicate(item)) {\n\t\t\t\t\t\tthrow new Error('MonotonousArray: current predicate must be weaker than (or equal to) the previous predicate.');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._prevFindLastPredicate = predicate;\n\t\t}\n\n\t\tconst idx = findLastIdxMonotonous(this._array, predicate, this._findLastMonotonousLastIdx);\n\t\tthis._findLastMonotonousLastIdx = idx + 1;\n\t\treturn idx === -1 ? undefined : this._array[idx];\n\t}\n}\n\n/**\n * Returns the first item that is equal to or greater than every other item.\n*/\nexport function findFirstMaxBy<T>(array: readonly T[], comparator: Comparator<T>): T | undefined {\n\tif (array.length === 0) {\n\t\treturn undefined;\n\t}\n\n\tlet max = array[0];\n\tfor (let i = 1; i < array.length; i++) {\n\t\tconst item = array[i];\n\t\tif (comparator(item, max) > 0) {\n\t\t\tmax = item;\n\t\t}\n\t}\n\treturn max;\n}\n\n/**\n * Returns the last item that is equal to or greater than every other item.\n*/\nexport function findLastMaxBy<T>(array: readonly T[], comparator: Comparator<T>): T | undefined {\n\tif (array.length === 0) {\n\t\treturn undefined;\n\t}\n\n\tlet max = array[0];\n\tfor (let i = 1; i < array.length; i++) {\n\t\tconst item = array[i];\n\t\tif (comparator(item, max) >= 0) {\n\t\t\tmax = item;\n\t\t}\n\t}\n\treturn max;\n}\n\n/**\n * Returns the first item that is equal to or less than every other item.\n*/\nexport function findFirstMinBy<T>(array: readonly T[], comparator: Comparator<T>): T | undefined {\n\treturn findFirstMaxBy(array, (a, b) => -comparator(a, b));\n}\n\nexport function findMaxIdxBy<T>(array: readonly T[], comparator: Comparator<T>): number {\n\tif (array.length === 0) {\n\t\treturn -1;\n\t}\n\n\tlet maxIdx = 0;\n\tfor (let i = 1; i < array.length; i++) {\n\t\tconst item = array[i];\n\t\tif (comparator(item, array[maxIdx]) > 0) {\n\t\t\tmaxIdx = i;\n\t\t}\n\t}\n\treturn maxIdx;\n}\n\n/**\n * Returns the first mapped value of the array which is not undefined.\n */\nexport function mapFindFirst<T, R>(items: Iterable<T>, mapFn: (value: T) => R | undefined): R | undefined {\n\tfor (const value of items) {\n\t\tconst mapped = mapFn(value);\n\t\tif (mapped !== undefined) {\n\t\t\treturn mapped;\n\t\t}\n\t}\n\n\treturn undefined;\n}\n"]}