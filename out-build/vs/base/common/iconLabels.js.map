{"version":3,"sources":["file:///workspace/appflow/src/vs/base/common/iconLabels.ts"],"names":[],"mappings":"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","file":"iconLabels.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IMatch, matchesFuzzy } from 'vs/base/common/filters';\nimport { ltrim } from 'vs/base/common/strings';\nimport { ThemeIcon } from 'vs/base/common/themables';\n\nconst iconStartMarker = '$(';\n\nconst iconsRegex = new RegExp(`\\\\$\\\\(${ThemeIcon.iconNameExpression}(?:${ThemeIcon.iconModifierExpression})?\\\\)`, 'g'); // no capturing groups\n\nconst escapeIconsRegex = new RegExp(`(\\\\\\\\)?${iconsRegex.source}`, 'g');\nexport function escapeIcons(text: string): string {\n\treturn text.replace(escapeIconsRegex, (match, escaped) => escaped ? match : `\\\\${match}`);\n}\n\nconst markdownEscapedIconsRegex = new RegExp(`\\\\\\\\${iconsRegex.source}`, 'g');\nexport function markdownEscapeEscapedIcons(text: string): string {\n\t// Need to add an extra \\ for escaping in markdown\n\treturn text.replace(markdownEscapedIconsRegex, match => `\\\\${match}`);\n}\n\nconst stripIconsRegex = new RegExp(`(\\\\s)?(\\\\\\\\)?${iconsRegex.source}(\\\\s)?`, 'g');\n\n/**\n * Takes a label with icons (`$(iconId)xyz`)  and strips the icons out (`xyz`)\n */\nexport function stripIcons(text: string): string {\n\tif (text.indexOf(iconStartMarker) === -1) {\n\t\treturn text;\n\t}\n\n\treturn text.replace(stripIconsRegex, (match, preWhitespace, escaped, postWhitespace) => escaped ? match : preWhitespace || postWhitespace || '');\n}\n\n\n/**\n * Takes a label with icons (`$(iconId)xyz`), removes the icon syntax adds whitespace so that screen readers can read the text better.\n */\nexport function getCodiconAriaLabel(text: string | undefined) {\n\tif (!text) {\n\t\treturn '';\n\t}\n\n\treturn text.replace(/\\$\\((.*?)\\)/g, (_match, codiconName) => ` ${codiconName} `).trim();\n}\n\n\nexport interface IParsedLabelWithIcons {\n\treadonly text: string;\n\treadonly iconOffsets?: readonly number[];\n}\n\nconst _parseIconsRegex = new RegExp(`\\\\$\\\\(${ThemeIcon.iconNameCharacter}+\\\\)`, 'g');\n\n/**\n * Takes a label with icons (`abc $(iconId)xyz`) and returns the text (`abc xyz`) and the offsets of the icons (`[3]`)\n */\nexport function parseLabelWithIcons(input: string): IParsedLabelWithIcons {\n\n\t_parseIconsRegex.lastIndex = 0;\n\n\tlet text = '';\n\tconst iconOffsets: number[] = [];\n\tlet iconsOffset = 0;\n\n\twhile (true) {\n\t\tconst pos = _parseIconsRegex.lastIndex;\n\t\tconst match = _parseIconsRegex.exec(input);\n\n\t\tconst chars = input.substring(pos, match?.index);\n\t\tif (chars.length > 0) {\n\t\t\ttext += chars;\n\t\t\tfor (let i = 0; i < chars.length; i++) {\n\t\t\t\ticonOffsets.push(iconsOffset);\n\t\t\t}\n\t\t}\n\t\tif (!match) {\n\t\t\tbreak;\n\t\t}\n\t\ticonsOffset += match[0].length;\n\t}\n\n\treturn { text, iconOffsets };\n}\n\n\nexport function matchesFuzzyIconAware(query: string, target: IParsedLabelWithIcons, enableSeparateSubstringMatching = false): IMatch[] | null {\n\tconst { text, iconOffsets } = target;\n\n\t// Return early if there are no icon markers in the word to match against\n\tif (!iconOffsets || iconOffsets.length === 0) {\n\t\treturn matchesFuzzy(query, text, enableSeparateSubstringMatching);\n\t}\n\n\t// Trim the word to match against because it could have leading\n\t// whitespace now if the word started with an icon\n\tconst wordToMatchAgainstWithoutIconsTrimmed = ltrim(text, ' ');\n\tconst leadingWhitespaceOffset = text.length - wordToMatchAgainstWithoutIconsTrimmed.length;\n\n\t// match on value without icon\n\tconst matches = matchesFuzzy(query, wordToMatchAgainstWithoutIconsTrimmed, enableSeparateSubstringMatching);\n\n\t// Map matches back to offsets with icon and trimming\n\tif (matches) {\n\t\tfor (const match of matches) {\n\t\t\tconst iconOffset = iconOffsets[match.start + leadingWhitespaceOffset] /* icon offsets at index */ + leadingWhitespaceOffset /* overall leading whitespace offset */;\n\t\t\tmatch.start += iconOffset;\n\t\t\tmatch.end += iconOffset;\n\t\t}\n\t}\n\n\treturn matches;\n}\n"]}