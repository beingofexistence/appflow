{"version":3,"sources":["file:///workspace/appflow/src/vs/base/common/prefixTree.ts"],"names":[],"mappings":"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","file":"prefixTree.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nconst unset = Symbol('unset');\n\n/**\n * A simple prefix tree implementation where a value is stored based on\n * well-defined prefix segments.\n */\nexport class WellDefinedPrefixTree<V> {\n\tprivate readonly root = new Node<V>();\n\tprivate _size = 0;\n\n\tpublic get size() {\n\t\treturn this._size;\n\t}\n\n\t/** Inserts a new value in the prefix tree. */\n\tinsert(key: Iterable<string>, value: V): void {\n\t\tthis.opNode(key, n => n.value = value);\n\t}\n\n\t/** Mutates a value in the prefix tree. */\n\tmutate(key: Iterable<string>, mutate: (value?: V) => V): void {\n\t\tthis.opNode(key, n => n.value = mutate(n.value === unset ? undefined : n.value));\n\t}\n\n\t/** Deletes a node from the prefix tree, returning the value it contained. */\n\tdelete(key: Iterable<string>): V | undefined {\n\t\tconst path = [{ part: '', node: this.root }];\n\t\tlet i = 0;\n\t\tfor (const part of key) {\n\t\t\tconst node = path[i].node.children?.get(part);\n\t\t\tif (!node) {\n\t\t\t\treturn undefined; // node not in tree\n\t\t\t}\n\n\t\t\tpath.push({ part, node });\n\t\t\ti++;\n\t\t}\n\n\t\tconst value = path[i].node.value;\n\t\tif (value === unset) {\n\t\t\treturn; // not actually a real node\n\t\t}\n\n\t\tthis._size--;\n\t\tfor (; i > 0; i--) {\n\t\t\tconst parent = path[i - 1];\n\t\t\tparent.node.children!.delete(path[i].part);\n\t\t\tif (parent.node.children!.size > 0 || parent.node.value !== unset) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn value;\n\t}\n\n\t/** Gets a value from the tree. */\n\tfind(key: Iterable<string>): V | undefined {\n\t\tlet node = this.root;\n\t\tfor (const segment of key) {\n\t\t\tconst next = node.children?.get(segment);\n\t\t\tif (!next) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tnode = next;\n\t\t}\n\n\t\treturn node.value === unset ? undefined : node.value;\n\t}\n\n\t/** Gets whether the tree has the key, or a parent of the key, already inserted. */\n\thasKeyOrParent(key: Iterable<string>): boolean {\n\t\tlet node = this.root;\n\t\tfor (const segment of key) {\n\t\t\tconst next = node.children?.get(segment);\n\t\t\tif (!next) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (next.value !== unset) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tnode = next;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/** Gets whether the tree has the given key or any children. */\n\thasKeyOrChildren(key: Iterable<string>): boolean {\n\t\tlet node = this.root;\n\t\tfor (const segment of key) {\n\t\t\tconst next = node.children?.get(segment);\n\t\t\tif (!next) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tnode = next;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/** Gets whether the tree has the given key. */\n\thasKey(key: Iterable<string>): boolean {\n\t\tlet node = this.root;\n\t\tfor (const segment of key) {\n\t\t\tconst next = node.children?.get(segment);\n\t\t\tif (!next) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tnode = next;\n\t\t}\n\n\t\treturn node.value !== unset;\n\t}\n\n\tprivate opNode(key: Iterable<string>, fn: (node: Node<V>) => void): void {\n\t\tlet node = this.root;\n\t\tfor (const part of key) {\n\t\t\tif (!node.children) {\n\t\t\t\tconst next = new Node<V>();\n\t\t\t\tnode.children = new Map([[part, next]]);\n\t\t\t\tnode = next;\n\t\t\t} else if (!node.children.has(part)) {\n\t\t\t\tconst next = new Node<V>();\n\t\t\t\tnode.children.set(part, next);\n\t\t\t\tnode = next;\n\t\t\t} else {\n\t\t\t\tnode = node.children.get(part)!;\n\t\t\t}\n\t\t}\n\n\t\tif (node.value === unset) {\n\t\t\tthis._size++;\n\t\t}\n\n\t\tfn(node);\n\t}\n\n\t/** Returns an iterable of the tree values in no defined order. */\n\t*values() {\n\t\tconst stack = [this.root];\n\t\twhile (stack.length > 0) {\n\t\t\tconst node = stack.pop()!;\n\t\t\tif (node.value !== unset) {\n\t\t\t\tyield node.value;\n\t\t\t}\n\n\t\t\tif (node.children) {\n\t\t\t\tfor (const child of node.children.values()) {\n\t\t\t\t\tstack.push(child);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass Node<T> {\n\tpublic children?: Map<string, Node<T>>;\n\tpublic value: T | typeof unset = unset;\n}\n"]}