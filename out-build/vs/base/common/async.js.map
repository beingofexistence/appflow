{"version":3,"sources":["file:///workspace/appflow/src/vs/base/common/async.ts"],"names":[],"mappings":"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","file":"async.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken, CancellationTokenSource } from 'vs/base/common/cancellation';\nimport { CancellationError } from 'vs/base/common/errors';\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { Disposable, DisposableMap, IDisposable, MutableDisposable, toDisposable } from 'vs/base/common/lifecycle';\nimport { extUri as defaultExtUri, IExtUri } from 'vs/base/common/resources';\nimport { URI } from 'vs/base/common/uri';\nimport { setTimeout0 } from 'vs/base/common/platform';\nimport { MicrotaskDelay } from './symbols';\n\nexport function isThenable<T>(obj: unknown): obj is Promise<T> {\n\treturn !!obj && typeof (obj as unknown as Promise<T>).then === 'function';\n}\n\nexport interface CancelablePromise<T> extends Promise<T> {\n\tcancel(): void;\n}\n\nexport function createCancelablePromise<T>(callback: (token: CancellationToken) => Promise<T>): CancelablePromise<T> {\n\tconst source = new CancellationTokenSource();\n\n\tconst thenable = callback(source.token);\n\tconst promise = new Promise<T>((resolve, reject) => {\n\t\tconst subscription = source.token.onCancellationRequested(() => {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\treject(new CancellationError());\n\t\t});\n\t\tPromise.resolve(thenable).then(value => {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\tresolve(value);\n\t\t}, err => {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\treject(err);\n\t\t});\n\t});\n\n\treturn <CancelablePromise<T>>new class {\n\t\tcancel() {\n\t\t\tsource.cancel();\n\t\t}\n\t\tthen<TResult1 = T, TResult2 = never>(resolve?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, reject?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2> {\n\t\t\treturn promise.then(resolve, reject);\n\t\t}\n\t\tcatch<TResult = never>(reject?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult> {\n\t\t\treturn this.then(undefined, reject);\n\t\t}\n\t\tfinally(onfinally?: (() => void) | undefined | null): Promise<T> {\n\t\t\treturn promise.finally(onfinally);\n\t\t}\n\t};\n}\n\n/**\n * Returns a promise that resolves with `undefined` as soon as the passed token is cancelled.\n * @see {@link raceCancellationError}\n */\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken): Promise<T | undefined>;\n\n/**\n * Returns a promise that resolves with `defaultValue` as soon as the passed token is cancelled.\n * @see {@link raceCancellationError}\n */\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken, defaultValue: T): Promise<T>;\n\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken, defaultValue?: T): Promise<T | undefined> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst ref = token.onCancellationRequested(() => {\n\t\t\tref.dispose();\n\t\t\tresolve(defaultValue);\n\t\t});\n\t\tpromise.then(resolve, reject).finally(() => ref.dispose());\n\t});\n}\n\n/**\n * Returns a promise that rejects with an {@CancellationError} as soon as the passed token is cancelled.\n * @see {@link raceCancellation}\n */\nexport function raceCancellationError<T>(promise: Promise<T>, token: CancellationToken): Promise<T> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst ref = token.onCancellationRequested(() => {\n\t\t\tref.dispose();\n\t\t\treject(new CancellationError());\n\t\t});\n\t\tpromise.then(resolve, reject).finally(() => ref.dispose());\n\t});\n}\n\n/**\n * Returns as soon as one of the promises resolves or rejects and cancels remaining promises\n */\nexport async function raceCancellablePromises<T>(cancellablePromises: CancelablePromise<T>[]): Promise<T> {\n\tlet resolvedPromiseIndex = -1;\n\tconst promises = cancellablePromises.map((promise, index) => promise.then(result => { resolvedPromiseIndex = index; return result; }));\n\ttry {\n\t\tconst result = await Promise.race(promises);\n\t\treturn result;\n\t} finally {\n\t\tcancellablePromises.forEach((cancellablePromise, index) => {\n\t\t\tif (index !== resolvedPromiseIndex) {\n\t\t\t\tcancellablePromise.cancel();\n\t\t\t}\n\t\t});\n\t}\n}\n\nexport function raceTimeout<T>(promise: Promise<T>, timeout: number, onTimeout?: () => void): Promise<T | undefined> {\n\tlet promiseResolve: ((value: T | undefined) => void) | undefined = undefined;\n\n\tconst timer = setTimeout(() => {\n\t\tpromiseResolve?.(undefined);\n\t\tonTimeout?.();\n\t}, timeout);\n\n\treturn Promise.race([\n\t\tpromise.finally(() => clearTimeout(timer)),\n\t\tnew Promise<T | undefined>(resolve => promiseResolve = resolve)\n\t]);\n}\n\nexport function asPromise<T>(callback: () => T | Thenable<T>): Promise<T> {\n\treturn new Promise<T>((resolve, reject) => {\n\t\tconst item = callback();\n\t\tif (isThenable<T>(item)) {\n\t\t\titem.then(resolve, reject);\n\t\t} else {\n\t\t\tresolve(item);\n\t\t}\n\t});\n}\n\nexport interface ITask<T> {\n\t(): T;\n}\n\n/**\n * A helper to prevent accumulation of sequential async tasks.\n *\n * Imagine a mail man with the sole task of delivering letters. As soon as\n * a letter submitted for delivery, he drives to the destination, delivers it\n * and returns to his base. Imagine that during the trip, N more letters were submitted.\n * When the mail man returns, he picks those N letters and delivers them all in a\n * single trip. Even though N+1 submissions occurred, only 2 deliveries were made.\n *\n * The throttler implements this via the queue() method, by providing it a task\n * factory. Following the example:\n *\n * \t\tconst throttler = new Throttler();\n * \t\tconst letters = [];\n *\n * \t\tfunction deliver() {\n * \t\t\tconst lettersToDeliver = letters;\n * \t\t\tletters = [];\n * \t\t\treturn makeTheTrip(lettersToDeliver);\n * \t\t}\n *\n * \t\tfunction onLetterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tthrottler.queue(deliver);\n * \t\t}\n */\nexport class Throttler implements IDisposable {\n\n\tprivate activePromise: Promise<any> | null;\n\tprivate queuedPromise: Promise<any> | null;\n\tprivate queuedPromiseFactory: ITask<Promise<any>> | null;\n\n\tprivate isDisposed = false;\n\n\tconstructor() {\n\t\tthis.activePromise = null;\n\t\tthis.queuedPromise = null;\n\t\tthis.queuedPromiseFactory = null;\n\t}\n\n\tqueue<T>(promiseFactory: ITask<Promise<T>>): Promise<T> {\n\t\tif (this.isDisposed) {\n\t\t\treturn Promise.reject(new Error('Throttler is disposed'));\n\t\t}\n\n\t\tif (this.activePromise) {\n\t\t\tthis.queuedPromiseFactory = promiseFactory;\n\n\t\t\tif (!this.queuedPromise) {\n\t\t\t\tconst onComplete = () => {\n\t\t\t\t\tthis.queuedPromise = null;\n\n\t\t\t\t\tif (this.isDisposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst result = this.queue(this.queuedPromiseFactory!);\n\t\t\t\t\tthis.queuedPromiseFactory = null;\n\n\t\t\t\t\treturn result;\n\t\t\t\t};\n\n\t\t\t\tthis.queuedPromise = new Promise(resolve => {\n\t\t\t\t\tthis.activePromise!.then(onComplete, onComplete).then(resolve);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tthis.queuedPromise!.then(resolve, reject);\n\t\t\t});\n\t\t}\n\n\t\tthis.activePromise = promiseFactory();\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.activePromise!.then((result: T) => {\n\t\t\t\tthis.activePromise = null;\n\t\t\t\tresolve(result);\n\t\t\t}, (err: unknown) => {\n\t\t\t\tthis.activePromise = null;\n\t\t\t\treject(err);\n\t\t\t});\n\t\t});\n\t}\n\n\tdispose(): void {\n\t\tthis.isDisposed = true;\n\t}\n}\n\nexport class Sequencer {\n\n\tprivate current: Promise<unknown> = Promise.resolve(null);\n\n\tqueue<T>(promiseTask: ITask<Promise<T>>): Promise<T> {\n\t\treturn this.current = this.current.then(() => promiseTask(), () => promiseTask());\n\t}\n}\n\nexport class SequencerByKey<TKey> {\n\n\tprivate promiseMap = new Map<TKey, Promise<unknown>>();\n\n\tqueue<T>(key: TKey, promiseTask: ITask<Promise<T>>): Promise<T> {\n\t\tconst runningPromise = this.promiseMap.get(key) ?? Promise.resolve();\n\t\tconst newPromise = runningPromise\n\t\t\t.catch(() => { })\n\t\t\t.then(promiseTask)\n\t\t\t.finally(() => {\n\t\t\t\tif (this.promiseMap.get(key) === newPromise) {\n\t\t\t\t\tthis.promiseMap.delete(key);\n\t\t\t\t}\n\t\t\t});\n\t\tthis.promiseMap.set(key, newPromise);\n\t\treturn newPromise;\n\t}\n}\n\ninterface IScheduledLater extends IDisposable {\n\tisTriggered(): boolean;\n}\n\nconst timeoutDeferred = (timeout: number, fn: () => void): IScheduledLater => {\n\tlet scheduled = true;\n\tconst handle = setTimeout(() => {\n\t\tscheduled = false;\n\t\tfn();\n\t}, timeout);\n\treturn {\n\t\tisTriggered: () => scheduled,\n\t\tdispose: () => {\n\t\t\tclearTimeout(handle);\n\t\t\tscheduled = false;\n\t\t},\n\t};\n};\n\nconst microtaskDeferred = (fn: () => void): IScheduledLater => {\n\tlet scheduled = true;\n\tqueueMicrotask(() => {\n\t\tif (scheduled) {\n\t\t\tscheduled = false;\n\t\t\tfn();\n\t\t}\n\t});\n\n\treturn {\n\t\tisTriggered: () => scheduled,\n\t\tdispose: () => { scheduled = false; },\n\t};\n};\n\n/**\n * A helper to delay (debounce) execution of a task that is being requested often.\n *\n * Following the throttler, now imagine the mail man wants to optimize the number of\n * trips proactively. The trip itself can be long, so he decides not to make the trip\n * as soon as a letter is submitted. Instead he waits a while, in case more\n * letters are submitted. After said waiting period, if no letters were submitted, he\n * decides to make the trip. Imagine that N more letters were submitted after the first\n * one, all within a short period of time between each other. Even though N+1\n * submissions occurred, only 1 delivery was made.\n *\n * The delayer offers this behavior via the trigger() method, into which both the task\n * to be executed and the waiting period (delay) must be passed in as arguments. Following\n * the example:\n *\n * \t\tconst delayer = new Delayer(WAITING_PERIOD);\n * \t\tconst letters = [];\n *\n * \t\tfunction letterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tdelayer.trigger(() => { return makeTheTrip(); });\n * \t\t}\n */\nexport class Delayer<T> implements IDisposable {\n\n\tprivate deferred: IScheduledLater | null;\n\tprivate completionPromise: Promise<any> | null;\n\tprivate doResolve: ((value?: any | Promise<any>) => void) | null;\n\tprivate doReject: ((err: any) => void) | null;\n\tprivate task: ITask<T | Promise<T>> | null;\n\n\tconstructor(public defaultDelay: number | typeof MicrotaskDelay) {\n\t\tthis.deferred = null;\n\t\tthis.completionPromise = null;\n\t\tthis.doResolve = null;\n\t\tthis.doReject = null;\n\t\tthis.task = null;\n\t}\n\n\ttrigger(task: ITask<T | Promise<T>>, delay = this.defaultDelay): Promise<T> {\n\t\tthis.task = task;\n\t\tthis.cancelTimeout();\n\n\t\tif (!this.completionPromise) {\n\t\t\tthis.completionPromise = new Promise((resolve, reject) => {\n\t\t\t\tthis.doResolve = resolve;\n\t\t\t\tthis.doReject = reject;\n\t\t\t}).then(() => {\n\t\t\t\tthis.completionPromise = null;\n\t\t\t\tthis.doResolve = null;\n\t\t\t\tif (this.task) {\n\t\t\t\t\tconst task = this.task;\n\t\t\t\t\tthis.task = null;\n\t\t\t\t\treturn task();\n\t\t\t\t}\n\t\t\t\treturn undefined;\n\t\t\t});\n\t\t}\n\n\t\tconst fn = () => {\n\t\t\tthis.deferred = null;\n\t\t\tthis.doResolve?.(null);\n\t\t};\n\n\t\tthis.deferred = delay === MicrotaskDelay ? microtaskDeferred(fn) : timeoutDeferred(delay, fn);\n\n\t\treturn this.completionPromise;\n\t}\n\n\tisTriggered(): boolean {\n\t\treturn !!this.deferred?.isTriggered();\n\t}\n\n\tcancel(): void {\n\t\tthis.cancelTimeout();\n\n\t\tif (this.completionPromise) {\n\t\t\tthis.doReject?.(new CancellationError());\n\t\t\tthis.completionPromise = null;\n\t\t}\n\t}\n\n\tprivate cancelTimeout(): void {\n\t\tthis.deferred?.dispose();\n\t\tthis.deferred = null;\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t}\n}\n\n/**\n * A helper to delay execution of a task that is being requested often, while\n * preventing accumulation of consecutive executions, while the task runs.\n *\n * The mail man is clever and waits for a certain amount of time, before going\n * out to deliver letters. While the mail man is going out, more letters arrive\n * and can only be delivered once he is back. Once he is back the mail man will\n * do one more trip to deliver the letters that have accumulated while he was out.\n */\nexport class ThrottledDelayer<T> {\n\n\tprivate delayer: Delayer<Promise<T>>;\n\tprivate throttler: Throttler;\n\n\tconstructor(defaultDelay: number) {\n\t\tthis.delayer = new Delayer(defaultDelay);\n\t\tthis.throttler = new Throttler();\n\t}\n\n\ttrigger(promiseFactory: ITask<Promise<T>>, delay?: number): Promise<T> {\n\t\treturn this.delayer.trigger(() => this.throttler.queue(promiseFactory), delay) as unknown as Promise<T>;\n\t}\n\n\tisTriggered(): boolean {\n\t\treturn this.delayer.isTriggered();\n\t}\n\n\tcancel(): void {\n\t\tthis.delayer.cancel();\n\t}\n\n\tdispose(): void {\n\t\tthis.delayer.dispose();\n\t\tthis.throttler.dispose();\n\t}\n}\n\n/**\n * A barrier that is initially closed and then becomes opened permanently.\n */\nexport class Barrier {\n\n\tprivate _isOpen: boolean;\n\tprivate _promise: Promise<boolean>;\n\tprivate _completePromise!: (v: boolean) => void;\n\n\tconstructor() {\n\t\tthis._isOpen = false;\n\t\tthis._promise = new Promise<boolean>((c, e) => {\n\t\t\tthis._completePromise = c;\n\t\t});\n\t}\n\n\tisOpen(): boolean {\n\t\treturn this._isOpen;\n\t}\n\n\topen(): void {\n\t\tthis._isOpen = true;\n\t\tthis._completePromise(true);\n\t}\n\n\twait(): Promise<boolean> {\n\t\treturn this._promise;\n\t}\n}\n\n/**\n * A barrier that is initially closed and then becomes opened permanently after a certain period of\n * time or when open is called explicitly\n */\nexport class AutoOpenBarrier extends Barrier {\n\n\tprivate readonly _timeout: any;\n\n\tconstructor(autoOpenTimeMs: number) {\n\t\tsuper();\n\t\tthis._timeout = setTimeout(() => this.open(), autoOpenTimeMs);\n\t}\n\n\toverride open(): void {\n\t\tclearTimeout(this._timeout);\n\t\tsuper.open();\n\t}\n}\n\nexport function timeout(millis: number): CancelablePromise<void>;\nexport function timeout(millis: number, token: CancellationToken): Promise<void>;\nexport function timeout(millis: number, token?: CancellationToken): CancelablePromise<void> | Promise<void> {\n\tif (!token) {\n\t\treturn createCancelablePromise(token => timeout(millis, token));\n\t}\n\n\treturn new Promise((resolve, reject) => {\n\t\tconst handle = setTimeout(() => {\n\t\t\tdisposable.dispose();\n\t\t\tresolve();\n\t\t}, millis);\n\t\tconst disposable = token.onCancellationRequested(() => {\n\t\t\tclearTimeout(handle);\n\t\t\tdisposable.dispose();\n\t\t\treject(new CancellationError());\n\t\t});\n\t});\n}\n\nexport function disposableTimeout(handler: () => void, timeout = 0): IDisposable {\n\tconst timer = setTimeout(handler, timeout);\n\treturn toDisposable(() => clearTimeout(timer));\n}\n\n/**\n * Runs the provided list of promise factories in sequential order. The returned\n * promise will complete to an array of results from each promise.\n */\n\nexport function sequence<T>(promiseFactories: ITask<Promise<T>>[]): Promise<T[]> {\n\tconst results: T[] = [];\n\tlet index = 0;\n\tconst len = promiseFactories.length;\n\n\tfunction next(): Promise<T> | null {\n\t\treturn index < len ? promiseFactories[index++]() : null;\n\t}\n\n\tfunction thenHandler(result: any): Promise<any> {\n\t\tif (result !== undefined && result !== null) {\n\t\t\tresults.push(result);\n\t\t}\n\n\t\tconst n = next();\n\t\tif (n) {\n\t\t\treturn n.then(thenHandler);\n\t\t}\n\n\t\treturn Promise.resolve(results);\n\t}\n\n\treturn Promise.resolve(null).then(thenHandler);\n}\n\nexport function first<T>(promiseFactories: ITask<Promise<T>>[], shouldStop: (t: T) => boolean = t => !!t, defaultValue: T | null = null): Promise<T | null> {\n\tlet index = 0;\n\tconst len = promiseFactories.length;\n\n\tconst loop: () => Promise<T | null> = () => {\n\t\tif (index >= len) {\n\t\t\treturn Promise.resolve(defaultValue);\n\t\t}\n\n\t\tconst factory = promiseFactories[index++];\n\t\tconst promise = Promise.resolve(factory());\n\n\t\treturn promise.then(result => {\n\t\t\tif (shouldStop(result)) {\n\t\t\t\treturn Promise.resolve(result);\n\t\t\t}\n\n\t\t\treturn loop();\n\t\t});\n\t};\n\n\treturn loop();\n}\n\n/**\n * Returns the result of the first promise that matches the \"shouldStop\",\n * running all promises in parallel. Supports cancelable promises.\n */\nexport function firstParallel<T>(promiseList: Promise<T>[], shouldStop?: (t: T) => boolean, defaultValue?: T | null): Promise<T | null>;\nexport function firstParallel<T, R extends T>(promiseList: Promise<T>[], shouldStop: (t: T) => t is R, defaultValue?: R | null): Promise<R | null>;\nexport function firstParallel<T>(promiseList: Promise<T>[], shouldStop: (t: T) => boolean = t => !!t, defaultValue: T | null = null) {\n\tif (promiseList.length === 0) {\n\t\treturn Promise.resolve(defaultValue);\n\t}\n\n\tlet todo = promiseList.length;\n\tconst finish = () => {\n\t\ttodo = -1;\n\t\tfor (const promise of promiseList) {\n\t\t\t(promise as Partial<CancelablePromise<T>>).cancel?.();\n\t\t}\n\t};\n\n\treturn new Promise<T | null>((resolve, reject) => {\n\t\tfor (const promise of promiseList) {\n\t\t\tpromise.then(result => {\n\t\t\t\tif (--todo >= 0 && shouldStop(result)) {\n\t\t\t\t\tfinish();\n\t\t\t\t\tresolve(result);\n\t\t\t\t} else if (todo === 0) {\n\t\t\t\t\tresolve(defaultValue);\n\t\t\t\t}\n\t\t\t})\n\t\t\t\t.catch(err => {\n\t\t\t\t\tif (--todo >= 0) {\n\t\t\t\t\t\tfinish();\n\t\t\t\t\t\treject(err);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t}\n\t});\n}\n\ninterface ILimitedTaskFactory<T> {\n\tfactory: ITask<Promise<T>>;\n\tc: (value: T | Promise<T>) => void;\n\te: (error?: unknown) => void;\n}\n\nexport interface ILimiter<T> {\n\n\treadonly size: number;\n\n\tqueue(factory: ITask<Promise<T>>): Promise<T>;\n}\n\n/**\n * A helper to queue N promises and run them all with a max degree of parallelism. The helper\n * ensures that at any time no more than M promises are running at the same time.\n */\nexport class Limiter<T> implements ILimiter<T>{\n\n\tprivate _size = 0;\n\tprivate runningPromises: number;\n\tprivate readonly maxDegreeOfParalellism: number;\n\tprivate readonly outstandingPromises: ILimitedTaskFactory<T>[];\n\tprivate readonly _onDrained: Emitter<void>;\n\n\tconstructor(maxDegreeOfParalellism: number) {\n\t\tthis.maxDegreeOfParalellism = maxDegreeOfParalellism;\n\t\tthis.outstandingPromises = [];\n\t\tthis.runningPromises = 0;\n\t\tthis._onDrained = new Emitter<void>();\n\t}\n\n\t/**\n\t * An event that fires when every promise in the queue\n\t * has started to execute. In other words: no work is\n\t * pending to be scheduled.\n\t *\n\t * This is NOT an event that signals when all promises\n\t * have finished though.\n\t */\n\tget onDrained(): Event<void> {\n\t\treturn this._onDrained.event;\n\t}\n\n\tget size(): number {\n\t\treturn this._size;\n\t}\n\n\tqueue(factory: ITask<Promise<T>>): Promise<T> {\n\t\tthis._size++;\n\n\t\treturn new Promise<T>((c, e) => {\n\t\t\tthis.outstandingPromises.push({ factory, c, e });\n\t\t\tthis.consume();\n\t\t});\n\t}\n\n\tprivate consume(): void {\n\t\twhile (this.outstandingPromises.length && this.runningPromises < this.maxDegreeOfParalellism) {\n\t\t\tconst iLimitedTask = this.outstandingPromises.shift()!;\n\t\t\tthis.runningPromises++;\n\n\t\t\tconst promise = iLimitedTask.factory();\n\t\t\tpromise.then(iLimitedTask.c, iLimitedTask.e);\n\t\t\tpromise.then(() => this.consumed(), () => this.consumed());\n\t\t}\n\t}\n\n\tprivate consumed(): void {\n\t\tthis._size--;\n\t\tthis.runningPromises--;\n\n\t\tif (this.outstandingPromises.length > 0) {\n\t\t\tthis.consume();\n\t\t} else {\n\t\t\tthis._onDrained.fire();\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis._onDrained.dispose();\n\t}\n}\n\n/**\n * A queue is handles one promise at a time and guarantees that at any time only one promise is executing.\n */\nexport class Queue<T> extends Limiter<T> {\n\n\tconstructor() {\n\t\tsuper(1);\n\t}\n}\n\n/**\n * Same as `Queue`, ensures that only 1 task is executed at the same time. The difference to `Queue` is that\n * there is only 1 task about to be scheduled next. As such, calling `queue` while a task is executing will\n * replace the currently queued task until it executes.\n *\n * As such, the returned promise may not be from the factory that is passed in but from the next factory that\n * is running after having called `queue`.\n */\nexport class LimitedQueue {\n\n\tprivate readonly sequentializer = new TaskSequentializer();\n\n\tprivate tasks = 0;\n\n\tqueue(factory: ITask<Promise<void>>): Promise<void> {\n\t\tif (!this.sequentializer.isRunning()) {\n\t\t\treturn this.sequentializer.run(this.tasks++, factory());\n\t\t}\n\n\t\treturn this.sequentializer.queue(() => {\n\t\t\treturn this.sequentializer.run(this.tasks++, factory());\n\t\t});\n\t}\n}\n\n/**\n * A helper to organize queues per resource. The ResourceQueue makes sure to manage queues per resource\n * by disposing them once the queue is empty.\n */\nexport class ResourceQueue implements IDisposable {\n\n\tprivate readonly queues = new Map<string, Queue<void>>();\n\n\tprivate readonly drainers = new Set<DeferredPromise<void>>();\n\n\tprivate drainListeners: DisposableMap<number> | undefined = undefined;\n\tprivate drainListenerCount = 0;\n\n\tasync whenDrained(): Promise<void> {\n\t\tif (this.isDrained()) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst promise = new DeferredPromise<void>();\n\t\tthis.drainers.add(promise);\n\n\t\treturn promise.p;\n\t}\n\n\tprivate isDrained(): boolean {\n\t\tfor (const [, queue] of this.queues) {\n\t\t\tif (queue.size > 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tqueueFor(resource: URI, extUri: IExtUri = defaultExtUri): ILimiter<void> {\n\t\tconst key = extUri.getComparisonKey(resource);\n\n\t\tlet queue = this.queues.get(key);\n\t\tif (!queue) {\n\t\t\tqueue = new Queue<void>();\n\t\t\tconst drainListenerId = this.drainListenerCount++;\n\t\t\tconst drainListener = Event.once(queue.onDrained)(() => {\n\t\t\t\tqueue?.dispose();\n\t\t\t\tthis.queues.delete(key);\n\t\t\t\tthis.onDidQueueDrain();\n\n\t\t\t\tthis.drainListeners?.deleteAndDispose(drainListenerId);\n\n\t\t\t\tif (this.drainListeners?.size === 0) {\n\t\t\t\t\tthis.drainListeners.dispose();\n\t\t\t\t\tthis.drainListeners = undefined;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (!this.drainListeners) {\n\t\t\t\tthis.drainListeners = new DisposableMap();\n\t\t\t}\n\t\t\tthis.drainListeners.set(drainListenerId, drainListener);\n\n\t\t\tthis.queues.set(key, queue);\n\t\t}\n\n\t\treturn queue;\n\t}\n\n\tprivate onDidQueueDrain(): void {\n\t\tif (!this.isDrained()) {\n\t\t\treturn; // not done yet\n\t\t}\n\n\t\tthis.releaseDrainers();\n\t}\n\n\tprivate releaseDrainers(): void {\n\t\tfor (const drainer of this.drainers) {\n\t\t\tdrainer.complete();\n\t\t}\n\n\t\tthis.drainers.clear();\n\t}\n\n\tdispose(): void {\n\t\tfor (const [, queue] of this.queues) {\n\t\t\tqueue.dispose();\n\t\t}\n\n\t\tthis.queues.clear();\n\n\t\t// Even though we might still have pending\n\t\t// tasks queued, after the queues have been\n\t\t// disposed, we can no longer track them, so\n\t\t// we release drainers to prevent hanging\n\t\t// promises when the resource queue is being\n\t\t// disposed.\n\t\tthis.releaseDrainers();\n\n\t\tthis.drainListeners?.dispose();\n\t}\n}\n\nexport class TimeoutTimer implements IDisposable {\n\tprivate _token: any;\n\n\tconstructor();\n\tconstructor(runner: () => void, timeout: number);\n\tconstructor(runner?: () => void, timeout?: number) {\n\t\tthis._token = -1;\n\n\t\tif (typeof runner === 'function' && typeof timeout === 'number') {\n\t\t\tthis.setIfNotSet(runner, timeout);\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t}\n\n\tcancel(): void {\n\t\tif (this._token !== -1) {\n\t\t\tclearTimeout(this._token);\n\t\t\tthis._token = -1;\n\t\t}\n\t}\n\n\tcancelAndSet(runner: () => void, timeout: number): void {\n\t\tthis.cancel();\n\t\tthis._token = setTimeout(() => {\n\t\t\tthis._token = -1;\n\t\t\trunner();\n\t\t}, timeout);\n\t}\n\n\tsetIfNotSet(runner: () => void, timeout: number): void {\n\t\tif (this._token !== -1) {\n\t\t\t// timer is already set\n\t\t\treturn;\n\t\t}\n\t\tthis._token = setTimeout(() => {\n\t\t\tthis._token = -1;\n\t\t\trunner();\n\t\t}, timeout);\n\t}\n}\n\nexport class IntervalTimer implements IDisposable {\n\n\tprivate _token: any;\n\n\tconstructor() {\n\t\tthis._token = -1;\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t}\n\n\tcancel(): void {\n\t\tif (this._token !== -1) {\n\t\t\tclearInterval(this._token);\n\t\t\tthis._token = -1;\n\t\t}\n\t}\n\n\tcancelAndSet(runner: () => void, interval: number): void {\n\t\tthis.cancel();\n\t\tthis._token = setInterval(() => {\n\t\t\trunner();\n\t\t}, interval);\n\t}\n}\n\nexport class RunOnceScheduler implements IDisposable {\n\n\tprotected runner: ((...args: unknown[]) => void) | null;\n\n\tprivate timeoutToken: any;\n\tprivate timeout: number;\n\tprivate timeoutHandler: () => void;\n\n\tconstructor(runner: (...args: any[]) => void, delay: number) {\n\t\tthis.timeoutToken = -1;\n\t\tthis.runner = runner;\n\t\tthis.timeout = delay;\n\t\tthis.timeoutHandler = this.onTimeout.bind(this);\n\t}\n\n\t/**\n\t * Dispose RunOnceScheduler\n\t */\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tthis.runner = null;\n\t}\n\n\t/**\n\t * Cancel current scheduled runner (if any).\n\t */\n\tcancel(): void {\n\t\tif (this.isScheduled()) {\n\t\t\tclearTimeout(this.timeoutToken);\n\t\t\tthis.timeoutToken = -1;\n\t\t}\n\t}\n\n\t/**\n\t * Cancel previous runner (if any) & schedule a new runner.\n\t */\n\tschedule(delay = this.timeout): void {\n\t\tthis.cancel();\n\t\tthis.timeoutToken = setTimeout(this.timeoutHandler, delay);\n\t}\n\n\tget delay(): number {\n\t\treturn this.timeout;\n\t}\n\n\tset delay(value: number) {\n\t\tthis.timeout = value;\n\t}\n\n\t/**\n\t * Returns true if scheduled.\n\t */\n\tisScheduled(): boolean {\n\t\treturn this.timeoutToken !== -1;\n\t}\n\n\tflush(): void {\n\t\tif (this.isScheduled()) {\n\t\t\tthis.cancel();\n\t\t\tthis.doRun();\n\t\t}\n\t}\n\n\tprivate onTimeout() {\n\t\tthis.timeoutToken = -1;\n\t\tif (this.runner) {\n\t\t\tthis.doRun();\n\t\t}\n\t}\n\n\tprotected doRun(): void {\n\t\tthis.runner?.();\n\t}\n}\n\n/**\n * Same as `RunOnceScheduler`, but doesn't count the time spent in sleep mode.\n * > **NOTE**: Only offers 1s resolution.\n *\n * When calling `setTimeout` with 3hrs, and putting the computer immediately to sleep\n * for 8hrs, `setTimeout` will fire **as soon as the computer wakes from sleep**. But\n * this scheduler will execute 3hrs **after waking the computer from sleep**.\n */\nexport class ProcessTimeRunOnceScheduler {\n\n\tprivate runner: (() => void) | null;\n\tprivate timeout: number;\n\n\tprivate counter: number;\n\tprivate intervalToken: any;\n\tprivate intervalHandler: () => void;\n\n\tconstructor(runner: () => void, delay: number) {\n\t\tif (delay % 1000 !== 0) {\n\t\t\tconsole.warn(`ProcessTimeRunOnceScheduler resolution is 1s, ${delay}ms is not a multiple of 1000ms.`);\n\t\t}\n\t\tthis.runner = runner;\n\t\tthis.timeout = delay;\n\t\tthis.counter = 0;\n\t\tthis.intervalToken = -1;\n\t\tthis.intervalHandler = this.onInterval.bind(this);\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tthis.runner = null;\n\t}\n\n\tcancel(): void {\n\t\tif (this.isScheduled()) {\n\t\t\tclearInterval(this.intervalToken);\n\t\t\tthis.intervalToken = -1;\n\t\t}\n\t}\n\n\t/**\n\t * Cancel previous runner (if any) & schedule a new runner.\n\t */\n\tschedule(delay = this.timeout): void {\n\t\tif (delay % 1000 !== 0) {\n\t\t\tconsole.warn(`ProcessTimeRunOnceScheduler resolution is 1s, ${delay}ms is not a multiple of 1000ms.`);\n\t\t}\n\t\tthis.cancel();\n\t\tthis.counter = Math.ceil(delay / 1000);\n\t\tthis.intervalToken = setInterval(this.intervalHandler, 1000);\n\t}\n\n\t/**\n\t * Returns true if scheduled.\n\t */\n\tisScheduled(): boolean {\n\t\treturn this.intervalToken !== -1;\n\t}\n\n\tprivate onInterval() {\n\t\tthis.counter--;\n\t\tif (this.counter > 0) {\n\t\t\t// still need to wait\n\t\t\treturn;\n\t\t}\n\n\t\t// time elapsed\n\t\tclearInterval(this.intervalToken);\n\t\tthis.intervalToken = -1;\n\t\tthis.runner?.();\n\t}\n}\n\nexport class RunOnceWorker<T> extends RunOnceScheduler {\n\n\tprivate units: T[] = [];\n\n\tconstructor(runner: (units: T[]) => void, timeout: number) {\n\t\tsuper(runner, timeout);\n\t}\n\n\twork(unit: T): void {\n\t\tthis.units.push(unit);\n\n\t\tif (!this.isScheduled()) {\n\t\t\tthis.schedule();\n\t\t}\n\t}\n\n\tprotected override doRun(): void {\n\t\tconst units = this.units;\n\t\tthis.units = [];\n\n\t\tthis.runner?.(units);\n\t}\n\n\toverride dispose(): void {\n\t\tthis.units = [];\n\n\t\tsuper.dispose();\n\t}\n}\n\nexport interface IThrottledWorkerOptions {\n\n\t/**\n\t * maximum of units the worker will pass onto handler at once\n\t */\n\tmaxWorkChunkSize: number;\n\n\t/**\n\t * maximum of units the worker will keep in memory for processing\n\t */\n\tmaxBufferedWork: number | undefined;\n\n\t/**\n\t * delay before processing the next round of chunks when chunk size exceeds limits\n\t */\n\tthrottleDelay: number;\n}\n\n/**\n * The `ThrottledWorker` will accept units of work `T`\n * to handle. The contract is:\n * * there is a maximum of units the worker can handle at once (via `maxWorkChunkSize`)\n * * there is a maximum of units the worker will keep in memory for processing (via `maxBufferedWork`)\n * * after having handled `maxWorkChunkSize` units, the worker needs to rest (via `throttleDelay`)\n */\nexport class ThrottledWorker<T> extends Disposable {\n\n\tprivate readonly pendingWork: T[] = [];\n\n\tprivate readonly throttler = this._register(new MutableDisposable<RunOnceScheduler>());\n\tprivate disposed = false;\n\n\tconstructor(\n\t\tprivate options: IThrottledWorkerOptions,\n\t\tprivate readonly handler: (units: T[]) => void\n\t) {\n\t\tsuper();\n\t}\n\n\t/**\n\t * The number of work units that are pending to be processed.\n\t */\n\tget pending(): number { return this.pendingWork.length; }\n\n\t/**\n\t * Add units to be worked on. Use `pending` to figure out\n\t * how many units are not yet processed after this method\n\t * was called.\n\t *\n\t * @returns whether the work was accepted or not. If the\n\t * worker is disposed, it will not accept any more work.\n\t * If the number of pending units would become larger\n\t * than `maxPendingWork`, more work will also not be accepted.\n\t */\n\twork(units: readonly T[]): boolean {\n\t\tif (this.disposed) {\n\t\t\treturn false; // work not accepted: disposed\n\t\t}\n\n\t\t// Check for reaching maximum of pending work\n\t\tif (typeof this.options.maxBufferedWork === 'number') {\n\n\t\t\t// Throttled: simple check if pending + units exceeds max pending\n\t\t\tif (this.throttler.value) {\n\t\t\t\tif (this.pending + units.length > this.options.maxBufferedWork) {\n\t\t\t\t\treturn false; // work not accepted: too much pending work\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Unthrottled: same as throttled, but account for max chunk getting\n\t\t\t// worked on directly without being pending\n\t\t\telse {\n\t\t\t\tif (this.pending + units.length - this.options.maxWorkChunkSize > this.options.maxBufferedWork) {\n\t\t\t\t\treturn false; // work not accepted: too much pending work\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add to pending units first\n\t\tfor (const unit of units) {\n\t\t\tthis.pendingWork.push(unit);\n\t\t}\n\n\t\t// If not throttled, start working directly\n\t\t// Otherwise, when the throttle delay has\n\t\t// past, pending work will be worked again.\n\t\tif (!this.throttler.value) {\n\t\t\tthis.doWork();\n\t\t}\n\n\t\treturn true; // work accepted\n\t}\n\n\tprivate doWork(): void {\n\n\t\t// Extract chunk to handle and handle it\n\t\tthis.handler(this.pendingWork.splice(0, this.options.maxWorkChunkSize));\n\n\t\t// If we have remaining work, schedule it after a delay\n\t\tif (this.pendingWork.length > 0) {\n\t\t\tthis.throttler.value = new RunOnceScheduler(() => {\n\t\t\t\tthis.throttler.clear();\n\n\t\t\t\tthis.doWork();\n\t\t\t}, this.options.throttleDelay);\n\t\t\tthis.throttler.value.schedule();\n\t\t}\n\t}\n\n\toverride dispose(): void {\n\t\tsuper.dispose();\n\n\t\tthis.disposed = true;\n\t}\n}\n\n//#region -- run on idle tricks ------------\n\nexport interface IdleDeadline {\n\treadonly didTimeout: boolean;\n\ttimeRemaining(): number;\n}\n\n/**\n * Execute the callback the next time the browser is idle, returning an\n * {@link IDisposable} that will cancel the callback when disposed. This wraps\n * [requestIdleCallback] so it will fallback to [setTimeout] if the environment\n * doesn't support it.\n *\n * @param callback The callback to run when idle, this includes an\n * [IdleDeadline] that provides the time alloted for the idle callback by the\n * browser. Not respecting this deadline will result in a degraded user\n * experience.\n * @param timeout A timeout at which point to queue no longer wait for an idle\n * callback but queue it on the regular event loop (like setTimeout). Typically\n * this should not be used.\n *\n * [IdleDeadline]: https://developer.mozilla.org/en-US/docs/Web/API/IdleDeadline\n * [requestIdleCallback]: https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback\n * [setTimeout]: https://developer.mozilla.org/en-US/docs/Web/API/Window/setTimeout\n */\nexport let runWhenIdle: (callback: (idle: IdleDeadline) => void, timeout?: number) => IDisposable;\n\ndeclare function requestIdleCallback(callback: (args: IdleDeadline) => void, options?: { timeout: number }): number;\ndeclare function cancelIdleCallback(handle: number): void;\n\n(function () {\n\tif (typeof requestIdleCallback !== 'function' || typeof cancelIdleCallback !== 'function') {\n\t\trunWhenIdle = (runner) => {\n\t\t\tsetTimeout0(() => {\n\t\t\t\tif (disposed) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst end = Date.now() + 15; // one frame at 64fps\n\t\t\t\trunner(Object.freeze({\n\t\t\t\t\tdidTimeout: true,\n\t\t\t\t\ttimeRemaining() {\n\t\t\t\t\t\treturn Math.max(0, end - Date.now());\n\t\t\t\t\t}\n\t\t\t\t}));\n\t\t\t});\n\t\t\tlet disposed = false;\n\t\t\treturn {\n\t\t\t\tdispose() {\n\t\t\t\t\tif (disposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tdisposed = true;\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t} else {\n\t\trunWhenIdle = (runner, timeout?) => {\n\t\t\tconst handle: number = requestIdleCallback(runner, typeof timeout === 'number' ? { timeout } : undefined);\n\t\t\tlet disposed = false;\n\t\t\treturn {\n\t\t\t\tdispose() {\n\t\t\t\t\tif (disposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tdisposed = true;\n\t\t\t\t\tcancelIdleCallback(handle);\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t}\n})();\n\n/**\n * An implementation of the \"idle-until-urgent\"-strategy as introduced\n * here: https://philipwalton.com/articles/idle-until-urgent/\n */\nexport class IdleValue<T> {\n\n\tprivate readonly _executor: () => void;\n\tprivate readonly _handle: IDisposable;\n\n\tprivate _didRun: boolean = false;\n\tprivate _value?: T;\n\tprivate _error: unknown;\n\n\tconstructor(executor: () => T) {\n\t\tthis._executor = () => {\n\t\t\ttry {\n\t\t\t\tthis._value = executor();\n\t\t\t} catch (err) {\n\t\t\t\tthis._error = err;\n\t\t\t} finally {\n\t\t\t\tthis._didRun = true;\n\t\t\t}\n\t\t};\n\t\tthis._handle = runWhenIdle(() => this._executor());\n\t}\n\n\tdispose(): void {\n\t\tthis._handle.dispose();\n\t}\n\n\tget value(): T {\n\t\tif (!this._didRun) {\n\t\t\tthis._handle.dispose();\n\t\t\tthis._executor();\n\t\t}\n\t\tif (this._error) {\n\t\t\tthrow this._error;\n\t\t}\n\t\treturn this._value!;\n\t}\n\n\tget isInitialized(): boolean {\n\t\treturn this._didRun;\n\t}\n}\n\n//#endregion\n\nexport async function retry<T>(task: ITask<Promise<T>>, delay: number, retries: number): Promise<T> {\n\tlet lastError: Error | undefined;\n\n\tfor (let i = 0; i < retries; i++) {\n\t\ttry {\n\t\t\treturn await task();\n\t\t} catch (error) {\n\t\t\tlastError = error;\n\n\t\t\tawait timeout(delay);\n\t\t}\n\t}\n\n\tthrow lastError;\n}\n\n//#region Task Sequentializer\n\ninterface IRunningTask {\n\treadonly taskId: number;\n\treadonly cancel: () => void;\n\treadonly promise: Promise<void>;\n}\n\ninterface IQueuedTask {\n\treadonly promise: Promise<void>;\n\treadonly promiseResolve: () => void;\n\treadonly promiseReject: (error: Error) => void;\n\trun: ITask<Promise<void>>;\n}\n\nexport interface ITaskSequentializerWithRunningTask {\n\treadonly running: Promise<void>;\n}\n\nexport interface ITaskSequentializerWithQueuedTask {\n\treadonly queued: IQueuedTask;\n}\n\n/**\n * @deprecated use `LimitedQueue` instead for an easier to use API\n */\nexport class TaskSequentializer {\n\n\tprivate _running?: IRunningTask;\n\tprivate _queued?: IQueuedTask;\n\n\tisRunning(taskId?: number): this is ITaskSequentializerWithRunningTask {\n\t\tif (typeof taskId === 'number') {\n\t\t\treturn this._running?.taskId === taskId;\n\t\t}\n\n\t\treturn !!this._running;\n\t}\n\n\tget running(): Promise<void> | undefined {\n\t\treturn this._running?.promise;\n\t}\n\n\tcancelRunning(): void {\n\t\tthis._running?.cancel();\n\t}\n\n\trun(taskId: number, promise: Promise<void>, onCancel?: () => void,): Promise<void> {\n\t\tthis._running = { taskId, cancel: () => onCancel?.(), promise };\n\n\t\tpromise.then(() => this.doneRunning(taskId), () => this.doneRunning(taskId));\n\n\t\treturn promise;\n\t}\n\n\tprivate doneRunning(taskId: number): void {\n\t\tif (this._running && taskId === this._running.taskId) {\n\n\t\t\t// only set running to done if the promise finished that is associated with that taskId\n\t\t\tthis._running = undefined;\n\n\t\t\t// schedule the queued task now that we are free if we have any\n\t\t\tthis.runQueued();\n\t\t}\n\t}\n\n\tprivate runQueued(): void {\n\t\tif (this._queued) {\n\t\t\tconst queued = this._queued;\n\t\t\tthis._queued = undefined;\n\n\t\t\t// Run queued task and complete on the associated promise\n\t\t\tqueued.run().then(queued.promiseResolve, queued.promiseReject);\n\t\t}\n\t}\n\n\t/**\n\t * Note: the promise to schedule as next run MUST itself call `run`.\n\t *       Otherwise, this sequentializer will report `false` for `isRunning`\n\t *       even when this task is running. Missing this detail means that\n\t *       suddenly multiple tasks will run in parallel.\n\t */\n\tqueue(run: ITask<Promise<void>>): Promise<void> {\n\n\t\t// this is our first queued task, so we create associated promise with it\n\t\t// so that we can return a promise that completes when the task has\n\t\t// completed.\n\t\tif (!this._queued) {\n\t\t\tlet promiseResolve: () => void;\n\t\t\tlet promiseReject: (error: Error) => void;\n\t\t\tconst promise = new Promise<void>((resolve, reject) => {\n\t\t\t\tpromiseResolve = resolve;\n\t\t\t\tpromiseReject = reject;\n\t\t\t});\n\n\t\t\tthis._queued = {\n\t\t\t\trun,\n\t\t\t\tpromise,\n\t\t\t\tpromiseResolve: promiseResolve!,\n\t\t\t\tpromiseReject: promiseReject!\n\t\t\t};\n\t\t}\n\n\t\t// we have a previous queued task, just overwrite it\n\t\telse {\n\t\t\tthis._queued.run = run;\n\t\t}\n\n\t\treturn this._queued.promise;\n\t}\n\n\thasQueued(): this is ITaskSequentializerWithQueuedTask {\n\t\treturn !!this._queued;\n\t}\n\n\tasync join(): Promise<void> {\n\t\treturn this._queued?.promise ?? this._running?.promise;\n\t}\n}\n\n//#endregion\n\n//#region\n\n/**\n * The `IntervalCounter` allows to count the number\n * of calls to `increment()` over a duration of\n * `interval`. This utility can be used to conditionally\n * throttle a frequent task when a certain threshold\n * is reached.\n */\nexport class IntervalCounter {\n\n\tprivate lastIncrementTime = 0;\n\n\tprivate value = 0;\n\n\tconstructor(private readonly interval: number, private readonly nowFn = () => Date.now()) { }\n\n\tincrement(): number {\n\t\tconst now = this.nowFn();\n\n\t\t// We are outside of the range of `interval` and as such\n\t\t// start counting from 0 and remember the time\n\t\tif (now - this.lastIncrementTime > this.interval) {\n\t\t\tthis.lastIncrementTime = now;\n\t\t\tthis.value = 0;\n\t\t}\n\n\t\tthis.value++;\n\n\t\treturn this.value;\n\t}\n}\n\n//#endregion\n\n//#region\n\nexport type ValueCallback<T = unknown> = (value: T | Promise<T>) => void;\n\nconst enum DeferredOutcome {\n\tResolved,\n\tRejected\n}\n\n/**\n * Creates a promise whose resolution or rejection can be controlled imperatively.\n */\nexport class DeferredPromise<T> {\n\n\tprivate completeCallback!: ValueCallback<T>;\n\tprivate errorCallback!: (err: unknown) => void;\n\tprivate outcome?: { outcome: DeferredOutcome.Rejected; value: any } | { outcome: DeferredOutcome.Resolved; value: T };\n\n\tpublic get isRejected() {\n\t\treturn this.outcome?.outcome === DeferredOutcome.Rejected;\n\t}\n\n\tpublic get isResolved() {\n\t\treturn this.outcome?.outcome === DeferredOutcome.Resolved;\n\t}\n\n\tpublic get isSettled() {\n\t\treturn !!this.outcome;\n\t}\n\n\tpublic get value() {\n\t\treturn this.outcome?.outcome === DeferredOutcome.Resolved ? this.outcome?.value : undefined;\n\t}\n\n\tpublic readonly p: Promise<T>;\n\n\tconstructor() {\n\t\tthis.p = new Promise<T>((c, e) => {\n\t\t\tthis.completeCallback = c;\n\t\t\tthis.errorCallback = e;\n\t\t});\n\t}\n\n\tpublic complete(value: T) {\n\t\treturn new Promise<void>(resolve => {\n\t\t\tthis.completeCallback(value);\n\t\t\tthis.outcome = { outcome: DeferredOutcome.Resolved, value };\n\t\t\tresolve();\n\t\t});\n\t}\n\n\tpublic error(err: unknown) {\n\t\treturn new Promise<void>(resolve => {\n\t\t\tthis.errorCallback(err);\n\t\t\tthis.outcome = { outcome: DeferredOutcome.Rejected, value: err };\n\t\t\tresolve();\n\t\t});\n\t}\n\n\tpublic cancel() {\n\t\treturn this.error(new CancellationError());\n\t}\n}\n\n//#endregion\n\n//#region Promises\n\nexport namespace Promises {\n\n\t/**\n\t * A drop-in replacement for `Promise.all` with the only difference\n\t * that the method awaits every promise to either fulfill or reject.\n\t *\n\t * Similar to `Promise.all`, only the first error will be returned\n\t * if any.\n\t */\n\texport async function settled<T>(promises: Promise<T>[]): Promise<T[]> {\n\t\tlet firstError: Error | undefined = undefined;\n\n\t\tconst result = await Promise.all(promises.map(promise => promise.then(value => value, error => {\n\t\t\tif (!firstError) {\n\t\t\t\tfirstError = error;\n\t\t\t}\n\n\t\t\treturn undefined; // do not rethrow so that other promises can settle\n\t\t})));\n\n\t\tif (typeof firstError !== 'undefined') {\n\t\t\tthrow firstError;\n\t\t}\n\n\t\treturn result as unknown as T[]; // cast is needed and protected by the `throw` above\n\t}\n\n\t/**\n\t * A helper to create a new `Promise<T>` with a body that is a promise\n\t * itself. By default, an error that raises from the async body will\n\t * end up as a unhandled rejection, so this utility properly awaits the\n\t * body and rejects the promise as a normal promise does without async\n\t * body.\n\t *\n\t * This method should only be used in rare cases where otherwise `async`\n\t * cannot be used (e.g. when callbacks are involved that require this).\n\t */\n\texport function withAsyncBody<T, E = Error>(bodyFn: (resolve: (value: T) => unknown, reject: (error: E) => unknown) => Promise<unknown>): Promise<T> {\n\t\t// eslint-disable-next-line no-async-promise-executor\n\t\treturn new Promise<T>(async (resolve, reject) => {\n\t\t\ttry {\n\t\t\t\tawait bodyFn(resolve, reject);\n\t\t\t} catch (error) {\n\t\t\t\treject(error);\n\t\t\t}\n\t\t});\n\t}\n}\n\n//#endregion\n\n//#region\n\nconst enum AsyncIterableSourceState {\n\tInitial,\n\tDoneOK,\n\tDoneError,\n}\n\n/**\n * An object that allows to emit async values asynchronously or bring the iterable to an error state using `reject()`.\n * This emitter is valid only for the duration of the executor (until the promise returned by the executor settles).\n */\nexport interface AsyncIterableEmitter<T> {\n\t/**\n\t * The value will be appended at the end.\n\t *\n\t * **NOTE** If `reject()` has already been called, this method has no effect.\n\t */\n\temitOne(value: T): void;\n\t/**\n\t * The values will be appended at the end.\n\t *\n\t * **NOTE** If `reject()` has already been called, this method has no effect.\n\t */\n\temitMany(values: T[]): void;\n\t/**\n\t * Writing an error will permanently invalidate this iterable.\n\t * The current users will receive an error thrown, as will all future users.\n\t *\n\t * **NOTE** If `reject()` have already been called, this method has no effect.\n\t */\n\treject(error: Error): void;\n}\n\n/**\n * An executor for the `AsyncIterableObject` that has access to an emitter.\n */\nexport interface AsyncIterableExecutor<T> {\n\t/**\n\t * @param emitter An object that allows to emit async values valid only for the duration of the executor.\n\t */\n\t(emitter: AsyncIterableEmitter<T>): void | Promise<void>;\n}\n\n/**\n * A rich implementation for an `AsyncIterable<T>`.\n */\nexport class AsyncIterableObject<T> implements AsyncIterable<T> {\n\n\tpublic static fromArray<T>(items: T[]): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>((writer) => {\n\t\t\twriter.emitMany(items);\n\t\t});\n\t}\n\n\tpublic static fromPromise<T>(promise: Promise<T[]>): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>(async (emitter) => {\n\t\t\temitter.emitMany(await promise);\n\t\t});\n\t}\n\n\tpublic static fromPromises<T>(promises: Promise<T>[]): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>(async (emitter) => {\n\t\t\tawait Promise.all(promises.map(async (p) => emitter.emitOne(await p)));\n\t\t});\n\t}\n\n\tpublic static merge<T>(iterables: AsyncIterable<T>[]): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject(async (emitter) => {\n\t\t\tawait Promise.all(iterables.map(async (iterable) => {\n\t\t\t\tfor await (const item of iterable) {\n\t\t\t\t\temitter.emitOne(item);\n\t\t\t\t}\n\t\t\t}));\n\t\t});\n\t}\n\n\tpublic static EMPTY = AsyncIterableObject.fromArray<any>([]);\n\n\tprivate _state: AsyncIterableSourceState;\n\tprivate _results: T[];\n\tprivate _error: Error | null;\n\tprivate readonly _onStateChanged: Emitter<void>;\n\n\tconstructor(executor: AsyncIterableExecutor<T>) {\n\t\tthis._state = AsyncIterableSourceState.Initial;\n\t\tthis._results = [];\n\t\tthis._error = null;\n\t\tthis._onStateChanged = new Emitter<void>();\n\n\t\tqueueMicrotask(async () => {\n\t\t\tconst writer: AsyncIterableEmitter<T> = {\n\t\t\t\temitOne: (item) => this.emitOne(item),\n\t\t\t\temitMany: (items) => this.emitMany(items),\n\t\t\t\treject: (error) => this.reject(error)\n\t\t\t};\n\t\t\ttry {\n\t\t\t\tawait Promise.resolve(executor(writer));\n\t\t\t\tthis.resolve();\n\t\t\t} catch (err) {\n\t\t\t\tthis.reject(err);\n\t\t\t} finally {\n\t\t\t\twriter.emitOne = undefined!;\n\t\t\t\twriter.emitMany = undefined!;\n\t\t\t\twriter.reject = undefined!;\n\t\t\t}\n\t\t});\n\t}\n\n\t[Symbol.asyncIterator](): AsyncIterator<T, undefined, undefined> {\n\t\tlet i = 0;\n\t\treturn {\n\t\t\tnext: async () => {\n\t\t\t\tdo {\n\t\t\t\t\tif (this._state === AsyncIterableSourceState.DoneError) {\n\t\t\t\t\t\tthrow this._error;\n\t\t\t\t\t}\n\t\t\t\t\tif (i < this._results.length) {\n\t\t\t\t\t\treturn { done: false, value: this._results[i++] };\n\t\t\t\t\t}\n\t\t\t\t\tif (this._state === AsyncIterableSourceState.DoneOK) {\n\t\t\t\t\t\treturn { done: true, value: undefined };\n\t\t\t\t\t}\n\t\t\t\t\tawait Event.toPromise(this._onStateChanged.event);\n\t\t\t\t} while (true);\n\t\t\t}\n\t\t};\n\t}\n\n\tpublic static map<T, R>(iterable: AsyncIterable<T>, mapFn: (item: T) => R): AsyncIterableObject<R> {\n\t\treturn new AsyncIterableObject<R>(async (emitter) => {\n\t\t\tfor await (const item of iterable) {\n\t\t\t\temitter.emitOne(mapFn(item));\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic map<R>(mapFn: (item: T) => R): AsyncIterableObject<R> {\n\t\treturn AsyncIterableObject.map(this, mapFn);\n\t}\n\n\tpublic static filter<T>(iterable: AsyncIterable<T>, filterFn: (item: T) => boolean): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>(async (emitter) => {\n\t\t\tfor await (const item of iterable) {\n\t\t\t\tif (filterFn(item)) {\n\t\t\t\t\temitter.emitOne(item);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic filter(filterFn: (item: T) => boolean): AsyncIterableObject<T> {\n\t\treturn AsyncIterableObject.filter(this, filterFn);\n\t}\n\n\tpublic static coalesce<T>(iterable: AsyncIterable<T | undefined | null>): AsyncIterableObject<T> {\n\t\treturn <AsyncIterableObject<T>>AsyncIterableObject.filter(iterable, item => !!item);\n\t}\n\n\tpublic coalesce(): AsyncIterableObject<NonNullable<T>> {\n\t\treturn AsyncIterableObject.coalesce(this) as AsyncIterableObject<NonNullable<T>>;\n\t}\n\n\tpublic static async toPromise<T>(iterable: AsyncIterable<T>): Promise<T[]> {\n\t\tconst result: T[] = [];\n\t\tfor await (const item of iterable) {\n\t\t\tresult.push(item);\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic toPromise(): Promise<T[]> {\n\t\treturn AsyncIterableObject.toPromise(this);\n\t}\n\n\t/**\n\t * The value will be appended at the end.\n\t *\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate emitOne(value: T): void {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\t// it is important to add new values at the end,\n\t\t// as we may have iterators already running on the array\n\t\tthis._results.push(value);\n\t\tthis._onStateChanged.fire();\n\t}\n\n\t/**\n\t * The values will be appended at the end.\n\t *\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate emitMany(values: T[]): void {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\t// it is important to add new values at the end,\n\t\t// as we may have iterators already running on the array\n\t\tthis._results = this._results.concat(values);\n\t\tthis._onStateChanged.fire();\n\t}\n\n\t/**\n\t * Calling `resolve()` will mark the result array as complete.\n\t *\n\t * **NOTE** `resolve()` must be called, otherwise all consumers of this iterable will hang indefinitely, similar to a non-resolved promise.\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate resolve(): void {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\tthis._state = AsyncIterableSourceState.DoneOK;\n\t\tthis._onStateChanged.fire();\n\t}\n\n\t/**\n\t * Writing an error will permanently invalidate this iterable.\n\t * The current users will receive an error thrown, as will all future users.\n\t *\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate reject(error: Error) {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\tthis._state = AsyncIterableSourceState.DoneError;\n\t\tthis._error = error;\n\t\tthis._onStateChanged.fire();\n\t}\n}\n\nexport class CancelableAsyncIterableObject<T> extends AsyncIterableObject<T> {\n\tconstructor(\n\t\tprivate readonly _source: CancellationTokenSource,\n\t\texecutor: AsyncIterableExecutor<T>\n\t) {\n\t\tsuper(executor);\n\t}\n\n\tcancel(): void {\n\t\tthis._source.cancel();\n\t}\n}\n\nexport function createCancelableAsyncIterable<T>(callback: (token: CancellationToken) => AsyncIterable<T>): CancelableAsyncIterableObject<T> {\n\tconst source = new CancellationTokenSource();\n\tconst innerIterable = callback(source.token);\n\n\treturn new CancelableAsyncIterableObject<T>(source, async (emitter) => {\n\t\tconst subscription = source.token.onCancellationRequested(() => {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\temitter.reject(new CancellationError());\n\t\t});\n\t\ttry {\n\t\t\tfor await (const item of innerIterable) {\n\t\t\t\tif (source.token.isCancellationRequested) {\n\t\t\t\t\t// canceled in the meantime\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\temitter.emitOne(item);\n\t\t\t}\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t} catch (err) {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\temitter.reject(err);\n\t\t}\n\t});\n}\n\n//#endregion\n"]}