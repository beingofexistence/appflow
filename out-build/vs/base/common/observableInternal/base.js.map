{"version":3,"sources":["file:///workspace/appflow/src/vs/base/common/observableInternal/base.ts"],"names":[],"mappings":"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","file":"base.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IDisposable } from 'vs/base/common/lifecycle';\nimport type { derivedOpts } from 'vs/base/common/observableInternal/derived';\nimport { getLogger } from 'vs/base/common/observableInternal/logging';\n\n/**\n * Represents an observable value.\n *\n * @template T The type of the value.\n * @template TChange The type of delta information (usually `void` and only used in advanced scenarios).\n */\nexport interface IObservable<T, TChange = unknown> {\n\t/**\n\t * Returns the current value.\n\t *\n\t * Calls {@link IObserver.handleChange} if the observable notices that the value changed.\n\t * Must not be called from {@link IObserver.handleChange}!\n\t */\n\tget(): T;\n\n\t/**\n\t * Forces the observable to check for and report changes.\n\t *\n\t * Has the same effect as calling {@link IObservable.get}, but does not force the observable\n\t * to actually construct the value, e.g. if change deltas are used.\n\t * Calls {@link IObserver.handleChange} if the observable notices that the value changed.\n\t * Must not be called from {@link IObserver.handleChange}!\n\t */\n\treportChanges(): void;\n\n\t/**\n\t * Adds the observer to the set of subscribed observers.\n\t * This method is idempotent.\n\t */\n\taddObserver(observer: IObserver): void;\n\n\t/**\n\t * Removes the observer from the set of subscribed observers.\n\t * This method is idempotent.\n\t */\n\tremoveObserver(observer: IObserver): void;\n\n\t/**\n\t * Reads the current value and subscribes to this observable.\n\t *\n\t * Just calls {@link IReader.readObservable} if a reader is given, otherwise {@link IObservable.get}\n\t * (see {@link ConvenientObservable.read}).\n\t */\n\tread(reader: IReader | undefined): T;\n\n\t/**\n\t * Creates a derived observable that depends on this observable.\n\t * Use the reader to read other observables\n\t * (see {@link ConvenientObservable.map}).\n\t */\n\tmap<TNew>(fn: (value: T, reader: IReader) => TNew): IObservable<TNew>;\n\tmap<TNew>(owner: object, fn: (value: T, reader: IReader) => TNew): IObservable<TNew>;\n\n\t/**\n\t * A human-readable name for debugging purposes.\n\t */\n\treadonly debugName: string;\n\n\t/**\n\t * This property captures the type of the change object. Do not use it at runtime!\n\t */\n\treadonly TChange: TChange;\n}\n\nexport interface IReader {\n\t/**\n\t * Reads the value of an observable and subscribes to it.\n\t */\n\treadObservable<T>(observable: IObservable<T, any>): T;\n}\n\n/**\n * Represents an observer that can be subscribed to an observable.\n *\n * If an observer is subscribed to an observable and that observable didn't signal\n * a change through one of the observer methods, the observer can assume that the\n * observable didn't change.\n * If an observable reported a possible change, {@link IObservable.reportChanges} forces\n * the observable to report an actual change if there was one.\n */\nexport interface IObserver {\n\t/**\n\t * Signals that the given observable might have changed and a transaction potentially modifying that observable started.\n\t * Before the given observable can call this method again, is must call {@link IObserver.endUpdate}.\n\t *\n\t * The method {@link IObservable.reportChanges} can be used to force the observable to report the changes.\n\t */\n\tbeginUpdate<T>(observable: IObservable<T>): void;\n\n\t/**\n\t * Signals that the transaction that potentially modified the given observable ended.\n\t */\n\tendUpdate<T>(observable: IObservable<T>): void;\n\n\t/**\n\t * Signals that the given observable might have changed.\n\t * The method {@link IObservable.reportChanges} can be used to force the observable to report the changes.\n\t *\n\t * Implementations must not call into other observables, as they might not have received this event yet!\n\t * The change should be processed lazily or in {@link IObserver.endUpdate}.\n\t */\n\thandlePossibleChange<T>(observable: IObservable<T>): void;\n\n\t/**\n\t * Signals that the given observable changed.\n\t *\n\t * Implementations must not call into other observables, as they might not have received this event yet!\n\t * The change should be processed lazily or in {@link IObserver.endUpdate}.\n\t */\n\thandleChange<T, TChange>(observable: IObservable<T, TChange>, change: TChange): void;\n}\n\nexport interface ISettable<T, TChange = void> {\n\t/**\n\t * Sets the value of the observable.\n\t * Use a transaction to batch multiple changes (with a transaction, observers only react at the end of the transaction).\n\t */\n\tset(value: T, transaction: ITransaction | undefined, change: TChange): void;\n}\n\nexport interface ITransaction {\n\t/**\n\t * Calls {@link Observer.beginUpdate} immediately\n\t * and {@link Observer.endUpdate} when the transaction ends.\n\t */\n\tupdateObserver(observer: IObserver, observable: IObservable<any, any>): void;\n}\n\nlet _derived: typeof derivedOpts;\n/**\n * @internal\n * This is to allow splitting files.\n*/\nexport function _setDerivedOpts(derived: typeof _derived) {\n\t_derived = derived;\n}\n\nexport abstract class ConvenientObservable<T, TChange> implements IObservable<T, TChange> {\n\tget TChange(): TChange { return null!; }\n\n\tpublic abstract get(): T;\n\n\tpublic reportChanges(): void {\n\t\tthis.get();\n\t}\n\n\tpublic abstract addObserver(observer: IObserver): void;\n\tpublic abstract removeObserver(observer: IObserver): void;\n\n\t/** @sealed */\n\tpublic read(reader: IReader | undefined): T {\n\t\tif (reader) {\n\t\t\treturn reader.readObservable(this);\n\t\t} else {\n\t\t\treturn this.get();\n\t\t}\n\t}\n\n\t/** @sealed */\n\tpublic map<TNew>(fn: (value: T, reader: IReader) => TNew): IObservable<TNew>;\n\tpublic map<TNew>(owner: object, fn: (value: T, reader: IReader) => TNew): IObservable<TNew>;\n\tpublic map<TNew>(fnOrOwner: object | ((value: T, reader: IReader) => TNew), fnOrUndefined?: (value: T, reader: IReader) => TNew): IObservable<TNew> {\n\t\tconst owner = fnOrUndefined === undefined ? undefined : fnOrOwner as object;\n\t\tconst fn = fnOrUndefined === undefined ? fnOrOwner as (value: T, reader: IReader) => TNew : fnOrUndefined;\n\n\t\treturn _derived(\n\t\t\t{\n\t\t\t\towner,\n\t\t\t\tdebugName: () => {\n\t\t\t\t\tconst name = getFunctionName(fn);\n\t\t\t\t\tif (name !== undefined) {\n\t\t\t\t\t\treturn name;\n\t\t\t\t\t}\n\n\t\t\t\t\t// regexp to match `x => x.y` where x and y can be arbitrary identifiers (uses backref):\n\t\t\t\t\tconst regexp = /^\\s*\\(?\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)\\s*\\)?\\s*=>\\s*\\1\\.([a-zA-Z_$][a-zA-Z_$0-9]*)\\s*$/;\n\t\t\t\t\tconst match = regexp.exec(fn.toString());\n\t\t\t\t\tif (match) {\n\t\t\t\t\t\treturn `${this.debugName}.${match[2]}`;\n\t\t\t\t\t}\n\t\t\t\t\tif (!owner) {\n\t\t\t\t\t\treturn `${this.debugName} (mapped)`;\n\t\t\t\t\t}\n\t\t\t\t\treturn undefined;\n\t\t\t\t},\n\t\t\t},\n\t\t\t(reader) => fn(this.read(reader), reader),\n\t\t);\n\t}\n\n\tpublic abstract get debugName(): string;\n}\n\nexport abstract class BaseObservable<T, TChange = void> extends ConvenientObservable<T, TChange> {\n\tprotected readonly observers = new Set<IObserver>();\n\n\tpublic addObserver(observer: IObserver): void {\n\t\tconst len = this.observers.size;\n\t\tthis.observers.add(observer);\n\t\tif (len === 0) {\n\t\t\tthis.onFirstObserverAdded();\n\t\t}\n\t}\n\n\tpublic removeObserver(observer: IObserver): void {\n\t\tconst deleted = this.observers.delete(observer);\n\t\tif (deleted && this.observers.size === 0) {\n\t\t\tthis.onLastObserverRemoved();\n\t\t}\n\t}\n\n\tprotected onFirstObserverAdded(): void { }\n\tprotected onLastObserverRemoved(): void { }\n}\n\nexport function transaction(fn: (tx: ITransaction) => void, getDebugName?: () => string): void {\n\tconst tx = new TransactionImpl(fn, getDebugName);\n\ttry {\n\t\tfn(tx);\n\t} finally {\n\t\ttx.finish();\n\t}\n}\n\nexport function subtransaction(tx: ITransaction | undefined, fn: (tx: ITransaction) => void, getDebugName?: () => string): void {\n\tif (!tx) {\n\t\ttransaction(fn, getDebugName);\n\t} else {\n\t\tfn(tx);\n\t}\n}\n\nexport class TransactionImpl implements ITransaction {\n\tprivate updatingObservers: { observer: IObserver; observable: IObservable<any> }[] | null = [];\n\n\tconstructor(public readonly _fn: Function, private readonly _getDebugName?: () => string) {\n\t\tgetLogger()?.handleBeginTransaction(this);\n\t}\n\n\tpublic getDebugName(): string | undefined {\n\t\tif (this._getDebugName) {\n\t\t\treturn this._getDebugName();\n\t\t}\n\t\treturn getFunctionName(this._fn);\n\t}\n\n\tpublic updateObserver(observer: IObserver, observable: IObservable<any>): void {\n\t\tthis.updatingObservers!.push({ observer, observable });\n\t\tobserver.beginUpdate(observable);\n\t}\n\n\tpublic finish(): void {\n\t\tconst updatingObservers = this.updatingObservers!;\n\t\t// Prevent anyone from updating observers from now on.\n\t\tthis.updatingObservers = null;\n\t\tfor (const { observer, observable } of updatingObservers) {\n\t\t\tobserver.endUpdate(observable);\n\t\t}\n\t\tgetLogger()?.handleEndTransaction();\n\t}\n}\n\nexport type DebugNameFn = string | (() => string | undefined);\n\nexport function getDebugName(debugNameFn: DebugNameFn | undefined, fn: Function | undefined, owner: object | undefined, self: object): string | undefined {\n\tlet result: string | undefined;\n\tif (debugNameFn !== undefined) {\n\t\tif (typeof debugNameFn === 'function') {\n\t\t\tresult = debugNameFn();\n\t\t\tif (result !== undefined) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t} else {\n\t\t\treturn debugNameFn;\n\t\t}\n\t}\n\n\tif (fn !== undefined) {\n\t\tresult = getFunctionName(fn);\n\t\tif (result !== undefined) {\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tif (owner !== undefined) {\n\t\tfor (const key in owner) {\n\t\t\tif ((owner as any)[key] === self) {\n\t\t\t\treturn key;\n\t\t\t}\n\t\t}\n\t}\n\treturn undefined;\n}\n\nexport function getFunctionName(fn: Function): string | undefined {\n\tconst fnSrc = fn.toString();\n\t// Pattern: /** @description ... */\n\tconst regexp = /\\/\\*\\*\\s*@description\\s*([^*]*)\\*\\//;\n\tconst match = regexp.exec(fnSrc);\n\tconst result = match ? match[1] : undefined;\n\treturn result?.trim();\n}\n\nexport interface ISettableObservable<T, TChange = void> extends IObservable<T, TChange>, ISettable<T, TChange> {\n}\n\n/**\n * Creates an observable value.\n * Observers get informed when the value changes.\n */\nexport function observableValue<T, TChange = void>(name: string, initialValue: T): ISettableObservable<T, TChange>;\nexport function observableValue<T, TChange = void>(owner: object, initialValue: T): ISettableObservable<T, TChange>;\nexport function observableValue<T, TChange = void>(nameOrOwner: string | object, initialValue: T): ISettableObservable<T, TChange> {\n\tif (typeof nameOrOwner === 'string') {\n\t\treturn new ObservableValue(undefined, nameOrOwner, initialValue);\n\t} else {\n\t\treturn new ObservableValue(nameOrOwner, undefined, initialValue);\n\t}\n}\n\nexport class ObservableValue<T, TChange = void>\n\textends BaseObservable<T, TChange>\n\timplements ISettableObservable<T, TChange>\n{\n\tprotected _value: T;\n\n\tget debugName() {\n\t\treturn getDebugName(this._debugName, undefined, this._owner, this) ?? 'ObservableValue';\n\t}\n\n\tconstructor(\n\t\tprivate readonly _owner: object | undefined,\n\t\tprivate readonly _debugName: string | undefined,\n\t\tinitialValue: T\n\t) {\n\t\tsuper();\n\t\tthis._value = initialValue;\n\t}\n\tpublic get(): T {\n\t\treturn this._value;\n\t}\n\n\tpublic set(value: T, tx: ITransaction | undefined, change: TChange): void {\n\t\tif (this._value === value) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet _tx: TransactionImpl | undefined;\n\t\tif (!tx) {\n\t\t\ttx = _tx = new TransactionImpl(() => { }, () => `Setting ${this.debugName}`);\n\t\t}\n\t\ttry {\n\t\t\tconst oldValue = this._value;\n\t\t\tthis._setValue(value);\n\t\t\tgetLogger()?.handleObservableChanged(this, { oldValue, newValue: value, change, didChange: true, hadValue: true });\n\n\t\t\tfor (const observer of this.observers) {\n\t\t\t\ttx.updateObserver(observer, this);\n\t\t\t\tobserver.handleChange(this, change);\n\t\t\t}\n\t\t} finally {\n\t\t\tif (_tx) {\n\t\t\t\t_tx.finish();\n\t\t\t}\n\t\t}\n\t}\n\n\toverride toString(): string {\n\t\treturn `${this.debugName}: ${this._value}`;\n\t}\n\n\tprotected _setValue(newValue: T): void {\n\t\tthis._value = newValue;\n\t}\n}\n\nexport function disposableObservableValue<T extends IDisposable | undefined, TChange = void>(nameOrOwner: string | object, initialValue: T): ISettableObservable<T, TChange> & IDisposable {\n\tif (typeof nameOrOwner === 'string') {\n\t\treturn new DisposableObservableValue(undefined, nameOrOwner, initialValue);\n\t} else {\n\t\treturn new DisposableObservableValue(nameOrOwner, undefined, initialValue);\n\t}\n}\n\nexport class DisposableObservableValue<T extends IDisposable | undefined, TChange = void> extends ObservableValue<T, TChange> implements IDisposable {\n\tprotected override _setValue(newValue: T): void {\n\t\tif (this._value === newValue) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._value) {\n\t\t\tthis._value.dispose();\n\t\t}\n\t\tthis._value = newValue;\n\t}\n\n\tpublic dispose(): void {\n\t\tthis._value?.dispose();\n\t}\n}\n\nexport interface IChangeContext {\n\treadonly changedObservable: IObservable<any, any>;\n\treadonly change: unknown;\n\n\tdidChange<T, TChange>(observable: IObservable<T, TChange>): this is { change: TChange };\n}\n\nexport interface IChangeTracker {\n\t/**\n\t * Returns if this change should cause an invalidation.\n\t * Can record the changes to just process deltas.\n\t*/\n\thandleChange(context: IChangeContext): boolean;\n}\n"]}