{"version":3,"sources":["file:///workspace/appflow/src/vs/base/common/observableInternal/autorun.ts"],"names":[],"mappings":"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","file":"autorun.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { assertFn } from 'vs/base/common/assert';\nimport { DisposableStore, IDisposable, markAsDisposed, toDisposable, trackDisposable } from 'vs/base/common/lifecycle';\nimport { IReader, IObservable, IObserver, IChangeContext, getFunctionName } from 'vs/base/common/observableInternal/base';\nimport { getLogger } from 'vs/base/common/observableInternal/logging';\n\nexport function autorunOpts(options: { debugName: string | (() => string | undefined) }, fn: (reader: IReader) => void): IDisposable {\n\treturn new AutorunObserver(options.debugName, fn, undefined, undefined);\n}\n\nexport function autorun(fn: (reader: IReader) => void): IDisposable {\n\treturn new AutorunObserver(undefined, fn, undefined, undefined);\n}\n\nexport function autorunHandleChanges<TChangeSummary>(\n\toptions: {\n\t\tdebugName?: string | (() => string | undefined);\n\t\tcreateEmptyChangeSummary?: () => TChangeSummary;\n\t\thandleChange: (context: IChangeContext, changeSummary: TChangeSummary) => boolean;\n\t},\n\tfn: (reader: IReader, changeSummary: TChangeSummary) => void\n): IDisposable {\n\treturn new AutorunObserver(options.debugName, fn, options.createEmptyChangeSummary, options.handleChange);\n}\n\nexport function autorunWithStoreHandleChanges<TChangeSummary>(\n\toptions: {\n\t\tdebugName?: string | (() => string | undefined);\n\t\tcreateEmptyChangeSummary?: () => TChangeSummary;\n\t\thandleChange: (context: IChangeContext, changeSummary: TChangeSummary) => boolean;\n\t},\n\tfn: (reader: IReader, changeSummary: TChangeSummary, store: DisposableStore) => void\n): IDisposable {\n\tconst store = new DisposableStore();\n\tconst disposable = autorunHandleChanges(\n\t\t{\n\t\t\tdebugName: options.debugName ?? (() => getFunctionName(fn)),\n\t\t\tcreateEmptyChangeSummary: options.createEmptyChangeSummary,\n\t\t\thandleChange: options.handleChange,\n\t\t},\n\t\t(reader, changeSummary) => {\n\t\t\tstore.clear();\n\t\t\tfn(reader, changeSummary, store);\n\t\t}\n\t);\n\treturn toDisposable(() => {\n\t\tdisposable.dispose();\n\t\tstore.dispose();\n\t});\n}\n\nexport function autorunWithStore(fn: (reader: IReader, store: DisposableStore) => void): IDisposable {\n\tconst store = new DisposableStore();\n\tconst disposable = autorunOpts(\n\t\t{\n\t\t\tdebugName: () => getFunctionName(fn) || '(anonymous)',\n\t\t},\n\t\treader => {\n\t\t\tstore.clear();\n\t\t\tfn(reader, store);\n\t\t}\n\t);\n\treturn toDisposable(() => {\n\t\tdisposable.dispose();\n\t\tstore.dispose();\n\t});\n}\n\nconst enum AutorunState {\n\t/**\n\t * A dependency could have changed.\n\t * We need to explicitly ask them if at least one dependency changed.\n\t */\n\tdependenciesMightHaveChanged = 1,\n\n\t/**\n\t * A dependency changed and we need to recompute.\n\t */\n\tstale = 2,\n\tupToDate = 3,\n}\n\nexport class AutorunObserver<TChangeSummary = any> implements IObserver, IReader, IDisposable {\n\tprivate state = AutorunState.stale;\n\tprivate updateCount = 0;\n\tprivate disposed = false;\n\tprivate dependencies = new Set<IObservable<any>>();\n\tprivate dependenciesToBeRemoved = new Set<IObservable<any>>();\n\tprivate changeSummary: TChangeSummary | undefined;\n\n\tpublic get debugName(): string {\n\t\tif (typeof this._debugName === 'string') {\n\t\t\treturn this._debugName;\n\t\t}\n\t\tif (typeof this._debugName === 'function') {\n\t\t\tconst name = this._debugName();\n\t\t\tif (name !== undefined) { return name; }\n\t\t}\n\t\tconst name = getFunctionName(this._runFn);\n\t\tif (name !== undefined) { return name; }\n\n\t\treturn '(anonymous)';\n\t}\n\n\tconstructor(\n\t\tprivate readonly _debugName: string | (() => string | undefined) | undefined,\n\t\tpublic readonly _runFn: (reader: IReader, changeSummary: TChangeSummary) => void,\n\t\tprivate readonly createChangeSummary: (() => TChangeSummary) | undefined,\n\t\tprivate readonly _handleChange: ((context: IChangeContext, summary: TChangeSummary) => boolean) | undefined,\n\t) {\n\t\tthis.changeSummary = this.createChangeSummary?.();\n\t\tgetLogger()?.handleAutorunCreated(this);\n\t\tthis._runIfNeeded();\n\n\t\ttrackDisposable(this);\n\t}\n\n\tpublic dispose(): void {\n\t\tthis.disposed = true;\n\t\tfor (const o of this.dependencies) {\n\t\t\to.removeObserver(this);\n\t\t}\n\t\tthis.dependencies.clear();\n\n\t\tmarkAsDisposed(this);\n\t}\n\n\tprivate _runIfNeeded() {\n\t\tif (this.state === AutorunState.upToDate) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst emptySet = this.dependenciesToBeRemoved;\n\t\tthis.dependenciesToBeRemoved = this.dependencies;\n\t\tthis.dependencies = emptySet;\n\n\t\tthis.state = AutorunState.upToDate;\n\n\t\ttry {\n\t\t\tif (!this.disposed) {\n\t\t\t\tgetLogger()?.handleAutorunTriggered(this);\n\t\t\t\tconst changeSummary = this.changeSummary!;\n\t\t\t\tthis.changeSummary = this.createChangeSummary?.();\n\t\t\t\tthis._runFn(this, changeSummary);\n\t\t\t}\n\t\t} finally {\n\t\t\tgetLogger()?.handleAutorunFinished(this);\n\t\t\t// We don't want our observed observables to think that they are (not even temporarily) not being observed.\n\t\t\t// Thus, we only unsubscribe from observables that are definitely not read anymore.\n\t\t\tfor (const o of this.dependenciesToBeRemoved) {\n\t\t\t\to.removeObserver(this);\n\t\t\t}\n\t\t\tthis.dependenciesToBeRemoved.clear();\n\t\t}\n\t}\n\n\tpublic toString(): string {\n\t\treturn `Autorun<${this.debugName}>`;\n\t}\n\n\t// IObserver implementation\n\tpublic beginUpdate(): void {\n\t\tif (this.state === AutorunState.upToDate) {\n\t\t\tthis.state = AutorunState.dependenciesMightHaveChanged;\n\t\t}\n\t\tthis.updateCount++;\n\t}\n\n\tpublic endUpdate(): void {\n\t\tif (this.updateCount === 1) {\n\t\t\tdo {\n\t\t\t\tif (this.state === AutorunState.dependenciesMightHaveChanged) {\n\t\t\t\t\tthis.state = AutorunState.upToDate;\n\t\t\t\t\tfor (const d of this.dependencies) {\n\t\t\t\t\t\td.reportChanges();\n\t\t\t\t\t\tif (this.state as AutorunState === AutorunState.stale) {\n\t\t\t\t\t\t\t// The other dependencies will refresh on demand\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis._runIfNeeded();\n\t\t\t} while (this.state !== AutorunState.upToDate);\n\t\t}\n\t\tthis.updateCount--;\n\n\t\tassertFn(() => this.updateCount >= 0);\n\t}\n\n\tpublic handlePossibleChange(observable: IObservable<any>): void {\n\t\tif (this.state === AutorunState.upToDate && this.dependencies.has(observable) && !this.dependenciesToBeRemoved.has(observable)) {\n\t\t\tthis.state = AutorunState.dependenciesMightHaveChanged;\n\t\t}\n\t}\n\n\tpublic handleChange<T, TChange>(observable: IObservable<T, TChange>, change: TChange): void {\n\t\tif (this.dependencies.has(observable) && !this.dependenciesToBeRemoved.has(observable)) {\n\t\t\tconst shouldReact = this._handleChange ? this._handleChange({\n\t\t\t\tchangedObservable: observable,\n\t\t\t\tchange,\n\t\t\t\tdidChange: o => o === observable as any,\n\t\t\t}, this.changeSummary!) : true;\n\t\t\tif (shouldReact) {\n\t\t\t\tthis.state = AutorunState.stale;\n\t\t\t}\n\t\t}\n\t}\n\n\t// IReader implementation\n\tpublic readObservable<T>(observable: IObservable<T>): T {\n\t\t// In case the run action disposes the autorun\n\t\tif (this.disposed) {\n\t\t\treturn observable.get();\n\t\t}\n\n\t\tobservable.addObserver(this);\n\t\tconst value = observable.get();\n\t\tthis.dependencies.add(observable);\n\t\tthis.dependenciesToBeRemoved.delete(observable);\n\t\treturn value;\n\t}\n}\n\nexport namespace autorun {\n\texport const Observer = AutorunObserver;\n}\n\nexport function autorunDelta<T>(\n\tobservable: IObservable<T>,\n\thandler: (args: { lastValue: T | undefined; newValue: T }) => void\n): IDisposable {\n\tlet _lastValue: T | undefined;\n\treturn autorunOpts({ debugName: () => getFunctionName(handler) }, (reader) => {\n\t\tconst newValue = observable.read(reader);\n\t\tconst lastValue = _lastValue;\n\t\t_lastValue = newValue;\n\t\thandler({ lastValue, newValue });\n\t});\n}\n"]}