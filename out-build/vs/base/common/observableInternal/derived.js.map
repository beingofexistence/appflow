{"version":3,"sources":["file:///workspace/appflow/src/vs/base/common/observableInternal/derived.ts"],"names":[],"mappings":"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","file":"derived.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { BugIndicatingError } from 'vs/base/common/errors';\nimport { DisposableStore } from 'vs/base/common/lifecycle';\nimport { IReader, IObservable, BaseObservable, IObserver, _setDerivedOpts, IChangeContext, getFunctionName, DebugNameFn, getDebugName } from 'vs/base/common/observableInternal/base';\nimport { getLogger } from 'vs/base/common/observableInternal/logging';\n\nexport type EqualityComparer<T> = (a: T, b: T) => boolean;\nconst defaultEqualityComparer: EqualityComparer<any> = (a, b) => a === b;\n\n/**\n * Creates an observable that is derived from other observables.\n */\nexport function derived<T>(computeFn: (reader: IReader) => T): IObservable<T>;\nexport function derived<T>(owner: object, computeFn: (reader: IReader) => T): IObservable<T>;\nexport function derived<T>(computeFnOrOwner: ((reader: IReader) => T) | object, computeFn?: ((reader: IReader) => T) | undefined): IObservable<T> {\n\tif (computeFn !== undefined) {\n\t\treturn new Derived(computeFnOrOwner, undefined, computeFn, undefined, undefined, undefined, defaultEqualityComparer);\n\t}\n\treturn new Derived(undefined, undefined, computeFnOrOwner as any, undefined, undefined, undefined, defaultEqualityComparer);\n}\n\nexport function derivedOpts<T>(\n\toptions: {\n\t\towner?: object;\n\t\tdebugName?: string | (() => string | undefined);\n\t\tequalityComparer?: EqualityComparer<T>;\n\t},\n\tcomputeFn: (reader: IReader) => T\n): IObservable<T> {\n\treturn new Derived(options.owner, options.debugName, computeFn, undefined, undefined, undefined, options.equalityComparer ?? defaultEqualityComparer);\n}\n\nexport function derivedHandleChanges<T, TChangeSummary>(\n\toptions: {\n\t\towner?: object;\n\t\tdebugName?: string | (() => string);\n\t\tcreateEmptyChangeSummary: () => TChangeSummary;\n\t\thandleChange: (context: IChangeContext, changeSummary: TChangeSummary) => boolean;\n\t\tequalityComparer?: EqualityComparer<T>;\n\t},\n\tcomputeFn: (reader: IReader, changeSummary: TChangeSummary) => T\n): IObservable<T> {\n\treturn new Derived(options.owner, options.debugName, computeFn, options.createEmptyChangeSummary, options.handleChange, undefined, options.equalityComparer ?? defaultEqualityComparer);\n}\n\nexport function derivedWithStore<T>(computeFn: (reader: IReader, store: DisposableStore) => T): IObservable<T>;\nexport function derivedWithStore<T>(owner: object, computeFn: (reader: IReader, store: DisposableStore) => T): IObservable<T>;\nexport function derivedWithStore<T>(computeFnOrOwner: ((reader: IReader, store: DisposableStore) => T) | object, computeFnOrUndefined?: ((reader: IReader, store: DisposableStore) => T)): IObservable<T> {\n\tlet computeFn: (reader: IReader, store: DisposableStore) => T;\n\tlet owner: object | undefined;\n\tif (computeFnOrUndefined === undefined) {\n\t\tcomputeFn = computeFnOrOwner as any;\n\t\towner = undefined;\n\t} else {\n\t\towner = computeFnOrOwner;\n\t\tcomputeFn = computeFnOrUndefined as any;\n\t}\n\n\tconst store = new DisposableStore();\n\treturn new Derived(\n\t\towner,\n\t\t(() => getFunctionName(computeFn) ?? '(anonymous)'),\n\t\tr => {\n\t\t\tstore.clear();\n\t\t\treturn computeFn(r, store);\n\t\t}, undefined,\n\t\tundefined,\n\t\t() => store.dispose(),\n\t\tdefaultEqualityComparer\n\t);\n}\n\n_setDerivedOpts(derived);\n\nconst enum DerivedState {\n\t/** Initial state, no previous value, recomputation needed */\n\tinitial = 0,\n\n\t/**\n\t * A dependency could have changed.\n\t * We need to explicitly ask them if at least one dependency changed.\n\t */\n\tdependenciesMightHaveChanged = 1,\n\n\t/**\n\t * A dependency changed and we need to recompute.\n\t * After recomputation, we need to check the previous value to see if we changed as well.\n\t */\n\tstale = 2,\n\n\t/**\n\t * No change reported, our cached value is up to date.\n\t */\n\tupToDate = 3,\n}\n\nexport class Derived<T, TChangeSummary = any> extends BaseObservable<T, void> implements IReader, IObserver {\n\tprivate state = DerivedState.initial;\n\tprivate value: T | undefined = undefined;\n\tprivate updateCount = 0;\n\tprivate dependencies = new Set<IObservable<any>>();\n\tprivate dependenciesToBeRemoved = new Set<IObservable<any>>();\n\tprivate changeSummary: TChangeSummary | undefined = undefined;\n\n\tpublic override get debugName(): string {\n\t\treturn getDebugName(this._debugName, this._computeFn, this._owner, this) ?? '(anonymous)';\n\t}\n\n\tconstructor(\n\t\tprivate readonly _owner: object | undefined,\n\t\tprivate readonly _debugName: DebugNameFn | undefined,\n\t\tpublic readonly _computeFn: (reader: IReader, changeSummary: TChangeSummary) => T,\n\t\tprivate readonly createChangeSummary: (() => TChangeSummary) | undefined,\n\t\tprivate readonly _handleChange: ((context: IChangeContext, summary: TChangeSummary) => boolean) | undefined,\n\t\tprivate readonly _handleLastObserverRemoved: (() => void) | undefined = undefined,\n\t\tprivate readonly _equalityComparator: EqualityComparer<T>,\n\t) {\n\t\tsuper();\n\t\tthis.changeSummary = this.createChangeSummary?.();\n\t\tgetLogger()?.handleDerivedCreated(this);\n\t}\n\n\tprotected override onLastObserverRemoved(): void {\n\t\t/**\n\t\t * We are not tracking changes anymore, thus we have to assume\n\t\t * that our cache is invalid.\n\t\t */\n\t\tthis.state = DerivedState.initial;\n\t\tthis.value = undefined;\n\t\tfor (const d of this.dependencies) {\n\t\t\td.removeObserver(this);\n\t\t}\n\t\tthis.dependencies.clear();\n\n\t\tthis._handleLastObserverRemoved?.();\n\t}\n\n\tpublic override get(): T {\n\t\tif (this.observers.size === 0) {\n\t\t\t// Without observers, we don't know when to clean up stuff.\n\t\t\t// Thus, we don't cache anything to prevent memory leaks.\n\t\t\tconst result = this._computeFn(this, this.createChangeSummary?.()!);\n\t\t\t// Clear new dependencies\n\t\t\tthis.onLastObserverRemoved();\n\t\t\treturn result;\n\t\t} else {\n\t\t\tdo {\n\t\t\t\t// We might not get a notification for a dependency that changed while it is updating,\n\t\t\t\t// thus we also have to ask all our depedencies if they changed in this case.\n\t\t\t\tif (this.state === DerivedState.dependenciesMightHaveChanged) {\n\t\t\t\t\tfor (const d of this.dependencies) {\n\t\t\t\t\t\t/** might call {@link handleChange} indirectly, which could make us stale */\n\t\t\t\t\t\td.reportChanges();\n\n\t\t\t\t\t\tif (this.state as DerivedState === DerivedState.stale) {\n\t\t\t\t\t\t\t// The other dependencies will refresh on demand, so early break\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// We called report changes of all dependencies.\n\t\t\t\t// If we are still not stale, we can assume to be up to date again.\n\t\t\t\tif (this.state === DerivedState.dependenciesMightHaveChanged) {\n\t\t\t\t\tthis.state = DerivedState.upToDate;\n\t\t\t\t}\n\n\t\t\t\tthis._recomputeIfNeeded();\n\t\t\t\t// In case recomputation changed one of our dependencies, we need to recompute again.\n\t\t\t} while (this.state !== DerivedState.upToDate);\n\t\t\treturn this.value!;\n\t\t}\n\t}\n\n\tprivate _recomputeIfNeeded() {\n\t\tif (this.state === DerivedState.upToDate) {\n\t\t\treturn;\n\t\t}\n\t\tconst emptySet = this.dependenciesToBeRemoved;\n\t\tthis.dependenciesToBeRemoved = this.dependencies;\n\t\tthis.dependencies = emptySet;\n\n\t\tconst hadValue = this.state !== DerivedState.initial;\n\t\tconst oldValue = this.value;\n\t\tthis.state = DerivedState.upToDate;\n\n\t\tconst changeSummary = this.changeSummary!;\n\t\tthis.changeSummary = this.createChangeSummary?.();\n\t\ttry {\n\t\t\t/** might call {@link handleChange} indirectly, which could invalidate us */\n\t\t\tthis.value = this._computeFn(this, changeSummary);\n\t\t} finally {\n\t\t\t// We don't want our observed observables to think that they are (not even temporarily) not being observed.\n\t\t\t// Thus, we only unsubscribe from observables that are definitely not read anymore.\n\t\t\tfor (const o of this.dependenciesToBeRemoved) {\n\t\t\t\to.removeObserver(this);\n\t\t\t}\n\t\t\tthis.dependenciesToBeRemoved.clear();\n\t\t}\n\n\t\tconst didChange = hadValue && !(this._equalityComparator(oldValue!, this.value));\n\n\t\tgetLogger()?.handleDerivedRecomputed(this, {\n\t\t\toldValue,\n\t\t\tnewValue: this.value,\n\t\t\tchange: undefined,\n\t\t\tdidChange,\n\t\t\thadValue,\n\t\t});\n\n\t\tif (didChange) {\n\t\t\tfor (const r of this.observers) {\n\t\t\t\tr.handleChange(this, undefined);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic override toString(): string {\n\t\treturn `LazyDerived<${this.debugName}>`;\n\t}\n\n\t// IObserver Implementation\n\tpublic beginUpdate<T>(_observable: IObservable<T>): void {\n\t\tthis.updateCount++;\n\t\tconst propagateBeginUpdate = this.updateCount === 1;\n\t\tif (this.state === DerivedState.upToDate) {\n\t\t\tthis.state = DerivedState.dependenciesMightHaveChanged;\n\t\t\t// If we propagate begin update, that will already signal a possible change.\n\t\t\tif (!propagateBeginUpdate) {\n\t\t\t\tfor (const r of this.observers) {\n\t\t\t\t\tr.handlePossibleChange(this);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (propagateBeginUpdate) {\n\t\t\tfor (const r of this.observers) {\n\t\t\t\tr.beginUpdate(this); // This signals a possible change\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic endUpdate<T>(_observable: IObservable<T>): void {\n\t\tthis.updateCount--;\n\t\tif (this.updateCount === 0) {\n\t\t\t// End update could change the observer list.\n\t\t\tconst observers = [...this.observers];\n\t\t\tfor (const r of observers) {\n\t\t\t\tr.endUpdate(this);\n\t\t\t}\n\t\t}\n\t\tif (this.updateCount < 0) {\n\t\t\tthrow new BugIndicatingError();\n\t\t}\n\t}\n\n\tpublic handlePossibleChange<T>(observable: IObservable<T, unknown>): void {\n\t\t// In all other states, observers already know that we might have changed.\n\t\tif (this.state === DerivedState.upToDate && this.dependencies.has(observable) && !this.dependenciesToBeRemoved.has(observable)) {\n\t\t\tthis.state = DerivedState.dependenciesMightHaveChanged;\n\t\t\tfor (const r of this.observers) {\n\t\t\t\tr.handlePossibleChange(this);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic handleChange<T, TChange>(observable: IObservable<T, TChange>, change: TChange): void {\n\t\tif (this.dependencies.has(observable) && !this.dependenciesToBeRemoved.has(observable)) {\n\t\t\tconst shouldReact = this._handleChange ? this._handleChange({\n\t\t\t\tchangedObservable: observable,\n\t\t\t\tchange,\n\t\t\t\tdidChange: o => o === observable as any,\n\t\t\t}, this.changeSummary!) : true;\n\t\t\tconst wasUpToDate = this.state === DerivedState.upToDate;\n\t\t\tif (shouldReact && (this.state === DerivedState.dependenciesMightHaveChanged || wasUpToDate)) {\n\t\t\t\tthis.state = DerivedState.stale;\n\t\t\t\tif (wasUpToDate) {\n\t\t\t\t\tfor (const r of this.observers) {\n\t\t\t\t\t\tr.handlePossibleChange(this);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// IReader Implementation\n\tpublic readObservable<T>(observable: IObservable<T>): T {\n\t\t// Subscribe before getting the value to enable caching\n\t\tobservable.addObserver(this);\n\t\t/** This might call {@link handleChange} indirectly, which could invalidate us */\n\t\tconst value = observable.get();\n\t\t// Which is why we only add the observable to the dependencies now.\n\t\tthis.dependencies.add(observable);\n\t\tthis.dependenciesToBeRemoved.delete(observable);\n\t\treturn value;\n\t}\n\n\tpublic override addObserver(observer: IObserver): void {\n\t\tconst shouldCallBeginUpdate = !this.observers.has(observer) && this.updateCount > 0;\n\t\tsuper.addObserver(observer);\n\n\t\tif (shouldCallBeginUpdate) {\n\t\t\tobserver.beginUpdate(this);\n\t\t}\n\t}\n\n\tpublic override removeObserver(observer: IObserver): void {\n\t\tconst shouldCallEndUpdate = this.observers.has(observer) && this.updateCount > 0;\n\t\tsuper.removeObserver(observer);\n\n\t\tif (shouldCallEndUpdate) {\n\t\t\t// Calling end update after removing the observer makes sure endUpdate cannot be called twice here.\n\t\t\tobserver.endUpdate(this);\n\t\t}\n\t}\n}\n"]}