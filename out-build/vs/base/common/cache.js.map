{"version":3,"sources":["file:///workspace/appflow/src/vs/base/common/cache.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;IAShG,MAAa,GAAG;QAGf,YAAoB,CAA2C;YAA3C,MAAC,GAAD,CAAC,CAA0C;YADvD,MAAC,GAA+B,IAAI,CAAC;QACsB,CAAC;QAEpE,GAAG;YACF,IAAI,IAAI,CAAC,CAAC,EAAO;gBAChB,OAAO,IAAI,CAAC,CAAC,CAAM;aACnB;YAED,MAAM,GAAG,GAAG,IAAI,kBAAG,EAAsB,CAAC;YAC1C,MAAM,OAAO,GAAG,IAAI,CAAC,CAAC,CAAI,GAAG,CAAC,KAAK,CAAC,CAAC;YAErC,IAAI,CAAC,CAAC,GAAQ;gBACb,OAAO;gBACP,OAAO,EAAE,GAAG,EAAE;oBACb,IAAI,CAAC,CAAC,GAAQ,IAAI,CAAC;oBACnB,GAAG,CAAC,MAAM,EAAE,CAAC;oBACb,GAAG,CAAC,OAAO,EAAE,CAAC;gBACf,CAAC;aACD,CAAC;YAEF,OAAO,IAAI,CAAC,CAAC,CAAM;QACpB,CAAC;KACD;IAxBD,kBAwBC;IAED;;;;MAIE;IACF,MAAa,GAAG;QAIf,YAA6B,CAA4B;YAA5B,MAAC,GAAD,CAAC,CAA2B;YAHjD,MAAC,GAAkC,SAAS,CAAC;YAC7C,MAAC,GAAgC,SAAS,CAAC;QAGnD,CAAC;QAEM,GAAG,CAAC,GAAS;YACnB,MAAM,GAAG,GAAG,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC;YAChC,IAAI,IAAI,CAAC,CAAC,KAAc,GAAG,EAAE;gBAC5B,IAAI,CAAC,CAAC,GAAY,GAAG,CAAC;gBACtB,IAAI,CAAC,CAAC,GAAW,IAAI,CAAC,CAAC,CAAE,GAAG,CAAC,CAAC;aAC9B;YACD,OAAO,IAAI,CAAC,CAAU,CAAC;QACxB,CAAC;KACD;IAfD,kBAeC;IAED;;MAEE;IACF,MAAa,GAAG;QAEf,IAAW,YAAY;YACtB,OAAO,IAAI,CAAC,CAAC,CAAI;QAClB,CAAC;QAED,YAA6B,CAAyB;YAAzB,MAAC,GAAD,CAAC,CAAwB;YALrC,MAAC,GAAM,IAAI,GAAG,EAAgB,CAAC;QAKU,CAAC;QAEpD,GAAG,CAAC,GAAS;YACnB,IAAI,IAAI,CAAC,CAAC,CAAI,GAAG,CAAC,GAAG,CAAC,EAAE;gBACvB,OAAO,IAAI,CAAC,CAAC,CAAI,GAAG,CAAC,GAAG,CAAE,CAAC;aAC3B;YACD,MAAM,KAAK,GAAG,IAAI,CAAC,CAAC,CAAE,GAAG,CAAC,CAAC;YAC3B,IAAI,CAAC,CAAC,CAAI,GAAG,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;YAC1B,OAAO,KAAK,CAAC;QACd,CAAC;KACD;IAhBD,kBAgBC","file":"cache.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken, CancellationTokenSource } from 'vs/base/common/cancellation';\nimport { IDisposable } from 'vs/base/common/lifecycle';\n\nexport interface CacheResult<T> extends IDisposable {\n\tpromise: Promise<T>;\n}\n\nexport class Cache<T> {\n\n\tprivate result: CacheResult<T> | null = null;\n\tconstructor(private task: (ct: CancellationToken) => Promise<T>) { }\n\n\tget(): CacheResult<T> {\n\t\tif (this.result) {\n\t\t\treturn this.result;\n\t\t}\n\n\t\tconst cts = new CancellationTokenSource();\n\t\tconst promise = this.task(cts.token);\n\n\t\tthis.result = {\n\t\t\tpromise,\n\t\t\tdispose: () => {\n\t\t\t\tthis.result = null;\n\t\t\t\tcts.cancel();\n\t\t\t\tcts.dispose();\n\t\t\t}\n\t\t};\n\n\t\treturn this.result;\n\t}\n}\n\n/**\n * Uses a LRU cache to make a given parametrized function cached.\n * Caches just the last value.\n * The key must be JSON serializable.\n*/\nexport class LRUCachedFunction<TArg, TComputed> {\n\tprivate lastCache: TComputed | undefined = undefined;\n\tprivate lastArgKey: string | undefined = undefined;\n\n\tconstructor(private readonly fn: (arg: TArg) => TComputed) {\n\t}\n\n\tpublic get(arg: TArg): TComputed {\n\t\tconst key = JSON.stringify(arg);\n\t\tif (this.lastArgKey !== key) {\n\t\t\tthis.lastArgKey = key;\n\t\t\tthis.lastCache = this.fn(arg);\n\t\t}\n\t\treturn this.lastCache!;\n\t}\n}\n\n/**\n * Uses an unbounded cache (referential equality) to memoize the results of the given function.\n*/\nexport class CachedFunction<TArg, TValue> {\n\tprivate readonly _map = new Map<TArg, TValue>();\n\tpublic get cachedValues(): ReadonlyMap<TArg, TValue> {\n\t\treturn this._map;\n\t}\n\n\tconstructor(private readonly fn: (arg: TArg) => TValue) { }\n\n\tpublic get(arg: TArg): TValue {\n\t\tif (this._map.has(arg)) {\n\t\t\treturn this._map.get(arg)!;\n\t\t}\n\t\tconst value = this.fn(arg);\n\t\tthis._map.set(arg, value);\n\t\treturn value;\n\t}\n}\n"]}