{"version":3,"sources":["file:///workspace/appflow/src/vs/base/common/lifecycle.ts"],"names":[],"mappings":"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","file":"lifecycle.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { compareBy, numberComparator } from 'vs/base/common/arrays';\nimport { SetMap, groupBy } from 'vs/base/common/collections';\nimport { once } from 'vs/base/common/functional';\nimport { Iterable } from 'vs/base/common/iterator';\n\n// #region Disposable Tracking\n\n/**\n * Enables logging of potentially leaked disposables.\n *\n * A disposable is considered leaked if it is not disposed or not registered as the child of\n * another disposable. This tracking is very simple an only works for classes that either\n * extend Disposable or use a DisposableStore. This means there are a lot of false positives.\n */\nconst TRACK_DISPOSABLES = false;\nlet disposableTracker: IDisposableTracker | null = null;\n\nexport interface IDisposableTracker {\n\t/**\n\t * Is called on construction of a disposable.\n\t*/\n\ttrackDisposable(disposable: IDisposable): void;\n\n\t/**\n\t * Is called when a disposable is registered as child of another disposable (e.g. {@link DisposableStore}).\n\t * If parent is `null`, the disposable is removed from its former parent.\n\t*/\n\tsetParent(child: IDisposable, parent: IDisposable | null): void;\n\n\t/**\n\t * Is called after a disposable is disposed.\n\t*/\n\tmarkAsDisposed(disposable: IDisposable): void;\n\n\t/**\n\t * Indicates that the given object is a singleton which does not need to be disposed.\n\t*/\n\tmarkAsSingleton(disposable: IDisposable): void;\n}\n\nexport interface DisposableInfo {\n\tvalue: IDisposable;\n\tsource: string | null;\n\tparent: IDisposable | null;\n\tisSingleton: boolean;\n\tidx: number;\n}\n\nexport class DisposableTracker implements IDisposableTracker {\n\tprivate static idx = 0;\n\n\tprivate readonly livingDisposables = new Map<IDisposable, DisposableInfo>();\n\n\tprivate getDisposableData(d: IDisposable): DisposableInfo {\n\t\tlet val = this.livingDisposables.get(d);\n\t\tif (!val) {\n\t\t\tval = { parent: null, source: null, isSingleton: false, value: d, idx: DisposableTracker.idx++ };\n\t\t\tthis.livingDisposables.set(d, val);\n\t\t}\n\t\treturn val;\n\t}\n\n\ttrackDisposable(d: IDisposable): void {\n\t\tconst data = this.getDisposableData(d);\n\t\tif (!data.source) {\n\t\t\tdata.source =\n\t\t\t\tnew Error().stack!;\n\t\t}\n\t}\n\n\tsetParent(child: IDisposable, parent: IDisposable | null): void {\n\t\tconst data = this.getDisposableData(child);\n\t\tdata.parent = parent;\n\t}\n\n\tmarkAsDisposed(x: IDisposable): void {\n\t\tthis.livingDisposables.delete(x);\n\t}\n\n\tmarkAsSingleton(disposable: IDisposable): void {\n\t\tthis.getDisposableData(disposable).isSingleton = true;\n\t}\n\n\tprivate getRootParent(data: DisposableInfo, cache: Map<DisposableInfo, DisposableInfo>): DisposableInfo {\n\t\tconst cacheValue = cache.get(data);\n\t\tif (cacheValue) {\n\t\t\treturn cacheValue;\n\t\t}\n\n\t\tconst result = data.parent ? this.getRootParent(this.getDisposableData(data.parent), cache) : data;\n\t\tcache.set(data, result);\n\t\treturn result;\n\t}\n\n\tgetTrackedDisposables(): IDisposable[] {\n\t\tconst rootParentCache = new Map<DisposableInfo, DisposableInfo>();\n\n\t\tconst leaking = [...this.livingDisposables.entries()]\n\t\t\t.filter(([, v]) => v.source !== null && !this.getRootParent(v, rootParentCache).isSingleton)\n\t\t\t.map(([k]) => k)\n\t\t\t.flat();\n\n\t\treturn leaking;\n\t}\n\n\tcomputeLeakingDisposables(maxReported = 10, preComputedLeaks?: DisposableInfo[]): { leaks: DisposableInfo[]; details: string } | undefined {\n\t\tlet uncoveredLeakingObjs: DisposableInfo[] | undefined;\n\t\tif (preComputedLeaks) {\n\t\t\tuncoveredLeakingObjs = preComputedLeaks;\n\t\t} else {\n\t\t\tconst rootParentCache = new Map<DisposableInfo, DisposableInfo>();\n\n\t\t\tconst leakingObjects = [...this.livingDisposables.values()]\n\t\t\t\t.filter((info) => info.source !== null && !this.getRootParent(info, rootParentCache).isSingleton);\n\n\t\t\tif (leakingObjects.length === 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst leakingObjsSet = new Set(leakingObjects.map(o => o.value));\n\n\t\t\t// Remove all objects that are a child of other leaking objects. Assumes there are no cycles.\n\t\t\tuncoveredLeakingObjs = leakingObjects.filter(l => {\n\t\t\t\treturn !(l.parent && leakingObjsSet.has(l.parent));\n\t\t\t});\n\n\t\t\tif (uncoveredLeakingObjs.length === 0) {\n\t\t\t\tthrow new Error('There are cyclic diposable chains!');\n\t\t\t}\n\t\t}\n\n\t\tif (!uncoveredLeakingObjs) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tfunction getStackTracePath(leaking: DisposableInfo): string[] {\n\t\t\tfunction removePrefix(array: string[], linesToRemove: (string | RegExp)[]) {\n\t\t\t\twhile (array.length > 0 && linesToRemove.some(regexp => typeof regexp === 'string' ? regexp === array[0] : array[0].match(regexp))) {\n\t\t\t\t\tarray.shift();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst lines = leaking.source!.split('\\n').map(p => p.trim().replace('at ', '')).filter(l => l !== '');\n\t\t\tremovePrefix(lines, ['Error', /^trackDisposable \\(.*\\)$/, /^DisposableTracker.trackDisposable \\(.*\\)$/]);\n\t\t\treturn lines.reverse();\n\t\t}\n\n\t\tconst stackTraceStarts = new SetMap<string, DisposableInfo>();\n\t\tfor (const leaking of uncoveredLeakingObjs) {\n\t\t\tconst stackTracePath = getStackTracePath(leaking);\n\t\t\tfor (let i = 0; i <= stackTracePath.length; i++) {\n\t\t\t\tstackTraceStarts.add(stackTracePath.slice(0, i).join('\\n'), leaking);\n\t\t\t}\n\t\t}\n\n\t\t// Put earlier leaks first\n\t\tuncoveredLeakingObjs.sort(compareBy(l => l.idx, numberComparator));\n\n\t\tlet message = '';\n\n\t\tlet i = 0;\n\t\tfor (const leaking of uncoveredLeakingObjs.slice(0, maxReported)) {\n\t\t\ti++;\n\t\t\tconst stackTracePath = getStackTracePath(leaking);\n\t\t\tconst stackTraceFormattedLines = [];\n\n\t\t\tfor (let i = 0; i < stackTracePath.length; i++) {\n\t\t\t\tlet line = stackTracePath[i];\n\t\t\t\tconst starts = stackTraceStarts.get(stackTracePath.slice(0, i + 1).join('\\n'));\n\t\t\t\tline = `(shared with ${starts.size}/${uncoveredLeakingObjs.length} leaks) at ${line}`;\n\n\t\t\t\tconst prevStarts = stackTraceStarts.get(stackTracePath.slice(0, i).join('\\n'));\n\t\t\t\tconst continuations = groupBy([...prevStarts].map(d => getStackTracePath(d)[i]), v => v);\n\t\t\t\tdelete continuations[stackTracePath[i]];\n\t\t\t\tfor (const [cont, set] of Object.entries(continuations)) {\n\t\t\t\t\tstackTraceFormattedLines.unshift(`    - stacktraces of ${set.length} other leaks continue with ${cont}`);\n\t\t\t\t}\n\n\t\t\t\tstackTraceFormattedLines.unshift(line);\n\t\t\t}\n\n\t\t\tmessage += `\\n\\n\\n==================== Leaking disposable ${i}/${uncoveredLeakingObjs.length}: ${leaking.value.constructor.name} ====================\\n${stackTraceFormattedLines.join('\\n')}\\n============================================================\\n\\n`;\n\t\t}\n\n\t\tif (uncoveredLeakingObjs.length > maxReported) {\n\t\t\tmessage += `\\n\\n\\n... and ${uncoveredLeakingObjs.length - maxReported} more leaking disposables\\n\\n`;\n\t\t}\n\n\t\treturn { leaks: uncoveredLeakingObjs, details: message };\n\t}\n}\n\nexport function setDisposableTracker(tracker: IDisposableTracker | null): void {\n\tdisposableTracker = tracker;\n}\n\nif (TRACK_DISPOSABLES) {\n\tconst __is_disposable_tracked__ = '__is_disposable_tracked__';\n\tsetDisposableTracker(new class implements IDisposableTracker {\n\t\ttrackDisposable(x: IDisposable): void {\n\t\t\tconst stack = new Error('Potentially leaked disposable').stack!;\n\t\t\tsetTimeout(() => {\n\t\t\t\tif (!(x as any)[__is_disposable_tracked__]) {\n\t\t\t\t\tconsole.log(stack);\n\t\t\t\t}\n\t\t\t}, 3000);\n\t\t}\n\n\t\tsetParent(child: IDisposable, parent: IDisposable | null): void {\n\t\t\tif (child && child !== Disposable.None) {\n\t\t\t\ttry {\n\t\t\t\t\t(child as any)[__is_disposable_tracked__] = true;\n\t\t\t\t} catch {\n\t\t\t\t\t// noop\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmarkAsDisposed(disposable: IDisposable): void {\n\t\t\tif (disposable && disposable !== Disposable.None) {\n\t\t\t\ttry {\n\t\t\t\t\t(disposable as any)[__is_disposable_tracked__] = true;\n\t\t\t\t} catch {\n\t\t\t\t\t// noop\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmarkAsSingleton(disposable: IDisposable): void { }\n\t});\n}\n\nexport function trackDisposable<T extends IDisposable>(x: T): T {\n\tdisposableTracker?.trackDisposable(x);\n\treturn x;\n}\n\nexport function markAsDisposed(disposable: IDisposable): void {\n\tdisposableTracker?.markAsDisposed(disposable);\n}\n\nfunction setParentOfDisposable(child: IDisposable, parent: IDisposable | null): void {\n\tdisposableTracker?.setParent(child, parent);\n}\n\nfunction setParentOfDisposables(children: IDisposable[], parent: IDisposable | null): void {\n\tif (!disposableTracker) {\n\t\treturn;\n\t}\n\tfor (const child of children) {\n\t\tdisposableTracker.setParent(child, parent);\n\t}\n}\n\n/**\n * Indicates that the given object is a singleton which does not need to be disposed.\n*/\nexport function markAsSingleton<T extends IDisposable>(singleton: T): T {\n\tdisposableTracker?.markAsSingleton(singleton);\n\treturn singleton;\n}\n\n// #endregion\n\n/**\n * An object that performs a cleanup operation when `.dispose()` is called.\n *\n * Some examples of how disposables are used:\n *\n * - An event listener that removes itself when `.dispose()` is called.\n * - A resource such as a file system watcher that cleans up the resource when `.dispose()` is called.\n * - The return value from registering a provider. When `.dispose()` is called, the provider is unregistered.\n */\nexport interface IDisposable {\n\tdispose(): void;\n}\n\n/**\n * Check if `thing` is {@link IDisposable disposable}.\n */\nexport function isDisposable<E extends object>(thing: E): thing is E & IDisposable {\n\treturn typeof (<IDisposable>thing).dispose === 'function' && (<IDisposable>thing).dispose.length === 0;\n}\n\n/**\n * Disposes of the value(s) passed in.\n */\nexport function dispose<T extends IDisposable>(disposable: T): T;\nexport function dispose<T extends IDisposable>(disposable: T | undefined): T | undefined;\nexport function dispose<T extends IDisposable, A extends Iterable<T> = Iterable<T>>(disposables: A): A;\nexport function dispose<T extends IDisposable>(disposables: Array<T>): Array<T>;\nexport function dispose<T extends IDisposable>(disposables: ReadonlyArray<T>): ReadonlyArray<T>;\nexport function dispose<T extends IDisposable>(arg: T | Iterable<T> | undefined): any {\n\tif (Iterable.is(arg)) {\n\t\tconst errors: any[] = [];\n\n\t\tfor (const d of arg) {\n\t\t\tif (d) {\n\t\t\t\ttry {\n\t\t\t\t\td.dispose();\n\t\t\t\t} catch (e) {\n\t\t\t\t\terrors.push(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (errors.length === 1) {\n\t\t\tthrow errors[0];\n\t\t} else if (errors.length > 1) {\n\t\t\tthrow new AggregateError(errors, 'Encountered errors while disposing of store');\n\t\t}\n\n\t\treturn Array.isArray(arg) ? [] : arg;\n\t} else if (arg) {\n\t\targ.dispose();\n\t\treturn arg;\n\t}\n}\n\nexport function disposeIfDisposable<T extends IDisposable | object>(disposables: Array<T>): Array<T> {\n\tfor (const d of disposables) {\n\t\tif (isDisposable(d)) {\n\t\t\td.dispose();\n\t\t}\n\t}\n\treturn [];\n}\n\n/**\n * Combine multiple disposable values into a single {@link IDisposable}.\n */\nexport function combinedDisposable(...disposables: IDisposable[]): IDisposable {\n\tconst parent = toDisposable(() => dispose(disposables));\n\tsetParentOfDisposables(disposables, parent);\n\treturn parent;\n}\n\n/**\n * Turn a function that implements dispose into an {@link IDisposable}.\n *\n * @param fn Clean up function, guaranteed to be called only **once**.\n */\nexport function toDisposable(fn: () => void): IDisposable {\n\tconst self = trackDisposable({\n\t\tdispose: once(() => {\n\t\t\tmarkAsDisposed(self);\n\t\t\tfn();\n\t\t})\n\t});\n\treturn self;\n}\n\n/**\n * Manages a collection of disposable values.\n *\n * This is the preferred way to manage multiple disposables. A `DisposableStore` is safer to work with than an\n * `IDisposable[]` as it considers edge cases, such as registering the same value multiple times or adding an item to a\n * store that has already been disposed of.\n */\nexport class DisposableStore implements IDisposable {\n\n\tstatic DISABLE_DISPOSED_WARNING = false;\n\n\tprivate readonly _toDispose = new Set<IDisposable>();\n\tprivate _isDisposed = false;\n\n\tconstructor() {\n\t\ttrackDisposable(this);\n\t}\n\n\t/**\n\t * Dispose of all registered disposables and mark this object as disposed.\n\t *\n\t * Any future disposables added to this object will be disposed of on `add`.\n\t */\n\tpublic dispose(): void {\n\t\tif (this._isDisposed) {\n\t\t\treturn;\n\t\t}\n\n\t\tmarkAsDisposed(this);\n\t\tthis._isDisposed = true;\n\t\tthis.clear();\n\t}\n\n\t/**\n\t * @return `true` if this object has been disposed of.\n\t */\n\tpublic get isDisposed(): boolean {\n\t\treturn this._isDisposed;\n\t}\n\n\t/**\n\t * Dispose of all registered disposables but do not mark this object as disposed.\n\t */\n\tpublic clear(): void {\n\t\tif (this._toDispose.size === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tdispose(this._toDispose);\n\t\t} finally {\n\t\t\tthis._toDispose.clear();\n\t\t}\n\t}\n\n\t/**\n\t * Add a new {@link IDisposable disposable} to the collection.\n\t */\n\tpublic add<T extends IDisposable>(o: T): T {\n\t\tif (!o) {\n\t\t\treturn o;\n\t\t}\n\t\tif ((o as unknown as DisposableStore) === this) {\n\t\t\tthrow new Error('Cannot register a disposable on itself!');\n\t\t}\n\n\t\tsetParentOfDisposable(o, this);\n\t\tif (this._isDisposed) {\n\t\t\tif (!DisposableStore.DISABLE_DISPOSED_WARNING) {\n\t\t\t\tconsole.warn(new Error('Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!').stack);\n\t\t\t}\n\t\t} else {\n\t\t\tthis._toDispose.add(o);\n\t\t}\n\n\t\treturn o;\n\t}\n}\n\n/**\n * Abstract base class for a {@link IDisposable disposable} object.\n *\n * Subclasses can {@linkcode _register} disposables that will be automatically cleaned up when this object is disposed of.\n */\nexport abstract class Disposable implements IDisposable {\n\n\t/**\n\t * A disposable that does nothing when it is disposed of.\n\t *\n\t * TODO: This should not be a static property.\n\t */\n\tstatic readonly None = Object.freeze<IDisposable>({ dispose() { } });\n\n\tprotected readonly _store = new DisposableStore();\n\n\tconstructor() {\n\t\ttrackDisposable(this);\n\t\tsetParentOfDisposable(this._store, this);\n\t}\n\n\tpublic dispose(): void {\n\t\tmarkAsDisposed(this);\n\n\t\tthis._store.dispose();\n\t}\n\n\t/**\n\t * Adds `o` to the collection of disposables managed by this object.\n\t */\n\tprotected _register<T extends IDisposable>(o: T): T {\n\t\tif ((o as unknown as Disposable) === this) {\n\t\t\tthrow new Error('Cannot register a disposable on itself!');\n\t\t}\n\t\treturn this._store.add(o);\n\t}\n}\n\n/**\n * Manages the lifecycle of a disposable value that may be changed.\n *\n * This ensures that when the disposable value is changed, the previously held disposable is disposed of. You can\n * also register a `MutableDisposable` on a `Disposable` to ensure it is automatically cleaned up.\n */\nexport class MutableDisposable<T extends IDisposable> implements IDisposable {\n\tprivate _value?: T;\n\tprivate _isDisposed = false;\n\n\tconstructor() {\n\t\ttrackDisposable(this);\n\t}\n\n\tget value(): T | undefined {\n\t\treturn this._isDisposed ? undefined : this._value;\n\t}\n\n\tset value(value: T | undefined) {\n\t\tif (this._isDisposed || value === this._value) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._value?.dispose();\n\t\tif (value) {\n\t\t\tsetParentOfDisposable(value, this);\n\t\t}\n\t\tthis._value = value;\n\t}\n\n\t/**\n\t * Resets the stored value and disposed of the previously stored value.\n\t */\n\tclear(): void {\n\t\tthis.value = undefined;\n\t}\n\n\tdispose(): void {\n\t\tthis._isDisposed = true;\n\t\tmarkAsDisposed(this);\n\t\tthis._value?.dispose();\n\t\tthis._value = undefined;\n\t}\n\n\t/**\n\t * Clears the value, but does not dispose it.\n\t * The old value is returned.\n\t*/\n\tclearAndLeak(): T | undefined {\n\t\tconst oldValue = this._value;\n\t\tthis._value = undefined;\n\t\tif (oldValue) {\n\t\t\tsetParentOfDisposable(oldValue, null);\n\t\t}\n\t\treturn oldValue;\n\t}\n}\n\nexport class RefCountedDisposable {\n\n\tprivate _counter: number = 1;\n\n\tconstructor(\n\t\tprivate readonly _disposable: IDisposable,\n\t) { }\n\n\tacquire() {\n\t\tthis._counter++;\n\t\treturn this;\n\t}\n\n\trelease() {\n\t\tif (--this._counter === 0) {\n\t\t\tthis._disposable.dispose();\n\t\t}\n\t\treturn this;\n\t}\n}\n\n/**\n * A safe disposable can be `unset` so that a leaked reference (listener)\n * can be cut-off.\n */\nexport class SafeDisposable implements IDisposable {\n\n\tdispose: () => void = () => { };\n\tunset: () => void = () => { };\n\tisset: () => boolean = () => false;\n\n\tconstructor() {\n\t\ttrackDisposable(this);\n\t}\n\n\tset(fn: Function) {\n\t\tlet callback: Function | undefined = fn;\n\t\tthis.unset = () => callback = undefined;\n\t\tthis.isset = () => callback !== undefined;\n\t\tthis.dispose = () => {\n\t\t\tif (callback) {\n\t\t\t\tcallback();\n\t\t\t\tcallback = undefined;\n\t\t\t\tmarkAsDisposed(this);\n\t\t\t}\n\t\t};\n\t\treturn this;\n\t}\n}\n\nexport interface IReference<T> extends IDisposable {\n\treadonly object: T;\n}\n\nexport abstract class ReferenceCollection<T> {\n\n\tprivate readonly references: Map<string, { readonly object: T; counter: number }> = new Map();\n\n\tacquire(key: string, ...args: any[]): IReference<T> {\n\t\tlet reference = this.references.get(key);\n\n\t\tif (!reference) {\n\t\t\treference = { counter: 0, object: this.createReferencedObject(key, ...args) };\n\t\t\tthis.references.set(key, reference);\n\t\t}\n\n\t\tconst { object } = reference;\n\t\tconst dispose = once(() => {\n\t\t\tif (--reference!.counter === 0) {\n\t\t\t\tthis.destroyReferencedObject(key, reference!.object);\n\t\t\t\tthis.references.delete(key);\n\t\t\t}\n\t\t});\n\n\t\treference.counter++;\n\n\t\treturn { object, dispose };\n\t}\n\n\tprotected abstract createReferencedObject(key: string, ...args: any[]): T;\n\tprotected abstract destroyReferencedObject(key: string, object: T): void;\n}\n\n/**\n * Unwraps a reference collection of promised values. Makes sure\n * references are disposed whenever promises get rejected.\n */\nexport class AsyncReferenceCollection<T> {\n\n\tconstructor(private referenceCollection: ReferenceCollection<Promise<T>>) { }\n\n\tasync acquire(key: string, ...args: any[]): Promise<IReference<T>> {\n\t\tconst ref = this.referenceCollection.acquire(key, ...args);\n\n\t\ttry {\n\t\t\tconst object = await ref.object;\n\n\t\t\treturn {\n\t\t\t\tobject,\n\t\t\t\tdispose: () => ref.dispose()\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tref.dispose();\n\t\t\tthrow error;\n\t\t}\n\t}\n}\n\nexport class ImmortalReference<T> implements IReference<T> {\n\tconstructor(public object: T) { }\n\tdispose(): void { /* noop */ }\n}\n\nexport function disposeOnReturn(fn: (store: DisposableStore) => void): void {\n\tconst store = new DisposableStore();\n\ttry {\n\t\tfn(store);\n\t} finally {\n\t\tstore.dispose();\n\t}\n}\n\n/**\n * A map the manages the lifecycle of the values that it stores.\n */\nexport class DisposableMap<K, V extends IDisposable = IDisposable> implements IDisposable {\n\n\tprivate readonly _store = new Map<K, V>();\n\tprivate _isDisposed = false;\n\n\tconstructor() {\n\t\ttrackDisposable(this);\n\t}\n\n\t/**\n\t * Disposes of all stored values and mark this object as disposed.\n\t *\n\t * Trying to use this object after it has been disposed of is an error.\n\t */\n\tdispose(): void {\n\t\tmarkAsDisposed(this);\n\t\tthis._isDisposed = true;\n\t\tthis.clearAndDisposeAll();\n\t}\n\n\t/**\n\t * Disposes of all stored values and clear the map, but DO NOT mark this object as disposed.\n\t */\n\tclearAndDisposeAll(): void {\n\t\tif (!this._store.size) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tdispose(this._store.values());\n\t\t} finally {\n\t\t\tthis._store.clear();\n\t\t}\n\t}\n\n\thas(key: K): boolean {\n\t\treturn this._store.has(key);\n\t}\n\n\tget size(): number {\n\t\treturn this._store.size;\n\t}\n\n\tget(key: K): V | undefined {\n\t\treturn this._store.get(key);\n\t}\n\n\tset(key: K, value: V, skipDisposeOnOverwrite = false): void {\n\t\tif (this._isDisposed) {\n\t\t\tconsole.warn(new Error('Trying to add a disposable to a DisposableMap that has already been disposed of. The added object will be leaked!').stack);\n\t\t}\n\n\t\tif (!skipDisposeOnOverwrite) {\n\t\t\tthis._store.get(key)?.dispose();\n\t\t}\n\n\t\tthis._store.set(key, value);\n\t}\n\n\t/**\n\t * Delete the value stored for `key` from this map and also dispose of it.\n\t */\n\tdeleteAndDispose(key: K): void {\n\t\tthis._store.get(key)?.dispose();\n\t\tthis._store.delete(key);\n\t}\n\n\t[Symbol.iterator](): IterableIterator<[K, V]> {\n\t\treturn this._store[Symbol.iterator]();\n\t}\n}\n"]}