{"version":3,"sources":["file:///workspace/appflow/src/vs/base/common/dataTransfer.ts"],"names":[],"mappings":"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","file":"dataTransfer.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { distinct } from 'vs/base/common/arrays';\nimport { Iterable } from 'vs/base/common/iterator';\nimport { URI } from 'vs/base/common/uri';\nimport { generateUuid } from 'vs/base/common/uuid';\n\nexport interface IDataTransferFile {\n\treadonly id: string;\n\treadonly name: string;\n\treadonly uri?: URI;\n\tdata(): Promise<Uint8Array>;\n}\n\nexport interface IDataTransferItem {\n\tasString(): Thenable<string>;\n\tasFile(): IDataTransferFile | undefined;\n\tvalue: any;\n}\n\nexport function createStringDataTransferItem(stringOrPromise: string | Promise<string>): IDataTransferItem {\n\treturn {\n\t\tasString: async () => stringOrPromise,\n\t\tasFile: () => undefined,\n\t\tvalue: typeof stringOrPromise === 'string' ? stringOrPromise : undefined,\n\t};\n}\n\nexport function createFileDataTransferItem(fileName: string, uri: URI | undefined, data: () => Promise<Uint8Array>): IDataTransferItem {\n\tconst file = { id: generateUuid(), name: fileName, uri, data };\n\treturn {\n\t\tasString: async () => '',\n\t\tasFile: () => file,\n\t\tvalue: undefined,\n\t};\n}\n\nexport interface IReadonlyVSDataTransfer extends Iterable<readonly [string, IDataTransferItem]> {\n\t/**\n\t * Get the total number of entries in this data transfer.\n\t */\n\tget size(): number;\n\n\t/**\n\t * Check if this data transfer contains data for `mimeType`.\n\t *\n\t * This uses exact matching and does not support wildcards.\n\t */\n\thas(mimeType: string): boolean;\n\t/**\n\t * Check if this data transfer contains data matching `pattern`.\n\t *\n\t * This allows matching for wildcards, such as `image/*`.\n\t *\n\t * Use the special `files` mime type to match any file in the data transfer.\n\t */\n\tmatches(pattern: string): boolean;\n\n\t/**\n\t * Retrieve the first entry for `mimeType`.\n\t *\n\t * Note that if you want to find all entries for a given mime type, use {@link IReadonlyVSDataTransfer.entries} instead.\n\t */\n\tget(mimeType: string): IDataTransferItem | undefined;\n}\n\nexport class VSDataTransfer implements IReadonlyVSDataTransfer {\n\n\tprivate readonly _entries = new Map<string, IDataTransferItem[]>();\n\n\tpublic get size(): number {\n\t\tlet size = 0;\n\t\tfor (const _ of this._entries) {\n\t\t\tsize++;\n\t\t}\n\t\treturn size;\n\t}\n\n\tpublic has(mimeType: string): boolean {\n\t\treturn this._entries.has(this.toKey(mimeType));\n\t}\n\n\tpublic matches(pattern: string): boolean {\n\t\tconst mimes = [...this._entries.keys()];\n\t\tif (Iterable.some(this, ([_, item]) => item.asFile())) {\n\t\t\tmimes.push('files');\n\t\t}\n\n\t\treturn matchesMimeType_normalized(normalizeMimeType(pattern), mimes);\n\t}\n\n\tpublic get(mimeType: string): IDataTransferItem | undefined {\n\t\treturn this._entries.get(this.toKey(mimeType))?.[0];\n\t}\n\n\t/**\n\t * Add a new entry to this data transfer.\n\t *\n\t * This does not replace existing entries for `mimeType`.\n\t */\n\tpublic append(mimeType: string, value: IDataTransferItem): void {\n\t\tconst existing = this._entries.get(mimeType);\n\t\tif (existing) {\n\t\t\texisting.push(value);\n\t\t} else {\n\t\t\tthis._entries.set(this.toKey(mimeType), [value]);\n\t\t}\n\t}\n\n\t/**\n\t * Set the entry for a given mime type.\n\t *\n\t * This replaces all existing entries for `mimeType`.\n\t */\n\tpublic replace(mimeType: string, value: IDataTransferItem): void {\n\t\tthis._entries.set(this.toKey(mimeType), [value]);\n\t}\n\n\t/**\n\t * Remove all entries for `mimeType`.\n\t */\n\tpublic delete(mimeType: string) {\n\t\tthis._entries.delete(this.toKey(mimeType));\n\t}\n\n\t/**\n\t * Iterate over all `[mime, item]` pairs in this data transfer.\n\t *\n\t * There may be multiple entries for each mime type.\n\t */\n\tpublic *[Symbol.iterator](): IterableIterator<readonly [string, IDataTransferItem]> {\n\t\tfor (const [mine, items] of this._entries) {\n\t\t\tfor (const item of items) {\n\t\t\t\tyield [mine, item];\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate toKey(mimeType: string): string {\n\t\treturn normalizeMimeType(mimeType);\n\t}\n}\n\nfunction normalizeMimeType(mimeType: string): string {\n\treturn mimeType.toLowerCase();\n}\n\nexport function matchesMimeType(pattern: string, mimeTypes: readonly string[]): boolean {\n\treturn matchesMimeType_normalized(\n\t\tnormalizeMimeType(pattern),\n\t\tmimeTypes.map(normalizeMimeType));\n}\n\nfunction matchesMimeType_normalized(normalizedPattern: string, normalizedMimeTypes: readonly string[]): boolean {\n\t// Anything wildcard\n\tif (normalizedPattern === '*/*') {\n\t\treturn normalizedMimeTypes.length > 0;\n\t}\n\n\t// Exact match\n\tif (normalizedMimeTypes.includes(normalizedPattern)) {\n\t\treturn true;\n\t}\n\n\t// Wildcard, such as `image/*`\n\tconst wildcard = normalizedPattern.match(/^([a-z]+)\\/([a-z]+|\\*)$/i);\n\tif (!wildcard) {\n\t\treturn false;\n\t}\n\n\tconst [_, type, subtype] = wildcard;\n\tif (subtype === '*') {\n\t\treturn normalizedMimeTypes.some(mime => mime.startsWith(type + '/'));\n\t}\n\n\treturn false;\n}\n\n\nexport const UriList = Object.freeze({\n\t// http://amundsen.com/hypermedia/urilist/\n\tcreate: (entries: ReadonlyArray<string | URI>): string => {\n\t\treturn distinct(entries.map(x => x.toString())).join('\\r\\n');\n\t},\n\tsplit: (str: string): string[] => {\n\t\treturn str.split('\\r\\n');\n\t},\n\tparse: (str: string): string[] => {\n\t\treturn UriList.split(str).filter(value => !value.startsWith('#'));\n\t}\n});\n"]}