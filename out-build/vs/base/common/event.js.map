{"version":3,"sources":["file:///workspace/appflow/src/vs/base/common/event.ts"],"names":[],"mappings":"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","file":"event.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken } from 'vs/base/common/cancellation';\nimport { onUnexpectedError } from 'vs/base/common/errors';\nimport { once as onceFn } from 'vs/base/common/functional';\nimport { combinedDisposable, Disposable, DisposableMap, DisposableStore, IDisposable, toDisposable } from 'vs/base/common/lifecycle';\nimport { LinkedList } from 'vs/base/common/linkedList';\nimport { IObservable, IObserver } from 'vs/base/common/observable';\nimport { StopWatch } from 'vs/base/common/stopwatch';\nimport { MicrotaskDelay } from 'vs/base/common/symbols';\n\n\n// -----------------------------------------------------------------------------------------------------------------------\n// Uncomment the next line to print warnings whenever an emitter with listeners is disposed. That is a sign of code smell.\n// -----------------------------------------------------------------------------------------------------------------------\nconst _enableDisposeWithListenerWarning = false;\n// _enableDisposeWithListenerWarning = Boolean(\"TRUE\"); // causes a linter warning so that it cannot be pushed\n\n\n// -----------------------------------------------------------------------------------------------------------------------\n// Uncomment the next line to print warnings whenever a snapshotted event is used repeatedly without cleanup.\n// See https://github.com/microsoft/vscode/issues/142851\n// -----------------------------------------------------------------------------------------------------------------------\nconst _enableSnapshotPotentialLeakWarning = false;\n// _enableSnapshotPotentialLeakWarning = Boolean(\"TRUE\"); // causes a linter warning so that it cannot be pushed\n\n/**\n * An event with zero or one parameters that can be subscribed to. The event is a function itself.\n */\nexport interface Event<T> {\n\t(listener: (e: T) => any, thisArgs?: any, disposables?: IDisposable[] | DisposableStore): IDisposable;\n}\n\nexport namespace Event {\n\texport const None: Event<any> = () => Disposable.None;\n\n\tfunction _addLeakageTraceLogic(options: EmitterOptions) {\n\t\tif (_enableSnapshotPotentialLeakWarning) {\n\t\t\tconst { onDidAddListener: origListenerDidAdd } = options;\n\t\t\tconst stack = Stacktrace.create();\n\t\t\tlet count = 0;\n\t\t\toptions.onDidAddListener = () => {\n\t\t\t\tif (++count === 2) {\n\t\t\t\t\tconsole.warn('snapshotted emitter LIKELY used public and SHOULD HAVE BEEN created with DisposableStore. snapshotted here');\n\t\t\t\t\tstack.print();\n\t\t\t\t}\n\t\t\t\torigListenerDidAdd?.();\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * Given an event, returns another event which debounces calls and defers the listeners to a later task via a shared\n\t * `setTimeout`. The event is converted into a signal (`Event<void>`) to avoid additional object creation as a\n\t * result of merging events and to try prevent race conditions that could arise when using related deferred and\n\t * non-deferred events.\n\t *\n\t * This is useful for deferring non-critical work (eg. general UI updates) to ensure it does not block critical work\n\t * (eg. latency of keypress to text rendered).\n\t *\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t *\n\t * @param event The event source for the new event.\n\t * @param disposable A disposable store to add the new EventEmitter to.\n\t */\n\texport function defer(event: Event<unknown>, disposable?: DisposableStore): Event<void> {\n\t\treturn debounce<unknown, void>(event, () => void 0, 0, undefined, true, undefined, disposable);\n\t}\n\n\t/**\n\t * Given an event, returns another event which only fires once.\n\t *\n\t * @param event The event source for the new event.\n\t */\n\texport function once<T>(event: Event<T>): Event<T> {\n\t\treturn (listener, thisArgs = null, disposables?) => {\n\t\t\t// we need this, in case the event fires during the listener call\n\t\t\tlet didFire = false;\n\t\t\tlet result: IDisposable | undefined = undefined;\n\t\t\tresult = event(e => {\n\t\t\t\tif (didFire) {\n\t\t\t\t\treturn;\n\t\t\t\t} else if (result) {\n\t\t\t\t\tresult.dispose();\n\t\t\t\t} else {\n\t\t\t\t\tdidFire = true;\n\t\t\t\t}\n\n\t\t\t\treturn listener.call(thisArgs, e);\n\t\t\t}, null, disposables);\n\n\t\t\tif (didFire) {\n\t\t\t\tresult.dispose();\n\t\t\t}\n\n\t\t\treturn result;\n\t\t};\n\t}\n\n\t/**\n\t * Maps an event of one type into an event of another type using a mapping function, similar to how\n\t * `Array.prototype.map` works.\n\t *\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t *\n\t * @param event The event source for the new event.\n\t * @param map The mapping function.\n\t * @param disposable A disposable store to add the new EventEmitter to.\n\t */\n\texport function map<I, O>(event: Event<I>, map: (i: I) => O, disposable?: DisposableStore): Event<O> {\n\t\treturn snapshot((listener, thisArgs = null, disposables?) => event(i => listener.call(thisArgs, map(i)), null, disposables), disposable);\n\t}\n\n\t/**\n\t * Wraps an event in another event that performs some function on the event object before firing.\n\t *\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t *\n\t * @param event The event source for the new event.\n\t * @param each The function to perform on the event object.\n\t * @param disposable A disposable store to add the new EventEmitter to.\n\t */\n\texport function forEach<I>(event: Event<I>, each: (i: I) => void, disposable?: DisposableStore): Event<I> {\n\t\treturn snapshot((listener, thisArgs = null, disposables?) => event(i => { each(i); listener.call(thisArgs, i); }, null, disposables), disposable);\n\t}\n\n\t/**\n\t * Wraps an event in another event that fires only when some condition is met.\n\t *\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t *\n\t * @param event The event source for the new event.\n\t * @param filter The filter function that defines the condition. The event will fire for the object if this function\n\t * returns true.\n\t * @param disposable A disposable store to add the new EventEmitter to.\n\t */\n\texport function filter<T, U>(event: Event<T | U>, filter: (e: T | U) => e is T, disposable?: DisposableStore): Event<T>;\n\texport function filter<T>(event: Event<T>, filter: (e: T) => boolean, disposable?: DisposableStore): Event<T>;\n\texport function filter<T, R>(event: Event<T | R>, filter: (e: T | R) => e is R, disposable?: DisposableStore): Event<R>;\n\texport function filter<T>(event: Event<T>, filter: (e: T) => boolean, disposable?: DisposableStore): Event<T> {\n\t\treturn snapshot((listener, thisArgs = null, disposables?) => event(e => filter(e) && listener.call(thisArgs, e), null, disposables), disposable);\n\t}\n\n\t/**\n\t * Given an event, returns the same event but typed as `Event<void>`.\n\t */\n\texport function signal<T>(event: Event<T>): Event<void> {\n\t\treturn event as Event<any> as Event<void>;\n\t}\n\n\t/**\n\t * Given a collection of events, returns a single event which emits whenever any of the provided events emit.\n\t */\n\texport function any<T>(...events: Event<T>[]): Event<T>;\n\texport function any(...events: Event<any>[]): Event<void>;\n\texport function any<T>(...events: Event<T>[]): Event<T> {\n\t\treturn (listener, thisArgs = null, disposables?) => {\n\t\t\tconst disposable = combinedDisposable(...events.map(event => event(e => listener.call(thisArgs, e))));\n\t\t\treturn addAndReturnDisposable(disposable, disposables);\n\t\t};\n\t}\n\n\t/**\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t */\n\texport function reduce<I, O>(event: Event<I>, merge: (last: O | undefined, event: I) => O, initial?: O, disposable?: DisposableStore): Event<O> {\n\t\tlet output: O | undefined = initial;\n\n\t\treturn map<I, O>(event, e => {\n\t\t\toutput = merge(output, e);\n\t\t\treturn output;\n\t\t}, disposable);\n\t}\n\n\tfunction snapshot<T>(event: Event<T>, disposable: DisposableStore | undefined): Event<T> {\n\t\tlet listener: IDisposable | undefined;\n\n\t\tconst options: EmitterOptions | undefined = {\n\t\t\tonWillAddFirstListener() {\n\t\t\t\tlistener = event(emitter.fire, emitter);\n\t\t\t},\n\t\t\tonDidRemoveLastListener() {\n\t\t\t\tlistener?.dispose();\n\t\t\t}\n\t\t};\n\n\t\tif (!disposable) {\n\t\t\t_addLeakageTraceLogic(options);\n\t\t}\n\n\t\tconst emitter = new Emitter<T>(options);\n\n\t\tdisposable?.add(emitter);\n\n\t\treturn emitter.event;\n\t}\n\n\t/**\n\t * Adds the IDisposable to the store if it's set, and returns it. Useful to\n\t * Event function implementation.\n\t */\n\tfunction addAndReturnDisposable<T extends IDisposable>(d: T, store: DisposableStore | IDisposable[] | undefined): T {\n\t\tif (store instanceof Array) {\n\t\t\tstore.push(d);\n\t\t} else if (store) {\n\t\t\tstore.add(d);\n\t\t}\n\t\treturn d;\n\t}\n\n\t/**\n\t * Given an event, creates a new emitter that event that will debounce events based on {@link delay} and give an\n\t * array event object of all events that fired.\n\t *\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t *\n\t * @param event The original event to debounce.\n\t * @param merge A function that reduces all events into a single event.\n\t * @param delay The number of milliseconds to debounce.\n\t * @param leading Whether to fire a leading event without debouncing.\n\t * @param flushOnListenerRemove Whether to fire all debounced events when a listener is removed. If this is not\n\t * specified, some events could go missing. Use this if it's important that all events are processed, even if the\n\t * listener gets disposed before the debounced event fires.\n\t * @param leakWarningThreshold See {@link EmitterOptions.leakWarningThreshold}.\n\t * @param disposable A disposable store to register the debounce emitter to.\n\t */\n\texport function debounce<T>(event: Event<T>, merge: (last: T | undefined, event: T) => T, delay?: number | typeof MicrotaskDelay, leading?: boolean, flushOnListenerRemove?: boolean, leakWarningThreshold?: number, disposable?: DisposableStore): Event<T>;\n\texport function debounce<I, O>(event: Event<I>, merge: (last: O | undefined, event: I) => O, delay?: number | typeof MicrotaskDelay, leading?: boolean, flushOnListenerRemove?: boolean, leakWarningThreshold?: number, disposable?: DisposableStore): Event<O>;\n\texport function debounce<I, O>(event: Event<I>, merge: (last: O | undefined, event: I) => O, delay: number | typeof MicrotaskDelay = 100, leading = false, flushOnListenerRemove = false, leakWarningThreshold?: number, disposable?: DisposableStore): Event<O> {\n\t\tlet subscription: IDisposable;\n\t\tlet output: O | undefined = undefined;\n\t\tlet handle: any = undefined;\n\t\tlet numDebouncedCalls = 0;\n\t\tlet doFire: (() => void) | undefined;\n\n\t\tconst options: EmitterOptions | undefined = {\n\t\t\tleakWarningThreshold,\n\t\t\tonWillAddFirstListener() {\n\t\t\t\tsubscription = event(cur => {\n\t\t\t\t\tnumDebouncedCalls++;\n\t\t\t\t\toutput = merge(output, cur);\n\n\t\t\t\t\tif (leading && !handle) {\n\t\t\t\t\t\temitter.fire(output);\n\t\t\t\t\t\toutput = undefined;\n\t\t\t\t\t}\n\n\t\t\t\t\tdoFire = () => {\n\t\t\t\t\t\tconst _output = output;\n\t\t\t\t\t\toutput = undefined;\n\t\t\t\t\t\thandle = undefined;\n\t\t\t\t\t\tif (!leading || numDebouncedCalls > 1) {\n\t\t\t\t\t\t\temitter.fire(_output!);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnumDebouncedCalls = 0;\n\t\t\t\t\t};\n\n\t\t\t\t\tif (typeof delay === 'number') {\n\t\t\t\t\t\tclearTimeout(handle);\n\t\t\t\t\t\thandle = setTimeout(doFire, delay);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (handle === undefined) {\n\t\t\t\t\t\t\thandle = 0;\n\t\t\t\t\t\t\tqueueMicrotask(doFire);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t},\n\t\t\tonWillRemoveListener() {\n\t\t\t\tif (flushOnListenerRemove && numDebouncedCalls > 0) {\n\t\t\t\t\tdoFire?.();\n\t\t\t\t}\n\t\t\t},\n\t\t\tonDidRemoveLastListener() {\n\t\t\t\tdoFire = undefined;\n\t\t\t\tsubscription.dispose();\n\t\t\t}\n\t\t};\n\n\t\tif (!disposable) {\n\t\t\t_addLeakageTraceLogic(options);\n\t\t}\n\n\t\tconst emitter = new Emitter<O>(options);\n\n\t\tdisposable?.add(emitter);\n\n\t\treturn emitter.event;\n\t}\n\n\t/**\n\t * Debounces an event, firing after some delay (default=0) with an array of all event original objects.\n\t *\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t */\n\texport function accumulate<T>(event: Event<T>, delay: number = 0, disposable?: DisposableStore): Event<T[]> {\n\t\treturn Event.debounce<T, T[]>(event, (last, e) => {\n\t\t\tif (!last) {\n\t\t\t\treturn [e];\n\t\t\t}\n\t\t\tlast.push(e);\n\t\t\treturn last;\n\t\t}, delay, undefined, true, undefined, disposable);\n\t}\n\n\t/**\n\t * Filters an event such that some condition is _not_ met more than once in a row, effectively ensuring duplicate\n\t * event objects from different sources do not fire the same event object.\n\t *\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t *\n\t * @param event The event source for the new event.\n\t * @param equals The equality condition.\n\t * @param disposable A disposable store to add the new EventEmitter to.\n\t *\n\t * @example\n\t * ```\n\t * // Fire only one time when a single window is opened or focused\n\t * Event.latch(Event.any(onDidOpenWindow, onDidFocusWindow))\n\t * ```\n\t */\n\texport function latch<T>(event: Event<T>, equals: (a: T, b: T) => boolean = (a, b) => a === b, disposable?: DisposableStore): Event<T> {\n\t\tlet firstCall = true;\n\t\tlet cache: T;\n\n\t\treturn filter(event, value => {\n\t\t\tconst shouldEmit = firstCall || !equals(value, cache);\n\t\t\tfirstCall = false;\n\t\t\tcache = value;\n\t\t\treturn shouldEmit;\n\t\t}, disposable);\n\t}\n\n\t/**\n\t * Splits an event whose parameter is a union type into 2 separate events for each type in the union.\n\t *\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t *\n\t * @example\n\t * ```\n\t * const event = new EventEmitter<number | undefined>().event;\n\t * const [numberEvent, undefinedEvent] = Event.split(event, isUndefined);\n\t * ```\n\t *\n\t * @param event The event source for the new event.\n\t * @param isT A function that determines what event is of the first type.\n\t * @param disposable A disposable store to add the new EventEmitter to.\n\t */\n\texport function split<T, U>(event: Event<T | U>, isT: (e: T | U) => e is T, disposable?: DisposableStore): [Event<T>, Event<U>] {\n\t\treturn [\n\t\t\tEvent.filter(event, isT, disposable),\n\t\t\tEvent.filter(event, e => !isT(e), disposable) as Event<U>,\n\t\t];\n\t}\n\n\t/**\n\t * Buffers an event until it has a listener attached.\n\t *\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t *\n\t * @param event The event source for the new event.\n\t * @param flushAfterTimeout Determines whether to flush the buffer after a timeout immediately or after a\n\t * `setTimeout` when the first event listener is added.\n\t * @param _buffer Internal: A source event array used for tests.\n\t *\n\t * @example\n\t * ```\n\t * // Start accumulating events, when the first listener is attached, flush\n\t * // the event after a timeout such that multiple listeners attached before\n\t * // the timeout would receive the event\n\t * this.onInstallExtension = Event.buffer(service.onInstallExtension, true);\n\t * ```\n\t */\n\texport function buffer<T>(event: Event<T>, flushAfterTimeout = false, _buffer: T[] = [], disposable?: DisposableStore): Event<T> {\n\t\tlet buffer: T[] | null = _buffer.slice();\n\n\t\tlet listener: IDisposable | null = event(e => {\n\t\t\tif (buffer) {\n\t\t\t\tbuffer.push(e);\n\t\t\t} else {\n\t\t\t\temitter.fire(e);\n\t\t\t}\n\t\t});\n\n\t\tif (disposable) {\n\t\t\tdisposable.add(listener);\n\t\t}\n\n\t\tconst flush = () => {\n\t\t\tbuffer?.forEach(e => emitter.fire(e));\n\t\t\tbuffer = null;\n\t\t};\n\n\t\tconst emitter = new Emitter<T>({\n\t\t\tonWillAddFirstListener() {\n\t\t\t\tif (!listener) {\n\t\t\t\t\tlistener = event(e => emitter.fire(e));\n\t\t\t\t\tif (disposable) {\n\t\t\t\t\t\tdisposable.add(listener);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tonDidAddFirstListener() {\n\t\t\t\tif (buffer) {\n\t\t\t\t\tif (flushAfterTimeout) {\n\t\t\t\t\t\tsetTimeout(flush);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tflush();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tonDidRemoveLastListener() {\n\t\t\t\tif (listener) {\n\t\t\t\t\tlistener.dispose();\n\t\t\t\t}\n\t\t\t\tlistener = null;\n\t\t\t}\n\t\t});\n\n\t\tif (disposable) {\n\t\t\tdisposable.add(emitter);\n\t\t}\n\n\t\treturn emitter.event;\n\t}\n\t/**\n\t * Wraps the event in an {@link IChainableEvent}, allowing a more functional programming style.\n\t *\n\t * @example\n\t * ```\n\t * // Normal\n\t * const onEnterPressNormal = Event.filter(\n\t *   Event.map(onKeyPress.event, e => new StandardKeyboardEvent(e)),\n\t *   e.keyCode === KeyCode.Enter\n\t * ).event;\n\t *\n\t * // Using chain\n\t * const onEnterPressChain = Event.chain(onKeyPress.event, $ => $\n\t *   .map(e => new StandardKeyboardEvent(e))\n\t *   .filter(e => e.keyCode === KeyCode.Enter)\n\t * );\n\t * ```\n\t */\n\texport function chain<T, R>(event: Event<T>, sythensize: ($: IChainableSythensis<T>) => IChainableSythensis<R>): Event<R> {\n\t\tconst fn: Event<R> = (listener, thisArgs, disposables) => {\n\t\t\tconst cs = sythensize(new ChainableSynthesis()) as ChainableSynthesis;\n\t\t\treturn event(function (value) {\n\t\t\t\tconst result = cs.evaluate(value);\n\t\t\t\tif (result !== HaltChainable) {\n\t\t\t\t\tlistener.call(thisArgs, result);\n\t\t\t\t}\n\t\t\t}, undefined, disposables);\n\t\t};\n\n\t\treturn fn;\n\t}\n\n\tconst HaltChainable = Symbol('HaltChainable');\n\n\tclass ChainableSynthesis implements IChainableSythensis<any> {\n\t\tprivate readonly steps: ((input: any) => any)[] = [];\n\n\t\tmap<O>(fn: (i: any) => O): this {\n\t\t\tthis.steps.push(fn);\n\t\t\treturn this;\n\t\t}\n\n\t\tforEach(fn: (i: any) => void): this {\n\t\t\tthis.steps.push(v => {\n\t\t\t\tfn(v);\n\t\t\t\treturn v;\n\t\t\t});\n\t\t\treturn this;\n\t\t}\n\n\t\tfilter(fn: (e: any) => boolean): this {\n\t\t\tthis.steps.push(v => fn(v) ? v : HaltChainable);\n\t\t\treturn this;\n\t\t}\n\n\t\treduce<R>(merge: (last: R | undefined, event: any) => R, initial?: R | undefined): this {\n\t\t\tlet last = initial;\n\t\t\tthis.steps.push(v => {\n\t\t\t\tlast = merge(last, v);\n\t\t\t\treturn last;\n\t\t\t});\n\t\t\treturn this;\n\t\t}\n\n\t\tlatch(equals: (a: any, b: any) => boolean = (a, b) => a === b): ChainableSynthesis {\n\t\t\tlet firstCall = true;\n\t\t\tlet cache: any;\n\t\t\tthis.steps.push(value => {\n\t\t\t\tconst shouldEmit = firstCall || !equals(value, cache);\n\t\t\t\tfirstCall = false;\n\t\t\t\tcache = value;\n\t\t\t\treturn shouldEmit ? value : HaltChainable;\n\t\t\t});\n\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic evaluate(value: any) {\n\t\t\tfor (const step of this.steps) {\n\t\t\t\tvalue = step(value);\n\t\t\t\tif (value === HaltChainable) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn value;\n\t\t}\n\t}\n\n\texport interface IChainableSythensis<T> {\n\t\tmap<O>(fn: (i: T) => O): IChainableSythensis<O>;\n\t\tforEach(fn: (i: T) => void): IChainableSythensis<T>;\n\t\tfilter(fn: (e: T) => boolean): IChainableSythensis<T>;\n\t\tfilter<R>(fn: (e: T | R) => e is R): IChainableSythensis<R>;\n\t\treduce<R>(merge: (last: R, event: T) => R, initial: R): IChainableSythensis<R>;\n\t\treduce<R>(merge: (last: R | undefined, event: T) => R): IChainableSythensis<R>;\n\t\tlatch(equals?: (a: T, b: T) => boolean): IChainableSythensis<T>;\n\t}\n\n\texport interface NodeEventEmitter {\n\t\ton(event: string | symbol, listener: Function): unknown;\n\t\tremoveListener(event: string | symbol, listener: Function): unknown;\n\t}\n\n\t/**\n\t * Creates an {@link Event} from a node event emitter.\n\t */\n\texport function fromNodeEventEmitter<T>(emitter: NodeEventEmitter, eventName: string, map: (...args: any[]) => T = id => id): Event<T> {\n\t\tconst fn = (...args: any[]) => result.fire(map(...args));\n\t\tconst onFirstListenerAdd = () => emitter.on(eventName, fn);\n\t\tconst onLastListenerRemove = () => emitter.removeListener(eventName, fn);\n\t\tconst result = new Emitter<T>({ onWillAddFirstListener: onFirstListenerAdd, onDidRemoveLastListener: onLastListenerRemove });\n\n\t\treturn result.event;\n\t}\n\n\texport interface DOMEventEmitter {\n\t\taddEventListener(event: string | symbol, listener: Function): void;\n\t\tremoveEventListener(event: string | symbol, listener: Function): void;\n\t}\n\n\t/**\n\t * Creates an {@link Event} from a DOM event emitter.\n\t */\n\texport function fromDOMEventEmitter<T>(emitter: DOMEventEmitter, eventName: string, map: (...args: any[]) => T = id => id): Event<T> {\n\t\tconst fn = (...args: any[]) => result.fire(map(...args));\n\t\tconst onFirstListenerAdd = () => emitter.addEventListener(eventName, fn);\n\t\tconst onLastListenerRemove = () => emitter.removeEventListener(eventName, fn);\n\t\tconst result = new Emitter<T>({ onWillAddFirstListener: onFirstListenerAdd, onDidRemoveLastListener: onLastListenerRemove });\n\n\t\treturn result.event;\n\t}\n\n\t/**\n\t * Creates a promise out of an event, using the {@link Event.once} helper.\n\t */\n\texport function toPromise<T>(event: Event<T>): Promise<T> {\n\t\treturn new Promise(resolve => once(event)(resolve));\n\t}\n\n\t/**\n\t * Creates an event out of a promise that fires once when the promise is\n\t * resolved with the result of the promise or `undefined`.\n\t */\n\texport function fromPromise<T>(promise: Promise<T>): Event<T | undefined> {\n\t\tconst result = new Emitter<T | undefined>();\n\n\t\tpromise.then(res => {\n\t\t\tresult.fire(res);\n\t\t}, () => {\n\t\t\tresult.fire(undefined);\n\t\t}).finally(() => {\n\t\t\tresult.dispose();\n\t\t});\n\n\t\treturn result.event;\n\t}\n\n\t/**\n\t * Adds a listener to an event and calls the listener immediately with undefined as the event object.\n\t *\n\t * @example\n\t * ```\n\t * // Initialize the UI and update it when dataChangeEvent fires\n\t * runAndSubscribe(dataChangeEvent, () => this._updateUI());\n\t * ```\n\t */\n\texport function runAndSubscribe<T>(event: Event<T>, handler: (e: T | undefined) => any): IDisposable {\n\t\thandler(undefined);\n\t\treturn event(e => handler(e));\n\t}\n\n\t/**\n\t * Adds a listener to an event and calls the listener immediately with undefined as the event object. A new\n\t * {@link DisposableStore} is passed to the listener which is disposed when the returned disposable is disposed.\n\t */\n\texport function runAndSubscribeWithStore<T>(event: Event<T>, handler: (e: T | undefined, disposableStore: DisposableStore) => any): IDisposable {\n\t\tlet store: DisposableStore | null = null;\n\n\t\tfunction run(e: T | undefined) {\n\t\t\tstore?.dispose();\n\t\t\tstore = new DisposableStore();\n\t\t\thandler(e, store);\n\t\t}\n\n\t\trun(undefined);\n\t\tconst disposable = event(e => run(e));\n\t\treturn toDisposable(() => {\n\t\t\tdisposable.dispose();\n\t\t\tstore?.dispose();\n\t\t});\n\t}\n\n\tclass EmitterObserver<T> implements IObserver {\n\n\t\treadonly emitter: Emitter<T>;\n\n\t\tprivate _counter = 0;\n\t\tprivate _hasChanged = false;\n\n\t\tconstructor(readonly _observable: IObservable<T, any>, store: DisposableStore | undefined) {\n\t\t\tconst options: EmitterOptions = {\n\t\t\t\tonWillAddFirstListener: () => {\n\t\t\t\t\t_observable.addObserver(this);\n\t\t\t\t},\n\t\t\t\tonDidRemoveLastListener: () => {\n\t\t\t\t\t_observable.removeObserver(this);\n\t\t\t\t}\n\t\t\t};\n\t\t\tif (!store) {\n\t\t\t\t_addLeakageTraceLogic(options);\n\t\t\t}\n\t\t\tthis.emitter = new Emitter<T>(options);\n\t\t\tif (store) {\n\t\t\t\tstore.add(this.emitter);\n\t\t\t}\n\t\t}\n\n\t\tbeginUpdate<T>(_observable: IObservable<T, void>): void {\n\t\t\t// assert(_observable === this.obs);\n\t\t\tthis._counter++;\n\t\t}\n\n\t\thandlePossibleChange<T>(_observable: IObservable<T, unknown>): void {\n\t\t\t// assert(_observable === this.obs);\n\t\t}\n\n\t\thandleChange<T, TChange>(_observable: IObservable<T, TChange>, _change: TChange): void {\n\t\t\t// assert(_observable === this.obs);\n\t\t\tthis._hasChanged = true;\n\t\t}\n\n\t\tendUpdate<T>(_observable: IObservable<T, void>): void {\n\t\t\t// assert(_observable === this.obs);\n\t\t\tthis._counter--;\n\t\t\tif (this._counter === 0) {\n\t\t\t\tthis._observable.reportChanges();\n\t\t\t\tif (this._hasChanged) {\n\t\t\t\t\tthis._hasChanged = false;\n\t\t\t\t\tthis.emitter.fire(this._observable.get());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Creates an event emitter that is fired when the observable changes.\n\t * Each listeners subscribes to the emitter.\n\t */\n\texport function fromObservable<T>(obs: IObservable<T, any>, store?: DisposableStore): Event<T> {\n\t\tconst observer = new EmitterObserver(obs, store);\n\t\treturn observer.emitter.event;\n\t}\n\n\t/**\n\t * Each listener is attached to the observable directly.\n\t */\n\texport function fromObservableLight(observable: IObservable<any>): Event<void> {\n\t\treturn (listener) => {\n\t\t\tlet count = 0;\n\t\t\tlet didChange = false;\n\t\t\tconst observer: IObserver = {\n\t\t\t\tbeginUpdate() {\n\t\t\t\t\tcount++;\n\t\t\t\t},\n\t\t\t\tendUpdate() {\n\t\t\t\t\tcount--;\n\t\t\t\t\tif (count === 0) {\n\t\t\t\t\t\tobservable.reportChanges();\n\t\t\t\t\t\tif (didChange) {\n\t\t\t\t\t\t\tdidChange = false;\n\t\t\t\t\t\t\tlistener();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\thandlePossibleChange() {\n\t\t\t\t\t// noop\n\t\t\t\t},\n\t\t\t\thandleChange() {\n\t\t\t\t\tdidChange = true;\n\t\t\t\t}\n\t\t\t};\n\t\t\tobservable.addObserver(observer);\n\t\t\tobservable.reportChanges();\n\t\t\treturn {\n\t\t\t\tdispose() {\n\t\t\t\t\tobservable.removeObserver(observer);\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t}\n}\n\nexport interface EmitterOptions {\n\t/**\n\t * Optional function that's called *before* the very first listener is added\n\t */\n\tonWillAddFirstListener?: Function;\n\t/**\n\t * Optional function that's called *after* the very first listener is added\n\t */\n\tonDidAddFirstListener?: Function;\n\t/**\n\t * Optional function that's called after a listener is added\n\t */\n\tonDidAddListener?: Function;\n\t/**\n\t * Optional function that's called *after* remove the very last listener\n\t */\n\tonDidRemoveLastListener?: Function;\n\t/**\n\t * Optional function that's called *before* a listener is removed\n\t */\n\tonWillRemoveListener?: Function;\n\t/**\n\t * Optional function that's called when a listener throws an error. Defaults to\n\t * {@link onUnexpectedError}\n\t */\n\tonListenerError?: (e: any) => void;\n\t/**\n\t * Number of listeners that are allowed before assuming a leak. Default to\n\t * a globally configured value\n\t *\n\t * @see setGlobalLeakWarningThreshold\n\t */\n\tleakWarningThreshold?: number;\n\t/**\n\t * Pass in a delivery queue, which is useful for ensuring\n\t * in order event delivery across multiple emitters.\n\t */\n\tdeliveryQueue?: EventDeliveryQueue;\n\n\t/** ONLY enable this during development */\n\t_profName?: string;\n}\n\n\nexport class EventProfiling {\n\n\tstatic readonly all = new Set<EventProfiling>();\n\n\tprivate static _idPool = 0;\n\n\treadonly name: string;\n\tpublic listenerCount: number = 0;\n\tpublic invocationCount = 0;\n\tpublic elapsedOverall = 0;\n\tpublic durations: number[] = [];\n\n\tprivate _stopWatch?: StopWatch;\n\n\tconstructor(name: string) {\n\t\tthis.name = `${name}_${EventProfiling._idPool++}`;\n\t\tEventProfiling.all.add(this);\n\t}\n\n\tstart(listenerCount: number): void {\n\t\tthis._stopWatch = new StopWatch();\n\t\tthis.listenerCount = listenerCount;\n\t}\n\n\tstop(): void {\n\t\tif (this._stopWatch) {\n\t\t\tconst elapsed = this._stopWatch.elapsed();\n\t\t\tthis.durations.push(elapsed);\n\t\t\tthis.elapsedOverall += elapsed;\n\t\t\tthis.invocationCount += 1;\n\t\t\tthis._stopWatch = undefined;\n\t\t}\n\t}\n}\n\nlet _globalLeakWarningThreshold = -1;\nexport function setGlobalLeakWarningThreshold(n: number): IDisposable {\n\tconst oldValue = _globalLeakWarningThreshold;\n\t_globalLeakWarningThreshold = n;\n\treturn {\n\t\tdispose() {\n\t\t\t_globalLeakWarningThreshold = oldValue;\n\t\t}\n\t};\n}\n\nclass LeakageMonitor {\n\n\tprivate _stacks: Map<string, number> | undefined;\n\tprivate _warnCountdown: number = 0;\n\n\tconstructor(\n\t\treadonly threshold: number,\n\t\treadonly name: string = Math.random().toString(18).slice(2, 5),\n\t) { }\n\n\tdispose(): void {\n\t\tthis._stacks?.clear();\n\t}\n\n\tcheck(stack: Stacktrace, listenerCount: number): undefined | (() => void) {\n\n\t\tconst threshold = this.threshold;\n\t\tif (threshold <= 0 || listenerCount < threshold) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (!this._stacks) {\n\t\t\tthis._stacks = new Map();\n\t\t}\n\t\tconst count = (this._stacks.get(stack.value) || 0);\n\t\tthis._stacks.set(stack.value, count + 1);\n\t\tthis._warnCountdown -= 1;\n\n\t\tif (this._warnCountdown <= 0) {\n\t\t\t// only warn on first exceed and then every time the limit\n\t\t\t// is exceeded by 50% again\n\t\t\tthis._warnCountdown = threshold * 0.5;\n\n\t\t\t// find most frequent listener and print warning\n\t\t\tlet topStack: string | undefined;\n\t\t\tlet topCount: number = 0;\n\t\t\tfor (const [stack, count] of this._stacks) {\n\t\t\t\tif (!topStack || topCount < count) {\n\t\t\t\t\ttopStack = stack;\n\t\t\t\t\ttopCount = count;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconsole.warn(`[${this.name}] potential listener LEAK detected, having ${listenerCount} listeners already. MOST frequent listener (${topCount}):`);\n\t\t\tconsole.warn(topStack!);\n\t\t}\n\n\t\treturn () => {\n\t\t\tconst count = (this._stacks!.get(stack.value) || 0);\n\t\t\tthis._stacks!.set(stack.value, count - 1);\n\t\t};\n\t}\n}\n\nclass Stacktrace {\n\n\tstatic create() {\n\t\treturn new Stacktrace(new Error().stack ?? '');\n\t}\n\n\tprivate constructor(readonly value: string) { }\n\n\tprint() {\n\t\tconsole.warn(this.value.split('\\n').slice(2).join('\\n'));\n\t}\n}\n\nlet id = 0;\nclass UniqueContainer<T> {\n\tstack?: Stacktrace;\n\tpublic id = id++;\n\tconstructor(public readonly value: T) { }\n}\nconst compactionThreshold = 2;\n\ntype ListenerContainer<T> = UniqueContainer<(data: T) => void>;\ntype ListenerOrListeners<T> = (ListenerContainer<T> | undefined)[] | ListenerContainer<T>;\n\nconst forEachListener = <T>(listeners: ListenerOrListeners<T>, fn: (c: ListenerContainer<T>) => void) => {\n\tif (listeners instanceof UniqueContainer) {\n\t\tfn(listeners);\n\t} else {\n\t\tfor (let i = 0; i < listeners.length; i++) {\n\t\t\tconst l = listeners[i];\n\t\t\tif (l) {\n\t\t\t\tfn(l);\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * The Emitter can be used to expose an Event to the public\n * to fire it from the insides.\n * Sample:\n\tclass Document {\n\n\t\tprivate readonly _onDidChange = new Emitter<(value:string)=>any>();\n\n\t\tpublic onDidChange = this._onDidChange.event;\n\n\t\t// getter-style\n\t\t// get onDidChange(): Event<(value:string)=>any> {\n\t\t// \treturn this._onDidChange.event;\n\t\t// }\n\n\t\tprivate _doIt() {\n\t\t\t//...\n\t\t\tthis._onDidChange.fire(value);\n\t\t}\n\t}\n */\nexport class Emitter<T> {\n\n\tprivate readonly _options?: EmitterOptions;\n\tprivate readonly _leakageMon?: LeakageMonitor;\n\tprivate readonly _perfMon?: EventProfiling;\n\tprivate _disposed?: true;\n\tprivate _event?: Event<T>;\n\n\t/**\n\t * A listener, or list of listeners. A single listener is the most common\n\t * for event emitters (#185789), so we optimize that special case to avoid\n\t * wrapping it in an array (just like Node.js itself.)\n\t *\n\t * A list of listeners never 'downgrades' back to a plain function if\n\t * listeners are removed, for two reasons:\n\t *\n\t *  1. That's complicated (especially with the deliveryQueue)\n\t *  2. A listener with >1 listener is likely to have >1 listener again at\n\t *     some point, and swapping between arrays and functions may[citation needed]\n\t *     introduce unnecessary work and garbage.\n\t *\n\t * The array listeners can be 'sparse', to avoid reallocating the array\n\t * whenever any listener is added or removed. If more than `1 / compactionThreshold`\n\t * of the array is empty, only then is it resized.\n\t */\n\tprotected _listeners?: ListenerOrListeners<T>;\n\n\t/**\n\t * Always to be defined if _listeners is an array. It's no longer a true\n\t * queue, but holds the dispatching 'state'. If `fire()` is called on an\n\t * emitter, any work left in the _deliveryQueue is finished first.\n\t */\n\tprivate _deliveryQueue?: EventDeliveryQueuePrivate;\n\tprotected _size = 0;\n\n\tconstructor(options?: EmitterOptions) {\n\t\tthis._options = options;\n\t\tthis._leakageMon = _globalLeakWarningThreshold > 0 || this._options?.leakWarningThreshold ? new LeakageMonitor(this._options?.leakWarningThreshold ?? _globalLeakWarningThreshold) : undefined;\n\t\tthis._perfMon = this._options?._profName ? new EventProfiling(this._options._profName) : undefined;\n\t\tthis._deliveryQueue = this._options?.deliveryQueue as EventDeliveryQueuePrivate | undefined;\n\t}\n\n\tdispose() {\n\t\tif (!this._disposed) {\n\t\t\tthis._disposed = true;\n\n\t\t\t// It is bad to have listeners at the time of disposing an emitter, it is worst to have listeners keep the emitter\n\t\t\t// alive via the reference that's embedded in their disposables. Therefore we loop over all remaining listeners and\n\t\t\t// unset their subscriptions/disposables. Looping and blaming remaining listeners is done on next tick because the\n\t\t\t// the following programming pattern is very popular:\n\t\t\t//\n\t\t\t// const someModel = this._disposables.add(new ModelObject()); // (1) create and register model\n\t\t\t// this._disposables.add(someModel.onDidChange(() => { ... }); // (2) subscribe and register model-event listener\n\t\t\t// ...later...\n\t\t\t// this._disposables.dispose(); disposes (1) then (2): don't warn after (1) but after the \"overall dispose\" is done\n\n\t\t\tif (this._deliveryQueue?.current === this) {\n\t\t\t\tthis._deliveryQueue.reset();\n\t\t\t}\n\t\t\tif (this._listeners) {\n\t\t\t\tif (_enableDisposeWithListenerWarning) {\n\t\t\t\t\tconst listeners = this._listeners;\n\t\t\t\t\tqueueMicrotask(() => {\n\t\t\t\t\t\tforEachListener(listeners, l => l.stack?.print());\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tthis._listeners = undefined;\n\t\t\t\tthis._size = 0;\n\t\t\t}\n\t\t\tthis._options?.onDidRemoveLastListener?.();\n\t\t\tthis._leakageMon?.dispose();\n\t\t}\n\t}\n\n\t/**\n\t * For the public to allow to subscribe\n\t * to events from this Emitter\n\t */\n\tget event(): Event<T> {\n\t\tthis._event ??= (callback: (e: T) => any, thisArgs?: any, disposables?: IDisposable[] | DisposableStore) => {\n\t\t\tif (this._leakageMon && this._size > this._leakageMon.threshold * 3) {\n\t\t\t\tconsole.warn(`[${this._leakageMon.name}] REFUSES to accept new listeners because it exceeded its threshold by far`);\n\t\t\t\treturn Disposable.None;\n\t\t\t}\n\n\t\t\tif (this._disposed) {\n\t\t\t\t// todo: should we warn if a listener is added to a disposed emitter? This happens often\n\t\t\t\treturn Disposable.None;\n\t\t\t}\n\n\t\t\tif (thisArgs) {\n\t\t\t\tcallback = callback.bind(thisArgs);\n\t\t\t}\n\n\t\t\tconst contained = new UniqueContainer(callback);\n\n\t\t\tlet removeMonitor: Function | undefined;\n\t\t\tlet stack: Stacktrace | undefined;\n\t\t\tif (this._leakageMon && this._size >= Math.ceil(this._leakageMon.threshold * 0.2)) {\n\t\t\t\t// check and record this emitter for potential leakage\n\t\t\t\tcontained.stack = Stacktrace.create();\n\t\t\t\tremoveMonitor = this._leakageMon.check(contained.stack, this._size + 1);\n\t\t\t}\n\n\t\t\tif (_enableDisposeWithListenerWarning) {\n\t\t\t\tcontained.stack = stack ?? Stacktrace.create();\n\t\t\t}\n\n\t\t\tif (!this._listeners) {\n\t\t\t\tthis._options?.onWillAddFirstListener?.(this);\n\t\t\t\tthis._listeners = contained;\n\t\t\t\tthis._options?.onDidAddFirstListener?.(this);\n\t\t\t} else if (this._listeners instanceof UniqueContainer) {\n\t\t\t\tthis._deliveryQueue ??= new EventDeliveryQueuePrivate();\n\t\t\t\tthis._listeners = [this._listeners, contained];\n\t\t\t} else {\n\t\t\t\tthis._listeners.push(contained);\n\t\t\t}\n\n\t\t\tthis._size++;\n\n\t\t\tconst result = toDisposable(() => { removeMonitor?.(); this._removeListener(contained); });\n\t\t\tif (disposables instanceof DisposableStore) {\n\t\t\t\tdisposables.add(result);\n\t\t\t} else if (Array.isArray(disposables)) {\n\t\t\t\tdisposables.push(result);\n\t\t\t}\n\n\t\t\treturn result;\n\t\t};\n\n\t\treturn this._event;\n\t}\n\n\tprivate _removeListener(listener: ListenerContainer<T>) {\n\t\tthis._options?.onWillRemoveListener?.(this);\n\n\t\tif (!this._listeners) {\n\t\t\treturn; // expected if a listener gets disposed\n\t\t}\n\n\t\tif (this._size === 1) {\n\t\t\tthis._listeners = undefined;\n\t\t\tthis._options?.onDidRemoveLastListener?.(this);\n\t\t\tthis._size = 0;\n\t\t\treturn;\n\t\t}\n\n\t\t// size > 1 which requires that listeners be a list:\n\t\tconst listeners = this._listeners as (ListenerContainer<T> | undefined)[];\n\n\t\tconst index = listeners.indexOf(listener);\n\t\tif (index === -1) {\n\t\t\tconsole.log('disposed?', this._disposed);\n\t\t\tconsole.log('size?', this._size);\n\t\t\tconsole.log('arr?', JSON.stringify(this._listeners));\n\t\t\tthrow new Error('Attempted to dispose unknown listener');\n\t\t}\n\n\t\tthis._size--;\n\t\tlisteners[index] = undefined;\n\n\t\tconst adjustDeliveryQueue = this._deliveryQueue!.current === this;\n\t\tif (this._size * compactionThreshold <= listeners.length) {\n\t\t\tlet n = 0;\n\t\t\tfor (let i = 0; i < listeners.length; i++) {\n\t\t\t\tif (listeners[i]) {\n\t\t\t\t\tlisteners[n++] = listeners[i];\n\t\t\t\t} else if (adjustDeliveryQueue) {\n\t\t\t\t\tthis._deliveryQueue!.end--;\n\t\t\t\t\tif (n < this._deliveryQueue!.i) {\n\t\t\t\t\t\tthis._deliveryQueue!.i--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlisteners.length = n;\n\t\t}\n\t}\n\n\tprivate _deliver(listener: undefined | UniqueContainer<(value: T) => void>, value: T) {\n\t\tif (!listener) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst errorHandler = this._options?.onListenerError || onUnexpectedError;\n\t\tif (!errorHandler) {\n\t\t\tlistener.value(value);\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tlistener.value(value);\n\t\t} catch (e) {\n\t\t\terrorHandler(e);\n\t\t}\n\t}\n\n\t/** Delivers items in the queue. Assumes the queue is ready to go. */\n\tprivate _deliverQueue(dq: EventDeliveryQueuePrivate) {\n\t\tconst listeners = dq.current!._listeners! as (ListenerContainer<T> | undefined)[];\n\t\twhile (dq.i < dq.end) {\n\t\t\t// important: dq.i is incremented before calling deliver() because it might reenter deliverQueue()\n\t\t\tthis._deliver(listeners[dq.i++], dq.value as T);\n\t\t}\n\t\tdq.reset();\n\t}\n\n\t/**\n\t * To be kept private to fire an event to\n\t * subscribers\n\t */\n\tfire(event: T): void {\n\t\tif (this._deliveryQueue?.current) {\n\t\t\tthis._deliverQueue(this._deliveryQueue);\n\t\t\tthis._perfMon?.stop(); // last fire() will have starting perfmon, stop it before starting the next dispatch\n\t\t}\n\n\t\tthis._perfMon?.start(this._size);\n\n\t\tif (!this._listeners) {\n\t\t\t// no-op\n\t\t} else if (this._listeners instanceof UniqueContainer) {\n\t\t\tthis._deliver(this._listeners, event);\n\t\t} else {\n\t\t\tconst dq = this._deliveryQueue!;\n\t\t\tdq.enqueue(this, event, this._listeners.length);\n\t\t\tthis._deliverQueue(dq);\n\t\t}\n\n\t\tthis._perfMon?.stop();\n\t}\n\n\thasListeners(): boolean {\n\t\treturn this._size > 0;\n\t}\n}\n\nexport interface EventDeliveryQueue {\n\t_isEventDeliveryQueue: true;\n}\n\nexport const createEventDeliveryQueue = (): EventDeliveryQueue => new EventDeliveryQueuePrivate();\n\nclass EventDeliveryQueuePrivate implements EventDeliveryQueue {\n\tdeclare _isEventDeliveryQueue: true;\n\n\t/**\n\t * Index in current's listener list.\n\t */\n\tpublic i = -1;\n\n\t/**\n\t * The last index in the listener's list to deliver.\n\t */\n\tpublic end = 0;\n\n\t/**\n\t * Emitter currently being dispatched on. Emitter._listeners is always an array.\n\t */\n\tpublic current?: Emitter<any>;\n\t/**\n\t * Currently emitting value. Defined whenever `current` is.\n\t */\n\tpublic value?: unknown;\n\n\tpublic enqueue<T>(emitter: Emitter<T>, value: T, end: number) {\n\t\tthis.i = 0;\n\t\tthis.end = end;\n\t\tthis.current = emitter;\n\t\tthis.value = value;\n\t}\n\n\tpublic reset() {\n\t\tthis.i = this.end; // force any current emission loop to stop, mainly for during dispose\n\t\tthis.current = undefined;\n\t\tthis.value = undefined;\n\t}\n}\n\nexport interface IWaitUntil {\n\ttoken: CancellationToken;\n\twaitUntil(thenable: Promise<unknown>): void;\n}\n\nexport type IWaitUntilData<T> = Omit<Omit<T, 'waitUntil'>, 'token'>;\n\nexport class AsyncEmitter<T extends IWaitUntil> extends Emitter<T> {\n\n\tprivate _asyncDeliveryQueue?: LinkedList<[(ev: T) => void, IWaitUntilData<T>]>;\n\n\tasync fireAsync(data: IWaitUntilData<T>, token: CancellationToken, promiseJoin?: (p: Promise<unknown>, listener: Function) => Promise<unknown>): Promise<void> {\n\t\tif (!this._listeners) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this._asyncDeliveryQueue) {\n\t\t\tthis._asyncDeliveryQueue = new LinkedList();\n\t\t}\n\n\t\tforEachListener(this._listeners, listener => this._asyncDeliveryQueue!.push([listener.value, data]));\n\n\t\twhile (this._asyncDeliveryQueue.size > 0 && !token.isCancellationRequested) {\n\n\t\t\tconst [listener, data] = this._asyncDeliveryQueue.shift()!;\n\t\t\tconst thenables: Promise<unknown>[] = [];\n\n\t\t\tconst event = <T>{\n\t\t\t\t...data,\n\t\t\t\ttoken,\n\t\t\t\twaitUntil: (p: Promise<unknown>): void => {\n\t\t\t\t\tif (Object.isFrozen(thenables)) {\n\t\t\t\t\t\tthrow new Error('waitUntil can NOT be called asynchronous');\n\t\t\t\t\t}\n\t\t\t\t\tif (promiseJoin) {\n\t\t\t\t\t\tp = promiseJoin(p, listener);\n\t\t\t\t\t}\n\t\t\t\t\tthenables.push(p);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\ttry {\n\t\t\t\tlistener(event);\n\t\t\t} catch (e) {\n\t\t\t\tonUnexpectedError(e);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// freeze thenables-collection to enforce sync-calls to\n\t\t\t// wait until and then wait for all thenables to resolve\n\t\t\tObject.freeze(thenables);\n\n\t\t\tawait Promise.allSettled(thenables).then(values => {\n\t\t\t\tfor (const value of values) {\n\t\t\t\t\tif (value.status === 'rejected') {\n\t\t\t\t\t\tonUnexpectedError(value.reason);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n}\n\n\nexport class PauseableEmitter<T> extends Emitter<T> {\n\n\tprivate _isPaused = 0;\n\tprotected _eventQueue = new LinkedList<T>();\n\tprivate _mergeFn?: (input: T[]) => T;\n\n\tpublic get isPaused(): boolean {\n\t\treturn this._isPaused !== 0;\n\t}\n\n\tconstructor(options?: EmitterOptions & { merge?: (input: T[]) => T }) {\n\t\tsuper(options);\n\t\tthis._mergeFn = options?.merge;\n\t}\n\n\tpause(): void {\n\t\tthis._isPaused++;\n\t}\n\n\tresume(): void {\n\t\tif (this._isPaused !== 0 && --this._isPaused === 0) {\n\t\t\tif (this._mergeFn) {\n\t\t\t\t// use the merge function to create a single composite\n\t\t\t\t// event. make a copy in case firing pauses this emitter\n\t\t\t\tif (this._eventQueue.size > 0) {\n\t\t\t\t\tconst events = Array.from(this._eventQueue);\n\t\t\t\t\tthis._eventQueue.clear();\n\t\t\t\t\tsuper.fire(this._mergeFn(events));\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\t// no merging, fire each event individually and test\n\t\t\t\t// that this emitter isn't paused halfway through\n\t\t\t\twhile (!this._isPaused && this._eventQueue.size !== 0) {\n\t\t\t\t\tsuper.fire(this._eventQueue.shift()!);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\toverride fire(event: T): void {\n\t\tif (this._size) {\n\t\t\tif (this._isPaused !== 0) {\n\t\t\t\tthis._eventQueue.push(event);\n\t\t\t} else {\n\t\t\t\tsuper.fire(event);\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport class DebounceEmitter<T> extends PauseableEmitter<T> {\n\n\tprivate readonly _delay: number;\n\tprivate _handle: any | undefined;\n\n\tconstructor(options: EmitterOptions & { merge: (input: T[]) => T; delay?: number }) {\n\t\tsuper(options);\n\t\tthis._delay = options.delay ?? 100;\n\t}\n\n\toverride fire(event: T): void {\n\t\tif (!this._handle) {\n\t\t\tthis.pause();\n\t\t\tthis._handle = setTimeout(() => {\n\t\t\t\tthis._handle = undefined;\n\t\t\t\tthis.resume();\n\t\t\t}, this._delay);\n\t\t}\n\t\tsuper.fire(event);\n\t}\n}\n\n/**\n * An emitter which queue all events and then process them at the\n * end of the event loop.\n */\nexport class MicrotaskEmitter<T> extends Emitter<T> {\n\tprivate _queuedEvents: T[] = [];\n\tprivate _mergeFn?: (input: T[]) => T;\n\n\tconstructor(options?: EmitterOptions & { merge?: (input: T[]) => T }) {\n\t\tsuper(options);\n\t\tthis._mergeFn = options?.merge;\n\t}\n\toverride fire(event: T): void {\n\n\t\tif (!this.hasListeners()) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._queuedEvents.push(event);\n\t\tif (this._queuedEvents.length === 1) {\n\t\t\tqueueMicrotask(() => {\n\t\t\t\tif (this._mergeFn) {\n\t\t\t\t\tsuper.fire(this._mergeFn(this._queuedEvents));\n\t\t\t\t} else {\n\t\t\t\t\tthis._queuedEvents.forEach(e => super.fire(e));\n\t\t\t\t}\n\t\t\t\tthis._queuedEvents = [];\n\t\t\t});\n\t\t}\n\t}\n}\n\n/**\n * An event emitter that multiplexes many events into a single event.\n *\n * @example Listen to the `onData` event of all `Thing`s, dynamically adding and removing `Thing`s\n * to the multiplexer as needed.\n *\n * ```typescript\n * const anythingDataMultiplexer = new EventMultiplexer<{ data: string }>();\n *\n * const thingListeners = DisposableMap<Thing, IDisposable>();\n *\n * thingService.onDidAddThing(thing => {\n *   thingListeners.set(thing, anythingDataMultiplexer.add(thing.onData);\n * });\n * thingService.onDidRemoveThing(thing => {\n *   thingListeners.deleteAndDispose(thing);\n * });\n *\n * anythingDataMultiplexer.event(e => {\n *   console.log('Something fired data ' + e.data)\n * });\n * ```\n */\nexport class EventMultiplexer<T> implements IDisposable {\n\n\tprivate readonly emitter: Emitter<T>;\n\tprivate hasListeners = false;\n\tprivate events: { event: Event<T>; listener: IDisposable | null }[] = [];\n\n\tconstructor() {\n\t\tthis.emitter = new Emitter<T>({\n\t\t\tonWillAddFirstListener: () => this.onFirstListenerAdd(),\n\t\t\tonDidRemoveLastListener: () => this.onLastListenerRemove()\n\t\t});\n\t}\n\n\tget event(): Event<T> {\n\t\treturn this.emitter.event;\n\t}\n\n\tadd(event: Event<T>): IDisposable {\n\t\tconst e = { event: event, listener: null };\n\t\tthis.events.push(e);\n\n\t\tif (this.hasListeners) {\n\t\t\tthis.hook(e);\n\t\t}\n\n\t\tconst dispose = () => {\n\t\t\tif (this.hasListeners) {\n\t\t\t\tthis.unhook(e);\n\t\t\t}\n\n\t\t\tconst idx = this.events.indexOf(e);\n\t\t\tthis.events.splice(idx, 1);\n\t\t};\n\n\t\treturn toDisposable(onceFn(dispose));\n\t}\n\n\tprivate onFirstListenerAdd(): void {\n\t\tthis.hasListeners = true;\n\t\tthis.events.forEach(e => this.hook(e));\n\t}\n\n\tprivate onLastListenerRemove(): void {\n\t\tthis.hasListeners = false;\n\t\tthis.events.forEach(e => this.unhook(e));\n\t}\n\n\tprivate hook(e: { event: Event<T>; listener: IDisposable | null }): void {\n\t\te.listener = e.event(r => this.emitter.fire(r));\n\t}\n\n\tprivate unhook(e: { event: Event<T>; listener: IDisposable | null }): void {\n\t\tif (e.listener) {\n\t\t\te.listener.dispose();\n\t\t}\n\t\te.listener = null;\n\t}\n\n\tdispose(): void {\n\t\tthis.emitter.dispose();\n\t}\n}\n\nexport interface IDynamicListEventMultiplexer<TEventType> extends IDisposable {\n\treadonly event: Event<TEventType>;\n}\nexport class DynamicListEventMultiplexer<TItem, TEventType> implements IDynamicListEventMultiplexer<TEventType> {\n\tprivate readonly _store = new DisposableStore();\n\n\treadonly event: Event<TEventType>;\n\n\tconstructor(\n\t\titems: TItem[],\n\t\tonAddItem: Event<TItem>,\n\t\tonRemoveItem: Event<TItem>,\n\t\tgetEvent: (item: TItem) => Event<TEventType>\n\t) {\n\t\tconst multiplexer = this._store.add(new EventMultiplexer<TEventType>());\n\t\tconst itemListeners = this._store.add(new DisposableMap<TItem, IDisposable>());\n\n\t\tfunction addItem(instance: TItem) {\n\t\t\titemListeners.set(instance, multiplexer.add(getEvent(instance)));\n\t\t}\n\n\t\t// Existing items\n\t\tfor (const instance of items) {\n\t\t\taddItem(instance);\n\t\t}\n\n\t\t// Added items\n\t\tthis._store.add(onAddItem(instance => {\n\t\t\taddItem(instance);\n\t\t}));\n\n\t\t// Removed items\n\t\tthis._store.add(onRemoveItem(instance => {\n\t\t\titemListeners.deleteAndDispose(instance);\n\t\t}));\n\n\t\tthis.event = multiplexer.event;\n\t}\n\n\tdispose() {\n\t\tthis._store.dispose();\n\t}\n}\n\n/**\n * The EventBufferer is useful in situations in which you want\n * to delay firing your events during some code.\n * You can wrap that code and be sure that the event will not\n * be fired during that wrap.\n *\n * ```\n * const emitter: Emitter;\n * const delayer = new EventDelayer();\n * const delayedEvent = delayer.wrapEvent(emitter.event);\n *\n * delayedEvent(console.log);\n *\n * delayer.bufferEvents(() => {\n *   emitter.fire(); // event will not be fired yet\n * });\n *\n * // event will only be fired at this point\n * ```\n */\nexport class EventBufferer {\n\n\tprivate buffers: Function[][] = [];\n\n\twrapEvent<T>(event: Event<T>): Event<T> {\n\t\treturn (listener, thisArgs?, disposables?) => {\n\t\t\treturn event(i => {\n\t\t\t\tconst buffer = this.buffers[this.buffers.length - 1];\n\n\t\t\t\tif (buffer) {\n\t\t\t\t\tbuffer.push(() => listener.call(thisArgs, i));\n\t\t\t\t} else {\n\t\t\t\t\tlistener.call(thisArgs, i);\n\t\t\t\t}\n\t\t\t}, undefined, disposables);\n\t\t};\n\t}\n\n\tbufferEvents<R = void>(fn: () => R): R {\n\t\tconst buffer: Array<() => R> = [];\n\t\tthis.buffers.push(buffer);\n\t\tconst r = fn();\n\t\tthis.buffers.pop();\n\t\tbuffer.forEach(flush => flush());\n\t\treturn r;\n\t}\n}\n\n/**\n * A Relay is an event forwarder which functions as a replugabble event pipe.\n * Once created, you can connect an input event to it and it will simply forward\n * events from that input event through its own `event` property. The `input`\n * can be changed at any point in time.\n */\nexport class Relay<T> implements IDisposable {\n\n\tprivate listening = false;\n\tprivate inputEvent: Event<T> = Event.None;\n\tprivate inputEventListener: IDisposable = Disposable.None;\n\n\tprivate readonly emitter = new Emitter<T>({\n\t\tonDidAddFirstListener: () => {\n\t\t\tthis.listening = true;\n\t\t\tthis.inputEventListener = this.inputEvent(this.emitter.fire, this.emitter);\n\t\t},\n\t\tonDidRemoveLastListener: () => {\n\t\t\tthis.listening = false;\n\t\t\tthis.inputEventListener.dispose();\n\t\t}\n\t});\n\n\treadonly event: Event<T> = this.emitter.event;\n\n\tset input(event: Event<T>) {\n\t\tthis.inputEvent = event;\n\n\t\tif (this.listening) {\n\t\t\tthis.inputEventListener.dispose();\n\t\t\tthis.inputEventListener = event(this.emitter.fire, this.emitter);\n\t\t}\n\t}\n\n\tdispose() {\n\t\tthis.inputEventListener.dispose();\n\t\tthis.emitter.dispose();\n\t}\n}\n"]}