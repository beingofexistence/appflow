{"version":3,"sources":["file:///workspace/appflow/src/vs/base/common/tfIdf.ts"],"names":[],"mappings":"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","file":"tfIdf.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken } from 'vs/base/common/cancellation';\n\ntype SparseEmbedding = Record</* word */ string, /* weight */number>;\ntype TermFrequencies = Map</* word */ string, /*occurrences*/ number>;\ntype DocumentOccurrences = Map</* word */ string, /*documentOccurrences*/ number>;\n\nfunction countMapFrom<K>(values: Iterable<K>): Map<K, number> {\n\tconst map = new Map<K, number>();\n\tfor (const value of values) {\n\t\tmap.set(value, (map.get(value) ?? 0) + 1);\n\t}\n\treturn map;\n}\n\ninterface DocumentChunkEntry {\n\treadonly text: string;\n\treadonly tf: TermFrequencies;\n}\n\nexport interface TfIdfDocument {\n\treadonly key: string;\n\treadonly textChunks: readonly string[];\n}\n\nexport interface TfIdfScore {\n\treadonly key: string;\n\t/**\n\t * An unbounded number.\n\t */\n\treadonly score: number;\n}\n\nexport interface NormalizedTfIdfScore {\n\treadonly key: string;\n\t/**\n\t * A number between 0 and 1.\n\t */\n\treadonly score: number;\n}\n\n/**\n * Implementation of tf-idf (term frequency-inverse document frequency) for a set of\n * documents where each document contains one or more chunks of text.\n * Each document is identified by a key, and the score for each document is computed\n * by taking the max score over all the chunks in the document.\n */\nexport class TfIdfCalculator {\n\tcalculateScores(query: string, token: CancellationToken): TfIdfScore[] {\n\t\tconst embedding = this.computeEmbedding(query);\n\t\tconst idfCache = new Map<string, number>();\n\t\tconst scores: TfIdfScore[] = [];\n\t\t// For each document, generate one score\n\t\tfor (const [key, doc] of this.documents) {\n\t\t\tif (token.isCancellationRequested) {\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\tfor (const chunk of doc.chunks) {\n\t\t\t\tconst score = this.computeSimilarityScore(chunk, embedding, idfCache);\n\t\t\t\tif (score > 0) {\n\t\t\t\t\tscores.push({ key, score });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn scores;\n\t}\n\n\t/**\n\t * Count how many times each term (word) appears in a string.\n\t */\n\tprivate static termFrequencies(input: string): TermFrequencies {\n\t\treturn countMapFrom(TfIdfCalculator.splitTerms(input));\n\t}\n\n\t/**\n\t * Break a string into terms (words).\n\t */\n\tprivate static *splitTerms(input: string): Iterable<string> {\n\t\tconst normalize = (word: string) => word.toLowerCase();\n\n\t\t// Only match on words that are at least 3 characters long and start with a letter\n\t\tfor (const [word] of input.matchAll(/\\b\\p{Letter}[\\p{Letter}\\d]{2,}\\b/gu)) {\n\t\t\tyield normalize(word);\n\n\t\t\t// eslint-disable-next-line local/code-no-look-behind-regex\n\t\t\tconst camelParts = word.split(/(?<=[a-z])(?=[A-Z])/g);\n\t\t\tif (camelParts.length > 1) {\n\t\t\t\tfor (const part of camelParts) {\n\t\t\t\t\t// Require at least 3 letters in the parts of a camel case word\n\t\t\t\t\tif (part.length > 2 && /\\p{Letter}{3,}/gu.test(part)) {\n\t\t\t\t\t\tyield normalize(part);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Total number of chunks\n\t */\n\tprivate chunkCount = 0;\n\n\tprivate readonly chunkOccurrences: DocumentOccurrences = new Map</* word */ string, /*documentOccurrences*/ number>();\n\n\tprivate readonly documents = new Map</* key */ string, {\n\t\treadonly chunks: ReadonlyArray<DocumentChunkEntry>;\n\t}>();\n\n\tupdateDocuments(documents: ReadonlyArray<TfIdfDocument>): this {\n\t\tfor (const { key } of documents) {\n\t\t\tthis.deleteDocument(key);\n\t\t}\n\n\t\tfor (const doc of documents) {\n\t\t\tconst chunks: Array<{ text: string; tf: TermFrequencies }> = [];\n\t\t\tfor (const text of doc.textChunks) {\n\t\t\t\t// TODO: See if we can compute the tf lazily\n\t\t\t\t// The challenge is that we need to also update the `chunkOccurrences`\n\t\t\t\t// and all of those updates need to get flushed before the real TF-IDF of\n\t\t\t\t// anything is computed.\n\t\t\t\tconst tf = TfIdfCalculator.termFrequencies(text);\n\n\t\t\t\t// Update occurrences list\n\t\t\t\tfor (const term of tf.keys()) {\n\t\t\t\t\tthis.chunkOccurrences.set(term, (this.chunkOccurrences.get(term) ?? 0) + 1);\n\t\t\t\t}\n\n\t\t\t\tchunks.push({ text, tf });\n\t\t\t}\n\n\t\t\tthis.chunkCount += chunks.length;\n\t\t\tthis.documents.set(doc.key, { chunks });\n\t\t}\n\t\treturn this;\n\t}\n\n\tdeleteDocument(key: string) {\n\t\tconst doc = this.documents.get(key);\n\t\tif (!doc) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.documents.delete(key);\n\t\tthis.chunkCount -= doc.chunks.length;\n\n\t\t// Update term occurrences for the document\n\t\tfor (const chunk of doc.chunks) {\n\t\t\tfor (const term of chunk.tf.keys()) {\n\t\t\t\tconst currentOccurrences = this.chunkOccurrences.get(term);\n\t\t\t\tif (typeof currentOccurrences === 'number') {\n\t\t\t\t\tconst newOccurrences = currentOccurrences - 1;\n\t\t\t\t\tif (newOccurrences <= 0) {\n\t\t\t\t\t\tthis.chunkOccurrences.delete(term);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.chunkOccurrences.set(term, newOccurrences);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate computeSimilarityScore(chunk: DocumentChunkEntry, queryEmbedding: SparseEmbedding, idfCache: Map<string, number>): number {\n\t\t// Compute the dot product between the chunk's embedding and the query embedding\n\n\t\t// Note that the chunk embedding is computed lazily on a per-term basis.\n\t\t// This lets us skip a large number of calculations because the majority\n\t\t// of chunks do not share any terms with the query.\n\n\t\tlet sum = 0;\n\t\tfor (const [term, termTfidf] of Object.entries(queryEmbedding)) {\n\t\t\tconst chunkTf = chunk.tf.get(term);\n\t\t\tif (!chunkTf) {\n\t\t\t\t// Term does not appear in chunk so it has no contribution\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlet chunkIdf = idfCache.get(term);\n\t\t\tif (typeof chunkIdf !== 'number') {\n\t\t\t\tchunkIdf = this.computeIdf(term);\n\t\t\t\tidfCache.set(term, chunkIdf);\n\t\t\t}\n\n\t\t\tconst chunkTfidf = chunkTf * chunkIdf;\n\t\t\tsum += chunkTfidf * termTfidf;\n\t\t}\n\t\treturn sum;\n\t}\n\n\tprivate computeEmbedding(input: string): SparseEmbedding {\n\t\tconst tf = TfIdfCalculator.termFrequencies(input);\n\t\treturn this.computeTfidf(tf);\n\t}\n\n\tprivate computeIdf(term: string): number {\n\t\tconst chunkOccurrences = this.chunkOccurrences.get(term) ?? 0;\n\t\treturn chunkOccurrences > 0\n\t\t\t? Math.log((this.chunkCount + 1) / chunkOccurrences)\n\t\t\t: 0;\n\t}\n\n\tprivate computeTfidf(termFrequencies: TermFrequencies): SparseEmbedding {\n\t\tconst embedding = Object.create(null);\n\t\tfor (const [word, occurrences] of termFrequencies) {\n\t\t\tconst idf = this.computeIdf(word);\n\t\t\tif (idf > 0) {\n\t\t\t\tembedding[word] = occurrences * idf;\n\t\t\t}\n\t\t}\n\t\treturn embedding;\n\t}\n}\n\n/**\n * Normalize the scores to be between 0 and 1 and sort them decending.\n * @param scores array of scores from {@link TfIdfCalculator.calculateScores}\n * @returns normalized scores\n */\nexport function normalizeTfIdfScores(scores: TfIdfScore[]): NormalizedTfIdfScore[] {\n\n\t// copy of scores\n\tconst result = scores.slice(0) as { score: number }[];\n\n\t// sort descending\n\tresult.sort((a, b) => b.score - a.score);\n\n\t// normalize\n\tconst max = result[0]?.score ?? 0;\n\tif (max > 0) {\n\t\tfor (const score of result) {\n\t\t\tscore.score /= max;\n\t\t}\n\t}\n\n\treturn result as TfIdfScore[];\n}\n"]}