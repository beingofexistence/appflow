{"version":3,"sources":["file:///workspace/appflow/src/vs/base/common/stream.ts"],"names":[],"mappings":"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","file":"stream.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken } from 'vs/base/common/cancellation';\nimport { onUnexpectedError } from 'vs/base/common/errors';\nimport { DisposableStore, toDisposable } from 'vs/base/common/lifecycle';\n\n/**\n * The payload that flows in readable stream events.\n */\nexport type ReadableStreamEventPayload<T> = T | Error | 'end';\n\nexport interface ReadableStreamEvents<T> {\n\n\t/**\n\t * The 'data' event is emitted whenever the stream is\n\t * relinquishing ownership of a chunk of data to a consumer.\n\t *\n\t * NOTE: PLEASE UNDERSTAND THAT ADDING A DATA LISTENER CAN\n\t * TURN THE STREAM INTO FLOWING MODE. IT IS THEREFOR THE\n\t * LAST LISTENER THAT SHOULD BE ADDED AND NOT THE FIRST\n\t *\n\t * Use `listenStream` as a helper method to listen to\n\t * stream events in the right order.\n\t */\n\ton(event: 'data', callback: (data: T) => void): void;\n\n\t/**\n\t * Emitted when any error occurs.\n\t */\n\ton(event: 'error', callback: (err: Error) => void): void;\n\n\t/**\n\t * The 'end' event is emitted when there is no more data\n\t * to be consumed from the stream. The 'end' event will\n\t * not be emitted unless the data is completely consumed.\n\t */\n\ton(event: 'end', callback: () => void): void;\n}\n\n/**\n * A interface that emulates the API shape of a node.js readable\n * stream for use in native and web environments.\n */\nexport interface ReadableStream<T> extends ReadableStreamEvents<T> {\n\n\t/**\n\t * Stops emitting any events until resume() is called.\n\t */\n\tpause(): void;\n\n\t/**\n\t * Starts emitting events again after pause() was called.\n\t */\n\tresume(): void;\n\n\t/**\n\t * Destroys the stream and stops emitting any event.\n\t */\n\tdestroy(): void;\n\n\t/**\n\t * Allows to remove a listener that was previously added.\n\t */\n\tremoveListener(event: string, callback: Function): void;\n}\n\n/**\n * A interface that emulates the API shape of a node.js readable\n * for use in native and web environments.\n */\nexport interface Readable<T> {\n\n\t/**\n\t * Read data from the underlying source. Will return\n\t * null to indicate that no more data can be read.\n\t */\n\tread(): T | null;\n}\n\nexport function isReadable<T>(obj: unknown): obj is Readable<T> {\n\tconst candidate = obj as Readable<T> | undefined;\n\tif (!candidate) {\n\t\treturn false;\n\t}\n\n\treturn typeof candidate.read === 'function';\n}\n\n/**\n * A interface that emulates the API shape of a node.js writeable\n * stream for use in native and web environments.\n */\nexport interface WriteableStream<T> extends ReadableStream<T> {\n\n\t/**\n\t * Writing data to the stream will trigger the on('data')\n\t * event listener if the stream is flowing and buffer the\n\t * data otherwise until the stream is flowing.\n\t *\n\t * If a `highWaterMark` is configured and writing to the\n\t * stream reaches this mark, a promise will be returned\n\t * that should be awaited on before writing more data.\n\t * Otherwise there is a risk of buffering a large number\n\t * of data chunks without consumer.\n\t */\n\twrite(data: T): void | Promise<void>;\n\n\t/**\n\t * Signals an error to the consumer of the stream via the\n\t * on('error') handler if the stream is flowing.\n\t *\n\t * NOTE: call `end` to signal that the stream has ended,\n\t * this DOES NOT happen automatically from `error`.\n\t */\n\terror(error: Error): void;\n\n\t/**\n\t * Signals the end of the stream to the consumer. If the\n\t * result is provided, will trigger the on('data') event\n\t * listener if the stream is flowing and buffer the data\n\t * otherwise until the stream is flowing.\n\t */\n\tend(result?: T): void;\n}\n\n/**\n * A stream that has a buffer already read. Returns the original stream\n * that was read as well as the chunks that got read.\n *\n * The `ended` flag indicates if the stream has been fully consumed.\n */\nexport interface ReadableBufferedStream<T> {\n\n\t/**\n\t * The original stream that is being read.\n\t */\n\tstream: ReadableStream<T>;\n\n\t/**\n\t * An array of chunks already read from this stream.\n\t */\n\tbuffer: T[];\n\n\t/**\n\t * Signals if the stream has ended or not. If not, consumers\n\t * should continue to read from the stream until consumed.\n\t */\n\tended: boolean;\n}\n\nexport function isReadableStream<T>(obj: unknown): obj is ReadableStream<T> {\n\tconst candidate = obj as ReadableStream<T> | undefined;\n\tif (!candidate) {\n\t\treturn false;\n\t}\n\n\treturn [candidate.on, candidate.pause, candidate.resume, candidate.destroy].every(fn => typeof fn === 'function');\n}\n\nexport function isReadableBufferedStream<T>(obj: unknown): obj is ReadableBufferedStream<T> {\n\tconst candidate = obj as ReadableBufferedStream<T> | undefined;\n\tif (!candidate) {\n\t\treturn false;\n\t}\n\n\treturn isReadableStream(candidate.stream) && Array.isArray(candidate.buffer) && typeof candidate.ended === 'boolean';\n}\n\nexport interface IReducer<T, R = T> {\n\t(data: T[]): R;\n}\n\nexport interface IDataTransformer<Original, Transformed> {\n\t(data: Original): Transformed;\n}\n\nexport interface IErrorTransformer {\n\t(error: Error): Error;\n}\n\nexport interface ITransformer<Original, Transformed> {\n\tdata: IDataTransformer<Original, Transformed>;\n\terror?: IErrorTransformer;\n}\n\nexport function newWriteableStream<T>(reducer: IReducer<T>, options?: WriteableStreamOptions): WriteableStream<T> {\n\treturn new WriteableStreamImpl<T>(reducer, options);\n}\n\nexport interface WriteableStreamOptions {\n\n\t/**\n\t * The number of objects to buffer before WriteableStream#write()\n\t * signals back that the buffer is full. Can be used to reduce\n\t * the memory pressure when the stream is not flowing.\n\t */\n\thighWaterMark?: number;\n}\n\nclass WriteableStreamImpl<T> implements WriteableStream<T> {\n\n\tprivate readonly state = {\n\t\tflowing: false,\n\t\tended: false,\n\t\tdestroyed: false\n\t};\n\n\tprivate readonly buffer = {\n\t\tdata: [] as T[],\n\t\terror: [] as Error[]\n\t};\n\n\tprivate readonly listeners = {\n\t\tdata: [] as { (data: T): void }[],\n\t\terror: [] as { (error: Error): void }[],\n\t\tend: [] as { (): void }[]\n\t};\n\n\tprivate readonly pendingWritePromises: Function[] = [];\n\n\tconstructor(private reducer: IReducer<T>, private options?: WriteableStreamOptions) { }\n\n\tpause(): void {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.state.flowing = false;\n\t}\n\n\tresume(): void {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this.state.flowing) {\n\t\t\tthis.state.flowing = true;\n\n\t\t\t// emit buffered events\n\t\t\tthis.flowData();\n\t\t\tthis.flowErrors();\n\t\t\tthis.flowEnd();\n\t\t}\n\t}\n\n\twrite(data: T): void | Promise<void> {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\t// flowing: directly send the data to listeners\n\t\tif (this.state.flowing) {\n\t\t\tthis.emitData(data);\n\t\t}\n\n\t\t// not yet flowing: buffer data until flowing\n\t\telse {\n\t\t\tthis.buffer.data.push(data);\n\n\t\t\t// highWaterMark: if configured, signal back when buffer reached limits\n\t\t\tif (typeof this.options?.highWaterMark === 'number' && this.buffer.data.length > this.options.highWaterMark) {\n\t\t\t\treturn new Promise(resolve => this.pendingWritePromises.push(resolve));\n\t\t\t}\n\t\t}\n\t}\n\n\terror(error: Error): void {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\t// flowing: directly send the error to listeners\n\t\tif (this.state.flowing) {\n\t\t\tthis.emitError(error);\n\t\t}\n\n\t\t// not yet flowing: buffer errors until flowing\n\t\telse {\n\t\t\tthis.buffer.error.push(error);\n\t\t}\n\t}\n\n\tend(result?: T): void {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\t// end with data if provided\n\t\tif (typeof result !== 'undefined') {\n\t\t\tthis.write(result);\n\t\t}\n\n\t\t// flowing: send end event to listeners\n\t\tif (this.state.flowing) {\n\t\t\tthis.emitEnd();\n\n\t\t\tthis.destroy();\n\t\t}\n\n\t\t// not yet flowing: remember state\n\t\telse {\n\t\t\tthis.state.ended = true;\n\t\t}\n\t}\n\n\tprivate emitData(data: T): void {\n\t\tthis.listeners.data.slice(0).forEach(listener => listener(data)); // slice to avoid listener mutation from delivering event\n\t}\n\n\tprivate emitError(error: Error): void {\n\t\tif (this.listeners.error.length === 0) {\n\t\t\tonUnexpectedError(error); // nobody listened to this error so we log it as unexpected\n\t\t} else {\n\t\t\tthis.listeners.error.slice(0).forEach(listener => listener(error)); // slice to avoid listener mutation from delivering event\n\t\t}\n\t}\n\n\tprivate emitEnd(): void {\n\t\tthis.listeners.end.slice(0).forEach(listener => listener()); // slice to avoid listener mutation from delivering event\n\t}\n\n\ton(event: 'data', callback: (data: T) => void): void;\n\ton(event: 'error', callback: (err: Error) => void): void;\n\ton(event: 'end', callback: () => void): void;\n\ton(event: 'data' | 'error' | 'end', callback: (arg0?: any) => void): void {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\tswitch (event) {\n\t\t\tcase 'data':\n\t\t\t\tthis.listeners.data.push(callback);\n\n\t\t\t\t// switch into flowing mode as soon as the first 'data'\n\t\t\t\t// listener is added and we are not yet in flowing mode\n\t\t\t\tthis.resume();\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'end':\n\t\t\t\tthis.listeners.end.push(callback);\n\n\t\t\t\t// emit 'end' event directly if we are flowing\n\t\t\t\t// and the end has already been reached\n\t\t\t\t//\n\t\t\t\t// finish() when it went through\n\t\t\t\tif (this.state.flowing && this.flowEnd()) {\n\t\t\t\t\tthis.destroy();\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'error':\n\t\t\t\tthis.listeners.error.push(callback);\n\n\t\t\t\t// emit buffered 'error' events unless done already\n\t\t\t\t// now that we know that we have at least one listener\n\t\t\t\tif (this.state.flowing) {\n\t\t\t\t\tthis.flowErrors();\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tremoveListener(event: string, callback: Function): void {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet listeners: unknown[] | undefined = undefined;\n\n\t\tswitch (event) {\n\t\t\tcase 'data':\n\t\t\t\tlisteners = this.listeners.data;\n\t\t\t\tbreak;\n\n\t\t\tcase 'end':\n\t\t\t\tlisteners = this.listeners.end;\n\t\t\t\tbreak;\n\n\t\t\tcase 'error':\n\t\t\t\tlisteners = this.listeners.error;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (listeners) {\n\t\t\tconst index = listeners.indexOf(callback);\n\t\t\tif (index >= 0) {\n\t\t\t\tlisteners.splice(index, 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate flowData(): void {\n\t\tif (this.buffer.data.length > 0) {\n\t\t\tconst fullDataBuffer = this.reducer(this.buffer.data);\n\n\t\t\tthis.emitData(fullDataBuffer);\n\n\t\t\tthis.buffer.data.length = 0;\n\n\t\t\t// When the buffer is empty, resolve all pending writers\n\t\t\tconst pendingWritePromises = [...this.pendingWritePromises];\n\t\t\tthis.pendingWritePromises.length = 0;\n\t\t\tpendingWritePromises.forEach(pendingWritePromise => pendingWritePromise());\n\t\t}\n\t}\n\n\tprivate flowErrors(): void {\n\t\tif (this.listeners.error.length > 0) {\n\t\t\tfor (const error of this.buffer.error) {\n\t\t\t\tthis.emitError(error);\n\t\t\t}\n\n\t\t\tthis.buffer.error.length = 0;\n\t\t}\n\t}\n\n\tprivate flowEnd(): boolean {\n\t\tif (this.state.ended) {\n\t\t\tthis.emitEnd();\n\n\t\t\treturn this.listeners.end.length > 0;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tdestroy(): void {\n\t\tif (!this.state.destroyed) {\n\t\t\tthis.state.destroyed = true;\n\t\t\tthis.state.ended = true;\n\n\t\t\tthis.buffer.data.length = 0;\n\t\t\tthis.buffer.error.length = 0;\n\n\t\t\tthis.listeners.data.length = 0;\n\t\t\tthis.listeners.error.length = 0;\n\t\t\tthis.listeners.end.length = 0;\n\n\t\t\tthis.pendingWritePromises.length = 0;\n\t\t}\n\t}\n}\n\n/**\n * Helper to fully read a T readable into a T.\n */\nexport function consumeReadable<T>(readable: Readable<T>, reducer: IReducer<T>): T {\n\tconst chunks: T[] = [];\n\n\tlet chunk: T | null;\n\twhile ((chunk = readable.read()) !== null) {\n\t\tchunks.push(chunk);\n\t}\n\n\treturn reducer(chunks);\n}\n\n/**\n * Helper to read a T readable up to a maximum of chunks. If the limit is\n * reached, will return a readable instead to ensure all data can still\n * be read.\n */\nexport function peekReadable<T>(readable: Readable<T>, reducer: IReducer<T>, maxChunks: number): T | Readable<T> {\n\tconst chunks: T[] = [];\n\n\tlet chunk: T | null | undefined = undefined;\n\twhile ((chunk = readable.read()) !== null && chunks.length < maxChunks) {\n\t\tchunks.push(chunk);\n\t}\n\n\t// If the last chunk is null, it means we reached the end of\n\t// the readable and return all the data at once\n\tif (chunk === null && chunks.length > 0) {\n\t\treturn reducer(chunks);\n\t}\n\n\t// Otherwise, we still have a chunk, it means we reached the maxChunks\n\t// value and as such we return a new Readable that first returns\n\t// the existing read chunks and then continues with reading from\n\t// the underlying readable.\n\treturn {\n\t\tread: () => {\n\n\t\t\t// First consume chunks from our array\n\t\t\tif (chunks.length > 0) {\n\t\t\t\treturn chunks.shift()!;\n\t\t\t}\n\n\t\t\t// Then ensure to return our last read chunk\n\t\t\tif (typeof chunk !== 'undefined') {\n\t\t\t\tconst lastReadChunk = chunk;\n\n\t\t\t\t// explicitly use undefined here to indicate that we consumed\n\t\t\t\t// the chunk, which could have either been null or valued.\n\t\t\t\tchunk = undefined;\n\n\t\t\t\treturn lastReadChunk;\n\t\t\t}\n\n\t\t\t// Finally delegate back to the Readable\n\t\t\treturn readable.read();\n\t\t}\n\t};\n}\n\n/**\n * Helper to fully read a T stream into a T or consuming\n * a stream fully, awaiting all the events without caring\n * about the data.\n */\nexport function consumeStream<T, R = T>(stream: ReadableStreamEvents<T>, reducer: IReducer<T, R>): Promise<R>;\nexport function consumeStream(stream: ReadableStreamEvents<unknown>): Promise<undefined>;\nexport function consumeStream<T, R = T>(stream: ReadableStreamEvents<T>, reducer?: IReducer<T, R>): Promise<R | undefined> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst chunks: T[] = [];\n\n\t\tlistenStream(stream, {\n\t\t\tonData: chunk => {\n\t\t\t\tif (reducer) {\n\t\t\t\t\tchunks.push(chunk);\n\t\t\t\t}\n\t\t\t},\n\t\t\tonError: error => {\n\t\t\t\tif (reducer) {\n\t\t\t\t\treject(error);\n\t\t\t\t} else {\n\t\t\t\t\tresolve(undefined);\n\t\t\t\t}\n\t\t\t},\n\t\t\tonEnd: () => {\n\t\t\t\tif (reducer) {\n\t\t\t\t\tresolve(reducer(chunks));\n\t\t\t\t} else {\n\t\t\t\t\tresolve(undefined);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n}\n\nexport interface IStreamListener<T> {\n\n\t/**\n\t * The 'data' event is emitted whenever the stream is\n\t * relinquishing ownership of a chunk of data to a consumer.\n\t */\n\tonData(data: T): void;\n\n\t/**\n\t * Emitted when any error occurs.\n\t */\n\tonError(err: Error): void;\n\n\t/**\n\t * The 'end' event is emitted when there is no more data\n\t * to be consumed from the stream. The 'end' event will\n\t * not be emitted unless the data is completely consumed.\n\t */\n\tonEnd(): void;\n}\n\n/**\n * Helper to listen to all events of a T stream in proper order.\n */\nexport function listenStream<T>(stream: ReadableStreamEvents<T>, listener: IStreamListener<T>, token?: CancellationToken): void {\n\n\tstream.on('error', error => {\n\t\tif (!token?.isCancellationRequested) {\n\t\t\tlistener.onError(error);\n\t\t}\n\t});\n\n\tstream.on('end', () => {\n\t\tif (!token?.isCancellationRequested) {\n\t\t\tlistener.onEnd();\n\t\t}\n\t});\n\n\t// Adding the `data` listener will turn the stream\n\t// into flowing mode. As such it is important to\n\t// add this listener last (DO NOT CHANGE!)\n\tstream.on('data', data => {\n\t\tif (!token?.isCancellationRequested) {\n\t\t\tlistener.onData(data);\n\t\t}\n\t});\n}\n\n/**\n * Helper to peek up to `maxChunks` into a stream. The return type signals if\n * the stream has ended or not. If not, caller needs to add a `data` listener\n * to continue reading.\n */\nexport function peekStream<T>(stream: ReadableStream<T>, maxChunks: number): Promise<ReadableBufferedStream<T>> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst streamListeners = new DisposableStore();\n\t\tconst buffer: T[] = [];\n\n\t\t// Data Listener\n\t\tconst dataListener = (chunk: T) => {\n\n\t\t\t// Add to buffer\n\t\t\tbuffer.push(chunk);\n\n\t\t\t// We reached maxChunks and thus need to return\n\t\t\tif (buffer.length > maxChunks) {\n\n\t\t\t\t// Dispose any listeners and ensure to pause the\n\t\t\t\t// stream so that it can be consumed again by caller\n\t\t\t\tstreamListeners.dispose();\n\t\t\t\tstream.pause();\n\n\t\t\t\treturn resolve({ stream, buffer, ended: false });\n\t\t\t}\n\t\t};\n\n\t\t// Error Listener\n\t\tconst errorListener = (error: Error) => {\n\t\t\tstreamListeners.dispose();\n\n\t\t\treturn reject(error);\n\t\t};\n\n\t\t// End Listener\n\t\tconst endListener = () => {\n\t\t\tstreamListeners.dispose();\n\n\t\t\treturn resolve({ stream, buffer, ended: true });\n\t\t};\n\n\t\tstreamListeners.add(toDisposable(() => stream.removeListener('error', errorListener)));\n\t\tstream.on('error', errorListener);\n\n\t\tstreamListeners.add(toDisposable(() => stream.removeListener('end', endListener)));\n\t\tstream.on('end', endListener);\n\n\t\t// Important: leave the `data` listener last because\n\t\t// this can turn the stream into flowing mode and we\n\t\t// want `error` events to be received as well.\n\t\tstreamListeners.add(toDisposable(() => stream.removeListener('data', dataListener)));\n\t\tstream.on('data', dataListener);\n\t});\n}\n\n/**\n * Helper to create a readable stream from an existing T.\n */\nexport function toStream<T>(t: T, reducer: IReducer<T>): ReadableStream<T> {\n\tconst stream = newWriteableStream<T>(reducer);\n\n\tstream.end(t);\n\n\treturn stream;\n}\n\n/**\n * Helper to create an empty stream\n */\nexport function emptyStream(): ReadableStream<never> {\n\tconst stream = newWriteableStream<never>(() => { throw new Error('not supported'); });\n\tstream.end();\n\n\treturn stream;\n}\n\n/**\n * Helper to convert a T into a Readable<T>.\n */\nexport function toReadable<T>(t: T): Readable<T> {\n\tlet consumed = false;\n\n\treturn {\n\t\tread: () => {\n\t\t\tif (consumed) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconsumed = true;\n\n\t\t\treturn t;\n\t\t}\n\t};\n}\n\n/**\n * Helper to transform a readable stream into another stream.\n */\nexport function transform<Original, Transformed>(stream: ReadableStreamEvents<Original>, transformer: ITransformer<Original, Transformed>, reducer: IReducer<Transformed>): ReadableStream<Transformed> {\n\tconst target = newWriteableStream<Transformed>(reducer);\n\n\tlistenStream(stream, {\n\t\tonData: data => target.write(transformer.data(data)),\n\t\tonError: error => target.error(transformer.error ? transformer.error(error) : error),\n\t\tonEnd: () => target.end()\n\t});\n\n\treturn target;\n}\n\n/**\n * Helper to take an existing readable that will\n * have a prefix injected to the beginning.\n */\nexport function prefixedReadable<T>(prefix: T, readable: Readable<T>, reducer: IReducer<T>): Readable<T> {\n\tlet prefixHandled = false;\n\n\treturn {\n\t\tread: () => {\n\t\t\tconst chunk = readable.read();\n\n\t\t\t// Handle prefix only once\n\t\t\tif (!prefixHandled) {\n\t\t\t\tprefixHandled = true;\n\n\t\t\t\t// If we have also a read-result, make\n\t\t\t\t// sure to reduce it to a single result\n\t\t\t\tif (chunk !== null) {\n\t\t\t\t\treturn reducer([prefix, chunk]);\n\t\t\t\t}\n\n\t\t\t\t// Otherwise, just return prefix directly\n\t\t\t\treturn prefix;\n\t\t\t}\n\n\t\t\treturn chunk;\n\t\t}\n\t};\n}\n\n/**\n * Helper to take an existing stream that will\n * have a prefix injected to the beginning.\n */\nexport function prefixedStream<T>(prefix: T, stream: ReadableStream<T>, reducer: IReducer<T>): ReadableStream<T> {\n\tlet prefixHandled = false;\n\n\tconst target = newWriteableStream<T>(reducer);\n\n\tlistenStream(stream, {\n\t\tonData: data => {\n\n\t\t\t// Handle prefix only once\n\t\t\tif (!prefixHandled) {\n\t\t\t\tprefixHandled = true;\n\n\t\t\t\treturn target.write(reducer([prefix, data]));\n\t\t\t}\n\n\t\t\treturn target.write(data);\n\t\t},\n\t\tonError: error => target.error(error),\n\t\tonEnd: () => {\n\n\t\t\t// Handle prefix only once\n\t\t\tif (!prefixHandled) {\n\t\t\t\tprefixHandled = true;\n\n\t\t\t\ttarget.write(prefix);\n\t\t\t}\n\n\t\t\ttarget.end();\n\t\t}\n\t});\n\n\treturn target;\n}\n"]}