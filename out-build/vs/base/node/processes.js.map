{"version":3,"sources":["file:///workspace/appflow/src/vs/base/node/processes.ts"],"names":[],"mappings":"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","file":"processes.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as cp from 'child_process';\nimport { Stats } from 'fs';\nimport * as path from 'vs/base/common/path';\nimport * as Platform from 'vs/base/common/platform';\nimport * as process from 'vs/base/common/process';\nimport { CommandOptions, ForkOptions, Source, SuccessData, TerminateResponse, TerminateResponseCode } from 'vs/base/common/processes';\nimport * as Types from 'vs/base/common/types';\nimport * as pfs from 'vs/base/node/pfs';\nexport { CommandOptions, ForkOptions, SuccessData, Source, TerminateResponse, TerminateResponseCode };\n\nexport type ValueCallback<T> = (value: T | Promise<T>) => void;\nexport type ErrorCallback = (error?: any) => void;\nexport type ProgressCallback<T> = (progress: T) => void;\n\n\nexport function getWindowsShell(env = process.env as Platform.IProcessEnvironment): string {\n\treturn env['comspec'] || 'cmd.exe';\n}\n\nexport interface IQueuedSender {\n\tsend: (msg: any) => void;\n}\n\n// Wrapper around process.send() that will queue any messages if the internal node.js\n// queue is filled with messages and only continue sending messages when the internal\n// queue is free again to consume messages.\n// On Windows we always wait for the send() method to return before sending the next message\n// to workaround https://github.com/nodejs/node/issues/7657 (IPC can freeze process)\nexport function createQueuedSender(childProcess: cp.ChildProcess): IQueuedSender {\n\tlet msgQueue: string[] = [];\n\tlet useQueue = false;\n\n\tconst send = function (msg: any): void {\n\t\tif (useQueue) {\n\t\t\tmsgQueue.push(msg); // add to the queue if the process cannot handle more messages\n\t\t\treturn;\n\t\t}\n\n\t\tconst result = childProcess.send(msg, (error: Error | null) => {\n\t\t\tif (error) {\n\t\t\t\tconsole.error(error); // unlikely to happen, best we can do is log this error\n\t\t\t}\n\n\t\t\tuseQueue = false; // we are good again to send directly without queue\n\n\t\t\t// now send all the messages that we have in our queue and did not send yet\n\t\t\tif (msgQueue.length > 0) {\n\t\t\t\tconst msgQueueCopy = msgQueue.slice(0);\n\t\t\t\tmsgQueue = [];\n\t\t\t\tmsgQueueCopy.forEach(entry => send(entry));\n\t\t\t}\n\t\t});\n\n\t\tif (!result || Platform.isWindows /* workaround https://github.com/nodejs/node/issues/7657 */) {\n\t\t\tuseQueue = true;\n\t\t}\n\t};\n\n\treturn { send };\n}\n\nexport namespace win32 {\n\texport async function findExecutable(command: string, cwd?: string, paths?: string[]): Promise<string> {\n\t\t// If we have an absolute path then we take it.\n\t\tif (path.isAbsolute(command)) {\n\t\t\treturn command;\n\t\t}\n\t\tif (cwd === undefined) {\n\t\t\tcwd = process.cwd();\n\t\t}\n\t\tconst dir = path.dirname(command);\n\t\tif (dir !== '.') {\n\t\t\t// We have a directory and the directory is relative (see above). Make the path absolute\n\t\t\t// to the current working directory.\n\t\t\treturn path.join(cwd, command);\n\t\t}\n\t\tif (paths === undefined && Types.isString(process.env['PATH'])) {\n\t\t\tpaths = process.env['PATH'].split(path.delimiter);\n\t\t}\n\t\t// No PATH environment. Make path absolute to the cwd.\n\t\tif (paths === undefined || paths.length === 0) {\n\t\t\treturn path.join(cwd, command);\n\t\t}\n\n\t\tasync function fileExists(path: string): Promise<boolean> {\n\t\t\tif (await pfs.Promises.exists(path)) {\n\t\t\t\tlet statValue: Stats | undefined;\n\t\t\t\ttry {\n\t\t\t\t\tstatValue = await pfs.Promises.stat(path);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tif (e.message.startsWith('EACCES')) {\n\t\t\t\t\t\t// it might be symlink\n\t\t\t\t\t\tstatValue = await pfs.Promises.lstat(path);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn statValue ? !statValue.isDirectory() : false;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t// We have a simple file name. We get the path variable from the env\n\t\t// and try to find the executable on the path.\n\t\tfor (const pathEntry of paths) {\n\t\t\t// The path entry is absolute.\n\t\t\tlet fullPath: string;\n\t\t\tif (path.isAbsolute(pathEntry)) {\n\t\t\t\tfullPath = path.join(pathEntry, command);\n\t\t\t} else {\n\t\t\t\tfullPath = path.join(cwd, pathEntry, command);\n\t\t\t}\n\t\t\tif (await fileExists(fullPath)) {\n\t\t\t\treturn fullPath;\n\t\t\t}\n\t\t\tlet withExtension = fullPath + '.com';\n\t\t\tif (await fileExists(withExtension)) {\n\t\t\t\treturn withExtension;\n\t\t\t}\n\t\t\twithExtension = fullPath + '.exe';\n\t\t\tif (await fileExists(withExtension)) {\n\t\t\t\treturn withExtension;\n\t\t\t}\n\t\t}\n\t\treturn path.join(cwd, command);\n\t}\n}\n"]}