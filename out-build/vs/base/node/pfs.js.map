{"version":3,"sources":["file:///workspace/appflow/src/vs/base/node/pfs.ts"],"names":[],"mappings":"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","file":"pfs.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as fs from 'fs';\nimport { tmpdir } from 'os';\nimport { promisify } from 'util';\nimport { ResourceQueue, timeout } from 'vs/base/common/async';\nimport { isEqualOrParent, isRootOrDriveLetter, randomPath } from 'vs/base/common/extpath';\nimport { normalizeNFC } from 'vs/base/common/normalization';\nimport { join } from 'vs/base/common/path';\nimport { isLinux, isMacintosh, isWindows } from 'vs/base/common/platform';\nimport { extUriBiasedIgnorePathCase } from 'vs/base/common/resources';\nimport { URI } from 'vs/base/common/uri';\n\n//#region rimraf\n\nexport enum RimRafMode {\n\n\t/**\n\t * Slow version that unlinks each file and folder.\n\t */\n\tUNLINK,\n\n\t/**\n\t * Fast version that first moves the file/folder\n\t * into a temp directory and then deletes that\n\t * without waiting for it.\n\t */\n\tMOVE\n}\n\n/**\n * Allows to delete the provided path (either file or folder) recursively\n * with the options:\n * - `UNLINK`: direct removal from disk\n * - `MOVE`: faster variant that first moves the target to temp dir and then\n *           deletes it in the background without waiting for that to finish.\n *           the optional `moveToPath` allows to override where to rename the\n *           path to before deleting it.\n */\nasync function rimraf(path: string, mode: RimRafMode.UNLINK): Promise<void>;\nasync function rimraf(path: string, mode: RimRafMode.MOVE, moveToPath?: string): Promise<void>;\nasync function rimraf(path: string, mode?: RimRafMode, moveToPath?: string): Promise<void>;\nasync function rimraf(path: string, mode = RimRafMode.UNLINK, moveToPath?: string): Promise<void> {\n\tif (isRootOrDriveLetter(path)) {\n\t\tthrow new Error('rimraf - will refuse to recursively delete root');\n\t}\n\n\t// delete: via rm\n\tif (mode === RimRafMode.UNLINK) {\n\t\treturn rimrafUnlink(path);\n\t}\n\n\t// delete: via move\n\treturn rimrafMove(path, moveToPath);\n}\n\nasync function rimrafMove(path: string, moveToPath = randomPath(tmpdir())): Promise<void> {\n\ttry {\n\t\ttry {\n\t\t\t// Intentionally using `fs.promises` here to skip\n\t\t\t// the patched graceful-fs method that can result\n\t\t\t// in very long running `rename` calls when the\n\t\t\t// folder is locked by a file watcher. We do not\n\t\t\t// really want to slow down this operation more\n\t\t\t// than necessary and we have a fallback to delete\n\t\t\t// via unlink.\n\t\t\t// https://github.com/microsoft/vscode/issues/139908\n\t\t\tawait fs.promises.rename(path, moveToPath);\n\t\t} catch (error) {\n\t\t\tif (error.code === 'ENOENT') {\n\t\t\t\treturn; // ignore - path to delete did not exist\n\t\t\t}\n\n\t\t\treturn rimrafUnlink(path); // otherwise fallback to unlink\n\t\t}\n\n\t\t// Delete but do not return as promise\n\t\trimrafUnlink(moveToPath).catch(error => {/* ignore */ });\n\t} catch (error) {\n\t\tif (error.code !== 'ENOENT') {\n\t\t\tthrow error;\n\t\t}\n\t}\n}\n\nasync function rimrafUnlink(path: string): Promise<void> {\n\treturn promisify(fs.rm)(path, { recursive: true, force: true, maxRetries: 3 });\n}\n\nexport function rimrafSync(path: string): void {\n\tif (isRootOrDriveLetter(path)) {\n\t\tthrow new Error('rimraf - will refuse to recursively delete root');\n\t}\n\n\tfs.rmSync(path, { recursive: true, force: true, maxRetries: 3 });\n}\n\n//#endregion\n\n//#region readdir with NFC support (macos)\n\nexport interface IDirent {\n\tname: string;\n\n\tisFile(): boolean;\n\tisDirectory(): boolean;\n\tisSymbolicLink(): boolean;\n}\n\n/**\n * Drop-in replacement of `fs.readdir` with support\n * for converting from macOS NFD unicon form to NFC\n * (https://github.com/nodejs/node/issues/2165)\n */\nasync function readdir(path: string): Promise<string[]>;\nasync function readdir(path: string, options: { withFileTypes: true }): Promise<IDirent[]>;\nasync function readdir(path: string, options?: { withFileTypes: true }): Promise<(string | IDirent)[]> {\n\treturn handleDirectoryChildren(await (options ? safeReaddirWithFileTypes(path) : promisify(fs.readdir)(path)));\n}\n\nasync function safeReaddirWithFileTypes(path: string): Promise<IDirent[]> {\n\ttry {\n\t\treturn await promisify(fs.readdir)(path, { withFileTypes: true });\n\t} catch (error) {\n\t\tconsole.warn('[node.js fs] readdir with filetypes failed with error: ', error);\n\t}\n\n\t// Fallback to manually reading and resolving each\n\t// children of the folder in case we hit an error\n\t// previously.\n\t// This can only really happen on exotic file systems\n\t// such as explained in #115645 where we get entries\n\t// from `readdir` that we can later not `lstat`.\n\tconst result: IDirent[] = [];\n\tconst children = await readdir(path);\n\tfor (const child of children) {\n\t\tlet isFile = false;\n\t\tlet isDirectory = false;\n\t\tlet isSymbolicLink = false;\n\n\t\ttry {\n\t\t\tconst lstat = await Promises.lstat(join(path, child));\n\n\t\t\tisFile = lstat.isFile();\n\t\t\tisDirectory = lstat.isDirectory();\n\t\t\tisSymbolicLink = lstat.isSymbolicLink();\n\t\t} catch (error) {\n\t\t\tconsole.warn('[node.js fs] unexpected error from lstat after readdir: ', error);\n\t\t}\n\n\t\tresult.push({\n\t\t\tname: child,\n\t\t\tisFile: () => isFile,\n\t\t\tisDirectory: () => isDirectory,\n\t\t\tisSymbolicLink: () => isSymbolicLink\n\t\t});\n\t}\n\n\treturn result;\n}\n\n/**\n * Drop-in replacement of `fs.readdirSync` with support\n * for converting from macOS NFD unicon form to NFC\n * (https://github.com/nodejs/node/issues/2165)\n */\nexport function readdirSync(path: string): string[] {\n\treturn handleDirectoryChildren(fs.readdirSync(path));\n}\n\nfunction handleDirectoryChildren(children: string[]): string[];\nfunction handleDirectoryChildren(children: IDirent[]): IDirent[];\nfunction handleDirectoryChildren(children: (string | IDirent)[]): (string | IDirent)[];\nfunction handleDirectoryChildren(children: (string | IDirent)[]): (string | IDirent)[] {\n\treturn children.map(child => {\n\n\t\t// Mac: uses NFD unicode form on disk, but we want NFC\n\t\t// See also https://github.com/nodejs/node/issues/2165\n\n\t\tif (typeof child === 'string') {\n\t\t\treturn isMacintosh ? normalizeNFC(child) : child;\n\t\t}\n\n\t\tchild.name = isMacintosh ? normalizeNFC(child.name) : child.name;\n\n\t\treturn child;\n\t});\n}\n\n/**\n * A convenience method to read all children of a path that\n * are directories.\n */\nasync function readDirsInDir(dirPath: string): Promise<string[]> {\n\tconst children = await readdir(dirPath);\n\tconst directories: string[] = [];\n\n\tfor (const child of children) {\n\t\tif (await SymlinkSupport.existsDirectory(join(dirPath, child))) {\n\t\t\tdirectories.push(child);\n\t\t}\n\t}\n\n\treturn directories;\n}\n\n//#endregion\n\n//#region whenDeleted()\n\n/**\n * A `Promise` that resolves when the provided `path`\n * is deleted from disk.\n */\nexport function whenDeleted(path: string, intervalMs = 1000): Promise<void> {\n\treturn new Promise<void>(resolve => {\n\t\tlet running = false;\n\t\tconst interval = setInterval(() => {\n\t\t\tif (!running) {\n\t\t\t\trunning = true;\n\t\t\t\tfs.access(path, err => {\n\t\t\t\t\trunning = false;\n\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tclearInterval(interval);\n\t\t\t\t\t\tresolve(undefined);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}, intervalMs);\n\t});\n}\n\n//#endregion\n\n//#region Methods with symbolic links support\n\nexport namespace SymlinkSupport {\n\n\texport interface IStats {\n\n\t\t// The stats of the file. If the file is a symbolic\n\t\t// link, the stats will be of that target file and\n\t\t// not the link itself.\n\t\t// If the file is a symbolic link pointing to a non\n\t\t// existing file, the stat will be of the link and\n\t\t// the `dangling` flag will indicate this.\n\t\tstat: fs.Stats;\n\n\t\t// Will be provided if the resource is a symbolic link\n\t\t// on disk. Use the `dangling` flag to find out if it\n\t\t// points to a resource that does not exist on disk.\n\t\tsymbolicLink?: { dangling: boolean };\n\t}\n\n\t/**\n\t * Resolves the `fs.Stats` of the provided path. If the path is a\n\t * symbolic link, the `fs.Stats` will be from the target it points\n\t * to. If the target does not exist, `dangling: true` will be returned\n\t * as `symbolicLink` value.\n\t */\n\texport async function stat(path: string): Promise<IStats> {\n\n\t\t// First stat the link\n\t\tlet lstats: fs.Stats | undefined;\n\t\ttry {\n\t\t\tlstats = await Promises.lstat(path);\n\n\t\t\t// Return early if the stat is not a symbolic link at all\n\t\t\tif (!lstats.isSymbolicLink()) {\n\t\t\t\treturn { stat: lstats };\n\t\t\t}\n\t\t} catch (error) {\n\t\t\t/* ignore - use stat() instead */\n\t\t}\n\n\t\t// If the stat is a symbolic link or failed to stat, use fs.stat()\n\t\t// which for symbolic links will stat the target they point to\n\t\ttry {\n\t\t\tconst stats = await Promises.stat(path);\n\n\t\t\treturn { stat: stats, symbolicLink: lstats?.isSymbolicLink() ? { dangling: false } : undefined };\n\t\t} catch (error) {\n\n\t\t\t// If the link points to a nonexistent file we still want\n\t\t\t// to return it as result while setting dangling: true flag\n\t\t\tif (error.code === 'ENOENT' && lstats) {\n\t\t\t\treturn { stat: lstats, symbolicLink: { dangling: true } };\n\t\t\t}\n\n\t\t\t// Windows: workaround a node.js bug where reparse points\n\t\t\t// are not supported (https://github.com/nodejs/node/issues/36790)\n\t\t\tif (isWindows && error.code === 'EACCES') {\n\t\t\t\ttry {\n\t\t\t\t\tconst stats = await Promises.stat(await Promises.readlink(path));\n\n\t\t\t\t\treturn { stat: stats, symbolicLink: { dangling: false } };\n\t\t\t\t} catch (error) {\n\n\t\t\t\t\t// If the link points to a nonexistent file we still want\n\t\t\t\t\t// to return it as result while setting dangling: true flag\n\t\t\t\t\tif (error.code === 'ENOENT' && lstats) {\n\t\t\t\t\t\treturn { stat: lstats, symbolicLink: { dangling: true } };\n\t\t\t\t\t}\n\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Figures out if the `path` exists and is a file with support\n\t * for symlinks.\n\t *\n\t * Note: this will return `false` for a symlink that exists on\n\t * disk but is dangling (pointing to a nonexistent path).\n\t *\n\t * Use `exists` if you only care about the path existing on disk\n\t * or not without support for symbolic links.\n\t */\n\texport async function existsFile(path: string): Promise<boolean> {\n\t\ttry {\n\t\t\tconst { stat, symbolicLink } = await SymlinkSupport.stat(path);\n\n\t\t\treturn stat.isFile() && symbolicLink?.dangling !== true;\n\t\t} catch (error) {\n\t\t\t// Ignore, path might not exist\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Figures out if the `path` exists and is a directory with support for\n\t * symlinks.\n\t *\n\t * Note: this will return `false` for a symlink that exists on\n\t * disk but is dangling (pointing to a nonexistent path).\n\t *\n\t * Use `exists` if you only care about the path existing on disk\n\t * or not without support for symbolic links.\n\t */\n\texport async function existsDirectory(path: string): Promise<boolean> {\n\t\ttry {\n\t\t\tconst { stat, symbolicLink } = await SymlinkSupport.stat(path);\n\n\t\t\treturn stat.isDirectory() && symbolicLink?.dangling !== true;\n\t\t} catch (error) {\n\t\t\t// Ignore, path might not exist\n\t\t}\n\n\t\treturn false;\n\t}\n}\n\n//#endregion\n\n//#region Write File\n\n// According to node.js docs (https://nodejs.org/docs/v14.16.0/api/fs.html#fs_fs_writefile_file_data_options_callback)\n// it is not safe to call writeFile() on the same path multiple times without waiting for the callback to return.\n// Therefor we use a Queue on the path that is given to us to sequentialize calls to the same path properly.\nconst writeQueues = new ResourceQueue();\n\n/**\n * Same as `fs.writeFile` but with an additional call to\n * `fs.fdatasync` after writing to ensure changes are\n * flushed to disk.\n *\n * In addition, multiple writes to the same path are queued.\n */\nfunction writeFile(path: string, data: string, options?: IWriteFileOptions): Promise<void>;\nfunction writeFile(path: string, data: Buffer, options?: IWriteFileOptions): Promise<void>;\nfunction writeFile(path: string, data: Uint8Array, options?: IWriteFileOptions): Promise<void>;\nfunction writeFile(path: string, data: string | Buffer | Uint8Array, options?: IWriteFileOptions): Promise<void>;\nfunction writeFile(path: string, data: string | Buffer | Uint8Array, options?: IWriteFileOptions): Promise<void> {\n\treturn writeQueues.queueFor(URI.file(path), extUriBiasedIgnorePathCase).queue(() => {\n\t\tconst ensuredOptions = ensureWriteOptions(options);\n\n\t\treturn new Promise((resolve, reject) => doWriteFileAndFlush(path, data, ensuredOptions, error => error ? reject(error) : resolve()));\n\t});\n}\n\ninterface IWriteFileOptions {\n\tmode?: number;\n\tflag?: string;\n}\n\ninterface IEnsuredWriteFileOptions extends IWriteFileOptions {\n\tmode: number;\n\tflag: string;\n}\n\nlet canFlush = true;\nexport function configureFlushOnWrite(enabled: boolean): void {\n\tcanFlush = enabled;\n}\n\n// Calls fs.writeFile() followed by a fs.sync() call to flush the changes to disk\n// We do this in cases where we want to make sure the data is really on disk and\n// not in some cache.\n//\n// See https://github.com/nodejs/node/blob/v5.10.0/lib/fs.js#L1194\nfunction doWriteFileAndFlush(path: string, data: string | Buffer | Uint8Array, options: IEnsuredWriteFileOptions, callback: (error: Error | null) => void): void {\n\tif (!canFlush) {\n\t\treturn fs.writeFile(path, data, { mode: options.mode, flag: options.flag }, callback);\n\t}\n\n\t// Open the file with same flags and mode as fs.writeFile()\n\tfs.open(path, options.flag, options.mode, (openError, fd) => {\n\t\tif (openError) {\n\t\t\treturn callback(openError);\n\t\t}\n\n\t\t// It is valid to pass a fd handle to fs.writeFile() and this will keep the handle open!\n\t\tfs.writeFile(fd, data, writeError => {\n\t\t\tif (writeError) {\n\t\t\t\treturn fs.close(fd, () => callback(writeError)); // still need to close the handle on error!\n\t\t\t}\n\n\t\t\t// Flush contents (not metadata) of the file to disk\n\t\t\t// https://github.com/microsoft/vscode/issues/9589\n\t\t\tfs.fdatasync(fd, (syncError: Error | null) => {\n\n\t\t\t\t// In some exotic setups it is well possible that node fails to sync\n\t\t\t\t// In that case we disable flushing and warn to the console\n\t\t\t\tif (syncError) {\n\t\t\t\t\tconsole.warn('[node.js fs] fdatasync is now disabled for this session because it failed: ', syncError);\n\t\t\t\t\tconfigureFlushOnWrite(false);\n\t\t\t\t}\n\n\t\t\t\treturn fs.close(fd, closeError => callback(closeError));\n\t\t\t});\n\t\t});\n\t});\n}\n\n/**\n * Same as `fs.writeFileSync` but with an additional call to\n * `fs.fdatasyncSync` after writing to ensure changes are\n * flushed to disk.\n */\nexport function writeFileSync(path: string, data: string | Buffer, options?: IWriteFileOptions): void {\n\tconst ensuredOptions = ensureWriteOptions(options);\n\n\tif (!canFlush) {\n\t\treturn fs.writeFileSync(path, data, { mode: ensuredOptions.mode, flag: ensuredOptions.flag });\n\t}\n\n\t// Open the file with same flags and mode as fs.writeFile()\n\tconst fd = fs.openSync(path, ensuredOptions.flag, ensuredOptions.mode);\n\n\ttry {\n\n\t\t// It is valid to pass a fd handle to fs.writeFile() and this will keep the handle open!\n\t\tfs.writeFileSync(fd, data);\n\n\t\t// Flush contents (not metadata) of the file to disk\n\t\ttry {\n\t\t\tfs.fdatasyncSync(fd); // https://github.com/microsoft/vscode/issues/9589\n\t\t} catch (syncError) {\n\t\t\tconsole.warn('[node.js fs] fdatasyncSync is now disabled for this session because it failed: ', syncError);\n\t\t\tconfigureFlushOnWrite(false);\n\t\t}\n\t} finally {\n\t\tfs.closeSync(fd);\n\t}\n}\n\nfunction ensureWriteOptions(options?: IWriteFileOptions): IEnsuredWriteFileOptions {\n\tif (!options) {\n\t\treturn { mode: 0o666 /* default node.js mode for files */, flag: 'w' };\n\t}\n\n\treturn {\n\t\tmode: typeof options.mode === 'number' ? options.mode : 0o666 /* default node.js mode for files */,\n\t\tflag: typeof options.flag === 'string' ? options.flag : 'w'\n\t};\n}\n\n//#endregion\n\n//#region Move / Copy\n\n/**\n * A drop-in replacement for `fs.rename` that:\n * - allows to move across multiple disks\n * - attempts to retry the operation for certain error codes on Windows\n */\nasync function rename(source: string, target: string, windowsRetryTimeout: number | false = 60000 /* matches graceful-fs */): Promise<void> {\n\tif (source === target) {\n\t\treturn;  // simulate node.js behaviour here and do a no-op if paths match\n\t}\n\n\ttry {\n\t\tif (isWindows && typeof windowsRetryTimeout === 'number') {\n\t\t\t// On Windows, a rename can fail when either source or target\n\t\t\t// is locked by AV software. We do leverage graceful-fs to iron\n\t\t\t// out these issues, however in case the target file exists,\n\t\t\t// graceful-fs will immediately return without retry for fs.rename().\n\t\t\tawait renameWithRetry(source, target, Date.now(), windowsRetryTimeout);\n\t\t} else {\n\t\t\tawait promisify(fs.rename)(source, target);\n\t\t}\n\t} catch (error) {\n\t\t// In two cases we fallback to classic copy and delete:\n\t\t//\n\t\t// 1.) The EXDEV error indicates that source and target are on different devices\n\t\t// In this case, fallback to using a copy() operation as there is no way to\n\t\t// rename() between different devices.\n\t\t//\n\t\t// 2.) The user tries to rename a file/folder that ends with a dot. This is not\n\t\t// really possible to move then, at least on UNC devices.\n\t\tif (source.toLowerCase() !== target.toLowerCase() && error.code === 'EXDEV' || source.endsWith('.')) {\n\t\t\tawait copy(source, target, { preserveSymlinks: false /* copying to another device */ });\n\t\t\tawait rimraf(source, RimRafMode.MOVE);\n\t\t} else {\n\t\t\tthrow error;\n\t\t}\n\t}\n}\n\nasync function renameWithRetry(source: string, target: string, startTime: number, retryTimeout: number, attempt = 0): Promise<void> {\n\ttry {\n\t\treturn await promisify(fs.rename)(source, target);\n\t} catch (error) {\n\t\tif (error.code !== 'EACCES' && error.code !== 'EPERM' && error.code !== 'EBUSY') {\n\t\t\tthrow error; // only for errors we think are temporary\n\t\t}\n\n\t\tif (Date.now() - startTime >= retryTimeout) {\n\t\t\tconsole.error(`[node.js fs] rename failed after ${attempt} retries with error: ${error}`);\n\n\t\t\tthrow error; // give up after configurable timeout\n\t\t}\n\n\t\tif (attempt === 0) {\n\t\t\tlet abortRetry = false;\n\t\t\ttry {\n\t\t\t\tconst { stat } = await SymlinkSupport.stat(target);\n\t\t\t\tif (!stat.isFile()) {\n\t\t\t\t\tabortRetry = true; // if target is not a file, EPERM error may be raised and we should not attempt to retry\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\t// Ignore\n\t\t\t}\n\n\t\t\tif (abortRetry) {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t}\n\n\t\t// Delay with incremental backoff up to 100ms\n\t\tawait timeout(Math.min(100, attempt * 10));\n\n\t\t// Attempt again\n\t\treturn renameWithRetry(source, target, startTime, retryTimeout, attempt + 1);\n\t}\n}\n\ninterface ICopyPayload {\n\treadonly root: { source: string; target: string };\n\treadonly options: { preserveSymlinks: boolean };\n\treadonly handledSourcePaths: Set<string>;\n}\n\n/**\n * Recursively copies all of `source` to `target`.\n *\n * The options `preserveSymlinks` configures how symbolic\n * links should be handled when encountered. Set to\n * `false` to not preserve them and `true` otherwise.\n */\nasync function copy(source: string, target: string, options: { preserveSymlinks: boolean }): Promise<void> {\n\treturn doCopy(source, target, { root: { source, target }, options, handledSourcePaths: new Set<string>() });\n}\n\n// When copying a file or folder, we want to preserve the mode\n// it had and as such provide it when creating. However, modes\n// can go beyond what we expect (see link below), so we mask it.\n// (https://github.com/nodejs/node-v0.x-archive/issues/3045#issuecomment-4862588)\nconst COPY_MODE_MASK = 0o777;\n\nasync function doCopy(source: string, target: string, payload: ICopyPayload): Promise<void> {\n\n\t// Keep track of paths already copied to prevent\n\t// cycles from symbolic links to cause issues\n\tif (payload.handledSourcePaths.has(source)) {\n\t\treturn;\n\t} else {\n\t\tpayload.handledSourcePaths.add(source);\n\t}\n\n\tconst { stat, symbolicLink } = await SymlinkSupport.stat(source);\n\n\t// Symlink\n\tif (symbolicLink) {\n\n\t\t// Try to re-create the symlink unless `preserveSymlinks: false`\n\t\tif (payload.options.preserveSymlinks) {\n\t\t\ttry {\n\t\t\t\treturn await doCopySymlink(source, target, payload);\n\t\t\t} catch (error) {\n\t\t\t\t// in any case of an error fallback to normal copy via dereferencing\n\t\t\t\tconsole.warn('[node.js fs] copy of symlink failed: ', error);\n\t\t\t}\n\t\t}\n\n\t\tif (symbolicLink.dangling) {\n\t\t\treturn; // skip dangling symbolic links from here on (https://github.com/microsoft/vscode/issues/111621)\n\t\t}\n\t}\n\n\t// Folder\n\tif (stat.isDirectory()) {\n\t\treturn doCopyDirectory(source, target, stat.mode & COPY_MODE_MASK, payload);\n\t}\n\n\t// File or file-like\n\telse {\n\t\treturn doCopyFile(source, target, stat.mode & COPY_MODE_MASK);\n\t}\n}\n\nasync function doCopyDirectory(source: string, target: string, mode: number, payload: ICopyPayload): Promise<void> {\n\n\t// Create folder\n\tawait Promises.mkdir(target, { recursive: true, mode });\n\n\t// Copy each file recursively\n\tconst files = await readdir(source);\n\tfor (const file of files) {\n\t\tawait doCopy(join(source, file), join(target, file), payload);\n\t}\n}\n\nasync function doCopyFile(source: string, target: string, mode: number): Promise<void> {\n\n\t// Copy file\n\tawait Promises.copyFile(source, target);\n\n\t// restore mode (https://github.com/nodejs/node/issues/1104)\n\tawait Promises.chmod(target, mode);\n}\n\nasync function doCopySymlink(source: string, target: string, payload: ICopyPayload): Promise<void> {\n\n\t// Figure out link target\n\tlet linkTarget = await Promises.readlink(source);\n\n\t// Special case: the symlink points to a target that is\n\t// actually within the path that is being copied. In that\n\t// case we want the symlink to point to the target and\n\t// not the source\n\tif (isEqualOrParent(linkTarget, payload.root.source, !isLinux)) {\n\t\tlinkTarget = join(payload.root.target, linkTarget.substr(payload.root.source.length + 1));\n\t}\n\n\t// Create symlink\n\tawait Promises.symlink(linkTarget, target);\n}\n\n//#endregion\n\n//#region Promise based fs methods\n\n/**\n * Prefer this helper class over the `fs.promises` API to\n * enable `graceful-fs` to function properly. Given issue\n * https://github.com/isaacs/node-graceful-fs/issues/160 it\n * is evident that the module only takes care of the non-promise\n * based fs methods.\n *\n * Another reason is `realpath` being entirely different in\n * the promise based implementation compared to the other\n * one (https://github.com/microsoft/vscode/issues/118562)\n *\n * Note: using getters for a reason, since `graceful-fs`\n * patching might kick in later after modules have been\n * loaded we need to defer access to fs methods.\n * (https://github.com/microsoft/vscode/issues/124176)\n */\nexport const Promises = new class {\n\n\t//#region Implemented by node.js\n\n\tget access() { return promisify(fs.access); }\n\n\tget stat() { return promisify(fs.stat); }\n\tget lstat() { return promisify(fs.lstat); }\n\tget utimes() { return promisify(fs.utimes); }\n\n\tget read() {\n\n\t\t// Not using `promisify` here for a reason: the return\n\t\t// type is not an object as indicated by TypeScript but\n\t\t// just the bytes read, so we create our own wrapper.\n\n\t\treturn (fd: number, buffer: Uint8Array, offset: number, length: number, position: number | null) => {\n\t\t\treturn new Promise<{ bytesRead: number; buffer: Uint8Array }>((resolve, reject) => {\n\t\t\t\tfs.read(fd, buffer, offset, length, position, (err, bytesRead, buffer) => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\treturn reject(err);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn resolve({ bytesRead, buffer });\n\t\t\t\t});\n\t\t\t});\n\t\t};\n\t}\n\tget readFile() { return promisify(fs.readFile); }\n\n\tget write() {\n\n\t\t// Not using `promisify` here for a reason: the return\n\t\t// type is not an object as indicated by TypeScript but\n\t\t// just the bytes written, so we create our own wrapper.\n\n\t\treturn (fd: number, buffer: Uint8Array, offset: number | undefined | null, length: number | undefined | null, position: number | undefined | null) => {\n\t\t\treturn new Promise<{ bytesWritten: number; buffer: Uint8Array }>((resolve, reject) => {\n\t\t\t\tfs.write(fd, buffer, offset, length, position, (err, bytesWritten, buffer) => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\treturn reject(err);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn resolve({ bytesWritten, buffer });\n\t\t\t\t});\n\t\t\t});\n\t\t};\n\t}\n\n\tget appendFile() { return promisify(fs.appendFile); }\n\n\tget fdatasync() { return promisify(fs.fdatasync); }\n\tget truncate() { return promisify(fs.truncate); }\n\n\tget copyFile() { return promisify(fs.copyFile); }\n\n\tget open() { return promisify(fs.open); }\n\tget close() { return promisify(fs.close); }\n\n\tget symlink() { return promisify(fs.symlink); }\n\tget readlink() { return promisify(fs.readlink); }\n\n\tget chmod() { return promisify(fs.chmod); }\n\n\tget mkdir() { return promisify(fs.mkdir); }\n\n\tget unlink() { return promisify(fs.unlink); }\n\tget rmdir() { return promisify(fs.rmdir); }\n\n\tget realpath() { return promisify(fs.realpath); }\n\n\t//#endregion\n\n\t//#region Implemented by us\n\n\tasync exists(path: string): Promise<boolean> {\n\t\ttry {\n\t\t\tawait Promises.access(path);\n\n\t\t\treturn true;\n\t\t} catch {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tget readdir() { return readdir; }\n\tget readDirsInDir() { return readDirsInDir; }\n\n\tget writeFile() { return writeFile; }\n\n\tget rm() { return rimraf; }\n\n\tget rename() { return rename; }\n\tget copy() { return copy; }\n\n\t//#endregion\n};\n\n//#endregion\n"]}