{"version":3,"sources":["file:///workspace/appflow/src/vs/base/parts/ipc/common/ipc.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;;;;;;;IAmChG,IAAW,WAKV;IALD,WAAW,WAAW;QACrB,qDAAa,CAAA;QACb,iEAAmB,CAAA;QACnB,6DAAiB,CAAA;QACjB,+DAAkB,CAAA;IACnB,CAAC,EALU,WAAW,KAAX,WAAW,QAKrB;IAED,SAAS,gBAAgB,CAAC,IAAiB;QAC1C,QAAQ,IAAI,EAAE;YACb;gBACC,OAAO,KAAK,CAAC;YACd;gBACC,OAAO,QAAQ,CAAC;YACjB;gBACC,OAAO,WAAW,CAAC;YACpB;gBACC,OAAO,aAAa,CAAC;SACtB;IACF,CAAC;IAQD,IAAW,YAMV;IAND,WAAW,YAAY;QACtB,6DAAgB,CAAA;QAChB,qEAAoB,CAAA;QACpB,iEAAkB,CAAA;QAClB,uEAAqB,CAAA;QACrB,2DAAe,CAAA;IAChB,CAAC,EANU,YAAY,KAAZ,YAAY,QAMtB;IAED,SAAS,iBAAiB,CAAC,IAAkB;QAC5C,QAAQ,IAAI,EAAE;YACb;gBACC,OAAO,MAAM,CAAC;YACf;gBACC,OAAO,QAAQ,CAAC;YACjB,yCAA+B;YAC/B;gBACC,OAAO,WAAW,CAAC;YACpB;gBACC,OAAO,QAAQ,CAAC;SACjB;IACF,CAAC;IAsBD,IAAK,KAGJ;IAHD,WAAK,KAAK;QACT,mDAAa,CAAA;QACb,iCAAI,CAAA;IACL,CAAC,EAHI,KAAK,KAAL,KAAK,QAGT;IA0DD;;OAEG;IACH,SAAS,UAAU,CAAC,MAAe;QAClC,IAAI,KAAK,GAAG,CAAC,CAAC;QACd,KAAK,IAAI,CAAC,GAAG,CAAC,GAAI,CAAC,IAAI,CAAC,EAAE;YACzB,MAAM,IAAI,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YAC5B,KAAK,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,GAAG,UAAU,CAAC,IAAI,CAAC,CAAC;YAC5C,IAAI,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,GAAG,UAAU,CAAC,EAAE;gBACnC,OAAO,KAAK,CAAC;aACb;SACD;IACF,CAAC;IAED,MAAM,OAAO,GAAG,mBAAmB,CAAC,CAAC,CAAC,CAAC;IAEvC;;OAEG;IACH,SAAS,aAAa,CAAC,MAAe,EAAE,KAAa;QACpD,IAAI,KAAK,KAAK,CAAC,EAAE;YAChB,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC;YACtB,OAAO;SACP;QAED,IAAI,GAAG,GAAG,CAAC,CAAC;QACZ,KAAK,IAAI,EAAE,GAAG,KAAK,EAAE,EAAE,KAAK,CAAC,EAAE,EAAE,GAAG,EAAE,KAAK,CAAC,EAAE;YAC7C,GAAG,EAAE,CAAC;SACN;QAED,MAAM,OAAO,GAAG,YAAG,CAAM,KAAK,CAAC,GAAG,CAAC,CAAC;QACpC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,KAAK,KAAK,CAAC,EAAE,CAAC,EAAE,EAAE;YACjC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,GAAG,KAAK,GAAG,UAAU,CAAC;YACvC,KAAK,GAAG,KAAK,KAAK,CAAC,CAAC;YACpB,IAAI,KAAK,GAAG,CAAC,EAAE;gBACd,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,UAAU,CAAC;aAChC;SACD;QAED,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC;IACvB,CAAC;IAED,MAAa,GAAG;QAIf,YAAoB,CAAW;YAAX,MAAC,GAAD,CAAC,CAAU;YAFvB,MAAC,GAAK,CAAC,CAAC;QAEwB,CAAC;QAEzC,IAAI,CAAC,KAAa;YACjB,MAAM,MAAM,GAAG,IAAI,CAAC,CAAC,CAAM,KAAK,CAAC,IAAI,CAAC,CAAC,EAAI,IAAI,CAAC,CAAC,GAAK,KAAK,CAAC,CAAC;YAC7D,IAAI,CAAC,CAAC,IAAM,MAAM,CAAC,UAAU,CAAC;YAC9B,OAAO,MAAM,CAAC;QACf,CAAC;KACD;IAXD,kBAWC;IAED,MAAa,GAAG;QAAhB;YAES,MAAC,GAAqB,EAAE,CAAC;QASlC,CAAC;QAPA,IAAI,MAAM;YACT,OAAO,YAAG,CAAM,MAAM,CAAC,IAAI,CAAC,CAAC,CAAO,CAAC;QACtC,CAAC;QAED,KAAK,CAAC,MAAW;YAChB,IAAI,CAAC,CAAC,CAAO,IAAI,CAAC,MAAM,CAAC,CAAC;QAC3B,CAAC;KACD;IAXD,kBAWC;IAED,IAAK,QAQJ;IARD,WAAK,QAAQ;QACZ,iDAAa,CAAA;QACb,2CAAU,CAAA;QACV,2CAAU,CAAA;QACV,+CAAY,CAAA;QACZ,yCAAS,CAAA;QACT,2CAAU,CAAA;QACV,qCAAO,CAAA;IACR,CAAC,EARI,QAAQ,KAAR,QAAQ,QAQZ;IAED,SAAS,mBAAmB,CAAC,KAAa;QACzC,MAAM,MAAM,GAAG,YAAG,CAAM,KAAK,CAAC,CAAC,CAAC,CAAC;QACjC,MAAM,CAAC,UAAU,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;QAC5B,OAAO,MAAM,CAAC;IACf,CAAC;IAED,MAAM,aAAa,GAAG;QACrB,SAAS,EAAE,mBAAmB,CAAC,QAAQ,CAAC,SAAS,CAAC;QAClD,MAAM,EAAE,mBAAmB,CAAC,QAAQ,CAAC,MAAM,CAAC;QAC5C,MAAM,EAAE,mBAAmB,CAAC,QAAQ,CAAC,MAAM,CAAC;QAC5C,QAAQ,EAAE,mBAAmB,CAAC,QAAQ,CAAC,QAAQ,CAAC;QAChD,KAAK,EAAE,mBAAmB,CAAC,QAAQ,CAAC,KAAK,CAAC;QAC1C,MAAM,EAAE,mBAAmB,CAAC,QAAQ,CAAC,MAAM,CAAC;QAC5C,IAAI,EAAE,mBAAmB,CAAC,QAAQ,CAAC,GAAG,CAAC;KACvC,CAAC;IAGF,MAAM,SAAS,GAAG,CAAC,OAAO,MAAM,KAAK,WAAW,CAAC,CAAC;IAElD,SAAgB,GAAG,CAAO,MAAe,EAAE,IAAS;QACnD,IAAI,OAAO,IAAI,KAAK,WAAW,EAAE;YAChC,MAAM,CAAC,KAAK,CAAC,aAAa,CAAC,SAAS,CAAC,CAAC;SACtC;aAAM,IAAI,OAAO,IAAI,KAAK,QAAQ,EAAE;YACpC,MAAM,MAAM,GAAG,YAAG,CAAM,UAAU,CAAC,IAAI,CAAC,CAAC;YACzC,MAAM,CAAC,KAAK,CAAC,aAAa,CAAC,MAAM,CAAC,CAAC;YACnC,aAAa,CAAC,MAAM,EAAE,MAAM,CAAC,UAAU,CAAC,CAAC;YACzC,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;SACrB;aAAM,IAAI,SAAS,IAAI,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE;YAC9C,MAAM,MAAM,GAAG,YAAG,CAAM,IAAI,CAAC,IAAI,CAAC,CAAC;YACnC,MAAM,CAAC,KAAK,CAAC,aAAa,CAAC,MAAM,CAAC,CAAC;YACnC,aAAa,CAAC,MAAM,EAAE,MAAM,CAAC,UAAU,CAAC,CAAC;YACzC,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;SACrB;aAAM,IAAI,IAAI,YAAY,YAAG,EAAO;YACpC,MAAM,CAAC,KAAK,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC;YACrC,aAAa,CAAC,MAAM,EAAE,IAAI,CAAC,UAAU,CAAC,CAAC;YACvC,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;SACnB;aAAM,IAAI,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE;YAC/B,MAAM,CAAC,KAAK,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC;YAClC,aAAa,CAAC,MAAM,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC;YAEnC,KAAK,MAAM,EAAE,IAAI,IAAI,EAAE;gBACtB,GAAG,CAAO,MAAM,EAAE,EAAE,CAAC,CAAC;aACtB;SACD;aAAM,IAAI,OAAO,IAAI,KAAK,QAAQ,IAAI,CAAC,IAAI,GAAG,CAAC,CAAC,KAAK,IAAI,EAAE;YAC3D,oEAAoE;YACpE,MAAM,CAAC,KAAK,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;YACjC,aAAa,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC;SAC5B;aAAM;YACN,MAAM,MAAM,GAAG,YAAG,CAAM,UAAU,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC;YACzD,MAAM,CAAC,KAAK,CAAC,aAAa,CAAC,MAAM,CAAC,CAAC;YACnC,aAAa,CAAC,MAAM,EAAE,MAAM,CAAC,UAAU,CAAC,CAAC;YACzC,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;SACrB;IACF,CAAC;IAlCD,kBAkCC;IAED,SAAgB,GAAG,CAAS,MAAe;QAC1C,MAAM,IAAI,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;QAEzC,QAAQ,IAAI,EAAE;YACb,KAAK,QAAQ,CAAC,SAAS,CAAC,CAAC,OAAO,SAAS,CAAC;YAC1C,KAAK,QAAQ,CAAC,MAAM,CAAC,CAAC,OAAO,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC,CAAC,QAAQ,EAAE,CAAC;YACxE,KAAK,QAAQ,CAAC,MAAM,CAAC,CAAC,OAAO,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC,CAAC,MAAM,CAAC;YACpE,KAAK,QAAQ,CAAC,QAAQ,CAAC,CAAC,OAAO,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC,CAAC;YAC/D,KAAK,QAAQ,CAAC,KAAK,CAAC,CAAC;gBACpB,MAAM,MAAM,GAAG,UAAU,CAAC,MAAM,CAAC,CAAC;gBAClC,MAAM,MAAM,GAAU,EAAE,CAAC;gBAEzB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,EAAE,CAAC,EAAE,EAAE;oBAChC,MAAM,CAAC,IAAI,CAAC,GAAG,CAAS,MAAM,CAAC,CAAC,CAAC;iBACjC;gBAED,OAAO,MAAM,CAAC;aACd;YACD,KAAK,QAAQ,CAAC,MAAM,CAAC,CAAC,OAAO,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC,CAAC,QAAQ,EAAE,CAAC,CAAC;YACpF,KAAK,QAAQ,CAAC,GAAG,CAAC,CAAC,OAAO,UAAU,CAAC,MAAM,CAAC,CAAC;SAC7C;IACF,CAAC;IArBD,kBAqBC;IAOD,MAAa,GAAG;QAUf,YAAoB,CAAiC,EAAU,CAAa,EAAU,IAA4B,IAAI,EAAU,IAAuB,IAAI;YAAvI,MAAC,GAAD,CAAC,CAAgC;YAAU,MAAC,GAAD,CAAC,CAAY;YAAU,MAAC,GAAD,CAAC,CAA+B;YAAU,MAAC,GAAD,CAAC,CAA0B;YARnJ,MAAC,GAAU,IAAI,GAAG,EAAoC,CAAC;YACvD,MAAC,GAAgB,IAAI,GAAG,EAAuB,CAAC;YAGxD,oEAAoE;YACpE,0CAA0C;YAClC,MAAC,GAAiB,IAAI,GAAG,EAA4B,CAAC;YAG7D,IAAI,CAAC,CAAC,GAAkB,IAAI,CAAC,CAAC,CAAQ,SAAS,CAAC,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,CAAC,CAAY,GAAG,CAAC,CAAC,CAAC;YAC/E,IAAI,CAAC,CAAC,CAAY,EAAE,IAAI,mCAAyB,EAAE,CAAC,CAAC;QACtD,CAAC;QAED,eAAe,CAAC,WAAmB,EAAE,OAAiC;YACrE,IAAI,CAAC,CAAC,CAAQ,GAAG,CAAC,WAAW,EAAE,OAAO,CAAC,CAAC;YAExC,mDAAmD;YACnD,UAAU,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,CAAC,CAAoB,WAAW,CAAC,EAAE,CAAC,CAAC,CAAC;QAC7D,CAAC;QAEO,CAAC,CAAY,QAAsB;YAC1C,QAAQ,QAAQ,CAAC,IAAI,EAAE;gBACtB,sCAA4B,CAAC,CAAC;oBAC7B,MAAM,SAAS,GAAG,IAAI,CAAC,CAAC,CAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC;oBAC7C,IAAI,CAAC,CAAC,EAAO,WAAW,CAAC,SAAS,EAAE,CAAC,sCAA8B,iBAAiB,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC;oBACrG,OAAO;iBACP;gBAED,2CAAiC;gBACjC,yCAA+B;gBAC/B,sCAA4B;gBAC5B,2CAAiC,CAAC,CAAC;oBAClC,MAAM,SAAS,GAAG,IAAI,CAAC,CAAC,CAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,QAAQ,CAAC,EAAE,CAAC,EAAE,QAAQ,CAAC,IAAI,CAAC,CAAC;oBACzE,IAAI,CAAC,CAAC,EAAO,WAAW,CAAC,SAAS,EAAE,QAAQ,CAAC,EAAE,sCAA8B,iBAAiB,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE,QAAQ,CAAC,IAAI,CAAC,CAAC;oBAC9H,OAAO;iBACP;aACD;QACF,CAAC;QAEO,CAAC,CAAI,MAAW,EAAE,OAAY,SAAS;YAC9C,MAAM,MAAM,GAAG,IAAI,GAAG,EAAW,CAAC;YAClC,GAAG,CAAO,MAAM,EAAE,MAAM,CAAC,CAAC;YAC1B,GAAG,CAAO,MAAM,EAAE,IAAI,CAAC,CAAC;YACxB,OAAO,IAAI,CAAC,CAAC,CAAU,MAAM,CAAC,MAAM,CAAC,CAAC;QACvC,CAAC;QAEO,CAAC,CAAU,OAAY;YAC9B,IAAI;gBACH,IAAI,CAAC,CAAC,CAAQ,IAAI,CAAC,OAAO,CAAC,CAAC;gBAC5B,OAAO,OAAO,CAAC,UAAU,CAAC;aAC1B;YAAC,OAAO,GAAG,EAAE;gBACb,OAAO;gBACP,OAAO,CAAC,CAAC;aACT;QACF,CAAC;QAEO,CAAC,CAAY,OAAY;YAChC,MAAM,MAAM,GAAG,IAAI,GAAG,CAAU,OAAO,CAAC,CAAC;YACzC,MAAM,MAAM,GAAG,GAAG,CAAS,MAAM,CAAC,CAAC;YACnC,MAAM,IAAI,GAAG,GAAG,CAAS,MAAM,CAAC,CAAC;YACjC,MAAM,IAAI,GAAG,MAAM,CAAC,CAAC,CAAgB,CAAC;YAEtC,QAAQ,IAAI,EAAE;gBACb;oBACC,IAAI,CAAC,CAAC,EAAO,WAAW,CAAC,OAAO,CAAC,UAAU,EAAE,MAAM,CAAC,CAAC,CAAC,sCAA8B,GAAG,gBAAgB,CAAC,IAAI,CAAC,KAAK,MAAM,CAAC,CAAC,CAAC,IAAI,MAAM,CAAC,CAAC,CAAC,EAAE,EAAE,IAAI,CAAC,CAAC;oBAClJ,OAAO,IAAI,CAAC,CAAC,CAAS,EAAE,IAAI,EAAE,EAAE,EAAE,MAAM,CAAC,CAAC,CAAC,EAAE,WAAW,EAAE,MAAM,CAAC,CAAC,CAAC,EAAE,IAAI,EAAE,MAAM,CAAC,CAAC,CAAC,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC,CAAC;gBACpG;oBACC,IAAI,CAAC,CAAC,EAAO,WAAW,CAAC,OAAO,CAAC,UAAU,EAAE,MAAM,CAAC,CAAC,CAAC,sCAA8B,GAAG,gBAAgB,CAAC,IAAI,CAAC,KAAK,MAAM,CAAC,CAAC,CAAC,IAAI,MAAM,CAAC,CAAC,CAAC,EAAE,EAAE,IAAI,CAAC,CAAC;oBAClJ,OAAO,IAAI,CAAC,CAAC,CAAa,EAAE,IAAI,EAAE,EAAE,EAAE,MAAM,CAAC,CAAC,CAAC,EAAE,WAAW,EAAE,MAAM,CAAC,CAAC,CAAC,EAAE,IAAI,EAAE,MAAM,CAAC,CAAC,CAAC,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC,CAAC;gBACxG;oBACC,IAAI,CAAC,CAAC,EAAO,WAAW,CAAC,OAAO,CAAC,UAAU,EAAE,MAAM,CAAC,CAAC,CAAC,sCAA8B,GAAG,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;oBACjH,OAAO,IAAI,CAAC,CAAC,CAAoB,EAAE,IAAI,EAAE,EAAE,EAAE,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;gBAC3D;oBACC,IAAI,CAAC,CAAC,EAAO,WAAW,CAAC,OAAO,CAAC,UAAU,EAAE,MAAM,CAAC,CAAC,CAAC,sCAA8B,GAAG,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;oBACjH,OAAO,IAAI,CAAC,CAAC,CAAoB,EAAE,IAAI,EAAE,EAAE,EAAE,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;aAC3D;QACF,CAAC;QAEO,CAAC,CAAS,OAA2B;YAC5C,MAAM,OAAO,GAAG,IAAI,CAAC,CAAC,CAAQ,GAAG,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC;YAEvD,IAAI,CAAC,OAAO,EAAE;gBACb,IAAI,CAAC,CAAC,CAAqB,OAAO,CAAC,CAAC;gBACpC,OAAO;aACP;YAED,MAAM,uBAAuB,GAAG,IAAI,kBAAG,EAAsB,CAAC;YAC9D,IAAI,OAAqB,CAAC;YAE1B,IAAI;gBACH,OAAO,GAAG,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,EAAI,OAAO,CAAC,IAAI,EAAE,OAAO,CAAC,GAAG,EAAE,uBAAuB,CAAC,KAAK,CAAC,CAAC;aAC3F;YAAC,OAAO,GAAG,EAAE;gBACb,OAAO,GAAG,OAAO,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;aAC9B;YAED,MAAM,EAAE,GAAG,OAAO,CAAC,EAAE,CAAC;YAEtB,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE;gBACnB,IAAI,CAAC,CAAC,CAA0B,EAAE,EAAE,EAAE,IAAI,EAAE,IAAI,uCAA6B,EAAE,CAAC,CAAC;YAClF,CAAC,EAAE,GAAG,CAAC,EAAE;gBACR,IAAI,GAAG,YAAY,KAAK,EAAE;oBACzB,IAAI,CAAC,CAAC,CAA0B;wBAC/B,EAAE,EAAE,IAAI,EAAE;4BACT,OAAO,EAAE,GAAG,CAAC,OAAO;4BACpB,IAAI,EAAE,GAAG,CAAC,IAAI;4BACd,KAAK,EAAE,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,SAAS;yBACpF,EAAE,IAAI,qCAA2B;qBAClC,CAAC,CAAC;iBACH;qBAAM;oBACN,IAAI,CAAC,CAAC,CAA0B,EAAE,EAAE,EAAE,IAAI,EAAE,GAAG,EAAE,IAAI,wCAA8B,EAAE,CAAC,CAAC;iBACvF;YACF,CAAC,CAAC,CAAC,OAAO,CAAC,GAAG,EAAE;gBACf,UAAU,CAAC,OAAO,EAAE,CAAC;gBACrB,IAAI,CAAC,CAAC,CAAc,MAAM,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC;YACxC,CAAC,CAAC,CAAC;YAEH,MAAM,UAAU,GAAG,IAAA,eAAG,EAAU,GAAG,EAAE,CAAC,uBAAuB,CAAC,MAAM,EAAE,CAAC,CAAC;YACxE,IAAI,CAAC,CAAC,CAAc,GAAG,CAAC,OAAO,CAAC,EAAE,EAAE,UAAU,CAAC,CAAC;QACjD,CAAC;QAEO,CAAC,CAAa,OAA+B;YACpD,MAAM,OAAO,GAAG,IAAI,CAAC,CAAC,CAAQ,GAAG,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC;YAEvD,IAAI,CAAC,OAAO,EAAE;gBACb,IAAI,CAAC,CAAC,CAAqB,OAAO,CAAC,CAAC;gBACpC,OAAO;aACP;YAED,MAAM,EAAE,GAAG,OAAO,CAAC,EAAE,CAAC;YACtB,MAAM,KAAK,GAAG,OAAO,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,EAAI,OAAO,CAAC,IAAI,EAAE,OAAO,CAAC,GAAG,CAAC,CAAC;YAClE,MAAM,UAAU,GAAG,KAAK,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,CAAC,CAA0B,EAAE,EAAE,EAAE,IAAI,EAAE,IAAI,kCAAwB,EAAE,CAAC,CAAC,CAAC;YAE9G,IAAI,CAAC,CAAC,CAAc,GAAG,CAAC,OAAO,CAAC,EAAE,EAAE,UAAU,CAAC,CAAC;QACjD,CAAC;QAEO,CAAC,CAAoB,OAAoB;YAChD,MAAM,UAAU,GAAG,IAAI,CAAC,CAAC,CAAc,GAAG,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC;YAEvD,IAAI,UAAU,EAAE;gBACf,UAAU,CAAC,OAAO,EAAE,CAAC;gBACrB,IAAI,CAAC,CAAC,CAAc,MAAM,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC;aACvC;QACF,CAAC;QAEO,CAAC,CAAqB,OAAoD;YACjF,IAAI,eAAe,GAAG,IAAI,CAAC,CAAC,CAAe,GAAG,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC;YAEpE,IAAI,CAAC,eAAe,EAAE;gBACrB,eAAe,GAAG,EAAE,CAAC;gBACrB,IAAI,CAAC,CAAC,CAAe,GAAG,CAAC,OAAO,CAAC,WAAW,EAAE,eAAe,CAAC,CAAC;aAC/D;YAED,MAAM,KAAK,GAAG,UAAU,CAAC,GAAG,EAAE;gBAC7B,OAAO,CAAC,KAAK,CAAC,oBAAoB,OAAO,CAAC,WAAW,EAAE,CAAC,CAAC;gBAEzD,IAAI,OAAO,CAAC,IAAI,kCAAwB,EAAE;oBACzC,IAAI,CAAC,CAAC,CAA0B;wBAC/B,EAAE,EAAE,OAAO,CAAC,EAAE;wBACd,IAAI,EAAE,EAAE,IAAI,EAAE,iBAAiB,EAAE,OAAO,EAAE,iBAAiB,OAAO,CAAC,WAAW,qBAAqB,IAAI,CAAC,CAAC,IAAe,EAAE,KAAK,EAAE,SAAS,EAAE;wBAC5I,IAAI,qCAA2B;qBAC/B,CAAC,CAAC;iBACH;YACF,CAAC,EAAE,IAAI,CAAC,CAAC,CAAY,CAAC;YAEtB,eAAe,CAAC,IAAI,CAAC,EAAE,OAAO,EAAE,YAAY,EAAE,KAAK,EAAE,CAAC,CAAC;QACxD,CAAC;QAEO,CAAC,CAAoB,WAAmB;YAC/C,MAAM,QAAQ,GAAG,IAAI,CAAC,CAAC,CAAe,GAAG,CAAC,WAAW,CAAC,CAAC;YAEvD,IAAI,QAAQ,EAAE;gBACb,KAAK,MAAM,OAAO,IAAI,QAAQ,EAAE;oBAC/B,YAAY,CAAC,OAAO,CAAC,YAAY,CAAC,CAAC;oBAEnC,QAAQ,OAAO,CAAC,OAAO,CAAC,IAAI,EAAE;wBAC7B;4BAA0B,IAAI,CAAC,CAAC,CAAS,OAAO,CAAC,OAAO,CAAC,CAAC;4BAAC,MAAM;wBACjE;4BAA8B,IAAI,CAAC,CAAC,CAAa,OAAO,CAAC,OAAO,CAAC,CAAC;4BAAC,MAAM;qBACzE;iBACD;gBAED,IAAI,CAAC,CAAC,CAAe,MAAM,CAAC,WAAW,CAAC,CAAC;aACzC;QACF,CAAC;QAEM,OAAO;YACb,IAAI,IAAI,CAAC,CAAC,EAAiB;gBAC1B,IAAI,CAAC,CAAC,CAAgB,OAAO,EAAE,CAAC;gBAChC,IAAI,CAAC,CAAC,GAAkB,IAAI,CAAC;aAC7B;YACD,IAAA,eAAG,EAAK,IAAI,CAAC,CAAC,CAAc,MAAM,EAAE,CAAC,CAAC;YACtC,IAAI,CAAC,CAAC,CAAc,KAAK,EAAE,CAAC;QAC7B,CAAC;KACD;IAlMD,kBAkMC;IAED,IAAkB,gBAGjB;IAHD,WAAkB,gBAAgB;QACjC,iEAAa,CAAA;QACb,iEAAa,CAAA;IACd,CAAC,EAHiB,gBAAgB,gCAAhB,gBAAgB,QAGjC;IAOD,MAAa,GAAG;QAaf,YAAoB,CAAiC,EAAE,SAA4B,IAAI;YAAnE,MAAC,GAAD,CAAC,CAAgC;YAX7C,MAAC,GAAqB,KAAK,CAAC;YAC5B,MAAC,GAAc,KAAK,CAAC,aAAa,CAAC;YACnC,MAAC,GAAgB,IAAI,GAAG,EAAe,CAAC;YACxC,MAAC,GAAU,IAAI,GAAG,EAAoB,CAAC;YACvC,MAAC,GAAuB,CAAC,CAAC;YAIjB,MAAC,GAAkB,IAAI,WAAG,EAAY,CAAC;YAC/C,oBAAe,GAAG,IAAI,CAAC,CAAC,CAAgB,KAAK,CAAC;YAGtD,IAAI,CAAC,CAAC,GAAkB,IAAI,CAAC,CAAC,CAAQ,SAAS,CAAC,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,CAAC,CAAQ,GAAG,CAAC,CAAC,CAAC;YAC3E,IAAI,CAAC,CAAC,GAAQ,MAAM,CAAC;QACtB,CAAC;QAED,UAAU,CAAqB,WAAmB;YACjD,MAAM,IAAI,GAAG,IAAI,CAAC;YAElB,OAAO;gBACN,IAAI,CAAC,OAAe,EAAE,GAAS,EAAE,iBAAqC;oBACrE,IAAI,IAAI,CAAC,CAAC,EAAW;wBACpB,OAAO,OAAO,CAAC,MAAM,CAAC,IAAI,WAAE,EAAiB,CAAC,CAAC;qBAC/C;oBACD,OAAO,IAAI,CAAC,CAAC,CAAc,WAAW,EAAE,OAAO,EAAE,GAAG,EAAE,iBAAiB,CAAC,CAAC;gBAC1E,CAAC;gBACD,MAAM,CAAC,KAAa,EAAE,GAAQ;oBAC7B,IAAI,IAAI,CAAC,CAAC,EAAW;wBACpB,OAAO,aAAK,CAAC,IAAI,CAAC;qBAClB;oBACD,OAAO,IAAI,CAAC,CAAC,CAAY,WAAW,EAAE,KAAK,EAAE,GAAG,CAAC,CAAC;gBACnD,CAAC;aACI,CAAC;QACR,CAAC;QAEO,CAAC,CAAc,WAAmB,EAAE,IAAY,EAAE,GAAS,EAAE,iBAAiB,GAAG,gCAAiB,CAAC,IAAI;YAC9G,MAAM,EAAE,GAAG,IAAI,CAAC,CAAC,EAAc,CAAC;YAChC,MAAM,IAAI,gCAAsB,CAAC;YACjC,MAAM,OAAO,GAAgB,EAAE,EAAE,EAAE,IAAI,EAAE,WAAW,EAAE,IAAI,EAAE,GAAG,EAAE,CAAC;YAElE,IAAI,iBAAiB,CAAC,uBAAuB,EAAE;gBAC9C,OAAO,OAAO,CAAC,MAAM,CAAC,IAAI,WAAE,EAAiB,CAAC,CAAC;aAC/C;YAED,IAAI,UAAuB,CAAC;YAE5B,MAAM,MAAM,GAAG,IAAI,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE;gBACnC,IAAI,iBAAiB,CAAC,uBAAuB,EAAE;oBAC9C,OAAO,CAAC,CAAC,IAAI,WAAE,EAAiB,CAAC,CAAC;iBAClC;gBAED,MAAM,SAAS,GAAG,GAAG,EAAE;oBACtB,MAAM,OAAO,GAAa,QAAQ,CAAC,EAAE;wBACpC,QAAQ,QAAQ,CAAC,IAAI,EAAE;4BACtB;gCACC,IAAI,CAAC,CAAC,CAAQ,MAAM,CAAC,EAAE,CAAC,CAAC;gCACzB,CAAC,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;gCACjB,MAAM;4BAEP,wCAA8B,CAAC,CAAC;gCAC/B,IAAI,CAAC,CAAC,CAAQ,MAAM,CAAC,EAAE,CAAC,CAAC;gCACzB,MAAM,KAAK,GAAG,IAAI,KAAK,CAAC,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;gCACzC,KAAM,CAAC,KAAK,GAAG,KAAK,CAAC,OAAO,CAAC,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC;gCAC/G,KAAK,CAAC,IAAI,GAAG,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC;gCAChC,CAAC,CAAC,KAAK,CAAC,CAAC;gCACT,MAAM;6BACN;4BACD;gCACC,IAAI,CAAC,CAAC,CAAQ,MAAM,CAAC,EAAE,CAAC,CAAC;gCACzB,CAAC,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;gCACjB,MAAM;yBACP;oBACF,CAAC,CAAC;oBAEF,IAAI,CAAC,CAAC,CAAQ,GAAG,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC;oBAC/B,IAAI,CAAC,CAAC,CAAW,OAAO,CAAC,CAAC;gBAC3B,CAAC,CAAC;gBAEF,IAAI,oBAAoB,GAAmC,IAAI,CAAC;gBAChE,IAAI,IAAI,CAAC,CAAC,KAAS,KAAK,CAAC,IAAI,EAAE;oBAC9B,SAAS,EAAE,CAAC;iBACZ;qBAAM;oBACN,oBAAoB,GAAG,IAAA,WAAG,EAAqB,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC,CAAC,EAAgB,CAAC,CAAC;oBAC5E,oBAAoB,CAAC,IAAI,CAAC,GAAG,EAAE;wBAC9B,oBAAoB,GAAG,IAAI,CAAC;wBAC5B,SAAS,EAAE,CAAC;oBACb,CAAC,CAAC,CAAC;iBACH;gBAED,MAAM,MAAM,GAAG,GAAG,EAAE;oBACnB,IAAI,oBAAoB,EAAE;wBACzB,oBAAoB,CAAC,MAAM,EAAE,CAAC;wBAC9B,oBAAoB,GAAG,IAAI,CAAC;qBAC5B;yBAAM;wBACN,IAAI,CAAC,CAAC,CAAW,EAAE,EAAE,EAAE,IAAI,qCAA2B,EAAE,CAAC,CAAC;qBAC1D;oBAED,CAAC,CAAC,IAAI,WAAE,EAAiB,CAAC,CAAC;gBAC5B,CAAC,CAAC;gBAEF,MAAM,yBAAyB,GAAG,iBAAiB,CAAC,uBAAuB,CAAC,MAAM,CAAC,CAAC;gBACpF,UAAU,GAAG,IAAA,eAAG,EAAgB,IAAA,eAAG,EAAU,MAAM,CAAC,EAAE,yBAAyB,CAAC,CAAC;gBACjF,IAAI,CAAC,CAAC,CAAc,GAAG,CAAC,UAAU,CAAC,CAAC;YACrC,CAAC,CAAC,CAAC;YAEH,OAAO,MAAM,CAAC,OAAO,CAAC,GAAG,EAAE;gBAC1B,UAAU,CAAC,OAAO,EAAE,CAAC;gBACrB,IAAI,CAAC,CAAC,CAAc,MAAM,CAAC,UAAU,CAAC,CAAC;YACxC,CAAC,CAAC,CAAC;QACJ,CAAC;QAEO,CAAC,CAAY,WAAmB,EAAE,IAAY,EAAE,GAAS;YAChE,MAAM,EAAE,GAAG,IAAI,CAAC,CAAC,EAAc,CAAC;YAChC,MAAM,IAAI,oCAA0B,CAAC;YACrC,MAAM,OAAO,GAAgB,EAAE,EAAE,EAAE,IAAI,EAAE,WAAW,EAAE,IAAI,EAAE,GAAG,EAAE,CAAC;YAElE,IAAI,oBAAoB,GAAmC,IAAI,CAAC;YAEhE,MAAM,OAAO,GAAG,IAAI,WAAG,CAAU;gBAChC,sBAAsB,EAAE,GAAG,EAAE;oBAC5B,oBAAoB,GAAG,IAAA,WAAG,EAAqB,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC,CAAC,EAAgB,CAAC,CAAC;oBAC5E,oBAAoB,CAAC,IAAI,CAAC,GAAG,EAAE;wBAC9B,oBAAoB,GAAG,IAAI,CAAC;wBAC5B,IAAI,CAAC,CAAC,CAAc,GAAG,CAAC,OAAO,CAAC,CAAC;wBACjC,IAAI,CAAC,CAAC,CAAW,OAAO,CAAC,CAAC;oBAC3B,CAAC,CAAC,CAAC;gBACJ,CAAC;gBACD,uBAAuB,EAAE,GAAG,EAAE;oBAC7B,IAAI,oBAAoB,EAAE;wBACzB,oBAAoB,CAAC,MAAM,EAAE,CAAC;wBAC9B,oBAAoB,GAAG,IAAI,CAAC;qBAC5B;yBAAM;wBACN,IAAI,CAAC,CAAC,CAAc,MAAM,CAAC,OAAO,CAAC,CAAC;wBACpC,IAAI,CAAC,CAAC,CAAW,EAAE,EAAE,EAAE,IAAI,oCAA0B,EAAE,CAAC,CAAC;qBACzD;gBACF,CAAC;aACD,CAAC,CAAC;YAEH,MAAM,OAAO,GAAa,CAAC,GAAiB,EAAE,EAAE,CAAC,OAAO,CAAC,IAAI,CAAE,GAA6B,CAAC,IAAI,CAAC,CAAC;YACnG,IAAI,CAAC,CAAC,CAAQ,GAAG,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC;YAE/B,OAAO,OAAO,CAAC,KAAK,CAAC;QACtB,CAAC;QAEO,CAAC,CAAW,OAAoB;YACvC,QAAQ,OAAO,CAAC,IAAI,EAAE;gBACrB,mCAAyB;gBACzB,sCAA4B,CAAC,CAAC;oBAC7B,MAAM,SAAS,GAAG,IAAI,CAAC,CAAC,CAAI,CAAC,OAAO,CAAC,IAAI,EAAE,OAAO,CAAC,EAAE,EAAE,OAAO,CAAC,WAAW,EAAE,OAAO,CAAC,IAAI,CAAC,EAAE,OAAO,CAAC,GAAG,CAAC,CAAC;oBACxG,IAAI,CAAC,CAAC,EAAO,WAAW,CAAC,SAAS,EAAE,OAAO,CAAC,EAAE,sCAA8B,GAAG,gBAAgB,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,OAAO,CAAC,WAAW,IAAI,OAAO,CAAC,IAAI,EAAE,EAAE,OAAO,CAAC,GAAG,CAAC,CAAC;oBACtK,OAAO;iBACP;gBAED,yCAA+B;gBAC/B,uCAA6B,CAAC,CAAC;oBAC9B,MAAM,SAAS,GAAG,IAAI,CAAC,CAAC,CAAI,CAAC,OAAO,CAAC,IAAI,EAAE,OAAO,CAAC,EAAE,CAAC,CAAC,CAAC;oBACxD,IAAI,CAAC,CAAC,EAAO,WAAW,CAAC,SAAS,EAAE,OAAO,CAAC,EAAE,sCAA8B,gBAAgB,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC;oBAC5G,OAAO;iBACP;aACD;QACF,CAAC;QAEO,CAAC,CAAI,MAAW,EAAE,OAAY,SAAS;YAC9C,MAAM,MAAM,GAAG,IAAI,GAAG,EAAW,CAAC;YAClC,GAAG,CAAO,MAAM,EAAE,MAAM,CAAC,CAAC;YAC1B,GAAG,CAAO,MAAM,EAAE,IAAI,CAAC,CAAC;YACxB,OAAO,IAAI,CAAC,CAAC,CAAU,MAAM,CAAC,MAAM,CAAC,CAAC;QACvC,CAAC;QAEO,CAAC,CAAU,OAAY;YAC9B,IAAI;gBACH,IAAI,CAAC,CAAC,CAAQ,IAAI,CAAC,OAAO,CAAC,CAAC;gBAC5B,OAAO,OAAO,CAAC,UAAU,CAAC;aAC1B;YAAC,OAAO,GAAG,EAAE;gBACb,OAAO;gBACP,OAAO,CAAC,CAAC;aACT;QACF,CAAC;QAEO,CAAC,CAAQ,OAAY;YAC5B,MAAM,MAAM,GAAG,IAAI,GAAG,CAAU,OAAO,CAAC,CAAC;YACzC,MAAM,MAAM,GAAG,GAAG,CAAS,MAAM,CAAC,CAAC;YACnC,MAAM,IAAI,GAAG,GAAG,CAAS,MAAM,CAAC,CAAC;YACjC,MAAM,IAAI,GAAiB,MAAM,CAAC,CAAC,CAAC,CAAC;YAErC,QAAQ,IAAI,EAAE;gBACb;oBACC,IAAI,CAAC,CAAC,EAAO,WAAW,CAAC,OAAO,CAAC,UAAU,EAAE,CAAC,sCAA8B,iBAAiB,CAAC,IAAI,CAAC,CAAC,CAAC;oBACrG,OAAO,IAAI,CAAC,CAAC,CAAU,EAAE,IAAI,EAAE,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;gBAE7C,2CAAiC;gBACjC,yCAA+B;gBAC/B,sCAA4B;gBAC5B;oBACC,IAAI,CAAC,CAAC,EAAO,WAAW,CAAC,OAAO,CAAC,UAAU,EAAE,MAAM,CAAC,CAAC,CAAC,sCAA8B,iBAAiB,CAAC,IAAI,CAAC,EAAE,IAAI,CAAC,CAAC;oBACnH,OAAO,IAAI,CAAC,CAAC,CAAU,EAAE,IAAI,EAAE,MAAM,CAAC,CAAC,CAAC,EAAE,EAAE,EAAE,MAAM,CAAC,CAAC,CAAC,EAAE,IAAI,EAAE,IAAI,EAAE,CAAC,CAAC;aACxE;QACF,CAAC;QAEO,CAAC,CAAU,QAAsB;YACxC,IAAI,QAAQ,CAAC,IAAI,sCAA4B,EAAE;gBAC9C,IAAI,CAAC,CAAC,GAAO,KAAK,CAAC,IAAI,CAAC;gBACxB,IAAI,CAAC,CAAC,CAAgB,IAAI,EAAE,CAAC;gBAC7B,OAAO;aACP;YAED,MAAM,OAAO,GAAG,IAAI,CAAC,CAAC,CAAQ,GAAG,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC;YAE/C,OAAO,EAAE,CAAC,QAAQ,CAAC,CAAC;QACrB,CAAC;QAGD,IAAI,sBAAsB;YACzB,OAAO,aAAK,CAAC,SAAS,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;QAC9C,CAAC;QAEO,CAAC;YACR,IAAI,IAAI,CAAC,CAAC,KAAS,KAAK,CAAC,IAAI,EAAE;gBAC9B,OAAO,OAAO,CAAC,OAAO,EAAE,CAAC;aACzB;iBAAM;gBACN,OAAO,IAAI,CAAC,sBAAsB,CAAC;aACnC;QACF,CAAC;QAED,OAAO;YACN,IAAI,CAAC,CAAC,GAAY,IAAI,CAAC;YACvB,IAAI,IAAI,CAAC,CAAC,EAAiB;gBAC1B,IAAI,CAAC,CAAC,CAAgB,OAAO,EAAE,CAAC;gBAChC,IAAI,CAAC,CAAC,GAAkB,IAAI,CAAC;aAC7B;YACD,IAAA,eAAG,EAAK,IAAI,CAAC,CAAC,CAAc,MAAM,EAAE,CAAC,CAAC;YACtC,IAAI,CAAC,CAAC,CAAc,KAAK,EAAE,CAAC;QAC7B,CAAC;KACD;IA3OD,kBA2OC;IArBA;QADC,gBAAG;qDAGH;IA+BF;;;;;;;OAOG;IACH,MAAa,GAAG;QAaf,IAAI,WAAW;YACd,MAAM,MAAM,GAA2B,EAAE,CAAC;YAC1C,IAAI,CAAC,CAAC,CAAY,OAAO,CAAC,GAAG,CAAC,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;YACnD,OAAO,MAAM,CAAC;QACf,CAAC;QAED,YAAY,kBAAgD;YAjBpD,MAAC,GAAU,IAAI,GAAG,EAAoC,CAAC;YACvD,MAAC,GAAc,IAAI,GAAG,EAAwB,CAAC;YAEtC,MAAC,GAAqB,IAAI,WAAG,EAA4B,CAAC;YAClE,uBAAkB,GAAgC,IAAI,CAAC,CAAC,CAAmB,KAAK,CAAC;YAEzE,MAAC,GAAwB,IAAI,WAAG,EAA4B,CAAC;YACrE,0BAAqB,GAAgC,IAAI,CAAC,CAAC,CAAsB,KAAK,CAAC;YAE/E,MAAC,GAAa,IAAI,eAAG,EAAc,CAAC;YASpD,IAAI,CAAC,CAAC,CAAW,GAAG,CAAC,kBAAkB,CAAC,CAAC,EAAE,QAAQ,EAAE,qBAAqB,EAAE,EAAE,EAAE;gBAC/E,MAAM,cAAc,GAAG,aAAK,CAAC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC;gBAEtD,IAAI,CAAC,CAAC,CAAW,GAAG,CAAC,cAAc,CAAC,GAAG,CAAC,EAAE;oBACzC,MAAM,MAAM,GAAG,IAAI,GAAG,CAAU,GAAG,CAAC,CAAC;oBACrC,MAAM,GAAG,GAAG,GAAG,CAAS,MAAM,CAAa,CAAC;oBAE5C,MAAM,aAAa,GAAG,IAAI,GAAG,CAAW,QAAQ,EAAE,GAAG,CAAC,CAAC;oBACvD,MAAM,aAAa,GAAG,IAAI,GAAG,CAAW,QAAQ,CAAC,CAAC;oBAElD,IAAI,CAAC,CAAC,CAAQ,OAAO,CAAC,CAAC,OAAO,EAAE,IAAI,EAAE,EAAE,CAAC,aAAa,CAAC,eAAe,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC,CAAC;oBAEvF,MAAM,UAAU,GAAyB,EAAE,aAAa,EAAE,aAAa,EAAE,GAAG,EAAE,CAAC;oBAC/E,IAAI,CAAC,CAAC,CAAY,GAAG,CAAC,UAAU,CAAC,CAAC;oBAClC,IAAI,CAAC,CAAC,CAAmB,IAAI,CAAC,UAAU,CAAC,CAAC;oBAE1C,IAAI,CAAC,CAAC,CAAW,GAAG,CAAC,qBAAqB,CAAC,GAAG,EAAE;wBAC/C,aAAa,CAAC,OAAO,EAAE,CAAC;wBACxB,aAAa,CAAC,OAAO,EAAE,CAAC;wBACxB,IAAI,CAAC,CAAC,CAAY,MAAM,CAAC,UAAU,CAAC,CAAC;wBACrC,IAAI,CAAC,CAAC,CAAsB,IAAI,CAAC,UAAU,CAAC,CAAC;oBAC9C,CAAC,CAAC,CAAC,CAAC;gBACL,CAAC,CAAC,CAAC,CAAC;YACL,CAAC,CAAC,CAAC,CAAC;QACL,CAAC;QAWD,UAAU,CAAqB,WAAmB,EAAE,oBAAuF;YAC1I,MAAM,IAAI,GAAG,IAAI,CAAC;YAElB,OAAO;gBACN,IAAI,CAAC,OAAe,EAAE,GAAS,EAAE,iBAAqC;oBACrE,IAAI,iBAA4C,CAAC;oBAEjD,IAAI,IAAA,WAAG,EAAQ,oBAAoB,CAAC,EAAE;wBACrC,0DAA0D;wBAC1D,MAAM,UAAU,GAAG,IAAA,YAAG,EAAc,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,oBAAoB,CAAC,CAAC,CAAC;wBAEnF,iBAAiB,GAAG,UAAU;4BAC7B,yCAAyC;4BACzC,CAAC,CAAC,OAAO,CAAC,OAAO,CAAC,UAAU,CAAC;4BAC7B,8CAA8C;4BAC9C,CAAC,CAAC,aAAK,CAAC,SAAS,CAAC,aAAK,CAAC,MAAM,CAAC,IAAI,CAAC,kBAAkB,EAAE,oBAAoB,CAAC,CAAC,CAAC;qBAChF;yBAAM;wBACN,iBAAiB,GAAG,oBAAoB,CAAC,SAAS,CAAC,IAAI,EAAE,OAAO,EAAE,GAAG,CAAC,CAAC;qBACvE;oBAED,MAAM,cAAc,GAAG,iBAAiB;yBACtC,IAAI,CAAC,UAAU,CAAC,EAAE,CAAE,UAAmC,CAAC,aAAa,CAAC,UAAU,CAAC,WAAW,CAAC,CAAC,CAAC;oBAEjG,OAAO,GAAG,CAAe,cAAc,CAAC;yBACtC,IAAI,CAAC,OAAO,EAAE,GAAG,EAAE,iBAAiB,CAAC,CAAC;gBACzC,CAAC;gBACD,MAAM,CAAC,KAAa,EAAE,GAAQ;oBAC7B,IAAI,IAAA,WAAG,EAAQ,oBAAoB,CAAC,EAAE;wBACrC,OAAO,IAAI,CAAC,CAAC,CAAiB,WAAW,EAAE,oBAAoB,EAAE,KAAK,EAAE,GAAG,CAAC,CAAC;qBAC7E;oBAED,MAAM,cAAc,GAAG,oBAAoB,CAAC,UAAU,CAAC,IAAI,EAAE,KAAK,EAAE,GAAG,CAAC;yBACtE,IAAI,CAAC,UAAU,CAAC,EAAE,CAAE,UAAmC,CAAC,aAAa,CAAC,UAAU,CAAC,WAAW,CAAC,CAAC,CAAC;oBAEjG,OAAO,GAAG,CAAe,cAAc,CAAC;yBACtC,MAAM,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;gBACtB,CAAC;aACI,CAAC;QACR,CAAC;QAEO,CAAC,CAAqC,WAAmB,EAAE,YAAmD,EAAE,SAAiB,EAAE,GAAQ;YAClJ,MAAM,IAAI,GAAG,IAAI,CAAC;YAClB,IAAI,WAAwC,CAAC;YAE7C,kDAAkD;YAClD,8CAA8C;YAC9C,4DAA4D;YAC5D,cAAc;YACd,MAAM,OAAO,GAAG,IAAI,WAAG,CAAQ;gBAC9B,sBAAsB,EAAE,GAAG,EAAE;oBAC5B,WAAW,GAAG,IAAI,eAAG,EAAc,CAAC;oBAEpC,mDAAmD;oBACnD,+DAA+D;oBAC/D,uCAAuC;oBACvC,MAAM,gBAAgB,GAAG,IAAI,WAAG,EAAkB,CAAC;oBACnD,MAAM,GAAG,GAAG,IAAI,GAAG,EAAqC,CAAC;oBAEzD,MAAM,kBAAkB,GAAG,CAAC,UAAgC,EAAE,EAAE;wBAC/D,MAAM,OAAO,GAAG,UAAU,CAAC,aAAa,CAAC,UAAU,CAAC,WAAW,CAAC,CAAC;wBACjE,MAAM,KAAK,GAAG,OAAO,CAAC,MAAM,CAAI,SAAS,EAAE,GAAG,CAAC,CAAC;wBAChD,MAAM,UAAU,GAAG,gBAAgB,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;wBAE/C,GAAG,CAAC,GAAG,CAAC,UAAU,EAAE,UAAU,CAAC,CAAC;oBACjC,CAAC,CAAC;oBAEF,MAAM,qBAAqB,GAAG,CAAC,UAAgC,EAAE,EAAE;wBAClE,MAAM,UAAU,GAAG,GAAG,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;wBAEvC,IAAI,CAAC,UAAU,EAAE;4BAChB,OAAO;yBACP;wBAED,UAAU,CAAC,OAAO,EAAE,CAAC;wBACrB,GAAG,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC;oBACxB,CAAC,CAAC;oBAEF,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,YAAY,CAAC,CAAC,OAAO,CAAC,kBAAkB,CAAC,CAAC;oBAClE,aAAK,CAAC,MAAM,CAAC,IAAI,CAAC,kBAAkB,EAAE,YAAY,CAAC,CAAC,kBAAkB,EAAE,SAAS,EAAE,WAAW,CAAC,CAAC;oBAChG,IAAI,CAAC,qBAAqB,CAAC,qBAAqB,EAAE,SAAS,EAAE,WAAW,CAAC,CAAC;oBAC1E,gBAAgB,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,EAAE,OAAO,EAAE,WAAW,CAAC,CAAC;oBAE3D,WAAW,CAAC,GAAG,CAAC,gBAAgB,CAAC,CAAC;gBACnC,CAAC;gBACD,uBAAuB,EAAE,GAAG,EAAE;oBAC7B,WAAW,EAAE,OAAO,EAAE,CAAC;oBACvB,WAAW,GAAG,SAAS,CAAC;gBACzB,CAAC;aACD,CAAC,CAAC;YAEH,OAAO,OAAO,CAAC,KAAK,CAAC;QACtB,CAAC;QAED,eAAe,CAAC,WAAmB,EAAE,OAAiC;YACrE,IAAI,CAAC,CAAC,CAAQ,GAAG,CAAC,WAAW,EAAE,OAAO,CAAC,CAAC;YAExC,KAAK,MAAM,UAAU,IAAI,IAAI,CAAC,CAAC,EAAa;gBAC3C,UAAU,CAAC,aAAa,CAAC,eAAe,CAAC,WAAW,EAAE,OAAO,CAAC,CAAC;aAC/D;QACF,CAAC;QAED,OAAO;YACN,IAAI,CAAC,CAAC,CAAW,OAAO,EAAE,CAAC;YAE3B,KAAK,MAAM,UAAU,IAAI,IAAI,CAAC,CAAC,EAAa;gBAC3C,UAAU,CAAC,aAAa,CAAC,OAAO,EAAE,CAAC;gBACnC,UAAU,CAAC,aAAa,CAAC,OAAO,EAAE,CAAC;aACnC;YAED,IAAI,CAAC,CAAC,CAAY,KAAK,EAAE,CAAC;YAC1B,IAAI,CAAC,CAAC,CAAQ,KAAK,EAAE,CAAC;YACtB,IAAI,CAAC,CAAC,CAAmB,OAAO,EAAE,CAAC;YACnC,IAAI,CAAC,CAAC,CAAsB,OAAO,EAAE,CAAC;QACvC,CAAC;KACD;IAzKD,kBAyKC;IAED;;;;;;OAMG;IACH,MAAa,GAAG;QAKf,YAAY,QAAiC,EAAE,GAAa,EAAE,YAA+B,IAAI;YAChG,MAAM,MAAM,GAAG,IAAI,GAAG,EAAW,CAAC;YAClC,GAAG,CAAO,MAAM,EAAE,GAAG,CAAC,CAAC;YACvB,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;YAE7B,IAAI,CAAC,CAAC,GAAe,IAAI,GAAG,CAAW,QAAQ,EAAE,SAAS,CAAC,CAAC;YAC5D,IAAI,CAAC,CAAC,GAAe,IAAI,GAAG,CAAW,QAAQ,EAAE,GAAG,EAAE,SAAS,CAAC,CAAC;QAClE,CAAC;QAED,UAAU,CAAqB,WAAmB;YACjD,OAAO,IAAI,CAAC,CAAC,CAAa,UAAU,CAAC,WAAW,CAAM,CAAC;QACxD,CAAC;QAED,eAAe,CAAC,WAAmB,EAAE,OAAiC;YACrE,IAAI,CAAC,CAAC,CAAa,eAAe,CAAC,WAAW,EAAE,OAAO,CAAC,CAAC;QAC1D,CAAC;QAED,OAAO;YACN,IAAI,CAAC,CAAC,CAAa,OAAO,EAAE,CAAC;YAC7B,IAAI,CAAC,CAAC,CAAa,OAAO,EAAE,CAAC;QAC9B,CAAC;KACD;IA1BD,kBA0BC;IAED,SAAgB,GAAG,CAAmC,OAAmB;QACxE,OAAO;YACN,IAAI,CAAC,OAAe,EAAE,GAAS,EAAE,iBAAqC;gBACrE,OAAO,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,CAAI,OAAO,EAAE,GAAG,EAAE,iBAAiB,CAAC,CAAC,CAAC;YACtE,CAAC;YAED,MAAM,CAAI,KAAa,EAAE,GAAS;gBACjC,MAAM,KAAK,GAAG,IAAI,WAAG,EAAS,CAAC;gBAC/B,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,KAAK,CAAC,KAAK,GAAG,CAAC,CAAC,MAAM,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC,CAAC;gBACtD,OAAO,KAAK,CAAC,KAAK,CAAC;YACpB,CAAC;SACI,CAAC;IACR,CAAC;IAZD,kBAYC;IAED,SAAgB,GAAG,CAAoC,OAAU;QAChE,IAAI,OAAO,GAAG,KAAK,CAAC;QAEpB,OAAO;YACN,IAAI,CAAI,OAAe,EAAE,GAAS,EAAE,iBAAqC;gBACxE,IAAI,OAAO,EAAE;oBACZ,OAAO,OAAO,CAAC,IAAI,CAAC,OAAO,EAAE,GAAG,EAAE,iBAAiB,CAAC,CAAC;iBACrD;gBAED,OAAO,IAAA,WAAG,EAAK,CAAC,CAAC;qBACf,IAAI,CAAC,GAAG,EAAE,CAAC,OAAO,GAAG,IAAI,CAAC;qBAC1B,IAAI,CAAC,GAAG,EAAE,CAAC,OAAO,CAAC,IAAI,CAAI,OAAO,EAAE,GAAG,EAAE,iBAAiB,CAAC,CAAC,CAAC;YAChE,CAAC;YACD,MAAM,CAAI,KAAa,EAAE,GAAS;gBACjC,IAAI,OAAO,EAAE;oBACZ,OAAO,OAAO,CAAC,MAAM,CAAI,KAAK,EAAE,GAAG,CAAC,CAAC;iBACrC;gBAED,MAAM,KAAK,GAAG,IAAI,WAAG,EAAO,CAAC;gBAE7B,IAAA,WAAG,EAAK,CAAC,CAAC;qBACR,IAAI,CAAC,GAAG,EAAE,CAAC,OAAO,GAAG,IAAI,CAAC;qBAC1B,IAAI,CAAC,GAAG,EAAE,CAAC,KAAK,CAAC,KAAK,GAAG,OAAO,CAAC,MAAM,CAAI,KAAK,EAAE,GAAG,CAAC,CAAC,CAAC;gBAE1D,OAAO,KAAK,CAAC,KAAK,CAAC;YACpB,CAAC;SACI,CAAC;IACR,CAAC;IA3BD,kBA2BC;IAED,MAAa,GAAG;QAEf,YAAoB,CAAiD;YAAjD,MAAC,GAAD,CAAC,CAAgD;QAAI,CAAC;QAE1E,SAAS,CAAC,GAA6B;YACtC,OAAO,IAAI,CAAC,CAAC,CAAK,GAAG,CAAC,CAAC;QACxB,CAAC;QAED,UAAU,CAAC,GAA6B;YACvC,OAAO,IAAI,CAAC,CAAC,CAAK,GAAG,CAAC,CAAC;QACxB,CAAC;QAEO,KAAK,CAAC,CAAC,CAAK,GAA6B;YAChD,KAAK,MAAM,UAAU,IAAI,GAAG,CAAC,WAAW,EAAE;gBACzC,IAAI,MAAM,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAE,UAAU,CAAC,GAAG,CAAC,CAAC,EAAE;oBACnD,OAAO,OAAO,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC;iBACnC;aACD;YAED,MAAM,aAAK,CAAC,SAAS,CAAC,GAAG,CAAC,kBAAkB,CAAC,CAAC;YAC9C,OAAO,MAAM,IAAI,CAAC,CAAC,CAAK,GAAG,CAAC,CAAC;QAC9B,CAAC;KACD;IAtBD,kBAsBC;IAED;;;;;;;;;;;;OAYG;IACH,IAAiB,YAAY,CA2I5B;IA3ID,WAAiB,YAAY;QAc5B,SAAgB,WAAW,CAAW,OAAgB,EAAE,WAAgB,EAAc,OAAsC;YAC3H,MAAM,OAAO,GAAG,OAAqC,CAAC;YACtD,MAAM,kBAAkB,GAAG,OAAO,IAAI,OAAO,CAAC,kBAAkB,CAAC;YAEjE,+CAA+C;YAC/C,oDAAoD;YACpD,MAAM,mBAAmB,GAAG,IAAI,GAAG,EAA0B,CAAC;YAC9D,KAAK,MAAM,GAAG,IAAI,OAAO,EAAE;gBAC1B,IAAI,eAAe,CAAC,GAAG,CAAC,EAAE;oBACzB,mBAAmB,CAAC,GAAG,CAAC,GAAG,EAAE,aAAK,CAAC,MAAM,CAAC,OAAO,CAAC,GAAG,CAAmB,EAAE,IAAI,EAAE,SAAS,EAAE,WAAW,CAAC,CAAC,CAAC;iBACzG;aACD;YAED,OAAO,IAAI;gBAEV,MAAM,CAAI,CAAU,EAAE,KAAa,EAAE,GAAQ;oBAC5C,MAAM,SAAS,GAAG,mBAAmB,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;oBACjD,IAAI,SAAS,EAAE;wBACd,OAAO,SAAqB,CAAC;qBAC7B;oBAED,IAAI,sBAAsB,CAAC,KAAK,CAAC,EAAE;wBAClC,MAAM,MAAM,GAAG,OAAO,CAAC,KAAK,CAAC,CAAC;wBAC9B,IAAI,OAAO,MAAM,KAAK,UAAU,EAAE;4BACjC,OAAO,MAAM,CAAC,IAAI,CAAC,OAAO,EAAE,GAAG,CAAC,CAAC;yBACjC;qBACD;oBAED,MAAM,IAAI,WAAE,CAAe,oBAAoB,KAAK,EAAE,CAAC,CAAC;gBACzD,CAAC;gBAED,IAAI,CAAC,CAAU,EAAE,OAAe,EAAE,IAAY;oBAC7C,MAAM,MAAM,GAAG,OAAO,CAAC,OAAO,CAAC,CAAC;oBAChC,IAAI,OAAO,MAAM,KAAK,UAAU,EAAE;wBAEjC,qCAAqC;wBACrC,IAAI,CAAC,kBAAkB,IAAI,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE;4BAC/C,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;gCACrC,IAAI,CAAC,CAAC,CAAC,GAAG,IAAA,iBAAG,EAAI,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;6BAC1B;yBACD;wBAED,OAAO,MAAM,CAAC,KAAK,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;qBACnC;oBAED,MAAM,IAAI,WAAE,CAAe,qBAAqB,OAAO,EAAE,CAAC,CAAC;gBAC5D,CAAC;aACD,CAAC;QACH,CAAC;QAhDe,wBAAW,cAgD1B,CAAA;QAiBD,SAAgB,SAAS,CAAmB,OAAiB,EAAE,OAAoC;YAClG,MAAM,kBAAkB,GAAG,OAAO,IAAI,OAAO,CAAC,kBAAkB,CAAC;YAEjE,OAAO,IAAI,KAAK,CAAC,EAAE,EAAE;gBACpB,GAAG,CAAC,OAAU,EAAE,OAAoB;oBACnC,IAAI,OAAO,OAAO,KAAK,QAAQ,EAAE;wBAEhC,8BAA8B;wBAC9B,IAAI,OAAO,EAAE,UAAU,EAAE,GAAG,CAAC,OAAO,CAAC,EAAE;4BACtC,OAAO,OAAO,CAAC,UAAU,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;yBACvC;wBAED,gBAAgB;wBAChB,IAAI,sBAAsB,CAAC,OAAO,CAAC,EAAE;4BACpC,OAAO,UAAU,GAAQ;gCACxB,OAAO,OAAO,CAAC,MAAM,CAAC,OAAO,EAAE,GAAG,CAAC,CAAC;4BACrC,CAAC,CAAC;yBACF;wBAED,QAAQ;wBACR,IAAI,eAAe,CAAC,OAAO,CAAC,EAAE;4BAC7B,OAAO,OAAO,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;yBAC/B;wBAED,WAAW;wBACX,OAAO,KAAK,WAAW,GAAG,IAAW;4BAEpC,qBAAqB;4BACrB,IAAI,UAAiB,CAAC;4BACtB,IAAI,OAAO,IAAI,CAAC,IAAA,WAAG,EAAe,OAAO,CAAC,OAAO,CAAC,EAAE;gCACnD,UAAU,GAAG,CAAC,OAAO,CAAC,OAAO,EAAE,GAAG,IAAI,CAAC,CAAC;6BACxC;iCAAM;gCACN,UAAU,GAAG,IAAI,CAAC;6BAClB;4BAED,MAAM,MAAM,GAAG,MAAM,OAAO,CAAC,IAAI,CAAC,OAAO,EAAE,UAAU,CAAC,CAAC;4BAEvD,qCAAqC;4BACrC,IAAI,CAAC,kBAAkB,EAAE;gCACxB,OAAO,IAAA,iBAAG,EAAI,MAAM,CAAC,CAAC;6BACtB;4BAED,OAAO,MAAM,CAAC;wBACf,CAAC,CAAC;qBACF;oBAED,MAAM,IAAI,WAAE,CAAe,uBAAuB,MAAM,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC;gBACtE,CAAC;aACD,CAAM,CAAC;QACT,CAAC;QAjDe,sBAAS,YAiDxB,CAAA;QAED,SAAS,eAAe,CAAC,IAAY;YACpC,kEAAkE;YAClE,OAAO,IAAI,CAAC,CAAC,CAAC,KAAK,GAAG,IAAI,IAAI,CAAC,CAAC,CAAC,KAAK,GAAG,IAAI,OAAO,CAAC,GAAG,CAAgB,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC;QAC7F,CAAC;QAED,SAAS,sBAAsB,CAAC,IAAY;YAC3C,iHAAiH;YACjH,OAAO,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC,GAAG,CAAgB,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC;QAClF,CAAC;IACF,CAAC,EA3IgB,YAAY,4BAAZ,YAAY,QA2I5B;IAED,MAAM,WAAW,GAAG;QACnB,CAAC,SAAS,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS,CAAC;QACvD,CAAC,SAAS,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS,CAAC;KACvD,CAAC;IAEF,SAAS,mBAAmB,CAAC,IAAS;QACrC,IAAI,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE;YACxB,OAAO,IAAI,CAAC;SACZ;QACD,IAAI,IAAI,IAAI,OAAO,IAAI,KAAK,QAAQ,IAAI,OAAO,IAAI,CAAC,QAAQ,KAAK,UAAU,EAAE;YAC5E,MAAM,MAAM,GAAG,IAAI,CAAC,QAAQ,EAAE,CAAC;YAC/B,IAAI,MAAM,KAAK,iBAAiB,EAAE;gBACjC,OAAO,MAAM,CAAC;aACd;SACD;QACD,OAAO,IAAI,CAAC;IACb,CAAC;IAED,SAAS,MAAM,CAAC,IAAS;QACxB,IAAI,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE;YACxB,OAAO,IAAI,CAAC,GAAG,CAAC,mBAAmB,CAAC,CAAC;SACrC;QACD,OAAO,mBAAmB,CAAC,IAAI,CAAC,CAAC;IAClC,CAAC;IAED,SAAS,aAAa,CAAC,SAAiB,EAAE,WAAmB,EAAE,SAAiB,EAAE,GAAW,EAAE,SAA2B,EAAE,GAAW,EAAE,IAAS;QACjJ,IAAI,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC;QAEpB,MAAM,UAAU,GAAG,WAAW,CAAC,SAAS,CAAC,CAAC;QAC1C,MAAM,KAAK,GAAG,UAAU,CAAC,GAAG,GAAG,UAAU,CAAC,MAAM,CAAC,CAAC;QAClD,IAAI,IAAI,GAAG,CAAC,MAAM,SAAS,OAAO,MAAM,CAAC,WAAW,CAAC,CAAC,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC,YAAY,MAAM,CAAC,SAAS,CAAC,CAAC,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC,MAAM,MAAM,CAAC,GAAG,CAAC,CAAC,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC,MAAM,GAAG,EAAE,EAAE,kBAAkB,EAAE,aAAa,EAAE,aAAa,EAAE,UAAU,KAAK,EAAE,CAAC,CAAC;QACxO,IAAI,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE;YACpB,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;YACzB,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;SACf;aAAM;YACN,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;SAChB;QACD,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,OAAO,EAAE,IAA6B,CAAC,CAAC;IAC3D,CAAC;IAED,MAAa,GAAG;QAIf,YACkB,CAAuB,EACvB,CAAuB;YADvB,MAAC,GAAD,CAAC,CAAsB;YACvB,MAAC,GAAD,CAAC,CAAsB;YALjC,MAAC,GAAgB,CAAC,CAAC;YACnB,MAAC,GAAgB,CAAC,CAAC;QAKvB,CAAC;QAEE,WAAW,CAAC,SAAiB,EAAE,SAAiB,EAAE,SAA2B,EAAE,GAAW,EAAE,IAAU;YAC5G,IAAI,CAAC,CAAC,IAAiB,SAAS,CAAC;YACjC,aAAa,CAAC,IAAI,CAAC,CAAC,EAAgB,IAAI,CAAC,CAAC,EAAe,SAAS,EAAE,SAAS,EAAE,SAAS,EAAE,GAAG,EAAE,IAAI,CAAC,CAAC;QACtG,CAAC;QAEM,WAAW,CAAC,SAAiB,EAAE,SAAiB,EAAE,SAA2B,EAAE,GAAW,EAAE,IAAU;YAC5G,IAAI,CAAC,CAAC,IAAiB,SAAS,CAAC;YACjC,aAAa,CAAC,IAAI,CAAC,CAAC,EAAgB,IAAI,CAAC,CAAC,EAAe,SAAS,EAAE,SAAS,EAAE,SAAS,EAAE,GAAG,EAAE,IAAI,CAAC,CAAC;QACtG,CAAC;KACD;IAlBD,kBAkBC","file":"ipc.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { getRandomElement } from 'vs/base/common/arrays';\nimport { CancelablePromise, createCancelablePromise, timeout } from 'vs/base/common/async';\nimport { VSBuffer } from 'vs/base/common/buffer';\nimport { CancellationToken, CancellationTokenSource } from 'vs/base/common/cancellation';\nimport { memoize } from 'vs/base/common/decorators';\nimport { CancellationError, ErrorNoTelemetry } from 'vs/base/common/errors';\nimport { Emitter, Event, EventMultiplexer, Relay } from 'vs/base/common/event';\nimport { combinedDisposable, DisposableStore, dispose, IDisposable, toDisposable } from 'vs/base/common/lifecycle';\nimport { revive } from 'vs/base/common/marshalling';\nimport * as strings from 'vs/base/common/strings';\nimport { isFunction, isUndefinedOrNull } from 'vs/base/common/types';\n\n/**\n * An `IChannel` is an abstraction over a collection of commands.\n * You can `call` several commands on a channel, each taking at\n * most one single argument. A `call` always returns a promise\n * with at most one single return value.\n */\nexport interface IChannel {\n\tcall<T>(command: string, arg?: any, cancellationToken?: CancellationToken): Promise<T>;\n\tlisten<T>(event: string, arg?: any): Event<T>;\n}\n\n/**\n * An `IServerChannel` is the counter part to `IChannel`,\n * on the server-side. You should implement this interface\n * if you'd like to handle remote promises or events.\n */\nexport interface IServerChannel<TContext = string> {\n\tcall<T>(ctx: TContext, command: string, arg?: any, cancellationToken?: CancellationToken): Promise<T>;\n\tlisten<T>(ctx: TContext, event: string, arg?: any): Event<T>;\n}\n\nconst enum RequestType {\n\tPromise = 100,\n\tPromiseCancel = 101,\n\tEventListen = 102,\n\tEventDispose = 103\n}\n\nfunction requestTypeToStr(type: RequestType): string {\n\tswitch (type) {\n\t\tcase RequestType.Promise:\n\t\t\treturn 'req';\n\t\tcase RequestType.PromiseCancel:\n\t\t\treturn 'cancel';\n\t\tcase RequestType.EventListen:\n\t\t\treturn 'subscribe';\n\t\tcase RequestType.EventDispose:\n\t\t\treturn 'unsubscribe';\n\t}\n}\n\ntype IRawPromiseRequest = { type: RequestType.Promise; id: number; channelName: string; name: string; arg: any };\ntype IRawPromiseCancelRequest = { type: RequestType.PromiseCancel; id: number };\ntype IRawEventListenRequest = { type: RequestType.EventListen; id: number; channelName: string; name: string; arg: any };\ntype IRawEventDisposeRequest = { type: RequestType.EventDispose; id: number };\ntype IRawRequest = IRawPromiseRequest | IRawPromiseCancelRequest | IRawEventListenRequest | IRawEventDisposeRequest;\n\nconst enum ResponseType {\n\tInitialize = 200,\n\tPromiseSuccess = 201,\n\tPromiseError = 202,\n\tPromiseErrorObj = 203,\n\tEventFire = 204\n}\n\nfunction responseTypeToStr(type: ResponseType): string {\n\tswitch (type) {\n\t\tcase ResponseType.Initialize:\n\t\t\treturn `init`;\n\t\tcase ResponseType.PromiseSuccess:\n\t\t\treturn `reply:`;\n\t\tcase ResponseType.PromiseError:\n\t\tcase ResponseType.PromiseErrorObj:\n\t\t\treturn `replyErr:`;\n\t\tcase ResponseType.EventFire:\n\t\t\treturn `event:`;\n\t}\n}\n\ntype IRawInitializeResponse = { type: ResponseType.Initialize };\ntype IRawPromiseSuccessResponse = { type: ResponseType.PromiseSuccess; id: number; data: any };\ntype IRawPromiseErrorResponse = { type: ResponseType.PromiseError; id: number; data: { message: string; name: string; stack: string[] | undefined } };\ntype IRawPromiseErrorObjResponse = { type: ResponseType.PromiseErrorObj; id: number; data: any };\ntype IRawEventFireResponse = { type: ResponseType.EventFire; id: number; data: any };\ntype IRawResponse = IRawInitializeResponse | IRawPromiseSuccessResponse | IRawPromiseErrorResponse | IRawPromiseErrorObjResponse | IRawEventFireResponse;\n\ninterface IHandler {\n\t(response: IRawResponse): void;\n}\n\nexport interface IMessagePassingProtocol {\n\tsend(buffer: VSBuffer): void;\n\tonMessage: Event<VSBuffer>;\n\t/**\n\t * Wait for the write buffer (if applicable) to become empty.\n\t */\n\tdrain?(): Promise<void>;\n}\n\nenum State {\n\tUninitialized,\n\tIdle\n}\n\n/**\n * An `IChannelServer` hosts a collection of channels. You are\n * able to register channels onto it, provided a channel name.\n */\nexport interface IChannelServer<TContext = string> {\n\tregisterChannel(channelName: string, channel: IServerChannel<TContext>): void;\n}\n\n/**\n * An `IChannelClient` has access to a collection of channels. You\n * are able to get those channels, given their channel name.\n */\nexport interface IChannelClient {\n\tgetChannel<T extends IChannel>(channelName: string): T;\n}\n\nexport interface Client<TContext> {\n\treadonly ctx: TContext;\n}\n\nexport interface IConnectionHub<TContext> {\n\treadonly connections: Connection<TContext>[];\n\treadonly onDidAddConnection: Event<Connection<TContext>>;\n\treadonly onDidRemoveConnection: Event<Connection<TContext>>;\n}\n\n/**\n * An `IClientRouter` is responsible for routing calls to specific\n * channels, in scenarios in which there are multiple possible\n * channels (each from a separate client) to pick from.\n */\nexport interface IClientRouter<TContext = string> {\n\trouteCall(hub: IConnectionHub<TContext>, command: string, arg?: any, cancellationToken?: CancellationToken): Promise<Client<TContext>>;\n\trouteEvent(hub: IConnectionHub<TContext>, event: string, arg?: any): Promise<Client<TContext>>;\n}\n\n/**\n * Similar to the `IChannelClient`, you can get channels from this\n * collection of channels. The difference being that in the\n * `IRoutingChannelClient`, there are multiple clients providing\n * the same channel. You'll need to pass in an `IClientRouter` in\n * order to pick the right one.\n */\nexport interface IRoutingChannelClient<TContext = string> {\n\tgetChannel<T extends IChannel>(channelName: string, router?: IClientRouter<TContext>): T;\n}\n\ninterface IReader {\n\tread(bytes: number): VSBuffer;\n}\n\ninterface IWriter {\n\twrite(buffer: VSBuffer): void;\n}\n\n\n/**\n * @see https://en.wikipedia.org/wiki/Variable-length_quantity\n */\nfunction readIntVQL(reader: IReader) {\n\tlet value = 0;\n\tfor (let n = 0; ; n += 7) {\n\t\tconst next = reader.read(1);\n\t\tvalue |= (next.buffer[0] & 0b01111111) << n;\n\t\tif (!(next.buffer[0] & 0b10000000)) {\n\t\t\treturn value;\n\t\t}\n\t}\n}\n\nconst vqlZero = createOneByteBuffer(0);\n\n/**\n * @see https://en.wikipedia.org/wiki/Variable-length_quantity\n */\nfunction writeInt32VQL(writer: IWriter, value: number) {\n\tif (value === 0) {\n\t\twriter.write(vqlZero);\n\t\treturn;\n\t}\n\n\tlet len = 0;\n\tfor (let v2 = value; v2 !== 0; v2 = v2 >>> 7) {\n\t\tlen++;\n\t}\n\n\tconst scratch = VSBuffer.alloc(len);\n\tfor (let i = 0; value !== 0; i++) {\n\t\tscratch.buffer[i] = value & 0b01111111;\n\t\tvalue = value >>> 7;\n\t\tif (value > 0) {\n\t\t\tscratch.buffer[i] |= 0b10000000;\n\t\t}\n\t}\n\n\twriter.write(scratch);\n}\n\nexport class BufferReader implements IReader {\n\n\tprivate pos = 0;\n\n\tconstructor(private buffer: VSBuffer) { }\n\n\tread(bytes: number): VSBuffer {\n\t\tconst result = this.buffer.slice(this.pos, this.pos + bytes);\n\t\tthis.pos += result.byteLength;\n\t\treturn result;\n\t}\n}\n\nexport class BufferWriter implements IWriter {\n\n\tprivate buffers: VSBuffer[] = [];\n\n\tget buffer(): VSBuffer {\n\t\treturn VSBuffer.concat(this.buffers);\n\t}\n\n\twrite(buffer: VSBuffer): void {\n\t\tthis.buffers.push(buffer);\n\t}\n}\n\nenum DataType {\n\tUndefined = 0,\n\tString = 1,\n\tBuffer = 2,\n\tVSBuffer = 3,\n\tArray = 4,\n\tObject = 5,\n\tInt = 6\n}\n\nfunction createOneByteBuffer(value: number): VSBuffer {\n\tconst result = VSBuffer.alloc(1);\n\tresult.writeUInt8(value, 0);\n\treturn result;\n}\n\nconst BufferPresets = {\n\tUndefined: createOneByteBuffer(DataType.Undefined),\n\tString: createOneByteBuffer(DataType.String),\n\tBuffer: createOneByteBuffer(DataType.Buffer),\n\tVSBuffer: createOneByteBuffer(DataType.VSBuffer),\n\tArray: createOneByteBuffer(DataType.Array),\n\tObject: createOneByteBuffer(DataType.Object),\n\tUint: createOneByteBuffer(DataType.Int),\n};\n\ndeclare const Buffer: any;\nconst hasBuffer = (typeof Buffer !== 'undefined');\n\nexport function serialize(writer: IWriter, data: any): void {\n\tif (typeof data === 'undefined') {\n\t\twriter.write(BufferPresets.Undefined);\n\t} else if (typeof data === 'string') {\n\t\tconst buffer = VSBuffer.fromString(data);\n\t\twriter.write(BufferPresets.String);\n\t\twriteInt32VQL(writer, buffer.byteLength);\n\t\twriter.write(buffer);\n\t} else if (hasBuffer && Buffer.isBuffer(data)) {\n\t\tconst buffer = VSBuffer.wrap(data);\n\t\twriter.write(BufferPresets.Buffer);\n\t\twriteInt32VQL(writer, buffer.byteLength);\n\t\twriter.write(buffer);\n\t} else if (data instanceof VSBuffer) {\n\t\twriter.write(BufferPresets.VSBuffer);\n\t\twriteInt32VQL(writer, data.byteLength);\n\t\twriter.write(data);\n\t} else if (Array.isArray(data)) {\n\t\twriter.write(BufferPresets.Array);\n\t\twriteInt32VQL(writer, data.length);\n\n\t\tfor (const el of data) {\n\t\t\tserialize(writer, el);\n\t\t}\n\t} else if (typeof data === 'number' && (data | 0) === data) {\n\t\t// write a vql if it's a number that we can do bitwise operations on\n\t\twriter.write(BufferPresets.Uint);\n\t\twriteInt32VQL(writer, data);\n\t} else {\n\t\tconst buffer = VSBuffer.fromString(JSON.stringify(data));\n\t\twriter.write(BufferPresets.Object);\n\t\twriteInt32VQL(writer, buffer.byteLength);\n\t\twriter.write(buffer);\n\t}\n}\n\nexport function deserialize(reader: IReader): any {\n\tconst type = reader.read(1).readUInt8(0);\n\n\tswitch (type) {\n\t\tcase DataType.Undefined: return undefined;\n\t\tcase DataType.String: return reader.read(readIntVQL(reader)).toString();\n\t\tcase DataType.Buffer: return reader.read(readIntVQL(reader)).buffer;\n\t\tcase DataType.VSBuffer: return reader.read(readIntVQL(reader));\n\t\tcase DataType.Array: {\n\t\t\tconst length = readIntVQL(reader);\n\t\t\tconst result: any[] = [];\n\n\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\tresult.push(deserialize(reader));\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\t\tcase DataType.Object: return JSON.parse(reader.read(readIntVQL(reader)).toString());\n\t\tcase DataType.Int: return readIntVQL(reader);\n\t}\n}\n\ninterface PendingRequest {\n\trequest: IRawPromiseRequest | IRawEventListenRequest;\n\ttimeoutTimer: any;\n}\n\nexport class ChannelServer<TContext = string> implements IChannelServer<TContext>, IDisposable {\n\n\tprivate channels = new Map<string, IServerChannel<TContext>>();\n\tprivate activeRequests = new Map<number, IDisposable>();\n\tprivate protocolListener: IDisposable | null;\n\n\t// Requests might come in for channels which are not yet registered.\n\t// They will timeout after `timeoutDelay`.\n\tprivate pendingRequests = new Map<string, PendingRequest[]>();\n\n\tconstructor(private protocol: IMessagePassingProtocol, private ctx: TContext, private logger: IIPCLogger | null = null, private timeoutDelay: number = 1000) {\n\t\tthis.protocolListener = this.protocol.onMessage(msg => this.onRawMessage(msg));\n\t\tthis.sendResponse({ type: ResponseType.Initialize });\n\t}\n\n\tregisterChannel(channelName: string, channel: IServerChannel<TContext>): void {\n\t\tthis.channels.set(channelName, channel);\n\n\t\t// https://github.com/microsoft/vscode/issues/72531\n\t\tsetTimeout(() => this.flushPendingRequests(channelName), 0);\n\t}\n\n\tprivate sendResponse(response: IRawResponse): void {\n\t\tswitch (response.type) {\n\t\t\tcase ResponseType.Initialize: {\n\t\t\t\tconst msgLength = this.send([response.type]);\n\t\t\t\tthis.logger?.logOutgoing(msgLength, 0, RequestInitiator.OtherSide, responseTypeToStr(response.type));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcase ResponseType.PromiseSuccess:\n\t\t\tcase ResponseType.PromiseError:\n\t\t\tcase ResponseType.EventFire:\n\t\t\tcase ResponseType.PromiseErrorObj: {\n\t\t\t\tconst msgLength = this.send([response.type, response.id], response.data);\n\t\t\t\tthis.logger?.logOutgoing(msgLength, response.id, RequestInitiator.OtherSide, responseTypeToStr(response.type), response.data);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate send(header: any, body: any = undefined): number {\n\t\tconst writer = new BufferWriter();\n\t\tserialize(writer, header);\n\t\tserialize(writer, body);\n\t\treturn this.sendBuffer(writer.buffer);\n\t}\n\n\tprivate sendBuffer(message: VSBuffer): number {\n\t\ttry {\n\t\t\tthis.protocol.send(message);\n\t\t\treturn message.byteLength;\n\t\t} catch (err) {\n\t\t\t// noop\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tprivate onRawMessage(message: VSBuffer): void {\n\t\tconst reader = new BufferReader(message);\n\t\tconst header = deserialize(reader);\n\t\tconst body = deserialize(reader);\n\t\tconst type = header[0] as RequestType;\n\n\t\tswitch (type) {\n\t\t\tcase RequestType.Promise:\n\t\t\t\tthis.logger?.logIncoming(message.byteLength, header[1], RequestInitiator.OtherSide, `${requestTypeToStr(type)}: ${header[2]}.${header[3]}`, body);\n\t\t\t\treturn this.onPromise({ type, id: header[1], channelName: header[2], name: header[3], arg: body });\n\t\t\tcase RequestType.EventListen:\n\t\t\t\tthis.logger?.logIncoming(message.byteLength, header[1], RequestInitiator.OtherSide, `${requestTypeToStr(type)}: ${header[2]}.${header[3]}`, body);\n\t\t\t\treturn this.onEventListen({ type, id: header[1], channelName: header[2], name: header[3], arg: body });\n\t\t\tcase RequestType.PromiseCancel:\n\t\t\t\tthis.logger?.logIncoming(message.byteLength, header[1], RequestInitiator.OtherSide, `${requestTypeToStr(type)}`);\n\t\t\t\treturn this.disposeActiveRequest({ type, id: header[1] });\n\t\t\tcase RequestType.EventDispose:\n\t\t\t\tthis.logger?.logIncoming(message.byteLength, header[1], RequestInitiator.OtherSide, `${requestTypeToStr(type)}`);\n\t\t\t\treturn this.disposeActiveRequest({ type, id: header[1] });\n\t\t}\n\t}\n\n\tprivate onPromise(request: IRawPromiseRequest): void {\n\t\tconst channel = this.channels.get(request.channelName);\n\n\t\tif (!channel) {\n\t\t\tthis.collectPendingRequest(request);\n\t\t\treturn;\n\t\t}\n\n\t\tconst cancellationTokenSource = new CancellationTokenSource();\n\t\tlet promise: Promise<any>;\n\n\t\ttry {\n\t\t\tpromise = channel.call(this.ctx, request.name, request.arg, cancellationTokenSource.token);\n\t\t} catch (err) {\n\t\t\tpromise = Promise.reject(err);\n\t\t}\n\n\t\tconst id = request.id;\n\n\t\tpromise.then(data => {\n\t\t\tthis.sendResponse(<IRawResponse>{ id, data, type: ResponseType.PromiseSuccess });\n\t\t}, err => {\n\t\t\tif (err instanceof Error) {\n\t\t\t\tthis.sendResponse(<IRawResponse>{\n\t\t\t\t\tid, data: {\n\t\t\t\t\t\tmessage: err.message,\n\t\t\t\t\t\tname: err.name,\n\t\t\t\t\t\tstack: err.stack ? (err.stack.split ? err.stack.split('\\n') : err.stack) : undefined\n\t\t\t\t\t}, type: ResponseType.PromiseError\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tthis.sendResponse(<IRawResponse>{ id, data: err, type: ResponseType.PromiseErrorObj });\n\t\t\t}\n\t\t}).finally(() => {\n\t\t\tdisposable.dispose();\n\t\t\tthis.activeRequests.delete(request.id);\n\t\t});\n\n\t\tconst disposable = toDisposable(() => cancellationTokenSource.cancel());\n\t\tthis.activeRequests.set(request.id, disposable);\n\t}\n\n\tprivate onEventListen(request: IRawEventListenRequest): void {\n\t\tconst channel = this.channels.get(request.channelName);\n\n\t\tif (!channel) {\n\t\t\tthis.collectPendingRequest(request);\n\t\t\treturn;\n\t\t}\n\n\t\tconst id = request.id;\n\t\tconst event = channel.listen(this.ctx, request.name, request.arg);\n\t\tconst disposable = event(data => this.sendResponse(<IRawResponse>{ id, data, type: ResponseType.EventFire }));\n\n\t\tthis.activeRequests.set(request.id, disposable);\n\t}\n\n\tprivate disposeActiveRequest(request: IRawRequest): void {\n\t\tconst disposable = this.activeRequests.get(request.id);\n\n\t\tif (disposable) {\n\t\t\tdisposable.dispose();\n\t\t\tthis.activeRequests.delete(request.id);\n\t\t}\n\t}\n\n\tprivate collectPendingRequest(request: IRawPromiseRequest | IRawEventListenRequest): void {\n\t\tlet pendingRequests = this.pendingRequests.get(request.channelName);\n\n\t\tif (!pendingRequests) {\n\t\t\tpendingRequests = [];\n\t\t\tthis.pendingRequests.set(request.channelName, pendingRequests);\n\t\t}\n\n\t\tconst timer = setTimeout(() => {\n\t\t\tconsole.error(`Unknown channel: ${request.channelName}`);\n\n\t\t\tif (request.type === RequestType.Promise) {\n\t\t\t\tthis.sendResponse(<IRawResponse>{\n\t\t\t\t\tid: request.id,\n\t\t\t\t\tdata: { name: 'Unknown channel', message: `Channel name '${request.channelName}' timed out after ${this.timeoutDelay}ms`, stack: undefined },\n\t\t\t\t\ttype: ResponseType.PromiseError\n\t\t\t\t});\n\t\t\t}\n\t\t}, this.timeoutDelay);\n\n\t\tpendingRequests.push({ request, timeoutTimer: timer });\n\t}\n\n\tprivate flushPendingRequests(channelName: string): void {\n\t\tconst requests = this.pendingRequests.get(channelName);\n\n\t\tif (requests) {\n\t\t\tfor (const request of requests) {\n\t\t\t\tclearTimeout(request.timeoutTimer);\n\n\t\t\t\tswitch (request.request.type) {\n\t\t\t\t\tcase RequestType.Promise: this.onPromise(request.request); break;\n\t\t\t\t\tcase RequestType.EventListen: this.onEventListen(request.request); break;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.pendingRequests.delete(channelName);\n\t\t}\n\t}\n\n\tpublic dispose(): void {\n\t\tif (this.protocolListener) {\n\t\t\tthis.protocolListener.dispose();\n\t\t\tthis.protocolListener = null;\n\t\t}\n\t\tdispose(this.activeRequests.values());\n\t\tthis.activeRequests.clear();\n\t}\n}\n\nexport const enum RequestInitiator {\n\tLocalSide = 0,\n\tOtherSide = 1\n}\n\nexport interface IIPCLogger {\n\tlogIncoming(msgLength: number, requestId: number, initiator: RequestInitiator, str: string, data?: any): void;\n\tlogOutgoing(msgLength: number, requestId: number, initiator: RequestInitiator, str: string, data?: any): void;\n}\n\nexport class ChannelClient implements IChannelClient, IDisposable {\n\n\tprivate isDisposed: boolean = false;\n\tprivate state: State = State.Uninitialized;\n\tprivate activeRequests = new Set<IDisposable>();\n\tprivate handlers = new Map<number, IHandler>();\n\tprivate lastRequestId: number = 0;\n\tprivate protocolListener: IDisposable | null;\n\tprivate logger: IIPCLogger | null;\n\n\tprivate readonly _onDidInitialize = new Emitter<void>();\n\treadonly onDidInitialize = this._onDidInitialize.event;\n\n\tconstructor(private protocol: IMessagePassingProtocol, logger: IIPCLogger | null = null) {\n\t\tthis.protocolListener = this.protocol.onMessage(msg => this.onBuffer(msg));\n\t\tthis.logger = logger;\n\t}\n\n\tgetChannel<T extends IChannel>(channelName: string): T {\n\t\tconst that = this;\n\n\t\treturn {\n\t\t\tcall(command: string, arg?: any, cancellationToken?: CancellationToken) {\n\t\t\t\tif (that.isDisposed) {\n\t\t\t\t\treturn Promise.reject(new CancellationError());\n\t\t\t\t}\n\t\t\t\treturn that.requestPromise(channelName, command, arg, cancellationToken);\n\t\t\t},\n\t\t\tlisten(event: string, arg: any) {\n\t\t\t\tif (that.isDisposed) {\n\t\t\t\t\treturn Event.None;\n\t\t\t\t}\n\t\t\t\treturn that.requestEvent(channelName, event, arg);\n\t\t\t}\n\t\t} as T;\n\t}\n\n\tprivate requestPromise(channelName: string, name: string, arg?: any, cancellationToken = CancellationToken.None): Promise<any> {\n\t\tconst id = this.lastRequestId++;\n\t\tconst type = RequestType.Promise;\n\t\tconst request: IRawRequest = { id, type, channelName, name, arg };\n\n\t\tif (cancellationToken.isCancellationRequested) {\n\t\t\treturn Promise.reject(new CancellationError());\n\t\t}\n\n\t\tlet disposable: IDisposable;\n\n\t\tconst result = new Promise((c, e) => {\n\t\t\tif (cancellationToken.isCancellationRequested) {\n\t\t\t\treturn e(new CancellationError());\n\t\t\t}\n\n\t\t\tconst doRequest = () => {\n\t\t\t\tconst handler: IHandler = response => {\n\t\t\t\t\tswitch (response.type) {\n\t\t\t\t\t\tcase ResponseType.PromiseSuccess:\n\t\t\t\t\t\t\tthis.handlers.delete(id);\n\t\t\t\t\t\t\tc(response.data);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase ResponseType.PromiseError: {\n\t\t\t\t\t\t\tthis.handlers.delete(id);\n\t\t\t\t\t\t\tconst error = new Error(response.data.message);\n\t\t\t\t\t\t\t(<any>error).stack = Array.isArray(response.data.stack) ? response.data.stack.join('\\n') : response.data.stack;\n\t\t\t\t\t\t\terror.name = response.data.name;\n\t\t\t\t\t\t\te(error);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase ResponseType.PromiseErrorObj:\n\t\t\t\t\t\t\tthis.handlers.delete(id);\n\t\t\t\t\t\t\te(response.data);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tthis.handlers.set(id, handler);\n\t\t\t\tthis.sendRequest(request);\n\t\t\t};\n\n\t\t\tlet uninitializedPromise: CancelablePromise<void> | null = null;\n\t\t\tif (this.state === State.Idle) {\n\t\t\t\tdoRequest();\n\t\t\t} else {\n\t\t\t\tuninitializedPromise = createCancelablePromise(_ => this.whenInitialized());\n\t\t\t\tuninitializedPromise.then(() => {\n\t\t\t\t\tuninitializedPromise = null;\n\t\t\t\t\tdoRequest();\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst cancel = () => {\n\t\t\t\tif (uninitializedPromise) {\n\t\t\t\t\tuninitializedPromise.cancel();\n\t\t\t\t\tuninitializedPromise = null;\n\t\t\t\t} else {\n\t\t\t\t\tthis.sendRequest({ id, type: RequestType.PromiseCancel });\n\t\t\t\t}\n\n\t\t\t\te(new CancellationError());\n\t\t\t};\n\n\t\t\tconst cancellationTokenListener = cancellationToken.onCancellationRequested(cancel);\n\t\t\tdisposable = combinedDisposable(toDisposable(cancel), cancellationTokenListener);\n\t\t\tthis.activeRequests.add(disposable);\n\t\t});\n\n\t\treturn result.finally(() => {\n\t\t\tdisposable.dispose();\n\t\t\tthis.activeRequests.delete(disposable);\n\t\t});\n\t}\n\n\tprivate requestEvent(channelName: string, name: string, arg?: any): Event<any> {\n\t\tconst id = this.lastRequestId++;\n\t\tconst type = RequestType.EventListen;\n\t\tconst request: IRawRequest = { id, type, channelName, name, arg };\n\n\t\tlet uninitializedPromise: CancelablePromise<void> | null = null;\n\n\t\tconst emitter = new Emitter<any>({\n\t\t\tonWillAddFirstListener: () => {\n\t\t\t\tuninitializedPromise = createCancelablePromise(_ => this.whenInitialized());\n\t\t\t\tuninitializedPromise.then(() => {\n\t\t\t\t\tuninitializedPromise = null;\n\t\t\t\t\tthis.activeRequests.add(emitter);\n\t\t\t\t\tthis.sendRequest(request);\n\t\t\t\t});\n\t\t\t},\n\t\t\tonDidRemoveLastListener: () => {\n\t\t\t\tif (uninitializedPromise) {\n\t\t\t\t\tuninitializedPromise.cancel();\n\t\t\t\t\tuninitializedPromise = null;\n\t\t\t\t} else {\n\t\t\t\t\tthis.activeRequests.delete(emitter);\n\t\t\t\t\tthis.sendRequest({ id, type: RequestType.EventDispose });\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tconst handler: IHandler = (res: IRawResponse) => emitter.fire((res as IRawEventFireResponse).data);\n\t\tthis.handlers.set(id, handler);\n\n\t\treturn emitter.event;\n\t}\n\n\tprivate sendRequest(request: IRawRequest): void {\n\t\tswitch (request.type) {\n\t\t\tcase RequestType.Promise:\n\t\t\tcase RequestType.EventListen: {\n\t\t\t\tconst msgLength = this.send([request.type, request.id, request.channelName, request.name], request.arg);\n\t\t\t\tthis.logger?.logOutgoing(msgLength, request.id, RequestInitiator.LocalSide, `${requestTypeToStr(request.type)}: ${request.channelName}.${request.name}`, request.arg);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcase RequestType.PromiseCancel:\n\t\t\tcase RequestType.EventDispose: {\n\t\t\t\tconst msgLength = this.send([request.type, request.id]);\n\t\t\t\tthis.logger?.logOutgoing(msgLength, request.id, RequestInitiator.LocalSide, requestTypeToStr(request.type));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate send(header: any, body: any = undefined): number {\n\t\tconst writer = new BufferWriter();\n\t\tserialize(writer, header);\n\t\tserialize(writer, body);\n\t\treturn this.sendBuffer(writer.buffer);\n\t}\n\n\tprivate sendBuffer(message: VSBuffer): number {\n\t\ttry {\n\t\t\tthis.protocol.send(message);\n\t\t\treturn message.byteLength;\n\t\t} catch (err) {\n\t\t\t// noop\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tprivate onBuffer(message: VSBuffer): void {\n\t\tconst reader = new BufferReader(message);\n\t\tconst header = deserialize(reader);\n\t\tconst body = deserialize(reader);\n\t\tconst type: ResponseType = header[0];\n\n\t\tswitch (type) {\n\t\t\tcase ResponseType.Initialize:\n\t\t\t\tthis.logger?.logIncoming(message.byteLength, 0, RequestInitiator.LocalSide, responseTypeToStr(type));\n\t\t\t\treturn this.onResponse({ type: header[0] });\n\n\t\t\tcase ResponseType.PromiseSuccess:\n\t\t\tcase ResponseType.PromiseError:\n\t\t\tcase ResponseType.EventFire:\n\t\t\tcase ResponseType.PromiseErrorObj:\n\t\t\t\tthis.logger?.logIncoming(message.byteLength, header[1], RequestInitiator.LocalSide, responseTypeToStr(type), body);\n\t\t\t\treturn this.onResponse({ type: header[0], id: header[1], data: body });\n\t\t}\n\t}\n\n\tprivate onResponse(response: IRawResponse): void {\n\t\tif (response.type === ResponseType.Initialize) {\n\t\t\tthis.state = State.Idle;\n\t\t\tthis._onDidInitialize.fire();\n\t\t\treturn;\n\t\t}\n\n\t\tconst handler = this.handlers.get(response.id);\n\n\t\thandler?.(response);\n\t}\n\n\t@memoize\n\tget onDidInitializePromise(): Promise<void> {\n\t\treturn Event.toPromise(this.onDidInitialize);\n\t}\n\n\tprivate whenInitialized(): Promise<void> {\n\t\tif (this.state === State.Idle) {\n\t\t\treturn Promise.resolve();\n\t\t} else {\n\t\t\treturn this.onDidInitializePromise;\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis.isDisposed = true;\n\t\tif (this.protocolListener) {\n\t\t\tthis.protocolListener.dispose();\n\t\t\tthis.protocolListener = null;\n\t\t}\n\t\tdispose(this.activeRequests.values());\n\t\tthis.activeRequests.clear();\n\t}\n}\n\nexport interface ClientConnectionEvent {\n\tprotocol: IMessagePassingProtocol;\n\tonDidClientDisconnect: Event<void>;\n}\n\ninterface Connection<TContext> extends Client<TContext> {\n\treadonly channelServer: ChannelServer<TContext>;\n\treadonly channelClient: ChannelClient;\n}\n\n/**\n * An `IPCServer` is both a channel server and a routing channel\n * client.\n *\n * As the owner of a protocol, you should extend both this\n * and the `IPCClient` classes to get IPC implementations\n * for your protocol.\n */\nexport class IPCServer<TContext = string> implements IChannelServer<TContext>, IRoutingChannelClient<TContext>, IConnectionHub<TContext>, IDisposable {\n\n\tprivate channels = new Map<string, IServerChannel<TContext>>();\n\tprivate _connections = new Set<Connection<TContext>>();\n\n\tprivate readonly _onDidAddConnection = new Emitter<Connection<TContext>>();\n\treadonly onDidAddConnection: Event<Connection<TContext>> = this._onDidAddConnection.event;\n\n\tprivate readonly _onDidRemoveConnection = new Emitter<Connection<TContext>>();\n\treadonly onDidRemoveConnection: Event<Connection<TContext>> = this._onDidRemoveConnection.event;\n\n\tprivate readonly disposables = new DisposableStore();\n\n\tget connections(): Connection<TContext>[] {\n\t\tconst result: Connection<TContext>[] = [];\n\t\tthis._connections.forEach(ctx => result.push(ctx));\n\t\treturn result;\n\t}\n\n\tconstructor(onDidClientConnect: Event<ClientConnectionEvent>) {\n\t\tthis.disposables.add(onDidClientConnect(({ protocol, onDidClientDisconnect }) => {\n\t\t\tconst onFirstMessage = Event.once(protocol.onMessage);\n\n\t\t\tthis.disposables.add(onFirstMessage(msg => {\n\t\t\t\tconst reader = new BufferReader(msg);\n\t\t\t\tconst ctx = deserialize(reader) as TContext;\n\n\t\t\t\tconst channelServer = new ChannelServer(protocol, ctx);\n\t\t\t\tconst channelClient = new ChannelClient(protocol);\n\n\t\t\t\tthis.channels.forEach((channel, name) => channelServer.registerChannel(name, channel));\n\n\t\t\t\tconst connection: Connection<TContext> = { channelServer, channelClient, ctx };\n\t\t\t\tthis._connections.add(connection);\n\t\t\t\tthis._onDidAddConnection.fire(connection);\n\n\t\t\t\tthis.disposables.add(onDidClientDisconnect(() => {\n\t\t\t\t\tchannelServer.dispose();\n\t\t\t\t\tchannelClient.dispose();\n\t\t\t\t\tthis._connections.delete(connection);\n\t\t\t\t\tthis._onDidRemoveConnection.fire(connection);\n\t\t\t\t}));\n\t\t\t}));\n\t\t}));\n\t}\n\n\t/**\n\t * Get a channel from a remote client. When passed a router,\n\t * one can specify which client it wants to call and listen to/from.\n\t * Otherwise, when calling without a router, a random client will\n\t * be selected and when listening without a router, every client\n\t * will be listened to.\n\t */\n\tgetChannel<T extends IChannel>(channelName: string, router: IClientRouter<TContext>): T;\n\tgetChannel<T extends IChannel>(channelName: string, clientFilter: (client: Client<TContext>) => boolean): T;\n\tgetChannel<T extends IChannel>(channelName: string, routerOrClientFilter: IClientRouter<TContext> | ((client: Client<TContext>) => boolean)): T {\n\t\tconst that = this;\n\n\t\treturn {\n\t\t\tcall(command: string, arg?: any, cancellationToken?: CancellationToken): Promise<T> {\n\t\t\t\tlet connectionPromise: Promise<Client<TContext>>;\n\n\t\t\t\tif (isFunction(routerOrClientFilter)) {\n\t\t\t\t\t// when no router is provided, we go random client picking\n\t\t\t\t\tconst connection = getRandomElement(that.connections.filter(routerOrClientFilter));\n\n\t\t\t\t\tconnectionPromise = connection\n\t\t\t\t\t\t// if we found a client, let's call on it\n\t\t\t\t\t\t? Promise.resolve(connection)\n\t\t\t\t\t\t// else, let's wait for a client to come along\n\t\t\t\t\t\t: Event.toPromise(Event.filter(that.onDidAddConnection, routerOrClientFilter));\n\t\t\t\t} else {\n\t\t\t\t\tconnectionPromise = routerOrClientFilter.routeCall(that, command, arg);\n\t\t\t\t}\n\n\t\t\t\tconst channelPromise = connectionPromise\n\t\t\t\t\t.then(connection => (connection as Connection<TContext>).channelClient.getChannel(channelName));\n\n\t\t\t\treturn getDelayedChannel(channelPromise)\n\t\t\t\t\t.call(command, arg, cancellationToken);\n\t\t\t},\n\t\t\tlisten(event: string, arg: any): Event<T> {\n\t\t\t\tif (isFunction(routerOrClientFilter)) {\n\t\t\t\t\treturn that.getMulticastEvent(channelName, routerOrClientFilter, event, arg);\n\t\t\t\t}\n\n\t\t\t\tconst channelPromise = routerOrClientFilter.routeEvent(that, event, arg)\n\t\t\t\t\t.then(connection => (connection as Connection<TContext>).channelClient.getChannel(channelName));\n\n\t\t\t\treturn getDelayedChannel(channelPromise)\n\t\t\t\t\t.listen(event, arg);\n\t\t\t}\n\t\t} as T;\n\t}\n\n\tprivate getMulticastEvent<T extends IChannel>(channelName: string, clientFilter: (client: Client<TContext>) => boolean, eventName: string, arg: any): Event<T> {\n\t\tconst that = this;\n\t\tlet disposables: DisposableStore | undefined;\n\n\t\t// Create an emitter which hooks up to all clients\n\t\t// as soon as first listener is added. It also\n\t\t// disconnects from all clients as soon as the last listener\n\t\t// is removed.\n\t\tconst emitter = new Emitter<T>({\n\t\t\tonWillAddFirstListener: () => {\n\t\t\t\tdisposables = new DisposableStore();\n\n\t\t\t\t// The event multiplexer is useful since the active\n\t\t\t\t// client list is dynamic. We need to hook up and disconnection\n\t\t\t\t// to/from clients as they come and go.\n\t\t\t\tconst eventMultiplexer = new EventMultiplexer<T>();\n\t\t\t\tconst map = new Map<Connection<TContext>, IDisposable>();\n\n\t\t\t\tconst onDidAddConnection = (connection: Connection<TContext>) => {\n\t\t\t\t\tconst channel = connection.channelClient.getChannel(channelName);\n\t\t\t\t\tconst event = channel.listen<T>(eventName, arg);\n\t\t\t\t\tconst disposable = eventMultiplexer.add(event);\n\n\t\t\t\t\tmap.set(connection, disposable);\n\t\t\t\t};\n\n\t\t\t\tconst onDidRemoveConnection = (connection: Connection<TContext>) => {\n\t\t\t\t\tconst disposable = map.get(connection);\n\n\t\t\t\t\tif (!disposable) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tdisposable.dispose();\n\t\t\t\t\tmap.delete(connection);\n\t\t\t\t};\n\n\t\t\t\tthat.connections.filter(clientFilter).forEach(onDidAddConnection);\n\t\t\t\tEvent.filter(that.onDidAddConnection, clientFilter)(onDidAddConnection, undefined, disposables);\n\t\t\t\tthat.onDidRemoveConnection(onDidRemoveConnection, undefined, disposables);\n\t\t\t\teventMultiplexer.event(emitter.fire, emitter, disposables);\n\n\t\t\t\tdisposables.add(eventMultiplexer);\n\t\t\t},\n\t\t\tonDidRemoveLastListener: () => {\n\t\t\t\tdisposables?.dispose();\n\t\t\t\tdisposables = undefined;\n\t\t\t}\n\t\t});\n\n\t\treturn emitter.event;\n\t}\n\n\tregisterChannel(channelName: string, channel: IServerChannel<TContext>): void {\n\t\tthis.channels.set(channelName, channel);\n\n\t\tfor (const connection of this._connections) {\n\t\t\tconnection.channelServer.registerChannel(channelName, channel);\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis.disposables.dispose();\n\n\t\tfor (const connection of this._connections) {\n\t\t\tconnection.channelClient.dispose();\n\t\t\tconnection.channelServer.dispose();\n\t\t}\n\n\t\tthis._connections.clear();\n\t\tthis.channels.clear();\n\t\tthis._onDidAddConnection.dispose();\n\t\tthis._onDidRemoveConnection.dispose();\n\t}\n}\n\n/**\n * An `IPCClient` is both a channel client and a channel server.\n *\n * As the owner of a protocol, you should extend both this\n * and the `IPCServer` classes to get IPC implementations\n * for your protocol.\n */\nexport class IPCClient<TContext = string> implements IChannelClient, IChannelServer<TContext>, IDisposable {\n\n\tprivate channelClient: ChannelClient;\n\tprivate channelServer: ChannelServer<TContext>;\n\n\tconstructor(protocol: IMessagePassingProtocol, ctx: TContext, ipcLogger: IIPCLogger | null = null) {\n\t\tconst writer = new BufferWriter();\n\t\tserialize(writer, ctx);\n\t\tprotocol.send(writer.buffer);\n\n\t\tthis.channelClient = new ChannelClient(protocol, ipcLogger);\n\t\tthis.channelServer = new ChannelServer(protocol, ctx, ipcLogger);\n\t}\n\n\tgetChannel<T extends IChannel>(channelName: string): T {\n\t\treturn this.channelClient.getChannel(channelName) as T;\n\t}\n\n\tregisterChannel(channelName: string, channel: IServerChannel<TContext>): void {\n\t\tthis.channelServer.registerChannel(channelName, channel);\n\t}\n\n\tdispose(): void {\n\t\tthis.channelClient.dispose();\n\t\tthis.channelServer.dispose();\n\t}\n}\n\nexport function getDelayedChannel<T extends IChannel>(promise: Promise<T>): T {\n\treturn {\n\t\tcall(command: string, arg?: any, cancellationToken?: CancellationToken): Promise<T> {\n\t\t\treturn promise.then(c => c.call<T>(command, arg, cancellationToken));\n\t\t},\n\n\t\tlisten<T>(event: string, arg?: any): Event<T> {\n\t\t\tconst relay = new Relay<any>();\n\t\t\tpromise.then(c => relay.input = c.listen(event, arg));\n\t\t\treturn relay.event;\n\t\t}\n\t} as T;\n}\n\nexport function getNextTickChannel<T extends IChannel>(channel: T): T {\n\tlet didTick = false;\n\n\treturn {\n\t\tcall<T>(command: string, arg?: any, cancellationToken?: CancellationToken): Promise<T> {\n\t\t\tif (didTick) {\n\t\t\t\treturn channel.call(command, arg, cancellationToken);\n\t\t\t}\n\n\t\t\treturn timeout(0)\n\t\t\t\t.then(() => didTick = true)\n\t\t\t\t.then(() => channel.call<T>(command, arg, cancellationToken));\n\t\t},\n\t\tlisten<T>(event: string, arg?: any): Event<T> {\n\t\t\tif (didTick) {\n\t\t\t\treturn channel.listen<T>(event, arg);\n\t\t\t}\n\n\t\t\tconst relay = new Relay<T>();\n\n\t\t\ttimeout(0)\n\t\t\t\t.then(() => didTick = true)\n\t\t\t\t.then(() => relay.input = channel.listen<T>(event, arg));\n\n\t\t\treturn relay.event;\n\t\t}\n\t} as T;\n}\n\nexport class StaticRouter<TContext = string> implements IClientRouter<TContext> {\n\n\tconstructor(private fn: (ctx: TContext) => boolean | Promise<boolean>) { }\n\n\trouteCall(hub: IConnectionHub<TContext>): Promise<Client<TContext>> {\n\t\treturn this.route(hub);\n\t}\n\n\trouteEvent(hub: IConnectionHub<TContext>): Promise<Client<TContext>> {\n\t\treturn this.route(hub);\n\t}\n\n\tprivate async route(hub: IConnectionHub<TContext>): Promise<Client<TContext>> {\n\t\tfor (const connection of hub.connections) {\n\t\t\tif (await Promise.resolve(this.fn(connection.ctx))) {\n\t\t\t\treturn Promise.resolve(connection);\n\t\t\t}\n\t\t}\n\n\t\tawait Event.toPromise(hub.onDidAddConnection);\n\t\treturn await this.route(hub);\n\t}\n}\n\n/**\n * Use ProxyChannels to automatically wrapping and unwrapping\n * services to/from IPC channels, instead of manually wrapping\n * each service method and event.\n *\n * Restrictions:\n * - If marshalling is enabled, only `URI` and `RegExp` is converted\n *   automatically for you\n * - Events must follow the naming convention `onUpperCase`\n * - `CancellationToken` is currently not supported\n * - If a context is provided, you can use `AddFirstParameterToFunctions`\n *   utility to signal this in the receiving side type\n */\nexport namespace ProxyChannel {\n\n\texport interface IProxyOptions {\n\n\t\t/**\n\t\t * Disables automatic marshalling of `URI`.\n\t\t * If marshalling is disabled, `UriComponents`\n\t\t * must be used instead.\n\t\t */\n\t\tdisableMarshalling?: boolean;\n\t}\n\n\texport interface ICreateServiceChannelOptions extends IProxyOptions { }\n\n\texport function fromService<TContext>(service: unknown, disposables: DisposableStore, options?: ICreateServiceChannelOptions): IServerChannel<TContext> {\n\t\tconst handler = service as { [key: string]: unknown };\n\t\tconst disableMarshalling = options && options.disableMarshalling;\n\n\t\t// Buffer any event that should be supported by\n\t\t// iterating over all property keys and finding them\n\t\tconst mapEventNameToEvent = new Map<string, Event<unknown>>();\n\t\tfor (const key in handler) {\n\t\t\tif (propertyIsEvent(key)) {\n\t\t\t\tmapEventNameToEvent.set(key, Event.buffer(handler[key] as Event<unknown>, true, undefined, disposables));\n\t\t\t}\n\t\t}\n\n\t\treturn new class implements IServerChannel {\n\n\t\t\tlisten<T>(_: unknown, event: string, arg: any): Event<T> {\n\t\t\t\tconst eventImpl = mapEventNameToEvent.get(event);\n\t\t\t\tif (eventImpl) {\n\t\t\t\t\treturn eventImpl as Event<T>;\n\t\t\t\t}\n\n\t\t\t\tif (propertyIsDynamicEvent(event)) {\n\t\t\t\t\tconst target = handler[event];\n\t\t\t\t\tif (typeof target === 'function') {\n\t\t\t\t\t\treturn target.call(handler, arg);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthrow new ErrorNoTelemetry(`Event not found: ${event}`);\n\t\t\t}\n\n\t\t\tcall(_: unknown, command: string, args?: any[]): Promise<any> {\n\t\t\t\tconst target = handler[command];\n\t\t\t\tif (typeof target === 'function') {\n\n\t\t\t\t\t// Revive unless marshalling disabled\n\t\t\t\t\tif (!disableMarshalling && Array.isArray(args)) {\n\t\t\t\t\t\tfor (let i = 0; i < args.length; i++) {\n\t\t\t\t\t\t\targs[i] = revive(args[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn target.apply(handler, args);\n\t\t\t\t}\n\n\t\t\t\tthrow new ErrorNoTelemetry(`Method not found: ${command}`);\n\t\t\t}\n\t\t};\n\t}\n\n\texport interface ICreateProxyServiceOptions extends IProxyOptions {\n\n\t\t/**\n\t\t * If provided, will add the value of `context`\n\t\t * to each method call to the target.\n\t\t */\n\t\tcontext?: unknown;\n\n\t\t/**\n\t\t * If provided, will not proxy any of the properties\n\t\t * that are part of the Map but rather return that value.\n\t\t */\n\t\tproperties?: Map<string, unknown>;\n\t}\n\n\texport function toService<T extends object>(channel: IChannel, options?: ICreateProxyServiceOptions): T {\n\t\tconst disableMarshalling = options && options.disableMarshalling;\n\n\t\treturn new Proxy({}, {\n\t\t\tget(_target: T, propKey: PropertyKey) {\n\t\t\t\tif (typeof propKey === 'string') {\n\n\t\t\t\t\t// Check for predefined values\n\t\t\t\t\tif (options?.properties?.has(propKey)) {\n\t\t\t\t\t\treturn options.properties.get(propKey);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Dynamic Event\n\t\t\t\t\tif (propertyIsDynamicEvent(propKey)) {\n\t\t\t\t\t\treturn function (arg: any) {\n\t\t\t\t\t\t\treturn channel.listen(propKey, arg);\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Event\n\t\t\t\t\tif (propertyIsEvent(propKey)) {\n\t\t\t\t\t\treturn channel.listen(propKey);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Function\n\t\t\t\t\treturn async function (...args: any[]) {\n\n\t\t\t\t\t\t// Add context if any\n\t\t\t\t\t\tlet methodArgs: any[];\n\t\t\t\t\t\tif (options && !isUndefinedOrNull(options.context)) {\n\t\t\t\t\t\t\tmethodArgs = [options.context, ...args];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tmethodArgs = args;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst result = await channel.call(propKey, methodArgs);\n\n\t\t\t\t\t\t// Revive unless marshalling disabled\n\t\t\t\t\t\tif (!disableMarshalling) {\n\t\t\t\t\t\t\treturn revive(result);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tthrow new ErrorNoTelemetry(`Property not found: ${String(propKey)}`);\n\t\t\t}\n\t\t}) as T;\n\t}\n\n\tfunction propertyIsEvent(name: string): boolean {\n\t\t// Assume a property is an event if it has a form of \"onSomething\"\n\t\treturn name[0] === 'o' && name[1] === 'n' && strings.isUpperAsciiLetter(name.charCodeAt(2));\n\t}\n\n\tfunction propertyIsDynamicEvent(name: string): boolean {\n\t\t// Assume a property is a dynamic event (a method that returns an event) if it has a form of \"onDynamicSomething\"\n\t\treturn /^onDynamic/.test(name) && strings.isUpperAsciiLetter(name.charCodeAt(9));\n\t}\n}\n\nconst colorTables = [\n\t['#2977B1', '#FC802D', '#34A13A', '#D3282F', '#9366BA'],\n\t['#8B564C', '#E177C0', '#7F7F7F', '#BBBE3D', '#2EBECD']\n];\n\nfunction prettyWithoutArrays(data: any): any {\n\tif (Array.isArray(data)) {\n\t\treturn data;\n\t}\n\tif (data && typeof data === 'object' && typeof data.toString === 'function') {\n\t\tconst result = data.toString();\n\t\tif (result !== '[object Object]') {\n\t\t\treturn result;\n\t\t}\n\t}\n\treturn data;\n}\n\nfunction pretty(data: any): any {\n\tif (Array.isArray(data)) {\n\t\treturn data.map(prettyWithoutArrays);\n\t}\n\treturn prettyWithoutArrays(data);\n}\n\nfunction logWithColors(direction: string, totalLength: number, msgLength: number, req: number, initiator: RequestInitiator, str: string, data: any): void {\n\tdata = pretty(data);\n\n\tconst colorTable = colorTables[initiator];\n\tconst color = colorTable[req % colorTable.length];\n\tlet args = [`%c[${direction}]%c[${String(totalLength).padStart(7, ' ')}]%c[len: ${String(msgLength).padStart(5, ' ')}]%c${String(req).padStart(5, ' ')} - ${str}`, 'color: darkgreen', 'color: grey', 'color: grey', `color: ${color}`];\n\tif (/\\($/.test(str)) {\n\t\targs = args.concat(data);\n\t\targs.push(')');\n\t} else {\n\t\targs.push(data);\n\t}\n\tconsole.log.apply(console, args as [string, ...string[]]);\n}\n\nexport class IPCLogger implements IIPCLogger {\n\tprivate _totalIncoming = 0;\n\tprivate _totalOutgoing = 0;\n\n\tconstructor(\n\t\tprivate readonly _outgoingPrefix: string,\n\t\tprivate readonly _incomingPrefix: string,\n\t) { }\n\n\tpublic logOutgoing(msgLength: number, requestId: number, initiator: RequestInitiator, str: string, data?: any): void {\n\t\tthis._totalOutgoing += msgLength;\n\t\tlogWithColors(this._outgoingPrefix, this._totalOutgoing, msgLength, requestId, initiator, str, data);\n\t}\n\n\tpublic logIncoming(msgLength: number, requestId: number, initiator: RequestInitiator, str: string, data?: any): void {\n\t\tthis._totalIncoming += msgLength;\n\t\tlogWithColors(this._incomingPrefix, this._totalIncoming, msgLength, requestId, initiator, str, data);\n\t}\n}\n"]}