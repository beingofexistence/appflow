{"version":3,"sources":["file:///workspace/appflow/src/vs/base/parts/ipc/common/ipc.net.ts"],"names":[],"mappings":"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","file":"ipc.net.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { VSBuffer } from 'vs/base/common/buffer';\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { Disposable, DisposableStore, IDisposable } from 'vs/base/common/lifecycle';\nimport { IIPCLogger, IMessagePassingProtocol, IPCClient } from 'vs/base/parts/ipc/common/ipc';\n\nexport const enum SocketDiagnosticsEventType {\n\tCreated = 'created',\n\tRead = 'read',\n\tWrite = 'write',\n\tOpen = 'open',\n\tError = 'error',\n\tClose = 'close',\n\n\tBrowserWebSocketBlobReceived = 'browserWebSocketBlobReceived',\n\n\tNodeEndReceived = 'nodeEndReceived',\n\tNodeEndSent = 'nodeEndSent',\n\tNodeDrainBegin = 'nodeDrainBegin',\n\tNodeDrainEnd = 'nodeDrainEnd',\n\n\tzlibInflateError = 'zlibInflateError',\n\tzlibInflateData = 'zlibInflateData',\n\tzlibInflateInitialWrite = 'zlibInflateInitialWrite',\n\tzlibInflateInitialFlushFired = 'zlibInflateInitialFlushFired',\n\tzlibInflateWrite = 'zlibInflateWrite',\n\tzlibInflateFlushFired = 'zlibInflateFlushFired',\n\tzlibDeflateError = 'zlibDeflateError',\n\tzlibDeflateData = 'zlibDeflateData',\n\tzlibDeflateWrite = 'zlibDeflateWrite',\n\tzlibDeflateFlushFired = 'zlibDeflateFlushFired',\n\n\tWebSocketNodeSocketWrite = 'webSocketNodeSocketWrite',\n\tWebSocketNodeSocketPeekedHeader = 'webSocketNodeSocketPeekedHeader',\n\tWebSocketNodeSocketReadHeader = 'webSocketNodeSocketReadHeader',\n\tWebSocketNodeSocketReadData = 'webSocketNodeSocketReadData',\n\tWebSocketNodeSocketUnmaskedData = 'webSocketNodeSocketUnmaskedData',\n\tWebSocketNodeSocketDrainBegin = 'webSocketNodeSocketDrainBegin',\n\tWebSocketNodeSocketDrainEnd = 'webSocketNodeSocketDrainEnd',\n\n\tProtocolHeaderRead = 'protocolHeaderRead',\n\tProtocolMessageRead = 'protocolMessageRead',\n\tProtocolHeaderWrite = 'protocolHeaderWrite',\n\tProtocolMessageWrite = 'protocolMessageWrite',\n\tProtocolWrite = 'protocolWrite',\n}\n\nexport namespace SocketDiagnostics {\n\n\texport const enableDiagnostics = false;\n\n\texport interface IRecord {\n\t\ttimestamp: number;\n\t\tid: string;\n\t\tlabel: string;\n\t\ttype: SocketDiagnosticsEventType;\n\t\tbuff?: VSBuffer;\n\t\tdata?: any;\n\t}\n\n\texport const records: IRecord[] = [];\n\tconst socketIds = new WeakMap<any, string>();\n\tlet lastUsedSocketId = 0;\n\n\tfunction getSocketId(nativeObject: any, label: string): string {\n\t\tif (!socketIds.has(nativeObject)) {\n\t\t\tconst id = String(++lastUsedSocketId);\n\t\t\tsocketIds.set(nativeObject, id);\n\t\t}\n\t\treturn socketIds.get(nativeObject)!;\n\t}\n\n\texport function traceSocketEvent(nativeObject: any, socketDebugLabel: string, type: SocketDiagnosticsEventType, data?: VSBuffer | Uint8Array | ArrayBuffer | ArrayBufferView | any): void {\n\t\tif (!enableDiagnostics) {\n\t\t\treturn;\n\t\t}\n\t\tconst id = getSocketId(nativeObject, socketDebugLabel);\n\n\t\tif (data instanceof VSBuffer || data instanceof Uint8Array || data instanceof ArrayBuffer || ArrayBuffer.isView(data)) {\n\t\t\tconst copiedData = VSBuffer.alloc(data.byteLength);\n\t\t\tcopiedData.set(data);\n\t\t\trecords.push({ timestamp: Date.now(), id, label: socketDebugLabel, type, buff: copiedData });\n\t\t} else {\n\t\t\t// data is a custom object\n\t\t\trecords.push({ timestamp: Date.now(), id, label: socketDebugLabel, type, data: data });\n\t\t}\n\t}\n}\n\nexport const enum SocketCloseEventType {\n\tNodeSocketCloseEvent = 0,\n\tWebSocketCloseEvent = 1\n}\n\nexport interface NodeSocketCloseEvent {\n\t/**\n\t * The type of the event\n\t */\n\treadonly type: SocketCloseEventType.NodeSocketCloseEvent;\n\t/**\n\t * `true` if the socket had a transmission error.\n\t */\n\treadonly hadError: boolean;\n\t/**\n\t * Underlying error.\n\t */\n\treadonly error: Error | undefined;\n}\n\nexport interface WebSocketCloseEvent {\n\t/**\n\t * The type of the event\n\t */\n\treadonly type: SocketCloseEventType.WebSocketCloseEvent;\n\t/**\n\t * Returns the WebSocket connection close code provided by the server.\n\t */\n\treadonly code: number;\n\t/**\n\t * Returns the WebSocket connection close reason provided by the server.\n\t */\n\treadonly reason: string;\n\t/**\n\t * Returns true if the connection closed cleanly; false otherwise.\n\t */\n\treadonly wasClean: boolean;\n\t/**\n\t * Underlying event.\n\t */\n\treadonly event: any | undefined;\n}\n\nexport type SocketCloseEvent = NodeSocketCloseEvent | WebSocketCloseEvent | undefined;\n\nexport interface SocketTimeoutEvent {\n\treadonly unacknowledgedMsgCount: number;\n\treadonly timeSinceOldestUnacknowledgedMsg: number;\n\treadonly timeSinceLastReceivedSomeData: number;\n}\n\nexport interface ISocket extends IDisposable {\n\tonData(listener: (e: VSBuffer) => void): IDisposable;\n\tonClose(listener: (e: SocketCloseEvent) => void): IDisposable;\n\tonEnd(listener: () => void): IDisposable;\n\twrite(buffer: VSBuffer): void;\n\tend(): void;\n\tdrain(): Promise<void>;\n\n\ttraceSocketEvent(type: SocketDiagnosticsEventType, data?: VSBuffer | Uint8Array | ArrayBuffer | ArrayBufferView | any): void;\n}\n\nlet emptyBuffer: VSBuffer | null = null;\nfunction getEmptyBuffer(): VSBuffer {\n\tif (!emptyBuffer) {\n\t\temptyBuffer = VSBuffer.alloc(0);\n\t}\n\treturn emptyBuffer;\n}\n\nexport class ChunkStream {\n\n\tprivate _chunks: VSBuffer[];\n\tprivate _totalLength: number;\n\n\tpublic get byteLength() {\n\t\treturn this._totalLength;\n\t}\n\n\tconstructor() {\n\t\tthis._chunks = [];\n\t\tthis._totalLength = 0;\n\t}\n\n\tpublic acceptChunk(buff: VSBuffer) {\n\t\tthis._chunks.push(buff);\n\t\tthis._totalLength += buff.byteLength;\n\t}\n\n\tpublic read(byteCount: number): VSBuffer {\n\t\treturn this._read(byteCount, true);\n\t}\n\n\tpublic peek(byteCount: number): VSBuffer {\n\t\treturn this._read(byteCount, false);\n\t}\n\n\tprivate _read(byteCount: number, advance: boolean): VSBuffer {\n\n\t\tif (byteCount === 0) {\n\t\t\treturn getEmptyBuffer();\n\t\t}\n\n\t\tif (byteCount > this._totalLength) {\n\t\t\tthrow new Error(`Cannot read so many bytes!`);\n\t\t}\n\n\t\tif (this._chunks[0].byteLength === byteCount) {\n\t\t\t// super fast path, precisely first chunk must be returned\n\t\t\tconst result = this._chunks[0];\n\t\t\tif (advance) {\n\t\t\t\tthis._chunks.shift();\n\t\t\t\tthis._totalLength -= byteCount;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tif (this._chunks[0].byteLength > byteCount) {\n\t\t\t// fast path, the reading is entirely within the first chunk\n\t\t\tconst result = this._chunks[0].slice(0, byteCount);\n\t\t\tif (advance) {\n\t\t\t\tthis._chunks[0] = this._chunks[0].slice(byteCount);\n\t\t\t\tthis._totalLength -= byteCount;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tconst result = VSBuffer.alloc(byteCount);\n\t\tlet resultOffset = 0;\n\t\tlet chunkIndex = 0;\n\t\twhile (byteCount > 0) {\n\t\t\tconst chunk = this._chunks[chunkIndex];\n\t\t\tif (chunk.byteLength > byteCount) {\n\t\t\t\t// this chunk will survive\n\t\t\t\tconst chunkPart = chunk.slice(0, byteCount);\n\t\t\t\tresult.set(chunkPart, resultOffset);\n\t\t\t\tresultOffset += byteCount;\n\n\t\t\t\tif (advance) {\n\t\t\t\t\tthis._chunks[chunkIndex] = chunk.slice(byteCount);\n\t\t\t\t\tthis._totalLength -= byteCount;\n\t\t\t\t}\n\n\t\t\t\tbyteCount -= byteCount;\n\t\t\t} else {\n\t\t\t\t// this chunk will be entirely read\n\t\t\t\tresult.set(chunk, resultOffset);\n\t\t\t\tresultOffset += chunk.byteLength;\n\n\t\t\t\tif (advance) {\n\t\t\t\t\tthis._chunks.shift();\n\t\t\t\t\tthis._totalLength -= chunk.byteLength;\n\t\t\t\t} else {\n\t\t\t\t\tchunkIndex++;\n\t\t\t\t}\n\n\t\t\t\tbyteCount -= chunk.byteLength;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n\nconst enum ProtocolMessageType {\n\tNone = 0,\n\tRegular = 1,\n\tControl = 2,\n\tAck = 3,\n\tDisconnect = 5,\n\tReplayRequest = 6,\n\tPause = 7,\n\tResume = 8,\n\tKeepAlive = 9\n}\n\nfunction protocolMessageTypeToString(messageType: ProtocolMessageType) {\n\tswitch (messageType) {\n\t\tcase ProtocolMessageType.None: return 'None';\n\t\tcase ProtocolMessageType.Regular: return 'Regular';\n\t\tcase ProtocolMessageType.Control: return 'Control';\n\t\tcase ProtocolMessageType.Ack: return 'Ack';\n\t\tcase ProtocolMessageType.Disconnect: return 'Disconnect';\n\t\tcase ProtocolMessageType.ReplayRequest: return 'ReplayRequest';\n\t\tcase ProtocolMessageType.Pause: return 'PauseWriting';\n\t\tcase ProtocolMessageType.Resume: return 'ResumeWriting';\n\t\tcase ProtocolMessageType.KeepAlive: return 'KeepAlive';\n\t}\n}\n\nexport const enum ProtocolConstants {\n\tHeaderLength = 13,\n\t/**\n\t * Send an Acknowledge message at most 2 seconds later...\n\t */\n\tAcknowledgeTime = 2000, // 2 seconds\n\t/**\n\t * If there is a sent message that has been unacknowledged for 20 seconds,\n\t * and we didn't see any incoming server data in the past 20 seconds,\n\t * then consider the connection has timed out.\n\t */\n\tTimeoutTime = 20000, // 20 seconds\n\t/**\n\t * If there is no reconnection within this time-frame, consider the connection permanently closed...\n\t */\n\tReconnectionGraceTime = 3 * 60 * 60 * 1000, // 3hrs\n\t/**\n\t * Maximal grace time between the first and the last reconnection...\n\t */\n\tReconnectionShortGraceTime = 5 * 60 * 1000, // 5min\n\t/**\n\t * Send a message every 5 seconds to avoid that the connection is closed by the OS.\n\t */\n\tKeepAliveSendTime = 5000, // 5 seconds\n}\n\nclass ProtocolMessage {\n\n\tpublic writtenTime: number;\n\n\tconstructor(\n\t\tpublic readonly type: ProtocolMessageType,\n\t\tpublic readonly id: number,\n\t\tpublic readonly ack: number,\n\t\tpublic readonly data: VSBuffer\n\t) {\n\t\tthis.writtenTime = 0;\n\t}\n\n\tpublic get size(): number {\n\t\treturn this.data.byteLength;\n\t}\n}\n\nclass ProtocolReader extends Disposable {\n\n\tprivate readonly _socket: ISocket;\n\tprivate _isDisposed: boolean;\n\tprivate readonly _incomingData: ChunkStream;\n\tpublic lastReadTime: number;\n\n\tprivate readonly _onMessage = this._register(new Emitter<ProtocolMessage>());\n\tpublic readonly onMessage: Event<ProtocolMessage> = this._onMessage.event;\n\n\tprivate readonly _state = {\n\t\treadHead: true,\n\t\treadLen: ProtocolConstants.HeaderLength,\n\t\tmessageType: ProtocolMessageType.None,\n\t\tid: 0,\n\t\tack: 0\n\t};\n\n\tconstructor(socket: ISocket) {\n\t\tsuper();\n\t\tthis._socket = socket;\n\t\tthis._isDisposed = false;\n\t\tthis._incomingData = new ChunkStream();\n\t\tthis._register(this._socket.onData(data => this.acceptChunk(data)));\n\t\tthis.lastReadTime = Date.now();\n\t}\n\n\tpublic acceptChunk(data: VSBuffer | null): void {\n\t\tif (!data || data.byteLength === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.lastReadTime = Date.now();\n\n\t\tthis._incomingData.acceptChunk(data);\n\n\t\twhile (this._incomingData.byteLength >= this._state.readLen) {\n\n\t\t\tconst buff = this._incomingData.read(this._state.readLen);\n\n\t\t\tif (this._state.readHead) {\n\t\t\t\t// buff is the header\n\n\t\t\t\t// save new state => next time will read the body\n\t\t\t\tthis._state.readHead = false;\n\t\t\t\tthis._state.readLen = buff.readUInt32BE(9);\n\t\t\t\tthis._state.messageType = buff.readUInt8(0);\n\t\t\t\tthis._state.id = buff.readUInt32BE(1);\n\t\t\t\tthis._state.ack = buff.readUInt32BE(5);\n\n\t\t\t\tthis._socket.traceSocketEvent(SocketDiagnosticsEventType.ProtocolHeaderRead, { messageType: protocolMessageTypeToString(this._state.messageType), id: this._state.id, ack: this._state.ack, messageSize: this._state.readLen });\n\n\t\t\t} else {\n\t\t\t\t// buff is the body\n\t\t\t\tconst messageType = this._state.messageType;\n\t\t\t\tconst id = this._state.id;\n\t\t\t\tconst ack = this._state.ack;\n\n\t\t\t\t// save new state => next time will read the header\n\t\t\t\tthis._state.readHead = true;\n\t\t\t\tthis._state.readLen = ProtocolConstants.HeaderLength;\n\t\t\t\tthis._state.messageType = ProtocolMessageType.None;\n\t\t\t\tthis._state.id = 0;\n\t\t\t\tthis._state.ack = 0;\n\n\t\t\t\tthis._socket.traceSocketEvent(SocketDiagnosticsEventType.ProtocolMessageRead, buff);\n\n\t\t\t\tthis._onMessage.fire(new ProtocolMessage(messageType, id, ack, buff));\n\n\t\t\t\tif (this._isDisposed) {\n\t\t\t\t\t// check if an event listener lead to our disposal\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic readEntireBuffer(): VSBuffer {\n\t\treturn this._incomingData.read(this._incomingData.byteLength);\n\t}\n\n\tpublic override dispose(): void {\n\t\tthis._isDisposed = true;\n\t\tsuper.dispose();\n\t}\n}\n\nclass ProtocolWriter {\n\n\tprivate _isDisposed: boolean;\n\tprivate _isPaused: boolean;\n\tprivate readonly _socket: ISocket;\n\tprivate _data: VSBuffer[];\n\tprivate _totalLength: number;\n\tpublic lastWriteTime: number;\n\n\tconstructor(socket: ISocket) {\n\t\tthis._isDisposed = false;\n\t\tthis._isPaused = false;\n\t\tthis._socket = socket;\n\t\tthis._data = [];\n\t\tthis._totalLength = 0;\n\t\tthis.lastWriteTime = 0;\n\t}\n\n\tpublic dispose(): void {\n\t\ttry {\n\t\t\tthis.flush();\n\t\t} catch (err) {\n\t\t\t// ignore error, since the socket could be already closed\n\t\t}\n\t\tthis._isDisposed = true;\n\t}\n\n\tpublic drain(): Promise<void> {\n\t\tthis.flush();\n\t\treturn this._socket.drain();\n\t}\n\n\tpublic flush(): void {\n\t\t// flush\n\t\tthis._writeNow();\n\t}\n\n\tpublic pause(): void {\n\t\tthis._isPaused = true;\n\t}\n\n\tpublic resume(): void {\n\t\tthis._isPaused = false;\n\t\tthis._scheduleWriting();\n\t}\n\n\tpublic write(msg: ProtocolMessage) {\n\t\tif (this._isDisposed) {\n\t\t\t// ignore: there could be left-over promises which complete and then\n\t\t\t// decide to write a response, etc...\n\t\t\treturn;\n\t\t}\n\t\tmsg.writtenTime = Date.now();\n\t\tthis.lastWriteTime = Date.now();\n\t\tconst header = VSBuffer.alloc(ProtocolConstants.HeaderLength);\n\t\theader.writeUInt8(msg.type, 0);\n\t\theader.writeUInt32BE(msg.id, 1);\n\t\theader.writeUInt32BE(msg.ack, 5);\n\t\theader.writeUInt32BE(msg.data.byteLength, 9);\n\n\t\tthis._socket.traceSocketEvent(SocketDiagnosticsEventType.ProtocolHeaderWrite, { messageType: protocolMessageTypeToString(msg.type), id: msg.id, ack: msg.ack, messageSize: msg.data.byteLength });\n\t\tthis._socket.traceSocketEvent(SocketDiagnosticsEventType.ProtocolMessageWrite, msg.data);\n\n\t\tthis._writeSoon(header, msg.data);\n\t}\n\n\tprivate _bufferAdd(head: VSBuffer, body: VSBuffer): boolean {\n\t\tconst wasEmpty = this._totalLength === 0;\n\t\tthis._data.push(head, body);\n\t\tthis._totalLength += head.byteLength + body.byteLength;\n\t\treturn wasEmpty;\n\t}\n\n\tprivate _bufferTake(): VSBuffer {\n\t\tconst ret = VSBuffer.concat(this._data, this._totalLength);\n\t\tthis._data.length = 0;\n\t\tthis._totalLength = 0;\n\t\treturn ret;\n\t}\n\n\tprivate _writeSoon(header: VSBuffer, data: VSBuffer): void {\n\t\tif (this._bufferAdd(header, data)) {\n\t\t\tthis._scheduleWriting();\n\t\t}\n\t}\n\n\tprivate _writeNowTimeout: any = null;\n\tprivate _scheduleWriting(): void {\n\t\tif (this._writeNowTimeout) {\n\t\t\treturn;\n\t\t}\n\t\tthis._writeNowTimeout = setTimeout(() => {\n\t\t\tthis._writeNowTimeout = null;\n\t\t\tthis._writeNow();\n\t\t});\n\t}\n\n\tprivate _writeNow(): void {\n\t\tif (this._totalLength === 0) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._isPaused) {\n\t\t\treturn;\n\t\t}\n\t\tconst data = this._bufferTake();\n\t\tthis._socket.traceSocketEvent(SocketDiagnosticsEventType.ProtocolWrite, { byteLength: data.byteLength });\n\t\tthis._socket.write(data);\n\t}\n}\n\n/**\n * A message has the following format:\n * ```\n *     /-------------------------------|------\\\n *     |             HEADER            |      |\n *     |-------------------------------| DATA |\n *     | TYPE | ID | ACK | DATA_LENGTH |      |\n *     \\-------------------------------|------/\n * ```\n * The header is 9 bytes and consists of:\n *  - TYPE is 1 byte (ProtocolMessageType) - the message type\n *  - ID is 4 bytes (u32be) - the message id (can be 0 to indicate to be ignored)\n *  - ACK is 4 bytes (u32be) - the acknowledged message id (can be 0 to indicate to be ignored)\n *  - DATA_LENGTH is 4 bytes (u32be) - the length in bytes of DATA\n *\n * Only Regular messages are counted, other messages are not counted, nor acknowledged.\n */\nexport class Protocol extends Disposable implements IMessagePassingProtocol {\n\n\tprivate _socket: ISocket;\n\tprivate _socketWriter: ProtocolWriter;\n\tprivate _socketReader: ProtocolReader;\n\n\tprivate readonly _onMessage = new Emitter<VSBuffer>();\n\treadonly onMessage: Event<VSBuffer> = this._onMessage.event;\n\n\tprivate readonly _onDidDispose = new Emitter<void>();\n\treadonly onDidDispose: Event<void> = this._onDidDispose.event;\n\n\tconstructor(socket: ISocket) {\n\t\tsuper();\n\t\tthis._socket = socket;\n\t\tthis._socketWriter = this._register(new ProtocolWriter(this._socket));\n\t\tthis._socketReader = this._register(new ProtocolReader(this._socket));\n\n\t\tthis._register(this._socketReader.onMessage((msg) => {\n\t\t\tif (msg.type === ProtocolMessageType.Regular) {\n\t\t\t\tthis._onMessage.fire(msg.data);\n\t\t\t}\n\t\t}));\n\n\t\tthis._register(this._socket.onClose(() => this._onDidDispose.fire()));\n\t}\n\n\tdrain(): Promise<void> {\n\t\treturn this._socketWriter.drain();\n\t}\n\n\tgetSocket(): ISocket {\n\t\treturn this._socket;\n\t}\n\n\tsendDisconnect(): void {\n\t\t// Nothing to do...\n\t}\n\n\tsend(buffer: VSBuffer): void {\n\t\tthis._socketWriter.write(new ProtocolMessage(ProtocolMessageType.Regular, 0, 0, buffer));\n\t}\n}\n\nexport class Client<TContext = string> extends IPCClient<TContext> {\n\n\tstatic fromSocket<TContext = string>(socket: ISocket, id: TContext): Client<TContext> {\n\t\treturn new Client(new Protocol(socket), id);\n\t}\n\n\tget onDidDispose(): Event<void> { return this.protocol.onDidDispose; }\n\n\tconstructor(private protocol: Protocol | PersistentProtocol, id: TContext, ipcLogger: IIPCLogger | null = null) {\n\t\tsuper(protocol, id, ipcLogger);\n\t}\n\n\toverride dispose(): void {\n\t\tsuper.dispose();\n\t\tconst socket = this.protocol.getSocket();\n\t\tthis.protocol.sendDisconnect();\n\t\tthis.protocol.dispose();\n\t\tsocket.end();\n\t}\n}\n\n/**\n * Will ensure no messages are lost if there are no event listeners.\n */\nexport class BufferedEmitter<T> {\n\tprivate _emitter: Emitter<T>;\n\tpublic readonly event: Event<T>;\n\n\tprivate _hasListeners = false;\n\tprivate _isDeliveringMessages = false;\n\tprivate _bufferedMessages: T[] = [];\n\n\tconstructor() {\n\t\tthis._emitter = new Emitter<T>({\n\t\t\tonWillAddFirstListener: () => {\n\t\t\t\tthis._hasListeners = true;\n\t\t\t\t// it is important to deliver these messages after this call, but before\n\t\t\t\t// other messages have a chance to be received (to guarantee in order delivery)\n\t\t\t\t// that's why we're using here queueMicrotask and not other types of timeouts\n\t\t\t\tqueueMicrotask(() => this._deliverMessages());\n\t\t\t},\n\t\t\tonDidRemoveLastListener: () => {\n\t\t\t\tthis._hasListeners = false;\n\t\t\t}\n\t\t});\n\n\t\tthis.event = this._emitter.event;\n\t}\n\n\tprivate _deliverMessages(): void {\n\t\tif (this._isDeliveringMessages) {\n\t\t\treturn;\n\t\t}\n\t\tthis._isDeliveringMessages = true;\n\t\twhile (this._hasListeners && this._bufferedMessages.length > 0) {\n\t\t\tthis._emitter.fire(this._bufferedMessages.shift()!);\n\t\t}\n\t\tthis._isDeliveringMessages = false;\n\t}\n\n\tpublic fire(event: T): void {\n\t\tif (this._hasListeners) {\n\t\t\tif (this._bufferedMessages.length > 0) {\n\t\t\t\tthis._bufferedMessages.push(event);\n\t\t\t} else {\n\t\t\t\tthis._emitter.fire(event);\n\t\t\t}\n\t\t} else {\n\t\t\tthis._bufferedMessages.push(event);\n\t\t}\n\t}\n\n\tpublic flushBuffer(): void {\n\t\tthis._bufferedMessages = [];\n\t}\n}\n\nclass QueueElement<T> {\n\tpublic readonly data: T;\n\tpublic next: QueueElement<T> | null;\n\n\tconstructor(data: T) {\n\t\tthis.data = data;\n\t\tthis.next = null;\n\t}\n}\n\nclass Queue<T> {\n\n\tprivate _first: QueueElement<T> | null;\n\tprivate _last: QueueElement<T> | null;\n\n\tconstructor() {\n\t\tthis._first = null;\n\t\tthis._last = null;\n\t}\n\n\tpublic length(): number {\n\t\tlet result = 0;\n\t\tlet current = this._first;\n\t\twhile (current) {\n\t\t\tcurrent = current.next;\n\t\t\tresult++;\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic peek(): T | null {\n\t\tif (!this._first) {\n\t\t\treturn null;\n\t\t}\n\t\treturn this._first.data;\n\t}\n\n\tpublic toArray(): T[] {\n\t\tconst result: T[] = [];\n\t\tlet resultLen = 0;\n\t\tlet it = this._first;\n\t\twhile (it) {\n\t\t\tresult[resultLen++] = it.data;\n\t\t\tit = it.next;\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic pop(): void {\n\t\tif (!this._first) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._first === this._last) {\n\t\t\tthis._first = null;\n\t\t\tthis._last = null;\n\t\t\treturn;\n\t\t}\n\t\tthis._first = this._first.next;\n\t}\n\n\tpublic push(item: T): void {\n\t\tconst element = new QueueElement(item);\n\t\tif (!this._first) {\n\t\t\tthis._first = element;\n\t\t\tthis._last = element;\n\t\t\treturn;\n\t\t}\n\t\tthis._last!.next = element;\n\t\tthis._last = element;\n\t}\n}\n\nclass LoadEstimator {\n\n\tprivate static _HISTORY_LENGTH = 10;\n\tprivate static _INSTANCE: LoadEstimator | null = null;\n\tpublic static getInstance(): LoadEstimator {\n\t\tif (!LoadEstimator._INSTANCE) {\n\t\t\tLoadEstimator._INSTANCE = new LoadEstimator();\n\t\t}\n\t\treturn LoadEstimator._INSTANCE;\n\t}\n\n\tprivate lastRuns: number[];\n\n\tconstructor() {\n\t\tthis.lastRuns = [];\n\t\tconst now = Date.now();\n\t\tfor (let i = 0; i < LoadEstimator._HISTORY_LENGTH; i++) {\n\t\t\tthis.lastRuns[i] = now - 1000 * i;\n\t\t}\n\t\tsetInterval(() => {\n\t\t\tfor (let i = LoadEstimator._HISTORY_LENGTH; i >= 1; i--) {\n\t\t\t\tthis.lastRuns[i] = this.lastRuns[i - 1];\n\t\t\t}\n\t\t\tthis.lastRuns[0] = Date.now();\n\t\t}, 1000);\n\t}\n\n\t/**\n\t * returns an estimative number, from 0 (low load) to 1 (high load)\n\t */\n\tprivate load(): number {\n\t\tconst now = Date.now();\n\t\tconst historyLimit = (1 + LoadEstimator._HISTORY_LENGTH) * 1000;\n\t\tlet score = 0;\n\t\tfor (let i = 0; i < LoadEstimator._HISTORY_LENGTH; i++) {\n\t\t\tif (now - this.lastRuns[i] <= historyLimit) {\n\t\t\t\tscore++;\n\t\t\t}\n\t\t}\n\t\treturn 1 - score / LoadEstimator._HISTORY_LENGTH;\n\t}\n\n\tpublic hasHighLoad(): boolean {\n\t\treturn this.load() >= 0.5;\n\t}\n}\n\nexport interface ILoadEstimator {\n\thasHighLoad(): boolean;\n}\n\nexport interface PersistentProtocolOptions {\n\t/**\n\t * The socket to use.\n\t */\n\tsocket: ISocket;\n\t/**\n\t * The initial chunk of data that has already been received from the socket.\n\t */\n\tinitialChunk?: VSBuffer | null;\n\t/**\n\t * The CPU load estimator to use.\n\t */\n\tloadEstimator?: ILoadEstimator;\n\t/**\n\t * Whether to send keep alive messages. Defaults to true.\n\t */\n\tsendKeepAlive?: boolean;\n}\n\n/**\n * Same as Protocol, but will actually track messages and acks.\n * Moreover, it will ensure no messages are lost if there are no event listeners.\n */\nexport class PersistentProtocol implements IMessagePassingProtocol {\n\n\tprivate _isReconnecting: boolean;\n\n\tprivate _outgoingUnackMsg: Queue<ProtocolMessage>;\n\tprivate _outgoingMsgId: number;\n\tprivate _outgoingAckId: number;\n\tprivate _outgoingAckTimeout: any | null;\n\n\tprivate _incomingMsgId: number;\n\tprivate _incomingAckId: number;\n\tprivate _incomingMsgLastTime: number;\n\tprivate _incomingAckTimeout: any | null;\n\n\tprivate _keepAliveInterval: any | null;\n\n\tprivate _lastReplayRequestTime: number;\n\tprivate _lastSocketTimeoutTime: number;\n\n\tprivate _socket: ISocket;\n\tprivate _socketWriter: ProtocolWriter;\n\tprivate _socketReader: ProtocolReader;\n\tprivate _socketDisposables: DisposableStore;\n\n\tprivate readonly _loadEstimator: ILoadEstimator;\n\tprivate readonly _shouldSendKeepAlive: boolean;\n\n\tprivate readonly _onControlMessage = new BufferedEmitter<VSBuffer>();\n\treadonly onControlMessage: Event<VSBuffer> = this._onControlMessage.event;\n\n\tprivate readonly _onMessage = new BufferedEmitter<VSBuffer>();\n\treadonly onMessage: Event<VSBuffer> = this._onMessage.event;\n\n\tprivate readonly _onDidDispose = new BufferedEmitter<void>();\n\treadonly onDidDispose: Event<void> = this._onDidDispose.event;\n\n\tprivate readonly _onSocketClose = new BufferedEmitter<SocketCloseEvent>();\n\treadonly onSocketClose: Event<SocketCloseEvent> = this._onSocketClose.event;\n\n\tprivate readonly _onSocketTimeout = new BufferedEmitter<SocketTimeoutEvent>();\n\treadonly onSocketTimeout: Event<SocketTimeoutEvent> = this._onSocketTimeout.event;\n\n\tpublic get unacknowledgedCount(): number {\n\t\treturn this._outgoingMsgId - this._outgoingAckId;\n\t}\n\n\tconstructor(opts: PersistentProtocolOptions) {\n\t\tthis._loadEstimator = opts.loadEstimator ?? LoadEstimator.getInstance();\n\t\tthis._shouldSendKeepAlive = opts.sendKeepAlive ?? true;\n\t\tthis._isReconnecting = false;\n\t\tthis._outgoingUnackMsg = new Queue<ProtocolMessage>();\n\t\tthis._outgoingMsgId = 0;\n\t\tthis._outgoingAckId = 0;\n\t\tthis._outgoingAckTimeout = null;\n\n\t\tthis._incomingMsgId = 0;\n\t\tthis._incomingAckId = 0;\n\t\tthis._incomingMsgLastTime = 0;\n\t\tthis._incomingAckTimeout = null;\n\n\t\tthis._lastReplayRequestTime = 0;\n\t\tthis._lastSocketTimeoutTime = Date.now();\n\n\t\tthis._socketDisposables = new DisposableStore();\n\t\tthis._socket = opts.socket;\n\t\tthis._socketWriter = this._socketDisposables.add(new ProtocolWriter(this._socket));\n\t\tthis._socketReader = this._socketDisposables.add(new ProtocolReader(this._socket));\n\t\tthis._socketDisposables.add(this._socketReader.onMessage(msg => this._receiveMessage(msg)));\n\t\tthis._socketDisposables.add(this._socket.onClose(e => this._onSocketClose.fire(e)));\n\n\t\tif (opts.initialChunk) {\n\t\t\tthis._socketReader.acceptChunk(opts.initialChunk);\n\t\t}\n\n\t\tif (this._shouldSendKeepAlive) {\n\t\t\tthis._keepAliveInterval = setInterval(() => {\n\t\t\t\tthis._sendKeepAlive();\n\t\t\t}, ProtocolConstants.KeepAliveSendTime);\n\t\t} else {\n\t\t\tthis._keepAliveInterval = null;\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tif (this._outgoingAckTimeout) {\n\t\t\tclearTimeout(this._outgoingAckTimeout);\n\t\t\tthis._outgoingAckTimeout = null;\n\t\t}\n\t\tif (this._incomingAckTimeout) {\n\t\t\tclearTimeout(this._incomingAckTimeout);\n\t\t\tthis._incomingAckTimeout = null;\n\t\t}\n\t\tif (this._keepAliveInterval) {\n\t\t\tclearInterval(this._keepAliveInterval);\n\t\t\tthis._keepAliveInterval = null;\n\t\t}\n\t\tthis._socketDisposables.dispose();\n\t}\n\n\tdrain(): Promise<void> {\n\t\treturn this._socketWriter.drain();\n\t}\n\n\tsendDisconnect(): void {\n\t\tconst msg = new ProtocolMessage(ProtocolMessageType.Disconnect, 0, 0, getEmptyBuffer());\n\t\tthis._socketWriter.write(msg);\n\t\tthis._socketWriter.flush();\n\t}\n\n\tsendPause(): void {\n\t\tconst msg = new ProtocolMessage(ProtocolMessageType.Pause, 0, 0, getEmptyBuffer());\n\t\tthis._socketWriter.write(msg);\n\t}\n\n\tsendResume(): void {\n\t\tconst msg = new ProtocolMessage(ProtocolMessageType.Resume, 0, 0, getEmptyBuffer());\n\t\tthis._socketWriter.write(msg);\n\t}\n\n\tpauseSocketWriting() {\n\t\tthis._socketWriter.pause();\n\t}\n\n\tpublic getSocket(): ISocket {\n\t\treturn this._socket;\n\t}\n\n\tpublic getMillisSinceLastIncomingData(): number {\n\t\treturn Date.now() - this._socketReader.lastReadTime;\n\t}\n\n\tpublic beginAcceptReconnection(socket: ISocket, initialDataChunk: VSBuffer | null): void {\n\t\tthis._isReconnecting = true;\n\n\t\tthis._socketDisposables.dispose();\n\t\tthis._socketDisposables = new DisposableStore();\n\t\tthis._onControlMessage.flushBuffer();\n\t\tthis._onSocketClose.flushBuffer();\n\t\tthis._onSocketTimeout.flushBuffer();\n\t\tthis._socket.dispose();\n\n\t\tthis._lastReplayRequestTime = 0;\n\t\tthis._lastSocketTimeoutTime = Date.now();\n\n\t\tthis._socket = socket;\n\t\tthis._socketWriter = this._socketDisposables.add(new ProtocolWriter(this._socket));\n\t\tthis._socketReader = this._socketDisposables.add(new ProtocolReader(this._socket));\n\t\tthis._socketDisposables.add(this._socketReader.onMessage(msg => this._receiveMessage(msg)));\n\t\tthis._socketDisposables.add(this._socket.onClose(e => this._onSocketClose.fire(e)));\n\n\t\tthis._socketReader.acceptChunk(initialDataChunk);\n\t}\n\n\tpublic endAcceptReconnection(): void {\n\t\tthis._isReconnecting = false;\n\n\t\t// After a reconnection, let the other party know (again) which messages have been received.\n\t\t// (perhaps the other party didn't receive a previous ACK)\n\t\tthis._incomingAckId = this._incomingMsgId;\n\t\tconst msg = new ProtocolMessage(ProtocolMessageType.Ack, 0, this._incomingAckId, getEmptyBuffer());\n\t\tthis._socketWriter.write(msg);\n\n\t\t// Send again all unacknowledged messages\n\t\tconst toSend = this._outgoingUnackMsg.toArray();\n\t\tfor (let i = 0, len = toSend.length; i < len; i++) {\n\t\t\tthis._socketWriter.write(toSend[i]);\n\t\t}\n\t\tthis._recvAckCheck();\n\t}\n\n\tpublic acceptDisconnect(): void {\n\t\tthis._onDidDispose.fire();\n\t}\n\n\tprivate _receiveMessage(msg: ProtocolMessage): void {\n\t\tif (msg.ack > this._outgoingAckId) {\n\t\t\tthis._outgoingAckId = msg.ack;\n\t\t\tdo {\n\t\t\t\tconst first = this._outgoingUnackMsg.peek();\n\t\t\t\tif (first && first.id <= msg.ack) {\n\t\t\t\t\t// this message has been confirmed, remove it\n\t\t\t\t\tthis._outgoingUnackMsg.pop();\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} while (true);\n\t\t}\n\n\t\tswitch (msg.type) {\n\t\t\tcase ProtocolMessageType.None: {\n\t\t\t\t// N/A\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase ProtocolMessageType.Regular: {\n\t\t\t\tif (msg.id > this._incomingMsgId) {\n\t\t\t\t\tif (msg.id !== this._incomingMsgId + 1) {\n\t\t\t\t\t\t// in case we missed some messages we ask the other party to resend them\n\t\t\t\t\t\tconst now = Date.now();\n\t\t\t\t\t\tif (now - this._lastReplayRequestTime > 10000) {\n\t\t\t\t\t\t\t// send a replay request at most once every 10s\n\t\t\t\t\t\t\tthis._lastReplayRequestTime = now;\n\t\t\t\t\t\t\tthis._socketWriter.write(new ProtocolMessage(ProtocolMessageType.ReplayRequest, 0, 0, getEmptyBuffer()));\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._incomingMsgId = msg.id;\n\t\t\t\t\t\tthis._incomingMsgLastTime = Date.now();\n\t\t\t\t\t\tthis._sendAckCheck();\n\t\t\t\t\t\tthis._onMessage.fire(msg.data);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase ProtocolMessageType.Control: {\n\t\t\t\tthis._onControlMessage.fire(msg.data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase ProtocolMessageType.Ack: {\n\t\t\t\t// nothing to do, .ack is handled above already\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase ProtocolMessageType.Disconnect: {\n\t\t\t\tthis._onDidDispose.fire();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase ProtocolMessageType.ReplayRequest: {\n\t\t\t\t// Send again all unacknowledged messages\n\t\t\t\tconst toSend = this._outgoingUnackMsg.toArray();\n\t\t\t\tfor (let i = 0, len = toSend.length; i < len; i++) {\n\t\t\t\t\tthis._socketWriter.write(toSend[i]);\n\t\t\t\t}\n\t\t\t\tthis._recvAckCheck();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase ProtocolMessageType.Pause: {\n\t\t\t\tthis._socketWriter.pause();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase ProtocolMessageType.Resume: {\n\t\t\t\tthis._socketWriter.resume();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase ProtocolMessageType.KeepAlive: {\n\t\t\t\t// nothing to do\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treadEntireBuffer(): VSBuffer {\n\t\treturn this._socketReader.readEntireBuffer();\n\t}\n\n\tflush(): void {\n\t\tthis._socketWriter.flush();\n\t}\n\n\tsend(buffer: VSBuffer): void {\n\t\tconst myId = ++this._outgoingMsgId;\n\t\tthis._incomingAckId = this._incomingMsgId;\n\t\tconst msg = new ProtocolMessage(ProtocolMessageType.Regular, myId, this._incomingAckId, buffer);\n\t\tthis._outgoingUnackMsg.push(msg);\n\t\tif (!this._isReconnecting) {\n\t\t\tthis._socketWriter.write(msg);\n\t\t\tthis._recvAckCheck();\n\t\t}\n\t}\n\n\t/**\n\t * Send a message which will not be part of the regular acknowledge flow.\n\t * Use this for early control messages which are repeated in case of reconnection.\n\t */\n\tsendControl(buffer: VSBuffer): void {\n\t\tconst msg = new ProtocolMessage(ProtocolMessageType.Control, 0, 0, buffer);\n\t\tthis._socketWriter.write(msg);\n\t}\n\n\tprivate _sendAckCheck(): void {\n\t\tif (this._incomingMsgId <= this._incomingAckId) {\n\t\t\t// nothink to acknowledge\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._incomingAckTimeout) {\n\t\t\t// there will be a check in the near future\n\t\t\treturn;\n\t\t}\n\n\t\tconst timeSinceLastIncomingMsg = Date.now() - this._incomingMsgLastTime;\n\t\tif (timeSinceLastIncomingMsg >= ProtocolConstants.AcknowledgeTime) {\n\t\t\t// sufficient time has passed since this message has been received,\n\t\t\t// and no message from our side needed to be sent in the meantime,\n\t\t\t// so we will send a message containing only an ack.\n\t\t\tthis._sendAck();\n\t\t\treturn;\n\t\t}\n\n\t\tthis._incomingAckTimeout = setTimeout(() => {\n\t\t\tthis._incomingAckTimeout = null;\n\t\t\tthis._sendAckCheck();\n\t\t}, ProtocolConstants.AcknowledgeTime - timeSinceLastIncomingMsg + 5);\n\t}\n\n\tprivate _recvAckCheck(): void {\n\t\tif (this._outgoingMsgId <= this._outgoingAckId) {\n\t\t\t// everything has been acknowledged\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._outgoingAckTimeout) {\n\t\t\t// there will be a check in the near future\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._isReconnecting) {\n\t\t\t// do not cause a timeout during reconnection,\n\t\t\t// because messages will not be actually written until `endAcceptReconnection`\n\t\t\treturn;\n\t\t}\n\n\t\tconst oldestUnacknowledgedMsg = this._outgoingUnackMsg.peek()!;\n\t\tconst timeSinceOldestUnacknowledgedMsg = Date.now() - oldestUnacknowledgedMsg.writtenTime;\n\t\tconst timeSinceLastReceivedSomeData = Date.now() - this._socketReader.lastReadTime;\n\t\tconst timeSinceLastTimeout = Date.now() - this._lastSocketTimeoutTime;\n\n\t\tif (\n\t\t\ttimeSinceOldestUnacknowledgedMsg >= ProtocolConstants.TimeoutTime\n\t\t\t&& timeSinceLastReceivedSomeData >= ProtocolConstants.TimeoutTime\n\t\t\t&& timeSinceLastTimeout >= ProtocolConstants.TimeoutTime\n\t\t) {\n\t\t\t// It's been a long time since our sent message was acknowledged\n\t\t\t// and a long time since we received some data\n\n\t\t\t// But this might be caused by the event loop being busy and failing to read messages\n\t\t\tif (!this._loadEstimator.hasHighLoad()) {\n\t\t\t\t// Trash the socket\n\t\t\t\tthis._lastSocketTimeoutTime = Date.now();\n\t\t\t\tthis._onSocketTimeout.fire({\n\t\t\t\t\tunacknowledgedMsgCount: this._outgoingUnackMsg.length(),\n\t\t\t\t\ttimeSinceOldestUnacknowledgedMsg,\n\t\t\t\t\ttimeSinceLastReceivedSomeData\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tconst minimumTimeUntilTimeout = Math.max(\n\t\t\tProtocolConstants.TimeoutTime - timeSinceOldestUnacknowledgedMsg,\n\t\t\tProtocolConstants.TimeoutTime - timeSinceLastReceivedSomeData,\n\t\t\tProtocolConstants.TimeoutTime - timeSinceLastTimeout,\n\t\t\t500\n\t\t);\n\n\t\tthis._outgoingAckTimeout = setTimeout(() => {\n\t\t\tthis._outgoingAckTimeout = null;\n\t\t\tthis._recvAckCheck();\n\t\t}, minimumTimeUntilTimeout);\n\t}\n\n\tprivate _sendAck(): void {\n\t\tif (this._incomingMsgId <= this._incomingAckId) {\n\t\t\t// nothink to acknowledge\n\t\t\treturn;\n\t\t}\n\n\t\tthis._incomingAckId = this._incomingMsgId;\n\t\tconst msg = new ProtocolMessage(ProtocolMessageType.Ack, 0, this._incomingAckId, getEmptyBuffer());\n\t\tthis._socketWriter.write(msg);\n\t}\n\n\tprivate _sendKeepAlive(): void {\n\t\tthis._incomingAckId = this._incomingMsgId;\n\t\tconst msg = new ProtocolMessage(ProtocolMessageType.KeepAlive, 0, this._incomingAckId, getEmptyBuffer());\n\t\tthis._socketWriter.write(msg);\n\t}\n}\n\n// (() => {\n// \tif (!SocketDiagnostics.enableDiagnostics) {\n// \t\treturn;\n// \t}\n// \tif (typeof require.__$__nodeRequire !== 'function') {\n// \t\tconsole.log(`Can only log socket diagnostics on native platforms.`);\n// \t\treturn;\n// \t}\n// \tconst type = (\n// \t\tprocess.argv.includes('--type=renderer')\n// \t\t\t? 'renderer'\n// \t\t\t: (process.argv.includes('--type=extensionHost')\n// \t\t\t\t? 'extensionHost'\n// \t\t\t\t: (process.argv.some(item => item.includes('server-main'))\n// \t\t\t\t\t? 'server'\n// \t\t\t\t\t: 'unknown'\n// \t\t\t\t)\n// \t\t\t)\n// \t);\n// \tsetTimeout(() => {\n// \t\tSocketDiagnostics.records.forEach(r => {\n// \t\t\tif (r.buff) {\n// \t\t\t\tr.data = Buffer.from(r.buff.buffer).toString('base64');\n// \t\t\t\tr.buff = undefined;\n// \t\t\t}\n// \t\t});\n\n// \t\tconst fs = <typeof import('fs')>require.__$__nodeRequire('fs');\n// \t\tconst path = <typeof import('path')>require.__$__nodeRequire('path');\n// \t\tconst logPath = path.join(process.cwd(),`${type}-${process.pid}`);\n\n// \t\tconsole.log(`dumping socket diagnostics at ${logPath}`);\n// \t\tfs.writeFileSync(logPath, JSON.stringify(SocketDiagnostics.records));\n// \t}, 20000);\n// })();\n"]}