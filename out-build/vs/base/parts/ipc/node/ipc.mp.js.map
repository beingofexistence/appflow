{"version":3,"sources":["file:///workspace/appflow/src/vs/base/parts/ipc/node/ipc.mp.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;IAShG;;;OAGG;IACH,MAAM,QAAQ;QAIb,YAAoB,CAAqB;YAArB,MAAC,GAAD,CAAC,CAAoB;YAFhC,cAAS,GAAG,aAAK,CAAC,oBAAoB,CAAW,IAAI,CAAC,CAAC,EAAK,SAAS,EAAE,CAAC,CAAe,EAAE,EAAE,CAAC,YAAG,CAAM,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;YAI3H,sDAAsD;YACtD,CAAC,CAAI,KAAK,EAAE,CAAC;QACd,CAAC;QAED,IAAI,CAAC,OAAY;YAChB,IAAI,CAAC,CAAC,CAAI,WAAW,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;QACvC,CAAC;QAED,UAAU;YACT,IAAI,CAAC,CAAC,CAAI,KAAK,EAAE,CAAC;QACnB,CAAC;KACD;IAeD;;;OAGG;IACH,MAAa,GAAO,SAAQ,SAAG;QAEtB,MAAM,CAAC,CAAC,CAAqB,MAAgC;YACpE,IAAA,WAAG,EAAQ,IAAA,mBAAG,EAAc,OAAO,CAAC,EAAE,0BAA0B,CAAC,CAAC;YAElE,MAAM,sBAAsB,GAAG,IAAI,WAAG,EAAuB,CAAC;YAE9D,OAAO,CAAC,UAAU,CAAC,EAAE,CAAC,SAAS,EAAE,CAAC,CAAe,EAAE,EAAE;gBACpD,IAAI,MAAM,EAAE,uBAAuB,CAAC,CAAC,CAAC,EAAE;oBACvC,OAAO;iBACP;gBAED,MAAM,IAAI,GAAG,IAAA,YAAG,EAAY,CAAC,CAAC,KAAK,CAAC,CAAC;gBACrC,IAAI,IAAI,EAAE;oBACT,sBAAsB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;iBAClC;YACF,CAAC,CAAC,CAAC;YAEH,OAAO,aAAK,CAAC,GAAG,CAAC,sBAAsB,CAAC,KAAK,EAAE,IAAI,CAAC,EAAE;gBACrD,MAAM,QAAQ,GAAG,IAAI,QAAQ,CAAC,IAAI,CAAC,CAAC;gBAEpC,MAAM,MAAM,GAA0B;oBACrC,QAAQ;oBACR,wEAAwE;oBACxE,oEAAoE;oBACpE,+FAA+F;oBAC/F,qBAAqB,EAAE,aAAK,CAAC,oBAAoB,CAAC,IAAI,EAAE,OAAO,CAAC;iBAChE,CAAC;gBAEF,OAAO,MAAM,CAAC;YACf,CAAC,CAAC,CAAC;QACJ,CAAC;QAED,YAAY,MAAgC;YAC3C,KAAK,CAAC,GAAG,CAAI,CAAC,CAAqB,MAAM,CAAC,CAAC,CAAC;QAC7C,CAAC;KACD;IApCD,kBAoCC;IAOD,SAAgB,GAAG,CAAE,IAA8B,EAAE,OAAgB,EAAE,QAAoB;QAC1F,MAAM,QAAQ,GAAG,CAAC,CAAe,EAAE,EAAE;YACpC,IAAI,CAAC,CAAC,IAAI,KAAK,OAAO,EAAE;gBACvB,IAAI,CAAC,cAAc,CAAC,SAAS,EAAE,QAAQ,CAAC,CAAC;gBACzC,QAAQ,EAAE,CAAC;aACX;QACF,CAAC,CAAC;QAEF,IAAI,CAAC,EAAE,CAAC,SAAS,EAAE,QAAQ,CAAC,CAAC;IAC9B,CAAC;IATD,kBASC","file":"ipc.mp.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { MessagePortMain, isUtilityProcess, MessageEvent } from 'vs/base/parts/sandbox/node/electronTypes';\nimport { VSBuffer } from 'vs/base/common/buffer';\nimport { ClientConnectionEvent, IMessagePassingProtocol, IPCServer } from 'vs/base/parts/ipc/common/ipc';\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { assertType } from 'vs/base/common/types';\nimport { firstOrDefault } from 'vs/base/common/arrays';\n\n/**\n * The MessagePort `Protocol` leverages MessagePortMain style IPC communication\n * for the implementation of the `IMessagePassingProtocol`.\n */\nclass Protocol implements IMessagePassingProtocol {\n\n\treadonly onMessage = Event.fromNodeEventEmitter<VSBuffer>(this.port, 'message', (e: MessageEvent) => VSBuffer.wrap(e.data));\n\n\tconstructor(private port: MessagePortMain) {\n\n\t\t// we must call start() to ensure messages are flowing\n\t\tport.start();\n\t}\n\n\tsend(message: VSBuffer): void {\n\t\tthis.port.postMessage(message.buffer);\n\t}\n\n\tdisconnect(): void {\n\t\tthis.port.close();\n\t}\n}\n\nexport interface IClientConnectionFilter {\n\n\t/**\n\t * Allows to filter incoming messages to the\n\t * server to handle them differently.\n\t *\n\t * @param e the message event to handle\n\t * @returns `true` if the event was handled\n\t * and should not be processed by the server.\n\t */\n\thandledClientConnection(e: MessageEvent): boolean;\n}\n\n/**\n * An implementation of a `IPCServer` on top of MessagePort style IPC communication.\n * The clients register themselves via Electron Utility Process IPC transfer.\n */\nexport class Server extends IPCServer {\n\n\tprivate static getOnDidClientConnect(filter?: IClientConnectionFilter): Event<ClientConnectionEvent> {\n\t\tassertType(isUtilityProcess(process), 'Electron Utility Process');\n\n\t\tconst onCreateMessageChannel = new Emitter<MessagePortMain>();\n\n\t\tprocess.parentPort.on('message', (e: MessageEvent) => {\n\t\t\tif (filter?.handledClientConnection(e)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst port = firstOrDefault(e.ports);\n\t\t\tif (port) {\n\t\t\t\tonCreateMessageChannel.fire(port);\n\t\t\t}\n\t\t});\n\n\t\treturn Event.map(onCreateMessageChannel.event, port => {\n\t\t\tconst protocol = new Protocol(port);\n\n\t\t\tconst result: ClientConnectionEvent = {\n\t\t\t\tprotocol,\n\t\t\t\t// Not part of the standard spec, but in Electron we get a `close` event\n\t\t\t\t// when the other side closes. We can use this to detect disconnects\n\t\t\t\t// (https://github.com/electron/electron/blob/11-x-y/docs/api/message-port-main.md#event-close)\n\t\t\t\tonDidClientDisconnect: Event.fromNodeEventEmitter(port, 'close')\n\t\t\t};\n\n\t\t\treturn result;\n\t\t});\n\t}\n\n\tconstructor(filter?: IClientConnectionFilter) {\n\t\tsuper(Server.getOnDidClientConnect(filter));\n\t}\n}\n\ninterface INodeMessagePortFragment {\n\ton(event: 'message', listener: (messageEvent: MessageEvent) => void): this;\n\tremoveListener(event: 'message', listener: (messageEvent: MessageEvent) => void): this;\n}\n\nexport function once(port: INodeMessagePortFragment, message: unknown, callback: () => void): void {\n\tconst listener = (e: MessageEvent) => {\n\t\tif (e.data === message) {\n\t\t\tport.removeListener('message', listener);\n\t\t\tcallback();\n\t\t}\n\t};\n\n\tport.on('message', listener);\n}\n"]}