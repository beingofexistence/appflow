{"version":3,"sources":["file:///workspace/appflow/src/vs/base/parts/sandbox/electron-sandbox/globals.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;IAkHnF,QAAA,EAAE,GAAyB,aAAE,CAAM,MAAM,CAAC,WAAW,CAAC;IACtD,QAAA,EAAE,GAA+B,aAAE,CAAM,MAAM,CAAC,cAAc,CAAC;IAC/D,QAAA,EAAE,GAAmB,aAAE,CAAM,MAAM,CAAC,QAAQ,CAAC;IAC7C,QAAA,EAAE,GAA6B,aAAE,CAAM,MAAM,CAAC,OAAO,CAAC;IACtD,QAAA,EAAE,GAAyB,aAAE,CAAM,MAAM,CAAC,OAAO,CAAC","file":"globals.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { globals, INodeProcess, IProcessEnvironment } from 'vs/base/common/platform';\nimport { ISandboxConfiguration } from 'vs/base/parts/sandbox/common/sandboxTypes';\nimport { IpcRenderer, ProcessMemoryInfo, WebFrame } from 'vs/base/parts/sandbox/electron-sandbox/electronTypes';\n\n/**\n * In Electron renderers we cannot expose all of the `process` global of node.js\n */\nexport interface ISandboxNodeProcess extends INodeProcess {\n\n\t/**\n\t * The process.platform property returns a string identifying the operating system platform\n\t * on which the Node.js process is running.\n\t */\n\treadonly platform: string;\n\n\t/**\n\t * The process.arch property returns a string identifying the CPU architecture\n\t * on which the Node.js process is running.\n\t */\n\treadonly arch: string;\n\n\t/**\n\t * The type will always be `renderer`.\n\t */\n\treadonly type: string;\n\n\t/**\n\t * A list of versions for the current node.js/electron configuration.\n\t */\n\treadonly versions: { [key: string]: string | undefined };\n\n\t/**\n\t * The process.env property returns an object containing the user environment.\n\t */\n\treadonly env: IProcessEnvironment;\n\n\t/**\n\t * The `execPath` will be the location of the executable of this application.\n\t */\n\treadonly execPath: string;\n\n\t/**\n\t * A listener on the process. Only a small subset of listener types are allowed.\n\t */\n\ton: (type: string, callback: Function) => void;\n\n\t/**\n\t * The current working directory of the process.\n\t */\n\tcwd: () => string;\n\n\t/**\n\t * Resolves with a ProcessMemoryInfo\n\t *\n\t * Returns an object giving memory usage statistics about the current process. Note\n\t * that all statistics are reported in Kilobytes. This api should be called after\n\t * app ready.\n\t *\n\t * Chromium does not provide `residentSet` value for macOS. This is because macOS\n\t * performs in-memory compression of pages that haven't been recently used. As a\n\t * result the resident set size value is not what one would expect. `private`\n\t * memory is more representative of the actual pre-compression memory usage of the\n\t * process on macOS.\n\t */\n\tgetProcessMemoryInfo: () => Promise<ProcessMemoryInfo>;\n\n\t/**\n\t * Returns a process environment that includes all shell environment variables even if\n\t * the application was not started from a shell / terminal / console.\n\t *\n\t * There are different layers of environment that will apply:\n\t * - `process.env`: this is the actual environment of the process before this method\n\t * - `shellEnv`   : if the program was not started from a terminal, we resolve all shell\n\t *                  variables to get the same experience as if the program was started from\n\t *                  a terminal (Linux, macOS)\n\t * - `userEnv`    : this is instance specific environment, e.g. if the user started the program\n\t *                  from a terminal and changed certain variables\n\t *\n\t * The order of overwrites is `process.env` < `shellEnv` < `userEnv`.\n\t */\n\tshellEnv(): Promise<IProcessEnvironment>;\n}\n\nexport interface IpcMessagePort {\n\n\t/**\n\t * Acquire a `MessagePort`. The main process will transfer the port over to\n\t * the `responseChannel` with a payload of `requestNonce` so that the source can\n\t * correlate the response.\n\t *\n\t * The source should install a `window.on('message')` listener, ensuring `e.data`\n\t * matches `nonce`, `e.source` matches `window` and then receiving the `MessagePort`\n\t * via `e.ports[0]`.\n\t */\n\tacquire(responseChannel: string, nonce: string): void;\n}\n\nexport interface ISandboxContext {\n\n\t/**\n\t * A configuration object made accessible from the main side\n\t * to configure the sandbox browser window. Will be `undefined`\n\t * for as long as `resolveConfiguration` is not awaited.\n\t */\n\tconfiguration(): ISandboxConfiguration | undefined;\n\n\t/**\n\t * Allows to await the resolution of the configuration object.\n\t */\n\tresolveConfiguration(): Promise<ISandboxConfiguration>;\n}\n\nexport const ipcRenderer: IpcRenderer = globals.vscode.ipcRenderer;\nexport const ipcMessagePort: IpcMessagePort = globals.vscode.ipcMessagePort;\nexport const webFrame: WebFrame = globals.vscode.webFrame;\nexport const process: ISandboxNodeProcess = globals.vscode.process;\nexport const context: ISandboxContext = globals.vscode.context;\n"]}