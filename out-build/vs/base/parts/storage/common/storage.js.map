{"version":3,"sources":["file:///workspace/appflow/src/vs/base/parts/storage/common/storage.ts"],"names":[],"mappings":"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","file":"storage.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ThrottledDelayer } from 'vs/base/common/async';\nimport { Event, PauseableEmitter } from 'vs/base/common/event';\nimport { Disposable, IDisposable } from 'vs/base/common/lifecycle';\nimport { parse, stringify } from 'vs/base/common/marshalling';\nimport { isObject, isUndefinedOrNull } from 'vs/base/common/types';\n\nexport enum StorageHint {\n\n\t// A hint to the storage that the storage\n\t// does not exist on disk yet. This allows\n\t// the storage library to improve startup\n\t// time by not checking the storage for data.\n\tSTORAGE_DOES_NOT_EXIST,\n\n\t// A hint to the storage that the storage\n\t// is backed by an in-memory storage.\n\tSTORAGE_IN_MEMORY\n}\n\nexport interface IStorageOptions {\n\treadonly hint?: StorageHint;\n}\n\nexport interface IUpdateRequest {\n\treadonly insert?: Map<string, string>;\n\treadonly delete?: Set<string>;\n}\n\nexport interface IStorageItemsChangeEvent {\n\treadonly changed?: Map<string, string>;\n\treadonly deleted?: Set<string>;\n}\n\nexport function isStorageItemsChangeEvent(thing: unknown): thing is IStorageItemsChangeEvent {\n\tconst candidate = thing as IStorageItemsChangeEvent | undefined;\n\n\treturn candidate?.changed instanceof Map || candidate?.deleted instanceof Set;\n}\n\nexport interface IStorageDatabase {\n\n\treadonly onDidChangeItemsExternal: Event<IStorageItemsChangeEvent>;\n\n\tgetItems(): Promise<Map<string, string>>;\n\tupdateItems(request: IUpdateRequest): Promise<void>;\n\n\toptimize(): Promise<void>;\n\n\tclose(recovery?: () => Map<string, string>): Promise<void>;\n}\n\nexport interface IStorageChangeEvent {\n\n\t/**\n\t * The `key` of the storage entry that was changed\n\t * or was removed.\n\t */\n\treadonly key: string;\n\n\t/**\n\t * A hint how the storage change event was triggered. If\n\t * `true`, the storage change was triggered by an external\n\t * source, such as:\n\t * - another process (for example another window)\n\t * - operations such as settings sync or profiles change\n\t */\n\treadonly external?: boolean;\n}\n\nexport type StorageValue = string | boolean | number | undefined | null | object;\n\nexport interface IStorage extends IDisposable {\n\n\treadonly onDidChangeStorage: Event<IStorageChangeEvent>;\n\n\treadonly items: Map<string, string>;\n\treadonly size: number;\n\n\tinit(): Promise<void>;\n\n\tget(key: string, fallbackValue: string): string;\n\tget(key: string, fallbackValue?: string): string | undefined;\n\n\tgetBoolean(key: string, fallbackValue: boolean): boolean;\n\tgetBoolean(key: string, fallbackValue?: boolean): boolean | undefined;\n\n\tgetNumber(key: string, fallbackValue: number): number;\n\tgetNumber(key: string, fallbackValue?: number): number | undefined;\n\n\tgetObject<T extends object>(key: string, fallbackValue: T): T;\n\tgetObject<T extends object>(key: string, fallbackValue?: T): T | undefined;\n\n\tset(key: string, value: StorageValue, external?: boolean): Promise<void>;\n\tdelete(key: string, external?: boolean): Promise<void>;\n\n\tflush(delay?: number): Promise<void>;\n\twhenFlushed(): Promise<void>;\n\n\toptimize(): Promise<void>;\n\n\tclose(): Promise<void>;\n}\n\nexport enum StorageState {\n\tNone,\n\tInitialized,\n\tClosed\n}\n\nexport class Storage extends Disposable implements IStorage {\n\n\tprivate static readonly DEFAULT_FLUSH_DELAY = 100;\n\n\tprivate readonly _onDidChangeStorage = this._register(new PauseableEmitter<IStorageChangeEvent>());\n\treadonly onDidChangeStorage = this._onDidChangeStorage.event;\n\n\tprivate state = StorageState.None;\n\n\tprivate cache = new Map<string, string>();\n\n\tprivate readonly flushDelayer = this._register(new ThrottledDelayer<void>(Storage.DEFAULT_FLUSH_DELAY));\n\n\tprivate pendingDeletes = new Set<string>();\n\tprivate pendingInserts = new Map<string, string>();\n\n\tprivate pendingClose: Promise<void> | undefined = undefined;\n\n\tprivate readonly whenFlushedCallbacks: Function[] = [];\n\n\tconstructor(\n\t\tprotected readonly database: IStorageDatabase,\n\t\tprivate readonly options: IStorageOptions = Object.create(null)\n\t) {\n\t\tsuper();\n\n\t\tthis.registerListeners();\n\t}\n\n\tprivate registerListeners(): void {\n\t\tthis._register(this.database.onDidChangeItemsExternal(e => this.onDidChangeItemsExternal(e)));\n\t}\n\n\tprivate onDidChangeItemsExternal(e: IStorageItemsChangeEvent): void {\n\t\tthis._onDidChangeStorage.pause();\n\n\t\ttry {\n\t\t\t// items that change external require us to update our\n\t\t\t// caches with the values. we just accept the value and\n\t\t\t// emit an event if there is a change.\n\n\t\t\te.changed?.forEach((value, key) => this.acceptExternal(key, value));\n\t\t\te.deleted?.forEach(key => this.acceptExternal(key, undefined));\n\n\t\t} finally {\n\t\t\tthis._onDidChangeStorage.resume();\n\t\t}\n\t}\n\n\tprivate acceptExternal(key: string, value: string | undefined): void {\n\t\tif (this.state === StorageState.Closed) {\n\t\t\treturn; // Return early if we are already closed\n\t\t}\n\n\t\tlet changed = false;\n\n\t\t// Item got removed, check for deletion\n\t\tif (isUndefinedOrNull(value)) {\n\t\t\tchanged = this.cache.delete(key);\n\t\t}\n\n\t\t// Item got updated, check for change\n\t\telse {\n\t\t\tconst currentValue = this.cache.get(key);\n\t\t\tif (currentValue !== value) {\n\t\t\t\tthis.cache.set(key, value);\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t}\n\n\t\t// Signal to outside listeners\n\t\tif (changed) {\n\t\t\tthis._onDidChangeStorage.fire({ key, external: true });\n\t\t}\n\t}\n\n\tget items(): Map<string, string> {\n\t\treturn this.cache;\n\t}\n\n\tget size(): number {\n\t\treturn this.cache.size;\n\t}\n\n\tasync init(): Promise<void> {\n\t\tif (this.state !== StorageState.None) {\n\t\t\treturn; // either closed or already initialized\n\t\t}\n\n\t\tthis.state = StorageState.Initialized;\n\n\t\tif (this.options.hint === StorageHint.STORAGE_DOES_NOT_EXIST) {\n\t\t\t// return early if we know the storage file does not exist. this is a performance\n\t\t\t// optimization to not load all items of the underlying storage if we know that\n\t\t\t// there can be no items because the storage does not exist.\n\t\t\treturn;\n\t\t}\n\n\t\tthis.cache = await this.database.getItems();\n\t}\n\n\tget(key: string, fallbackValue: string): string;\n\tget(key: string, fallbackValue?: string): string | undefined;\n\tget(key: string, fallbackValue?: string): string | undefined {\n\t\tconst value = this.cache.get(key);\n\n\t\tif (isUndefinedOrNull(value)) {\n\t\t\treturn fallbackValue;\n\t\t}\n\n\t\treturn value;\n\t}\n\n\tgetBoolean(key: string, fallbackValue: boolean): boolean;\n\tgetBoolean(key: string, fallbackValue?: boolean): boolean | undefined;\n\tgetBoolean(key: string, fallbackValue?: boolean): boolean | undefined {\n\t\tconst value = this.get(key);\n\n\t\tif (isUndefinedOrNull(value)) {\n\t\t\treturn fallbackValue;\n\t\t}\n\n\t\treturn value === 'true';\n\t}\n\n\tgetNumber(key: string, fallbackValue: number): number;\n\tgetNumber(key: string, fallbackValue?: number): number | undefined;\n\tgetNumber(key: string, fallbackValue?: number): number | undefined {\n\t\tconst value = this.get(key);\n\n\t\tif (isUndefinedOrNull(value)) {\n\t\t\treturn fallbackValue;\n\t\t}\n\n\t\treturn parseInt(value, 10);\n\t}\n\n\tgetObject(key: string, fallbackValue: object): object;\n\tgetObject(key: string, fallbackValue?: object | undefined): object | undefined;\n\tgetObject(key: string, fallbackValue?: object): object | undefined {\n\t\tconst value = this.get(key);\n\n\t\tif (isUndefinedOrNull(value)) {\n\t\t\treturn fallbackValue;\n\t\t}\n\n\t\treturn parse(value);\n\t}\n\n\tasync set(key: string, value: string | boolean | number | null | undefined | object, external = false): Promise<void> {\n\t\tif (this.state === StorageState.Closed) {\n\t\t\treturn; // Return early if we are already closed\n\t\t}\n\n\t\t// We remove the key for undefined/null values\n\t\tif (isUndefinedOrNull(value)) {\n\t\t\treturn this.delete(key, external);\n\t\t}\n\n\t\t// Otherwise, convert to String and store\n\t\tconst valueStr = isObject(value) || Array.isArray(value) ? stringify(value) : String(value);\n\n\t\t// Return early if value already set\n\t\tconst currentValue = this.cache.get(key);\n\t\tif (currentValue === valueStr) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Update in cache and pending\n\t\tthis.cache.set(key, valueStr);\n\t\tthis.pendingInserts.set(key, valueStr);\n\t\tthis.pendingDeletes.delete(key);\n\n\t\t// Event\n\t\tthis._onDidChangeStorage.fire({ key, external });\n\n\t\t// Accumulate work by scheduling after timeout\n\t\treturn this.doFlush();\n\t}\n\n\tasync delete(key: string, external = false): Promise<void> {\n\t\tif (this.state === StorageState.Closed) {\n\t\t\treturn; // Return early if we are already closed\n\t\t}\n\n\t\t// Remove from cache and add to pending\n\t\tconst wasDeleted = this.cache.delete(key);\n\t\tif (!wasDeleted) {\n\t\t\treturn; // Return early if value already deleted\n\t\t}\n\n\t\tif (!this.pendingDeletes.has(key)) {\n\t\t\tthis.pendingDeletes.add(key);\n\t\t}\n\n\t\tthis.pendingInserts.delete(key);\n\n\t\t// Event\n\t\tthis._onDidChangeStorage.fire({ key, external });\n\n\t\t// Accumulate work by scheduling after timeout\n\t\treturn this.doFlush();\n\t}\n\n\tasync optimize(): Promise<void> {\n\t\tif (this.state === StorageState.Closed) {\n\t\t\treturn; // Return early if we are already closed\n\t\t}\n\n\t\t// Await pending data to be flushed to the DB\n\t\t// before attempting to optimize the DB\n\t\tawait this.flush(0);\n\n\t\treturn this.database.optimize();\n\t}\n\n\tasync close(): Promise<void> {\n\t\tif (!this.pendingClose) {\n\t\t\tthis.pendingClose = this.doClose();\n\t\t}\n\n\t\treturn this.pendingClose;\n\t}\n\n\tprivate async doClose(): Promise<void> {\n\n\t\t// Update state\n\t\tthis.state = StorageState.Closed;\n\n\t\t// Trigger new flush to ensure data is persisted and then close\n\t\t// even if there is an error flushing. We must always ensure\n\t\t// the DB is closed to avoid corruption.\n\t\t//\n\t\t// Recovery: we pass our cache over as recovery option in case\n\t\t// the DB is not healthy.\n\t\ttry {\n\t\t\tawait this.doFlush(0 /* as soon as possible */);\n\t\t} catch (error) {\n\t\t\t// Ignore\n\t\t}\n\n\t\tawait this.database.close(() => this.cache);\n\t}\n\n\tprivate get hasPending() {\n\t\treturn this.pendingInserts.size > 0 || this.pendingDeletes.size > 0;\n\t}\n\n\tprivate async flushPending(): Promise<void> {\n\t\tif (!this.hasPending) {\n\t\t\treturn; // return early if nothing to do\n\t\t}\n\n\t\t// Get pending data\n\t\tconst updateRequest: IUpdateRequest = { insert: this.pendingInserts, delete: this.pendingDeletes };\n\n\t\t// Reset pending data for next run\n\t\tthis.pendingDeletes = new Set<string>();\n\t\tthis.pendingInserts = new Map<string, string>();\n\n\t\t// Update in storage and release any\n\t\t// waiters we have once done\n\t\treturn this.database.updateItems(updateRequest).finally(() => {\n\t\t\tif (!this.hasPending) {\n\t\t\t\twhile (this.whenFlushedCallbacks.length) {\n\t\t\t\t\tthis.whenFlushedCallbacks.pop()?.();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tasync flush(delay?: number): Promise<void> {\n\t\tif (!this.hasPending) {\n\t\t\treturn; // return early if nothing to do\n\t\t}\n\n\t\treturn this.doFlush(delay);\n\t}\n\n\tprivate async doFlush(delay?: number): Promise<void> {\n\t\tif (this.options.hint === StorageHint.STORAGE_IN_MEMORY) {\n\t\t\treturn this.flushPending(); // return early if in-memory\n\t\t}\n\n\t\treturn this.flushDelayer.trigger(() => this.flushPending(), delay);\n\t}\n\n\tasync whenFlushed(): Promise<void> {\n\t\tif (!this.hasPending) {\n\t\t\treturn; // return early if nothing to do\n\t\t}\n\n\t\treturn new Promise(resolve => this.whenFlushedCallbacks.push(resolve));\n\t}\n\n\tisInMemory(): boolean {\n\t\treturn this.options.hint === StorageHint.STORAGE_IN_MEMORY;\n\t}\n}\n\nexport class InMemoryStorageDatabase implements IStorageDatabase {\n\n\treadonly onDidChangeItemsExternal = Event.None;\n\n\tprivate readonly items = new Map<string, string>();\n\n\tasync getItems(): Promise<Map<string, string>> {\n\t\treturn this.items;\n\t}\n\n\tasync updateItems(request: IUpdateRequest): Promise<void> {\n\t\trequest.insert?.forEach((value, key) => this.items.set(key, value));\n\n\t\trequest.delete?.forEach(key => this.items.delete(key));\n\t}\n\n\tasync optimize(): Promise<void> { }\n\tasync close(): Promise<void> { }\n}\n"]}