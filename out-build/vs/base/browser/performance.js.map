{"version":3,"sources":["file:///workspace/appflow/src/vs/base/browser/performance.ts","vs/base/browser/performance.ts"],"names":[],"mappings":"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","file":"performance.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport namespace inputLatency {\n\n\t// Measurements are recorded as totals, the average is calculated when the final measurements\n\t// are created.\n\tinterface ICumulativeMeasurement {\n\t\ttotal: number;\n\t\tmin: number;\n\t\tmax: number;\n\t}\n\tconst totalKeydownTime: ICumulativeMeasurement = { total: 0, min: Number.MAX_VALUE, max: 0 };\n\tconst totalInputTime: ICumulativeMeasurement = { ...totalKeydownTime };\n\tconst totalRenderTime: ICumulativeMeasurement = { ...totalKeydownTime };\n\tconst totalInputLatencyTime: ICumulativeMeasurement = { ...totalKeydownTime };\n\tlet measurementsCount = 0;\n\n\n\n\t// The state of each event, this helps ensure the integrity of the measurement and that\n\t// something unexpected didn't happen that could skew the measurement.\n\tconst enum EventPhase {\n\t\tBefore = 0,\n\t\tInProgress = 1,\n\t\tFinished = 2\n\t}\n\tconst state = {\n\t\tkeydown: EventPhase.Before,\n\t\tinput: EventPhase.Before,\n\t\trender: EventPhase.Before,\n\t};\n\n\t/**\n\t * Record the start of the keydown event.\n\t */\n\texport function onKeyDown() {\n\t\t/** Direct Check C. See explanation in {@link recordIfFinished} */\n\t\trecordIfFinished();\n\t\tperformance.mark('inputlatency/start');\n\t\tperformance.mark('keydown/start');\n\t\tstate.keydown = EventPhase.InProgress;\n\t\tqueueMicrotask(markKeyDownEnd);\n\t}\n\n\t/**\n\t * Mark the end of the keydown event.\n\t */\n\tfunction markKeyDownEnd() {\n\t\tif (state.keydown === EventPhase.InProgress) {\n\t\t\tperformance.mark('keydown/end');\n\t\t\tstate.keydown = EventPhase.Finished;\n\t\t}\n\t}\n\n\t/**\n\t * Record the start of the beforeinput event.\n\t */\n\texport function onBeforeInput() {\n\t\tperformance.mark('input/start');\n\t\tstate.input = EventPhase.InProgress;\n\t\t/** Schedule Task A. See explanation in {@link recordIfFinished} */\n\t\tscheduleRecordIfFinishedTask();\n\t}\n\n\t/**\n\t * Record the start of the input event.\n\t */\n\texport function onInput() {\n\t\tif (state.input === EventPhase.Before) {\n\t\t\t// it looks like we didn't receive a `beforeinput`\n\t\t\tonBeforeInput();\n\t\t}\n\t\tqueueMicrotask(markInputEnd);\n\t}\n\n\tfunction markInputEnd() {\n\t\tif (state.input === EventPhase.InProgress) {\n\t\t\tperformance.mark('input/end');\n\t\t\tstate.input = EventPhase.Finished;\n\t\t}\n\t}\n\n\t/**\n\t * Record the start of the keyup event.\n\t */\n\texport function onKeyUp() {\n\t\t/** Direct Check D. See explanation in {@link recordIfFinished} */\n\t\trecordIfFinished();\n\t}\n\n\t/**\n\t * Record the start of the selectionchange event.\n\t */\n\texport function onSelectionChange() {\n\t\t/** Direct Check E. See explanation in {@link recordIfFinished} */\n\t\trecordIfFinished();\n\t}\n\n\t/**\n\t * Record the start of the animation frame performing the rendering.\n\t */\n\texport function onRenderStart() {\n\t\t// Render may be triggered during input, but we only measure the following animation frame\n\t\tif (state.keydown === EventPhase.Finished && state.input === EventPhase.Finished && state.render === EventPhase.Before) {\n\t\t\t// Only measure the first render after keyboard input\n\t\t\tperformance.mark('render/start');\n\t\t\tstate.render = EventPhase.InProgress;\n\t\t\tqueueMicrotask(markRenderEnd);\n\t\t\t/** Schedule Task B. See explanation in {@link recordIfFinished} */\n\t\t\tscheduleRecordIfFinishedTask();\n\t\t}\n\t}\n\n\t/**\n\t * Mark the end of the animation frame performing the rendering.\n\t */\n\tfunction markRenderEnd() {\n\t\tif (state.render === EventPhase.InProgress) {\n\t\t\tperformance.mark('render/end');\n\t\t\tstate.render = EventPhase.Finished;\n\t\t}\n\t}\n\n\tfunction scheduleRecordIfFinishedTask() {\n\t\t// Here we can safely assume that the `setTimeout` will not be\n\t\t// artificially delayed by 4ms because we schedule it from\n\t\t// event handlers\n\t\tsetTimeout(recordIfFinished);\n\t}\n\n\t/**\n\t * Record the input latency sample if input handling and rendering are finished.\n\t *\n\t * The challenge here is that we want to record the latency in such a way that it includes\n\t * also the layout and painting work the browser does during the animation frame task.\n\t *\n\t * Simply scheduling a new task (via `setTimeout`) from the animation frame task would\n\t * schedule the new task at the end of the task queue (after other code that uses `setTimeout`),\n\t * so we need to use multiple strategies to make sure our task runs before others:\n\t *\n\t * We schedule tasks (A and B):\n\t *    - we schedule a task A (via a `setTimeout` call) when the input starts in `markInputStart`.\n\t *      If the animation frame task is scheduled quickly by the browser, then task A has a very good\n\t *      chance of being the very first task after the animation frame and thus will record the input latency.\n\t *    - however, if the animation frame task is scheduled a bit later, then task A might execute\n\t *      before the animation frame task. We therefore schedule another task B from `markRenderStart`.\n\t *\n\t * We do direct checks in browser event handlers (C, D, E):\n\t *    - if the browser has multiple keydown events queued up, they will be scheduled before the `setTimeout` tasks,\n\t *      so we do a direct check in the keydown event handler (C).\n\t *    - depending on timing, sometimes the animation frame is scheduled even before the `keyup` event, so we\n\t *      do a direct check there too (E).\n\t *    - the browser oftentimes emits a `selectionchange` event after an `input`, so we do a direct check there (D).\n\t */\n\tfunction recordIfFinished() {\n\t\tif (state.keydown === EventPhase.Finished && state.input === EventPhase.Finished && state.render === EventPhase.Finished) {\n\t\t\tperformance.mark('inputlatency/end');\n\n\t\t\tperformance.measure('keydown', 'keydown/start', 'keydown/end');\n\t\t\tperformance.measure('input', 'input/start', 'input/end');\n\t\t\tperformance.measure('render', 'render/start', 'render/end');\n\t\t\tperformance.measure('inputlatency', 'inputlatency/start', 'inputlatency/end');\n\n\t\t\taddMeasure('keydown', totalKeydownTime);\n\t\t\taddMeasure('input', totalInputTime);\n\t\t\taddMeasure('render', totalRenderTime);\n\t\t\taddMeasure('inputlatency', totalInputLatencyTime);\n\n\t\t\t// console.info(\n\t\t\t// \t`input latency=${performance.getEntriesByName('inputlatency')[0].duration.toFixed(1)} [` +\n\t\t\t// \t`keydown=${performance.getEntriesByName('keydown')[0].duration.toFixed(1)}, ` +\n\t\t\t// \t`input=${performance.getEntriesByName('input')[0].duration.toFixed(1)}, ` +\n\t\t\t// \t`render=${performance.getEntriesByName('render')[0].duration.toFixed(1)}` +\n\t\t\t// \t`]`\n\t\t\t// );\n\n\t\t\tmeasurementsCount++;\n\n\t\t\treset();\n\t\t}\n\t}\n\n\tfunction addMeasure(entryName: string, cumulativeMeasurement: ICumulativeMeasurement): void {\n\t\tconst duration = performance.getEntriesByName(entryName)[0].duration;\n\t\tcumulativeMeasurement.total += duration;\n\t\tcumulativeMeasurement.min = Math.min(cumulativeMeasurement.min, duration);\n\t\tcumulativeMeasurement.max = Math.max(cumulativeMeasurement.max, duration);\n\t}\n\n\t/**\n\t * Clear the current sample.\n\t */\n\tfunction reset() {\n\t\tperformance.clearMarks('keydown/start');\n\t\tperformance.clearMarks('keydown/end');\n\t\tperformance.clearMarks('input/start');\n\t\tperformance.clearMarks('input/end');\n\t\tperformance.clearMarks('render/start');\n\t\tperformance.clearMarks('render/end');\n\t\tperformance.clearMarks('inputlatency/start');\n\t\tperformance.clearMarks('inputlatency/end');\n\n\t\tperformance.clearMeasures('keydown');\n\t\tperformance.clearMeasures('input');\n\t\tperformance.clearMeasures('render');\n\t\tperformance.clearMeasures('inputlatency');\n\n\t\tstate.keydown = EventPhase.Before;\n\t\tstate.input = EventPhase.Before;\n\t\tstate.render = EventPhase.Before;\n\t}\n\n\texport interface IInputLatencyMeasurements {\n\t\tkeydown: IInputLatencySingleMeasurement;\n\t\tinput: IInputLatencySingleMeasurement;\n\t\trender: IInputLatencySingleMeasurement;\n\t\ttotal: IInputLatencySingleMeasurement;\n\t\tsampleCount: number;\n\t}\n\n\texport interface IInputLatencySingleMeasurement {\n\t\taverage: number;\n\t\tmin: number;\n\t\tmax: number;\n\t}\n\n\t/**\n\t * Gets all input latency samples and clears the internal buffers to start recording a new set\n\t * of samples.\n\t */\n\texport function getAndClearMeasurements(): IInputLatencyMeasurements | undefined {\n\t\tif (measurementsCount === 0) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Assemble the result\n\t\tconst result = {\n\t\t\tkeydown: cumulativeToFinalMeasurement(totalKeydownTime),\n\t\t\tinput: cumulativeToFinalMeasurement(totalInputTime),\n\t\t\trender: cumulativeToFinalMeasurement(totalRenderTime),\n\t\t\ttotal: cumulativeToFinalMeasurement(totalInputLatencyTime),\n\t\t\tsampleCount: measurementsCount\n\t\t};\n\n\t\t// Clear the cumulative measurements\n\t\tclearCumulativeMeasurement(totalKeydownTime);\n\t\tclearCumulativeMeasurement(totalInputTime);\n\t\tclearCumulativeMeasurement(totalRenderTime);\n\t\tclearCumulativeMeasurement(totalInputLatencyTime);\n\t\tmeasurementsCount = 0;\n\n\t\treturn result;\n\t}\n\n\tfunction cumulativeToFinalMeasurement(cumulative: ICumulativeMeasurement): IInputLatencySingleMeasurement {\n\t\treturn {\n\t\t\taverage: cumulative.total / measurementsCount,\n\t\t\tmax: cumulative.max,\n\t\t\tmin: cumulative.min,\n\t\t};\n\t}\n\n\tfunction clearCumulativeMeasurement(cumulative: ICumulativeMeasurement): void {\n\t\tcumulative.total = 0;\n\t\tcumulative.min = Number.MAX_VALUE;\n\t\tcumulative.max = 0;\n\t}\n\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport namespace inputLatency {\n\n\t// Measurements are recorded as totals, the average is calculated when the final measurements\n\t// are created.\n\tinterface ICumulativeMeasurement {\n\t\ttotal: number;\n\t\tmin: number;\n\t\tmax: number;\n\t}\n\tconst totalKeydownTime: ICumulativeMeasurement = { total: 0, min: Number.MAX_VALUE, max: 0 };\n\tconst totalInputTime: ICumulativeMeasurement = { ...totalKeydownTime };\n\tconst totalRenderTime: ICumulativeMeasurement = { ...totalKeydownTime };\n\tconst totalInputLatencyTime: ICumulativeMeasurement = { ...totalKeydownTime };\n\tlet measurementsCount = 0;\n\n\n\n\t// The state of each event, this helps ensure the integrity of the measurement and that\n\t// something unexpected didn't happen that could skew the measurement.\n\tconst enum EventPhase {\n\t\tBefore = 0,\n\t\tInProgress = 1,\n\t\tFinished = 2\n\t}\n\tconst state = {\n\t\tkeydown: EventPhase.Before,\n\t\tinput: EventPhase.Before,\n\t\trender: EventPhase.Before,\n\t};\n\n\t/**\n\t * Record the start of the keydown event.\n\t */\n\texport function onKeyDown() {\n\t\t/** Direct Check C. See explanation in {@link recordIfFinished} */\n\t\trecordIfFinished();\n\t\tperformance.mark('inputlatency/start');\n\t\tperformance.mark('keydown/start');\n\t\tstate.keydown = EventPhase.InProgress;\n\t\tqueueMicrotask(markKeyDownEnd);\n\t}\n\n\t/**\n\t * Mark the end of the keydown event.\n\t */\n\tfunction markKeyDownEnd() {\n\t\tif (state.keydown === EventPhase.InProgress) {\n\t\t\tperformance.mark('keydown/end');\n\t\t\tstate.keydown = EventPhase.Finished;\n\t\t}\n\t}\n\n\t/**\n\t * Record the start of the beforeinput event.\n\t */\n\texport function onBeforeInput() {\n\t\tperformance.mark('input/start');\n\t\tstate.input = EventPhase.InProgress;\n\t\t/** Schedule Task A. See explanation in {@link recordIfFinished} */\n\t\tscheduleRecordIfFinishedTask();\n\t}\n\n\t/**\n\t * Record the start of the input event.\n\t */\n\texport function onInput() {\n\t\tif (state.input === EventPhase.Before) {\n\t\t\t// it looks like we didn't receive a `beforeinput`\n\t\t\tonBeforeInput();\n\t\t}\n\t\tqueueMicrotask(markInputEnd);\n\t}\n\n\tfunction markInputEnd() {\n\t\tif (state.input === EventPhase.InProgress) {\n\t\t\tperformance.mark('input/end');\n\t\t\tstate.input = EventPhase.Finished;\n\t\t}\n\t}\n\n\t/**\n\t * Record the start of the keyup event.\n\t */\n\texport function onKeyUp() {\n\t\t/** Direct Check D. See explanation in {@link recordIfFinished} */\n\t\trecordIfFinished();\n\t}\n\n\t/**\n\t * Record the start of the selectionchange event.\n\t */\n\texport function onSelectionChange() {\n\t\t/** Direct Check E. See explanation in {@link recordIfFinished} */\n\t\trecordIfFinished();\n\t}\n\n\t/**\n\t * Record the start of the animation frame performing the rendering.\n\t */\n\texport function onRenderStart() {\n\t\t// Render may be triggered during input, but we only measure the following animation frame\n\t\tif (state.keydown === EventPhase.Finished && state.input === EventPhase.Finished && state.render === EventPhase.Before) {\n\t\t\t// Only measure the first render after keyboard input\n\t\t\tperformance.mark('render/start');\n\t\t\tstate.render = EventPhase.InProgress;\n\t\t\tqueueMicrotask(markRenderEnd);\n\t\t\t/** Schedule Task B. See explanation in {@link recordIfFinished} */\n\t\t\tscheduleRecordIfFinishedTask();\n\t\t}\n\t}\n\n\t/**\n\t * Mark the end of the animation frame performing the rendering.\n\t */\n\tfunction markRenderEnd() {\n\t\tif (state.render === EventPhase.InProgress) {\n\t\t\tperformance.mark('render/end');\n\t\t\tstate.render = EventPhase.Finished;\n\t\t}\n\t}\n\n\tfunction scheduleRecordIfFinishedTask() {\n\t\t// Here we can safely assume that the `setTimeout` will not be\n\t\t// artificially delayed by 4ms because we schedule it from\n\t\t// event handlers\n\t\tsetTimeout(recordIfFinished);\n\t}\n\n\t/**\n\t * Record the input latency sample if input handling and rendering are finished.\n\t *\n\t * The challenge here is that we want to record the latency in such a way that it includes\n\t * also the layout and painting work the browser does during the animation frame task.\n\t *\n\t * Simply scheduling a new task (via `setTimeout`) from the animation frame task would\n\t * schedule the new task at the end of the task queue (after other code that uses `setTimeout`),\n\t * so we need to use multiple strategies to make sure our task runs before others:\n\t *\n\t * We schedule tasks (A and B):\n\t *    - we schedule a task A (via a `setTimeout` call) when the input starts in `markInputStart`.\n\t *      If the animation frame task is scheduled quickly by the browser, then task A has a very good\n\t *      chance of being the very first task after the animation frame and thus will record the input latency.\n\t *    - however, if the animation frame task is scheduled a bit later, then task A might execute\n\t *      before the animation frame task. We therefore schedule another task B from `markRenderStart`.\n\t *\n\t * We do direct checks in browser event handlers (C, D, E):\n\t *    - if the browser has multiple keydown events queued up, they will be scheduled before the `setTimeout` tasks,\n\t *      so we do a direct check in the keydown event handler (C).\n\t *    - depending on timing, sometimes the animation frame is scheduled even before the `keyup` event, so we\n\t *      do a direct check there too (E).\n\t *    - the browser oftentimes emits a `selectionchange` event after an `input`, so we do a direct check there (D).\n\t */\n\tfunction recordIfFinished() {\n\t\tif (state.keydown === EventPhase.Finished && state.input === EventPhase.Finished && state.render === EventPhase.Finished) {\n\t\t\tperformance.mark('inputlatency/end');\n\n\t\t\tperformance.measure('keydown', 'keydown/start', 'keydown/end');\n\t\t\tperformance.measure('input', 'input/start', 'input/end');\n\t\t\tperformance.measure('render', 'render/start', 'render/end');\n\t\t\tperformance.measure('inputlatency', 'inputlatency/start', 'inputlatency/end');\n\n\t\t\taddMeasure('keydown', totalKeydownTime);\n\t\t\taddMeasure('input', totalInputTime);\n\t\t\taddMeasure('render', totalRenderTime);\n\t\t\taddMeasure('inputlatency', totalInputLatencyTime);\n\n\t\t\t// console.info(\n\t\t\t// \t`input latency=${performance.getEntriesByName('inputlatency')[0].duration.toFixed(1)} [` +\n\t\t\t// \t`keydown=${performance.getEntriesByName('keydown')[0].duration.toFixed(1)}, ` +\n\t\t\t// \t`input=${performance.getEntriesByName('input')[0].duration.toFixed(1)}, ` +\n\t\t\t// \t`render=${performance.getEntriesByName('render')[0].duration.toFixed(1)}` +\n\t\t\t// \t`]`\n\t\t\t// );\n\n\t\t\tmeasurementsCount++;\n\n\t\t\treset();\n\t\t}\n\t}\n\n\tfunction addMeasure(entryName: string, cumulativeMeasurement: ICumulativeMeasurement): void {\n\t\tconst duration = performance.getEntriesByName(entryName)[0].duration;\n\t\tcumulativeMeasurement.total += duration;\n\t\tcumulativeMeasurement.min = Math.min(cumulativeMeasurement.min, duration);\n\t\tcumulativeMeasurement.max = Math.max(cumulativeMeasurement.max, duration);\n\t}\n\n\t/**\n\t * Clear the current sample.\n\t */\n\tfunction reset() {\n\t\tperformance.clearMarks('keydown/start');\n\t\tperformance.clearMarks('keydown/end');\n\t\tperformance.clearMarks('input/start');\n\t\tperformance.clearMarks('input/end');\n\t\tperformance.clearMarks('render/start');\n\t\tperformance.clearMarks('render/end');\n\t\tperformance.clearMarks('inputlatency/start');\n\t\tperformance.clearMarks('inputlatency/end');\n\n\t\tperformance.clearMeasures('keydown');\n\t\tperformance.clearMeasures('input');\n\t\tperformance.clearMeasures('render');\n\t\tperformance.clearMeasures('inputlatency');\n\n\t\tstate.keydown = EventPhase.Before;\n\t\tstate.input = EventPhase.Before;\n\t\tstate.render = EventPhase.Before;\n\t}\n\n\texport interface IInputLatencyMeasurements {\n\t\tkeydown: IInputLatencySingleMeasurement;\n\t\tinput: IInputLatencySingleMeasurement;\n\t\trender: IInputLatencySingleMeasurement;\n\t\ttotal: IInputLatencySingleMeasurement;\n\t\tsampleCount: number;\n\t}\n\n\texport interface IInputLatencySingleMeasurement {\n\t\taverage: number;\n\t\tmin: number;\n\t\tmax: number;\n\t}\n\n\t/**\n\t * Gets all input latency samples and clears the internal buffers to start recording a new set\n\t * of samples.\n\t */\n\texport function getAndClearMeasurements(): IInputLatencyMeasurements | undefined {\n\t\tif (measurementsCount === 0) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Assemble the result\n\t\tconst result = {\n\t\t\tkeydown: cumulativeToFinalMeasurement(totalKeydownTime),\n\t\t\tinput: cumulativeToFinalMeasurement(totalInputTime),\n\t\t\trender: cumulativeToFinalMeasurement(totalRenderTime),\n\t\t\ttotal: cumulativeToFinalMeasurement(totalInputLatencyTime),\n\t\t\tsampleCount: measurementsCount\n\t\t};\n\n\t\t// Clear the cumulative measurements\n\t\tclearCumulativeMeasurement(totalKeydownTime);\n\t\tclearCumulativeMeasurement(totalInputTime);\n\t\tclearCumulativeMeasurement(totalRenderTime);\n\t\tclearCumulativeMeasurement(totalInputLatencyTime);\n\t\tmeasurementsCount = 0;\n\n\t\treturn result;\n\t}\n\n\tfunction cumulativeToFinalMeasurement(cumulative: ICumulativeMeasurement): IInputLatencySingleMeasurement {\n\t\treturn {\n\t\t\taverage: cumulative.total / measurementsCount,\n\t\t\tmax: cumulative.max,\n\t\t\tmin: cumulative.min,\n\t\t};\n\t}\n\n\tfunction clearCumulativeMeasurement(cumulative: ICumulativeMeasurement): void {\n\t\tcumulative.total = 0;\n\t\tcumulative.min = Number.MAX_VALUE;\n\t\tcumulative.max = 0;\n\t}\n\n}\n"]}